var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/commander/lib/error.js
var require_error = __commonJS((exports) => {
  class CommanderError extends Error {
    constructor(exitCode, code, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code;
      this.exitCode = exitCode;
      this.nestedError = undefined;
    }
  }

  class InvalidArgumentError extends CommanderError {
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS((exports) => {
  var humanReadableArgName = function(arg) {
    const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  };
  var { InvalidArgumentError } = require_error();

  class Argument {
    constructor(name, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = undefined;
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.argChoices = undefined;
      switch (name[0]) {
        case "<":
          this.required = true;
          this._name = name.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name;
          break;
      }
      if (this._name.length > 3 && this._name.slice(-3) === "...") {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    name() {
      return this._name;
    }
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    argRequired() {
      this.required = true;
      return this;
    }
    argOptional() {
      this.required = false;
      return this;
    }
  }
  exports.Argument = Argument;
  exports.humanReadableArgName = humanReadableArgName;
});

// node_modules/commander/lib/help.js
var require_help = __commonJS((exports) => {
  var { humanReadableArgName } = require_argument();

  class Help {
    constructor() {
      this.helpWidth = undefined;
      this.sortSubcommands = false;
      this.sortOptions = false;
      this.showGlobalOptions = false;
    }
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      if (cmd._hasImplicitHelpCommand()) {
        const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
        const helpCommand = cmd.createCommand(helpName).helpOption(false);
        helpCommand.description(cmd._helpCommandDescription);
        if (helpArgs)
          helpCommand.arguments(helpArgs);
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a, b) => {
          return a.name().localeCompare(b.name());
        });
      }
      return visibleCommands;
    }
    compareOptions(a, b) {
      const getSortKey = (option) => {
        return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
      };
      return getSortKey(a).localeCompare(getSortKey(b));
    }
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option) => !option.hidden);
      const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
      const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
      if (showShortHelpFlag || showLongHelpFlag) {
        let helpOption;
        if (!showShortHelpFlag) {
          helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
        } else if (!showLongHelpFlag) {
          helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
        } else {
          helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
        }
        visibleOptions.push(helpOption);
      }
      if (this.sortOptions) {
        visibleOptions.sort(this.compareOptions);
      }
      return visibleOptions;
    }
    visibleGlobalOptions(cmd) {
      if (!this.showGlobalOptions)
        return [];
      const globalOptions = [];
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
        globalOptions.push(...visibleOptions);
      }
      if (this.sortOptions) {
        globalOptions.sort(this.compareOptions);
      }
      return globalOptions;
    }
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd.registeredArguments.forEach((argument) => {
          argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
        });
      }
      if (cmd.registeredArguments.find((argument) => argument.description)) {
        return cmd.registeredArguments;
      }
      return [];
    }
    subcommandTerm(cmd) {
      const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
    }
    optionTerm(option) {
      return option.flags;
    }
    argumentTerm(argument) {
      return argument.name();
    }
    longestSubcommandTermLength(cmd, helper) {
      return helper.visibleCommands(cmd).reduce((max, command) => {
        return Math.max(max, helper.subcommandTerm(command).length);
      }, 0);
    }
    longestOptionTermLength(cmd, helper) {
      return helper.visibleOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestGlobalOptionTermLength(cmd, helper) {
      return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestArgumentTermLength(cmd, helper) {
      return helper.visibleArguments(cmd).reduce((max, argument) => {
        return Math.max(max, helper.argumentTerm(argument).length);
      }, 0);
    }
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let ancestorCmdNames = "";
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
      }
      return ancestorCmdNames + cmdName + " " + cmd.usage();
    }
    commandDescription(cmd) {
      return cmd.description();
    }
    subcommandDescription(cmd) {
      return cmd.summary() || cmd.description();
    }
    optionDescription(option) {
      const extraInfo = [];
      if (option.argChoices) {
        extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (option.defaultValue !== undefined) {
        const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
        if (showDefault) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
      }
      if (option.presetArg !== undefined && option.optional) {
        extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
      }
      if (option.envVar !== undefined) {
        extraInfo.push(`env: ${option.envVar}`);
      }
      if (extraInfo.length > 0) {
        return `${option.description} (${extraInfo.join(", ")})`;
      }
      return option.description;
    }
    argumentDescription(argument) {
      const extraInfo = [];
      if (argument.argChoices) {
        extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (argument.defaultValue !== undefined) {
        extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescripton = `(${extraInfo.join(", ")})`;
        if (argument.description) {
          return `${argument.description} ${extraDescripton}`;
        }
        return extraDescripton;
      }
      return argument.description;
    }
    formatHelp(cmd, helper) {
      const termWidth = helper.padWidth(cmd, helper);
      const helpWidth = helper.helpWidth || 80;
      const itemIndentWidth = 2;
      const itemSeparatorWidth = 2;
      function formatItem(term, description) {
        if (description) {
          const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
          return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
        }
        return term;
      }
      function formatList(textArray) {
        return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
      }
      let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
      const commandDescription = helper.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
      }
      const argumentList = helper.visibleArguments(cmd).map((argument) => {
        return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
      });
      if (argumentList.length > 0) {
        output = output.concat(["Arguments:", formatList(argumentList), ""]);
      }
      const optionList = helper.visibleOptions(cmd).map((option) => {
        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
      });
      if (optionList.length > 0) {
        output = output.concat(["Options:", formatList(optionList), ""]);
      }
      if (this.showGlobalOptions) {
        const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (globalOptionList.length > 0) {
          output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
        }
      }
      const commandList = helper.visibleCommands(cmd).map((cmd2) => {
        return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
      });
      if (commandList.length > 0) {
        output = output.concat(["Commands:", formatList(commandList), ""]);
      }
      return output.join("\n");
    }
    padWidth(cmd, helper) {
      return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
    }
    wrap(str, width, indent, minColumnWidth = 40) {
      const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
      const manualIndent = new RegExp(`[\\n][${indents}]+`);
      if (str.match(manualIndent))
        return str;
      const columnWidth = width - indent;
      if (columnWidth < minColumnWidth)
        return str;
      const leadingStr = str.slice(0, indent);
      const columnText = str.slice(indent).replace("\r\n", "\n");
      const indentString = " ".repeat(indent);
      const zeroWidthSpace = "\u200B";
      const breaks = `\\s${zeroWidthSpace}`;
      const regex = new RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|\$)|[^${breaks}]+?([${breaks}]|\$)`, "g");
      const lines = columnText.match(regex) || [];
      return leadingStr + lines.map((line, i) => {
        if (line === "\n")
          return "";
        return (i > 0 ? indentString : "") + line.trimEnd();
      }).join("\n");
    }
  }
  exports.Help = Help;
});

// node_modules/commander/lib/option.js
var require_option = __commonJS((exports) => {
  var camelcase = function(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  };
  var splitOptionFlags = function(flags) {
    let shortFlag;
    let longFlag;
    const flagParts = flags.split(/[ |,]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
      shortFlag = flagParts.shift();
    longFlag = flagParts.shift();
    if (!shortFlag && /^-[^-]$/.test(longFlag)) {
      shortFlag = longFlag;
      longFlag = undefined;
    }
    return { shortFlag, longFlag };
  };
  var { InvalidArgumentError } = require_error();

  class Option {
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.presetArg = undefined;
      this.envVar = undefined;
      this.parseArg = undefined;
      this.hidden = false;
      this.argChoices = undefined;
      this.conflictsWith = [];
      this.implied = undefined;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    preset(arg) {
      this.presetArg = arg;
      return this;
    }
    conflicts(names) {
      this.conflictsWith = this.conflictsWith.concat(names);
      return this;
    }
    implies(impliedOptionValues) {
      let newImplied = impliedOptionValues;
      if (typeof impliedOptionValues === "string") {
        newImplied = { [impliedOptionValues]: true };
      }
      this.implied = Object.assign(this.implied || {}, newImplied);
      return this;
    }
    env(name) {
      this.envVar = name;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    attributeName() {
      return camelcase(this.name().replace(/^no-/, ""));
    }
    is(arg) {
      return this.short === arg || this.long === arg;
    }
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }

  class DualOptions {
    constructor(options) {
      this.positiveOptions = new Map;
      this.negativeOptions = new Map;
      this.dualOptions = new Set;
      options.forEach((option) => {
        if (option.negate) {
          this.negativeOptions.set(option.attributeName(), option);
        } else {
          this.positiveOptions.set(option.attributeName(), option);
        }
      });
      this.negativeOptions.forEach((value, key) => {
        if (this.positiveOptions.has(key)) {
          this.dualOptions.add(key);
        }
      });
    }
    valueFromOption(value, option) {
      const optionKey = option.attributeName();
      if (!this.dualOptions.has(optionKey))
        return true;
      const preset = this.negativeOptions.get(optionKey).presetArg;
      const negativeValue = preset !== undefined ? preset : false;
      return option.negate === (negativeValue === value);
    }
  }
  exports.Option = Option;
  exports.splitOptionFlags = splitOptionFlags;
  exports.DualOptions = DualOptions;
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS((exports) => {
  var editDistance = function(a, b) {
    if (Math.abs(a.length - b.length) > maxDistance)
      return Math.max(a.length, b.length);
    const d = [];
    for (let i = 0;i <= a.length; i++) {
      d[i] = [i];
    }
    for (let j = 0;j <= b.length; j++) {
      d[0][j] = j;
    }
    for (let j = 1;j <= b.length; j++) {
      for (let i = 1;i <= a.length; i++) {
        let cost = 1;
        if (a[i - 1] === b[j - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
        }
      }
    }
    return d[a.length][b.length];
  };
  var suggestSimilar = function(word, candidates) {
    if (!candidates || candidates.length === 0)
      return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1)
        return;
      const distance = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance) / length;
      if (similarity > minSimilarity) {
        if (distance < bestDistance) {
          bestDistance = distance;
          similar = [candidate];
        } else if (distance === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a, b) => a.localeCompare(b));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `\n(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `\n(Did you mean ${similar[0]}?)`;
    }
    return "";
  };
  var maxDistance = 3;
  exports.suggestSimilar = suggestSimilar;
});

// node_modules/commander/lib/command.js
var require_command = __commonJS((exports) => {
  var outputHelpIfRequested = function(cmd, args) {
    const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
    if (helpOption) {
      cmd.outputHelp();
      cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
    }
  };
  var incrementNodeInspectorPort = function(args) {
    return args.map((arg) => {
      if (!arg.startsWith("--inspect")) {
        return arg;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort = "9229";
      let match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          debugPort = match[3];
        } else {
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }
      if (debugOption && debugPort !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
      return arg;
    });
  };
  var EventEmitter = __require("events").EventEmitter;
  var childProcess = __require("child_process");
  var path = __require("path");
  var fs = __require("fs");
  var process2 = __require("process");
  var { Argument, humanReadableArgName } = require_argument();
  var { CommanderError } = require_error();
  var { Help } = require_help();
  var { Option, splitOptionFlags, DualOptions } = require_option();
  var { suggestSimilar } = require_suggestSimilar();

  class Command extends EventEmitter {
    constructor(name) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = true;
      this.registeredArguments = [];
      this._args = this.registeredArguments;
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._executableDir = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._summary = "";
      this._argsDescription = undefined;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = true;
      this._outputConfiguration = {
        writeOut: (str) => process2.stdout.write(str),
        writeErr: (str) => process2.stderr.write(str),
        getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : undefined,
        getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : undefined,
        outputError: (str, write) => write(str)
      };
      this._hidden = false;
      this._hasHelpOption = true;
      this._helpFlags = "-h, --help";
      this._helpDescription = "display help for command";
      this._helpShortFlag = "-h";
      this._helpLongFlag = "--help";
      this._addImplicitHelpCommand = undefined;
      this._helpCommandName = "help";
      this._helpCommandnameAndArgs = "help [command]";
      this._helpCommandDescription = "display help for command";
      this._helpConfiguration = {};
    }
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._hasHelpOption = sourceCommand._hasHelpOption;
      this._helpFlags = sourceCommand._helpFlags;
      this._helpDescription = sourceCommand._helpDescription;
      this._helpShortFlag = sourceCommand._helpShortFlag;
      this._helpLongFlag = sourceCommand._helpLongFlag;
      this._helpCommandName = sourceCommand._helpCommandName;
      this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
      this._helpCommandDescription = sourceCommand._helpCommandDescription;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    _getCommandAndAncestors() {
      const result = [];
      for (let command = this;command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args)
        cmd.arguments(args);
      this.commands.push(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc)
        return this;
      return cmd;
    }
    createCommand(name) {
      return new Command(name);
    }
    createHelp() {
      return Object.assign(new Help, this.configureHelp());
    }
    configureHelp(configuration) {
      if (configuration === undefined)
        return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    configureOutput(configuration) {
      if (configuration === undefined)
        return this._outputConfiguration;
      Object.assign(this._outputConfiguration, configuration);
      return this;
    }
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string")
        displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    addCommand(cmd, opts) {
      if (!cmd._name) {
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      }
      opts = opts || {};
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden)
        cmd._hidden = true;
      this.commands.push(cmd);
      cmd.parent = this;
      return this;
    }
    createArgument(name, description) {
      return new Argument(name, description);
    }
    argument(name, description, fn, defaultValue) {
      const argument = this.createArgument(name, description);
      if (typeof fn === "function") {
        argument.default(defaultValue).argParser(fn);
      } else {
        argument.default(fn);
      }
      this.addArgument(argument);
      return this;
    }
    arguments(names) {
      names.trim().split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    addArgument(argument) {
      const previousArgument = this.registeredArguments.slice(-1)[0];
      if (previousArgument && previousArgument.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
        throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
      }
      this.registeredArguments.push(argument);
      return this;
    }
    addHelpCommand(enableOrNameAndArgs, description) {
      if (enableOrNameAndArgs === false) {
        this._addImplicitHelpCommand = false;
      } else {
        this._addImplicitHelpCommand = true;
        if (typeof enableOrNameAndArgs === "string") {
          this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
          this._helpCommandnameAndArgs = enableOrNameAndArgs;
        }
        this._helpCommandDescription = description || this._helpCommandDescription;
      }
      return this;
    }
    _hasImplicitHelpCommand() {
      if (this._addImplicitHelpCommand === undefined) {
        return this.commands.length && !this._actionHandler && !this._findCommand("help");
      }
      return this._addImplicitHelpCommand;
    }
    hook(event, listener) {
      const allowedValues = ["preSubcommand", "preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          } else {
          }
        };
      }
      return this;
    }
    _exit(exitCode, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code, message));
      }
      process2.exit(exitCode);
    }
    action(fn) {
      const listener = (args) => {
        const expectedArgsCount = this.registeredArguments.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      };
      this._actionHandler = listener;
      return this;
    }
    createOption(flags, description) {
      return new Option(flags, description);
    }
    _callParseArg(target, value, previous, invalidArgumentMessage) {
      try {
        return target.parseArg(value, previous);
      } catch (err) {
        if (err.code === "commander.invalidArgument") {
          const message = `${invalidArgumentMessage} ${err.message}`;
          this.error(message, { exitCode: err.exitCode, code: err.code });
        }
        throw err;
      }
    }
    addOption(option) {
      const oname = option.name();
      const name = option.attributeName();
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, "--");
        if (!this._findOption(positiveLongFlag)) {
          this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
        }
      } else if (option.defaultValue !== undefined) {
        this.setOptionValueWithSource(name, option.defaultValue, "default");
      }
      this.options.push(option);
      const handleOptionValue = (val2, invalidValueMessage, valueSource) => {
        if (val2 == null && option.presetArg !== undefined) {
          val2 = option.presetArg;
        }
        const oldValue = this.getOptionValue(name);
        if (val2 !== null && option.parseArg) {
          val2 = this._callParseArg(option, val2, oldValue, invalidValueMessage);
        } else if (val2 !== null && option.variadic) {
          val2 = option._concatValue(val2, oldValue);
        }
        if (val2 == null) {
          if (option.negate) {
            val2 = false;
          } else if (option.isBoolean() || option.optional) {
            val2 = true;
          } else {
            val2 = "";
          }
        }
        this.setOptionValueWithSource(name, val2, valueSource);
      };
      this.on("option:" + oname, (val2) => {
        const invalidValueMessage = `error: option '${option.flags}' argument '${val2}' is invalid.`;
        handleOptionValue(val2, invalidValueMessage, "cli");
      });
      if (option.envVar) {
        this.on("optionEnv:" + oname, (val2) => {
          const invalidValueMessage = `error: option '${option.flags}' value '${val2}' from env '${option.envVar}' is invalid.`;
          handleOptionValue(val2, invalidValueMessage, "env");
        });
      }
      return this;
    }
    _optionEx(config, flags, description, fn, defaultValue) {
      if (typeof flags === "object" && flags instanceof Option) {
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      }
      const option = this.createOption(flags, description);
      option.makeOptionMandatory(!!config.mandatory);
      if (typeof fn === "function") {
        option.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = (val2, def) => {
          const m = regex.exec(val2);
          return m ? m[0] : def;
        };
        option.default(defaultValue).argParser(fn);
      } else {
        option.default(fn);
      }
      return this.addOption(option);
    }
    option(flags, description, parseArg, defaultValue) {
      return this._optionEx({}, flags, description, parseArg, defaultValue);
    }
    requiredOption(flags, description, parseArg, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
    }
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
        throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
      }
      return this;
    }
    storeOptionsAsProperties(storeAsProperties = true) {
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      this._storeOptionsAsProperties = !!storeAsProperties;
      return this;
    }
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    setOptionValue(key, value) {
      return this.setOptionValueWithSource(key, value, undefined);
    }
    setOptionValueWithSource(key, value, source) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
      this._optionValueSources[key] = source;
      return this;
    }
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    getOptionValueSourceWithGlobals(key) {
      let source;
      this._getCommandAndAncestors().forEach((cmd) => {
        if (cmd.getOptionValueSource(key) !== undefined) {
          source = cmd.getOptionValueSource(key);
        }
      });
      return source;
    }
    _prepareUserArgs(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions = parseOptions || {};
      if (argv === undefined) {
        argv = process2.argv;
        if (process2.versions && process2.versions.electron) {
          parseOptions.from = "electron";
        }
      }
      this.rawArgs = argv.slice();
      let userArgs;
      switch (parseOptions.from) {
        case undefined:
        case "node":
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;
        case "electron":
          if (process2.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }
          break;
        case "user":
          userArgs = argv.slice(0);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
      }
      if (!this._name && this._scriptPath)
        this.nameFromFilename(this._scriptPath);
      this._name = this._name || "program";
      return userArgs;
    }
    parse(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      this._parseCommand([], userArgs);
      return this;
    }
    async parseAsync(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      await this._parseCommand([], userArgs);
      return this;
    }
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function findFile(baseDir, baseName) {
        const localBin = path.resolve(baseDir, baseName);
        if (fs.existsSync(localBin))
          return localBin;
        if (sourceExt.includes(path.extname(baseName)))
          return;
        const foundExt = sourceExt.find((ext) => fs.existsSync(`${localBin}${ext}`));
        if (foundExt)
          return `${localBin}${foundExt}`;
        return;
      }
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
      let executableDir = this._executableDir || "";
      if (this._scriptPath) {
        let resolvedScriptPath;
        try {
          resolvedScriptPath = fs.realpathSync(this._scriptPath);
        } catch (err) {
          resolvedScriptPath = this._scriptPath;
        }
        executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
      }
      if (executableDir) {
        let localFile = findFile(executableDir, executableFile);
        if (!localFile && !subcommand._executableFile && this._scriptPath) {
          const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
          if (legacyName !== this._name) {
            localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
          }
        }
        executableFile = localFile || executableFile;
      }
      launchWithNode = sourceExt.includes(path.extname(executableFile));
      let proc;
      if (process2.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
        }
      } else {
        args.unshift(executableFile);
        args = incrementNodeInspectorPort(process2.execArgv).concat(args);
        proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
      }
      if (!proc.killed) {
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process2.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
      }
      const exitCallback = this._exitCallback;
      if (!exitCallback) {
        proc.on("close", process2.exit.bind(process2));
      } else {
        proc.on("close", () => {
          exitCallback(new CommanderError(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
        });
      }
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
          const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
          throw new Error(executableMissing);
        } else if (err.code === "EACCES") {
          throw new Error(`'${executableFile}' not executable`);
        }
        if (!exitCallback) {
          process2.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand)
        this.help({ error: true });
      let promiseChain;
      promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
      promiseChain = this._chainOrCall(promiseChain, () => {
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      });
      return promiseChain;
    }
    _dispatchHelpCommand(subcommandName) {
      if (!subcommandName) {
        this.help();
      }
      const subCommand = this._findCommand(subcommandName);
      if (subCommand && !subCommand._executableHandler) {
        subCommand.help();
      }
      return this._dispatchSubcommand(subcommandName, [], [
        this._helpLongFlag || this._helpShortFlag
      ]);
    }
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((arg, i) => {
        if (arg.required && this.args[i] == null) {
          this.missingArgument(arg.name());
        }
      });
      if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
        return;
      }
      if (this.args.length > this.registeredArguments.length) {
        this._excessArguments(this.args);
      }
    }
    _processArguments() {
      const myParseArg = (argument, value, previous) => {
        let parsedValue = value;
        if (value !== null && argument.parseArg) {
          const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
          parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
        }
        return parsedValue;
      };
      this._checkNumberOfArguments();
      const processedArgs = [];
      this.registeredArguments.forEach((declaredArg, index) => {
        let value = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index < this.args.length) {
            value = this.args.slice(index);
            if (declaredArg.parseArg) {
              value = value.reduce((processed, v) => {
                return myParseArg(declaredArg, v, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value === undefined) {
            value = [];
          }
        } else if (index < this.args.length) {
          value = this.args[index];
          if (declaredArg.parseArg) {
            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
          }
        }
        processedArgs[index] = value;
      });
      this.processedArgs = processedArgs;
    }
    _chainOrCall(promise, fn) {
      if (promise && promise.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    _chainOrCallSubCommandHook(promise, subCommand, event) {
      let result = promise;
      if (this._lifeCycleHooks[event] !== undefined) {
        this._lifeCycleHooks[event].forEach((hook) => {
          result = this._chainOrCall(result, () => {
            return hook(this, subCommand);
          });
        });
      }
      return result;
    }
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      this._parseOptionsImplied();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
        return this._dispatchHelpCommand(operands[1]);
      }
      if (this._defaultCommandName) {
        outputHelpIfRequested(this, unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      outputHelpIfRequested(this, parsed.unknown);
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      const checkForUnknownOptions = () => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      };
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let promiseChain;
        promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
        promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
        if (this.parent) {
          promiseChain = this._chainOrCall(promiseChain, () => {
            this.parent.emit(commandEvent, operands, unknown);
          });
        }
        promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
        return promiseChain;
      }
      if (this.parent && this.parent.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    _findCommand(name) {
      if (!name)
        return;
      return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
    }
    _findOption(arg) {
      return this.options.find((option) => option.is(arg));
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      });
    }
    _checkForConflictingLocalOptions() {
      const definedNonDefaultOptions = this.options.filter((option) => {
        const optionKey = option.attributeName();
        if (this.getOptionValue(optionKey) === undefined) {
          return false;
        }
        return this.getOptionValueSource(optionKey) !== "default";
      });
      const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
      optionsWithConflicting.forEach((option) => {
        const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
        if (conflictingAndDefined) {
          this._conflictingOption(option, conflictingAndDefined);
        }
      });
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd._checkForConflictingLocalOptions();
      });
    }
    parseOptions(argv) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      const args = argv.slice();
      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === "-";
      }
      let activeVariadicOption = null;
      while (args.length) {
        const arg = args.shift();
        if (arg === "--") {
          if (dest === unknown)
            dest.push(arg);
          dest.push(...args);
          break;
        }
        if (activeVariadicOption && !maybeOption(arg)) {
          this.emit(`option:${activeVariadicOption.name()}`, arg);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg)) {
          const option = this._findOption(arg);
          if (option) {
            if (option.required) {
              const value = args.shift();
              if (value === undefined)
                this.optionMissingArgument(option);
              this.emit(`option:${option.name()}`, value);
            } else if (option.optional) {
              let value = null;
              if (args.length > 0 && !maybeOption(args[0])) {
                value = args.shift();
              }
              this.emit(`option:${option.name()}`, value);
            } else {
              this.emit(`option:${option.name()}`);
            }
            activeVariadicOption = option.variadic ? option : null;
            continue;
          }
        }
        if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
          const option = this._findOption(`-${arg[1]}`);
          if (option) {
            if (option.required || option.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option.name()}`, arg.slice(2));
            } else {
              this.emit(`option:${option.name()}`);
              args.unshift(`-${arg.slice(2)}`);
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg)) {
          const index = arg.indexOf("=");
          const option = this._findOption(arg.slice(0, index));
          if (option && (option.required || option.optional)) {
            this.emit(`option:${option.name()}`, arg.slice(index + 1));
            continue;
          }
        }
        if (maybeOption(arg)) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg)) {
            operands.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
            operands.push(arg);
            if (args.length > 0)
              operands.push(...args);
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg);
          if (args.length > 0)
            dest.push(...args);
          break;
        }
        dest.push(arg);
      }
      return { operands, unknown };
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i = 0;i < len; i++) {
          const key = this.options[i].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
    }
    error(message, errorOptions) {
      this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr("\n");
        this.outputHelp({ error: true });
      }
      const config = errorOptions || {};
      const exitCode = config.exitCode || 1;
      const code = config.code || "commander.error";
      this._exit(exitCode, code, message);
    }
    _parseOptionsEnv() {
      this.options.forEach((option) => {
        if (option.envVar && (option.envVar in process2.env)) {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option.required || option.optional) {
              this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
            } else {
              this.emit(`optionEnv:${option.name()}`);
            }
          }
        }
      });
    }
    _parseOptionsImplied() {
      const dualHelper = new DualOptions(this.options);
      const hasCustomOptionValue = (optionKey) => {
        return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
      };
      this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
        Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
          this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
        });
      });
    }
    missingArgument(name) {
      const message = `error: missing required argument '${name}'`;
      this.error(message, { code: "commander.missingArgument" });
    }
    optionMissingArgument(option) {
      const message = `error: option '${option.flags}' argument missing`;
      this.error(message, { code: "commander.optionMissingArgument" });
    }
    missingMandatoryOptionValue(option) {
      const message = `error: required option '${option.flags}' not specified`;
      this.error(message, { code: "commander.missingMandatoryOptionValue" });
    }
    _conflictingOption(option, conflictingOption) {
      const findBestOptionFromValue = (option2) => {
        const optionKey = option2.attributeName();
        const optionValue = this.getOptionValue(optionKey);
        const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
        const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
        if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
          return negativeOption;
        }
        return positiveOption || option2;
      };
      const getErrorMessage = (option2) => {
        const bestOption = findBestOptionFromValue(option2);
        const optionKey = bestOption.attributeName();
        const source = this.getOptionValueSource(optionKey);
        if (source === "env") {
          return `environment variable '${bestOption.envVar}'`;
        }
        return `option '${bestOption.flags}'`;
      };
      const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
      this.error(message, { code: "commander.conflictingOption" });
    }
    unknownOption(flag) {
      if (this._allowUnknownOption)
        return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command = this;
        do {
          const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command = command.parent;
        } while (command && !command._enablePositionalOptions);
        suggestion = suggestSimilar(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this.error(message, { code: "commander.unknownOption" });
    }
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments)
        return;
      const expected = this.registeredArguments.length;
      const s = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
      this.error(message, { code: "commander.excessArguments" });
    }
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command) => {
          candidateNames.push(command.name());
          if (command.alias())
            candidateNames.push(command.alias());
        });
        suggestion = suggestSimilar(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this.error(message, { code: "commander.unknownCommand" });
    }
    version(str, flags, description) {
      if (str === undefined)
        return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this.options.push(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}\n`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined)
        return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    summary(str) {
      if (str === undefined)
        return this._summary;
      this._summary = str;
      return this;
    }
    alias(alias) {
      if (alias === undefined)
        return this._aliases[0];
      let command = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command = this.commands[this.commands.length - 1];
      }
      if (alias === command._name)
        throw new Error("Command alias can\'t be the same as its name");
      command._aliases.push(alias);
      return this;
    }
    aliases(aliases) {
      if (aliases === undefined)
        return this._aliases;
      aliases.forEach((alias) => this.alias(alias));
      return this;
    }
    usage(str) {
      if (str === undefined) {
        if (this._usage)
          return this._usage;
        const args = this.registeredArguments.map((arg) => {
          return humanReadableArgName(arg);
        });
        return [].concat(this.options.length || this._hasHelpOption ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
      }
      this._usage = str;
      return this;
    }
    name(str) {
      if (str === undefined)
        return this._name;
      this._name = str;
      return this;
    }
    nameFromFilename(filename) {
      this._name = path.basename(filename, path.extname(filename));
      return this;
    }
    executableDir(path2) {
      if (path2 === undefined)
        return this._executableDir;
      this._executableDir = path2;
      return this;
    }
    helpInformation(contextOptions) {
      const helper = this.createHelp();
      if (helper.helpWidth === undefined) {
        helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
      }
      return helper.formatHelp(this, helper);
    }
    _getHelpContext(contextOptions) {
      contextOptions = contextOptions || {};
      const context = { error: !!contextOptions.error };
      let write;
      if (context.error) {
        write = (arg) => this._outputConfiguration.writeErr(arg);
      } else {
        write = (arg) => this._outputConfiguration.writeOut(arg);
      }
      context.write = contextOptions.write || write;
      context.command = this;
      return context;
    }
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = undefined;
      }
      const context = this._getHelpContext(contextOptions);
      this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
      this.emit("beforeHelp", context);
      let helpInformation = this.helpInformation(context);
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      context.write(helpInformation);
      if (this._helpLongFlag) {
        this.emit(this._helpLongFlag);
      }
      this.emit("afterHelp", context);
      this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", context));
    }
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        this._hasHelpOption = flags;
        return this;
      }
      this._helpFlags = flags || this._helpFlags;
      this._helpDescription = description || this._helpDescription;
      const helpFlags = splitOptionFlags(this._helpFlags);
      this._helpShortFlag = helpFlags.shortFlag;
      this._helpLongFlag = helpFlags.longFlag;
      return this;
    }
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode = process2.exitCode || 0;
      if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode = 1;
      }
      this._exit(exitCode, "commander.help", "(outputHelp)");
    }
    addHelpText(position, text) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position}Help`;
      this.on(helpEvent, (context) => {
        let helpStr;
        if (typeof text === "function") {
          helpStr = text({ error: context.error, command: context.command });
        } else {
          helpStr = text;
        }
        if (helpStr) {
          context.write(`${helpStr}\n`);
        }
      });
      return this;
    }
  }
  exports.Command = Command;
});

// node_modules/commander/index.js
var require_commander = __commonJS((exports, module) => {
  var { Argument } = require_argument();
  var { Command } = require_command();
  var { CommanderError, InvalidArgumentError } = require_error();
  var { Help } = require_help();
  var { Option } = require_option();
  exports = module.exports = new Command;
  exports.program = exports;
  exports.Command = Command;
  exports.Option = Option;
  exports.Argument = Argument;
  exports.Help = Help;
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
  exports.InvalidOptionArgumentError = InvalidArgumentError;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val2, options) {
    options = options || {};
    var type = typeof val2;
    if (type === "string" && val2.length > 0) {
      return parse(val2);
    } else if (type === "number" && isFinite(val2)) {
      return options.long ? fmtLong(val2) : fmtShort(val2);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val2));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val2 = args[index];
            match = formatter.call(self2, val2);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val2) {
      if (val2 instanceof Error) {
        return val2.stack || val2.message;
      }
      return val2;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && ("env" in process)) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var envForceColor = function() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  };
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  };
  var getSupportLevel = function(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  };
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val2 = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val2)) {
      val2 = true;
    } else if (/^(no|off|false|disabled)$/i.test(val2)) {
      val2 = false;
    } else if (val2 === "null") {
      val2 = null;
    } else {
      val2 = Number(val2);
    }
    obj[prop] = val2;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var DataStream = function(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = __require("stream");
  var util = __require("util");
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var bufferEq = function(a, b) {
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0;i < a.length; i++) {
      c |= a[i] ^ b[i];
    }
    return c === 0;
  };
  var Buffer2 = __require("buffer").Buffer;
  var SlowBuffer = __require("buffer").SlowBuffer;
  module.exports = bufferEq;
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  var getParamSize = function(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  };
  var getParamBytesForAlg = function(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  };
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var base64Url = function(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  var signatureAsBuffer = function(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  };
  var derToJose = function(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset;offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  };
  var countPadding = function(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  };
  var joseToDer = function(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var checkIsPublicKey = function(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  };
  var checkIsPrivateKey = function(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  };
  var checkIsSecretKey = function(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  };
  var fromBase64 = function(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  var toBase64 = function(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i = 0;i < padding; ++i) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  };
  var typeError = function(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  };
  var bufferOrString = function(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  };
  var normalizeInput = function(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  };
  var createHmacSigner = function(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  };
  var createHmacVerifier = function(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  };
  var createKeySigner = function(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  };
  var createKeyVerifier = function(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  };
  var createPSSKeySigner = function(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  };
  var createPSSKeyVerifier = function(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  };
  var createECDSASigner = function(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  };
  var createECDSAVerifer = function(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  };
  var createNoneSigner = function() {
    return function sign() {
      return "";
    };
  };
  var createNoneVerifier = function() {
    return function verify(thing, signature) {
      return signature === "";
    };
  };
  var bufferEqual = require_buffer_equal_constant_time();
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto = __require("crypto");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = __require("util");
  var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var base64url = function(string, encoding) {
    return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  var jwsSecuredInput = function(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  };
  var jwsSign = function(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  };
  var SignStream = function(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = __require("stream");
  var toString = require_tostring();
  var util = __require("util");
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var isObject = function(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  };
  var safeJsonParse = function(thing) {
    if (isObject(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return;
    }
  };
  var headerFromJWS = function(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  };
  var securedInputFromJWS = function(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  };
  var signatureFromJWS = function(jwsSig) {
    return jwsSig.split(".")[2];
  };
  var payloadFromJWS = function(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  };
  var isValidJws = function(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
  };
  var jwsVerify = function(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  };
  var jwsDecode = function(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  };
  var VerifyStream = function(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = __require("stream");
  var toString = require_tostring();
  var util = __require("util");
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports, module) => {
  var jws = require_jws();
  module.exports = function(jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e) {
      }
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
  var JsonWebTokenError = function(message, error) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error)
      this.inner = error;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function(message, date) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module.exports = TokenExpiredError;
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
  var ms = require_ms();
  module.exports = function(time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);
    if (typeof time === "string") {
      var milliseconds = ms(time);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1000);
    } else if (typeof time === "number") {
      return timestamp + time;
    } else {
      return;
    }
  };
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse = require_parse();
  var valid = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse = require_parse();
  var clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = require_parse();
  var { safeRe: re, t } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
  module.exports = coerce;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lru_cache();
  var cache = new LRU({ max: 1000 });
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse = require_parse();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
  var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
  var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
  var allowedAlgorithmsForKeys = {
    ec: ["ES256", "ES384", "ES512"],
    rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  var allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  module.exports = function(algorithm, key) {
    if (!algorithm || !key)
      return;
    const keyType = key.asymmetricKeyType;
    if (!keyType)
      return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== undefined && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode = require_decode();
  var timespan = require_timespan();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var { KeyObject, createSecretKey, createPublicKey } = __require("crypto");
  var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err, data) {
        if (err)
          throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err, secretOrPublicKey2) {
      if (err) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_2) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
      }
      let valid;
      try {
        valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e) {
        return done(e);
      }
      if (!valid) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS((exports, module) => {
  var arrayMap = function(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  };
  var baseFindIndex = function(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  };
  var baseIndexOf = function(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  };
  var baseIsNaN = function(value) {
    return value !== value;
  };
  var baseTimes = function(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  };
  var baseValues = function(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  };
  var overArg = function(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  };
  var arrayLikeKeys = function(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  };
  var baseKeys = function(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  };
  var isIndex = function(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  };
  var isPrototype = function(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var includes = function(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  };
  var isArguments = function(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  };
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isArrayLikeObject = function(value) {
    return isObjectLike(value) && isArrayLike(value);
  };
  var isFunction = function(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var isObject = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isString = function(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  };
  var toFinite = function(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  };
  var toInteger = function(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  };
  var toNumber = function(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  };
  var keys = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  };
  var values = function(object) {
    return object ? baseValues(object, keys(object)) : [];
  };
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  var isArray = Array.isArray;
  module.exports = includes;
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var isBoolean = function(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = isBoolean;
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var isInteger = function(value) {
    return typeof value == "number" && value == toInteger(value);
  };
  var isObject = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  };
  var toFinite = function(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  };
  var toInteger = function(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  };
  var toNumber = function(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  };
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isNumber = function(value) {
    return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
  };
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = isNumber;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var isHostObject = function(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  };
  var overArg = function(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isPlainObject = function(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  };
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = isPlainObject;
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS((exports, module) => {
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isString = function(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  };
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  module.exports = isString;
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS((exports, module) => {
  var before = function(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  };
  var once = function(func) {
    return before(2, func);
  };
  var isObject = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  };
  var toFinite = function(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  };
  var toInteger = function(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  };
  var toNumber = function(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = once;
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports, module) => {
  var validate = function(schema, allowUnknown, object, parameterName) {
    if (!isPlainObject(object)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object).forEach(function(key) {
      const validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
  };
  var validateOptions = function(options) {
    return validate(sign_options_schema, false, options, "options");
  };
  var validatePayload = function(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  };
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var jws = require_jws();
  var includes = require_lodash();
  var isBoolean = require_lodash2();
  var isInteger = require_lodash3();
  var isNumber = require_lodash4();
  var isPlainObject = require_lodash5();
  var isString = require_lodash6();
  var once = require_lodash7();
  var { KeyObject, createSecretKey, createPrivateKey } = __require("crypto");
  var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  var sign_options_schema = {
    expiresIn: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value) {
      return isString(value) || Array.isArray(value);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
  };
  var options_to_payload = {
    audience: "aud",
    issuer: "iss",
    subject: "sub",
    jwtid: "jti"
  };
  var options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : undefined,
      kid: options.keyid
    }, options.header);
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
      try {
        secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
      } catch (_) {
        try {
          secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
        } catch (_2) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error) {
        return failure(error);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error) {
      return failure(error);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPrivateKey);
      } catch (error) {
        return failure(error);
      }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan(options.notBefore, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan(options.expiresIn, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once(callback);
      jws.createSign({
        header,
        privateKey: secretOrPrivateKey,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
  module.exports = {
    decode: require_decode(),
    verify: require_verify(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError()
  };
});

// node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  module.exports = function(...args) {
    try {
      return JSON.stringify(...args);
    } catch (err) {
      return "[Cannot display object: " + err.message + "]";
    }
  };
});

// node_modules/@hapi/hoek/lib/error.js
var require_error2 = __commonJS((exports, module) => {
  var Stringify = require_stringify();
  module.exports = class extends Error {
    constructor(args) {
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      super(msgs.join(" ") || "Unknown error");
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, exports.assert);
      }
    }
  };
});

// node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS((exports, module) => {
  var AssertError = require_error2();
  module.exports = function(condition, ...args) {
    if (condition) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Error) {
      throw args[0];
    }
    throw new AssertError(args);
  };
});

// node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS((exports, module) => {
  var Assert = require_assert();
  var internals = {};
  module.exports = function(obj, chain, options) {
    if (chain === false || chain === null || chain === undefined) {
      return obj;
    }
    options = options || {};
    if (typeof options === "string") {
      options = { separator: options };
    }
    const isChainArray = Array.isArray(chain);
    Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
    const path = isChainArray ? chain : chain.split(options.separator || ".");
    let ref = obj;
    for (let i = 0;i < path.length; ++i) {
      let key = path[i];
      const type = options.iterables && internals.iterables(ref);
      if (Array.isArray(ref) || type === "set") {
        const number = Number(key);
        if (Number.isInteger(number)) {
          key = number < 0 ? ref.length + number : number;
        }
      }
      if (!ref || typeof ref === "function" && options.functions === false || !type && ref[key] === undefined) {
        Assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
        Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
        ref = options.default;
        break;
      }
      if (!type) {
        ref = ref[key];
      } else if (type === "set") {
        ref = [...ref][key];
      } else {
        ref = ref.get(key);
      }
    }
    return ref;
  };
  internals.iterables = function(ref) {
    if (ref instanceof Set) {
      return "set";
    }
    if (ref instanceof Map) {
      return "map";
    }
  };
});

// node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS((exports, module) => {
  var internals = {};
  exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
  };
  internals.typeMap = new Map([
    ["[object Error]", exports.error],
    ["[object Map]", exports.map],
    ["[object Promise]", exports.promise],
    ["[object Set]", exports.set],
    ["[object WeakMap]", exports.weakMap],
    ["[object WeakSet]", exports.weakSet]
  ]);
  exports.getInternalProto = function(obj) {
    if (Array.isArray(obj)) {
      return exports.array;
    }
    if (Buffer && obj instanceof Buffer) {
      return exports.buffer;
    }
    if (obj instanceof Date) {
      return exports.date;
    }
    if (obj instanceof RegExp) {
      return exports.regex;
    }
    if (obj instanceof Error) {
      return exports.error;
    }
    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
  };
});

// node_modules/@hapi/hoek/lib/utils.js
var require_utils = __commonJS((exports) => {
  exports.keys = function(obj, options = {}) {
    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
  };
});

// node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS((exports, module) => {
  var Reach = require_reach();
  var Types = require_types();
  var Utils = require_utils();
  var internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
  };
  module.exports = internals.clone = function(obj, options = {}, _seen = null) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    let clone = internals.clone;
    let seen = _seen;
    if (options.shallow) {
      if (options.shallow !== true) {
        return internals.cloneWithShallow(obj, options);
      }
      clone = (value) => value;
    } else if (seen) {
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
    } else {
      seen = new Map;
    }
    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
      return Buffer && Buffer.from(obj);
    }
    if (baseProto === Types.date) {
      return new Date(obj.getTime());
    }
    if (baseProto === Types.regex) {
      return new RegExp(obj);
    }
    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
      return obj;
    }
    if (seen) {
      seen.set(obj, newObj);
    }
    if (baseProto === Types.set) {
      for (const value of obj) {
        newObj.add(clone(value, options, seen));
      }
    } else if (baseProto === Types.map) {
      for (const [key, value] of obj) {
        newObj.set(key, clone(value, options, seen));
      }
    }
    const keys = Utils.keys(obj, options);
    for (const key of keys) {
      if (key === "__proto__") {
        continue;
      }
      if (baseProto === Types.array && key === "length") {
        newObj.length = obj.length;
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor) {
        if (descriptor.get || descriptor.set) {
          Object.defineProperty(newObj, key, descriptor);
        } else if (descriptor.enumerable) {
          newObj[key] = clone(obj[key], options, seen);
        } else {
          Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
        }
      } else {
        Object.defineProperty(newObj, key, {
          enumerable: true,
          writable: true,
          configurable: true,
          value: clone(obj[key], options, seen)
        });
      }
    }
    return newObj;
  };
  internals.cloneWithShallow = function(source, options) {
    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;
    const seen = new Map;
    for (const key of keys) {
      const ref = Reach(source, key);
      if (typeof ref === "object" || typeof ref === "function") {
        seen.set(ref, ref);
      }
    }
    return internals.clone(source, options, seen);
  };
  internals.base = function(obj, baseProto, options) {
    if (options.prototype === false) {
      if (internals.needsProtoHack.has(baseProto)) {
        return new baseProto.constructor;
      }
      return baseProto === Types.array ? [] : {};
    }
    const proto = Object.getPrototypeOf(obj);
    if (proto && proto.isImmutable) {
      return obj;
    }
    if (baseProto === Types.array) {
      const newObj = [];
      if (proto !== baseProto) {
        Object.setPrototypeOf(newObj, proto);
      }
      return newObj;
    }
    if (internals.needsProtoHack.has(baseProto)) {
      const newObj = new proto.constructor;
      if (proto !== baseProto) {
        Object.setPrototypeOf(newObj, proto);
      }
      return newObj;
    }
    return Object.create(proto);
  };
});

// node_modules/joi/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "joi",
    description: "Object schema validation",
    version: "17.11.0",
    repository: "git://github.com/hapijs/joi",
    main: "lib/index.js",
    types: "lib/index.d.ts",
    browser: "dist/joi-browser.min.js",
    files: [
      "lib/**/*",
      "dist/*"
    ],
    keywords: [
      "schema",
      "validation"
    ],
    dependencies: {
      "@hapi/hoek": "^9.0.0",
      "@hapi/topo": "^5.0.0",
      "@sideway/address": "^4.1.3",
      "@sideway/formula": "^3.0.1",
      "@sideway/pinpoint": "^2.0.0"
    },
    devDependencies: {
      "@hapi/bourne": "2.x.x",
      "@hapi/code": "8.x.x",
      "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
      "@hapi/lab": "^25.0.1",
      "@types/node": "^14.18.24",
      typescript: "4.3.x"
    },
    scripts: {
      prepublishOnly: "cd browser && npm install && npm run build",
      test: "lab -t 100 -a @hapi/code -L -Y",
      "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
    },
    license: "BSD-3-Clause"
  };
});

// node_modules/joi/lib/schemas.js
var require_schemas = __commonJS((exports) => {
  var Joi = require_lib4();
  var internals = {};
  internals.wrap = Joi.string().min(1).max(2).allow(false);
  exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    artifacts: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid("date", "iso", "string", "time", "utc"),
    debug: Joi.boolean(),
    errors: {
      escapeHtml: Joi.boolean(),
      label: Joi.valid("path", "key", false),
      language: [
        Joi.string(),
        Joi.object().ref()
      ],
      render: Joi.boolean(),
      stack: Joi.boolean(),
      wrap: {
        label: internals.wrap,
        array: internals.wrap,
        string: internals.wrap
      }
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid("required", "optional", "forbidden"),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
      arrays: Joi.boolean(),
      objects: Joi.boolean()
    }).or("arrays", "objects").allow(true, false),
    warnings: Joi.boolean()
  }).strict();
  internals.nameRx = /^[a-zA-Z0-9]\w*$/;
  internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(Joi.string(), Joi.object({
      name: Joi.string().pattern(internals.nameRx).required(),
      ref: Joi.boolean(),
      assert: Joi.alternatives([
        Joi.function(),
        Joi.object().schema()
      ]).conditional("ref", { is: true, then: Joi.required() }),
      normalize: Joi.function(),
      message: Joi.string().when("assert", { is: Joi.function(), then: Joi.required() })
    })),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
  });
  exports.extension = Joi.object({
    type: Joi.alternatives([
      Joi.string(),
      Joi.object().regex()
    ]).required(),
    args: Joi.function(),
    cast: Joi.object().pattern(internals.nameRx, Joi.object({
      from: Joi.function().maxArity(1).required(),
      to: Joi.function().minArity(1).maxArity(2).required()
    })),
    base: Joi.object().schema().when("type", { is: Joi.object().regex(), then: Joi.forbidden() }),
    coerce: [
      Joi.function().maxArity(3),
      Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
      setter: Joi.string(),
      default: Joi.any()
    })),
    manifest: {
      build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
      init: Joi.array().allow(null).required(),
      manifest: Joi.object().pattern(/.+/, [
        Joi.valid("schema", "single"),
        Joi.object({
          mapped: Joi.object({
            from: Joi.string().required(),
            to: Joi.string().required()
          }).required()
        })
      ])
    })),
    validate: Joi.function().maxArity(3)
  }).strict();
  exports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();
  internals.desc = {
    buffer: Joi.object({
      buffer: Joi.string()
    }),
    func: Joi.object({
      function: Joi.function().required(),
      options: {
        literal: true
      }
    }),
    override: Joi.object({
      override: true
    }),
    ref: Joi.object({
      ref: Joi.object({
        type: Joi.valid("value", "global", "local"),
        path: Joi.array().required(),
        separator: Joi.string().length(1).allow(false),
        ancestor: Joi.number().min(0).integer().allow("root"),
        map: Joi.array().items(Joi.array().length(2)).min(1),
        adjust: Joi.function(),
        iterables: Joi.boolean(),
        in: Joi.boolean(),
        render: Joi.boolean()
      }).required()
    }),
    regex: Joi.object({
      regex: Joi.string().min(3)
    }),
    special: Joi.object({
      special: Joi.valid("deep").required()
    }),
    template: Joi.object({
      template: Joi.string().required(),
      options: Joi.object()
    }),
    value: Joi.object({
      value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
  };
  internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link("...")),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link("/")
  ]);
  internals.desc.values = Joi.array().items(null, Joi.boolean(), Joi.function(), Joi.number().allow(Infinity, (-Infinity)), Joi.string().allow(""), Joi.symbol(), internals.desc.buffer, internals.desc.func, internals.desc.override, internals.desc.ref, internals.desc.regex, internals.desc.template, internals.desc.value);
  internals.desc.messages = Joi.object().pattern(/.+/, [
    Joi.string(),
    internals.desc.template,
    Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
  ]);
  exports.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
      cast: Joi.string(),
      default: Joi.any(),
      description: Joi.string(),
      empty: Joi.link("/"),
      failover: internals.desc.entity,
      id: Joi.string(),
      label: Joi.string(),
      only: true,
      presence: ["optional", "required", "forbidden"],
      result: ["raw", "strip"],
      strip: Joi.boolean(),
      unit: Joi.string()
    }).unknown(),
    preferences: {
      allowUnknown: Joi.boolean(),
      abortEarly: Joi.boolean(),
      artifacts: Joi.boolean(),
      cache: Joi.boolean(),
      convert: Joi.boolean(),
      dateFormat: ["date", "iso", "string", "time", "utc"],
      errors: {
        escapeHtml: Joi.boolean(),
        label: ["path", "key"],
        language: [
          Joi.string(),
          internals.desc.ref
        ],
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      externals: Joi.boolean(),
      messages: internals.desc.messages,
      noDefaults: Joi.boolean(),
      nonEnumerables: Joi.boolean(),
      presence: ["required", "optional", "forbidden"],
      skipFunctions: Joi.boolean(),
      stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
      name: Joi.string().required(),
      args: Joi.object().min(1),
      keep: Joi.boolean(),
      message: [
        Joi.string(),
        internals.desc.messages
      ],
      warn: Joi.boolean()
    }),
    keys: Joi.object().pattern(/.*/, Joi.link("/")),
    link: internals.desc.ref
  }).pattern(/^[a-z]\w*$/, Joi.any());
});

// node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(input) {
    if (!input) {
      return "";
    }
    let escaped = "";
    for (let i = 0;i < input.length; ++i) {
      const charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeHtmlChar(charCode);
      }
    }
    return escaped;
  };
  internals.escapeHtmlChar = function(charCode) {
    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
      return namedEscape;
    }
    if (charCode >= 256) {
      return "&#" + charCode + ";";
    }
    const hexValue = charCode.toString(16).padStart(2, "0");
    return `&#x${hexValue};`;
  };
  internals.isSafe = function(charCode) {
    return internals.safeCharCodes.has(charCode);
  };
  internals.namedHtml = new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [34, "&quot;"],
    [160, "&nbsp;"],
    [162, "&cent;"],
    [163, "&pound;"],
    [164, "&curren;"],
    [169, "&copy;"],
    [174, "&reg;"]
  ]);
  internals.safeCharCodes = function() {
    const safe = new Set;
    for (let i = 32;i < 123; ++i) {
      if (i >= 97 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 32 || i === 46 || i === 44 || i === 45 || i === 58 || i === 95) {
        safe.add(i);
      }
    }
    return safe;
  }();
});

// node_modules/@sideway/formula/lib/index.js
var require_lib = __commonJS((exports) => {
  var internals = {
    operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
    operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
    operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
    operatorsPrefix: ["!", "n"],
    literals: {
      '"': '"',
      "`": "`",
      "\'": "\'",
      "[": "]"
    },
    numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
    symbol: Symbol("formula"),
    settings: Symbol("settings")
  };
  exports.Parser = class {
    constructor(string, options = {}) {
      if (!options[internals.settings] && options.constants) {
        for (const constant in options.constants) {
          const value = options.constants[constant];
          if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
            throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
          }
        }
      }
      this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
      this.single = null;
      this._parts = null;
      this._parse(string);
    }
    _parse(string) {
      let parts = [];
      let current = "";
      let parenthesis = 0;
      let literal = false;
      const flush = (inner) => {
        if (parenthesis) {
          throw new Error("Formula missing closing parenthesis");
        }
        const last = parts.length ? parts[parts.length - 1] : null;
        if (!literal && !current && !inner) {
          return;
        }
        if (last && last.type === "reference" && inner === ")") {
          last.type = "function";
          last.value = this._subFormula(current, last.value);
          current = "";
          return;
        }
        if (inner === ")") {
          const sub = new exports.Parser(current, this.settings);
          parts.push({ type: "segment", value: sub });
        } else if (literal) {
          if (literal === "]") {
            parts.push({ type: "reference", value: current });
            current = "";
            return;
          }
          parts.push({ type: "literal", value: current });
        } else if (internals.operatorCharacters.includes(current)) {
          if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
            last.value += current;
          } else {
            parts.push({ type: "operator", value: current });
          }
        } else if (current.match(internals.numberRx)) {
          parts.push({ type: "constant", value: parseFloat(current) });
        } else if (this.settings.constants[current] !== undefined) {
          parts.push({ type: "constant", value: this.settings.constants[current] });
        } else {
          if (!current.match(internals.tokenRx)) {
            throw new Error(`Formula contains invalid token: ${current}`);
          }
          parts.push({ type: "reference", value: current });
        }
        current = "";
      };
      for (const c of string) {
        if (literal) {
          if (c === literal) {
            flush();
            literal = false;
          } else {
            current += c;
          }
        } else if (parenthesis) {
          if (c === "(") {
            current += c;
            ++parenthesis;
          } else if (c === ")") {
            --parenthesis;
            if (!parenthesis) {
              flush(c);
            } else {
              current += c;
            }
          } else {
            current += c;
          }
        } else if (c in internals.literals) {
          literal = internals.literals[c];
        } else if (c === "(") {
          flush();
          ++parenthesis;
        } else if (internals.operatorCharacters.includes(c)) {
          flush();
          current = c;
          flush();
        } else if (c !== " ") {
          current += c;
        } else {
          flush();
        }
      }
      flush();
      parts = parts.map((part, i) => {
        if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
          return part;
        }
        return { type: "operator", value: "n" };
      });
      let operator = false;
      for (const part of parts) {
        if (part.type === "operator") {
          if (internals.operatorsPrefix.includes(part.value)) {
            continue;
          }
          if (!operator) {
            throw new Error("Formula contains an operator in invalid position");
          }
          if (!internals.operators.includes(part.value)) {
            throw new Error(`Formula contains an unknown operator ${part.value}`);
          }
        } else if (operator) {
          throw new Error("Formula missing expected operator");
        }
        operator = !operator;
      }
      if (!operator) {
        throw new Error("Formula contains invalid trailing operator");
      }
      if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
        this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
      }
      this._parts = parts.map((part) => {
        if (part.type === "operator") {
          return internals.operatorsPrefix.includes(part.value) ? part : part.value;
        }
        if (part.type !== "reference") {
          return part.value;
        }
        if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
          throw new Error(`Formula contains invalid reference ${part.value}`);
        }
        if (this.settings.reference) {
          return this.settings.reference(part.value);
        }
        return internals.reference(part.value);
      });
    }
    _subFormula(string, name) {
      const method = this.settings.functions[name];
      if (typeof method !== "function") {
        throw new Error(`Formula contains unknown function ${name}`);
      }
      let args = [];
      if (string) {
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = () => {
          if (!current) {
            throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
          }
          args.push(current);
          current = "";
        };
        for (let i = 0;i < string.length; ++i) {
          const c = string[i];
          if (literal) {
            current += c;
            if (c === literal) {
              literal = false;
            }
          } else if ((c in internals.literals) && !parenthesis) {
            current += c;
            literal = internals.literals[c];
          } else if (c === "," && !parenthesis) {
            flush();
          } else {
            current += c;
            if (c === "(") {
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
            }
          }
        }
        flush();
      }
      args = args.map((arg) => new exports.Parser(arg, this.settings));
      return function(context) {
        const innerValues = [];
        for (const arg of args) {
          innerValues.push(arg.evaluate(context));
        }
        return method.call(context, ...innerValues);
      };
    }
    evaluate(context) {
      const parts = this._parts.slice();
      for (let i = parts.length - 2;i >= 0; --i) {
        const part = parts[i];
        if (part && part.type === "operator") {
          const current = parts[i + 1];
          parts.splice(i + 1, 1);
          const value = internals.evaluate(current, context);
          parts[i] = internals.single(part.value, value);
        }
      }
      internals.operatorsOrder.forEach((set) => {
        for (let i = 1;i < parts.length - 1; ) {
          if (set.includes(parts[i])) {
            const operator = parts[i];
            const left = internals.evaluate(parts[i - 1], context);
            const right = internals.evaluate(parts[i + 1], context);
            parts.splice(i, 2);
            const result = internals.calculate(operator, left, right);
            parts[i - 1] = result === 0 ? 0 : result;
          } else {
            i += 2;
          }
        }
      });
      return internals.evaluate(parts[0], context);
    }
  };
  exports.Parser.prototype[internals.symbol] = true;
  internals.reference = function(name) {
    return function(context) {
      return context && context[name] !== undefined ? context[name] : null;
    };
  };
  internals.evaluate = function(part, context) {
    if (part === null) {
      return null;
    }
    if (typeof part === "function") {
      return part(context);
    }
    if (part[internals.symbol]) {
      return part.evaluate(context);
    }
    return part;
  };
  internals.single = function(operator, value) {
    if (operator === "!") {
      return value ? false : true;
    }
    const negative = -value;
    if (negative === 0) {
      return 0;
    }
    return negative;
  };
  internals.calculate = function(operator, left, right) {
    if (operator === "??") {
      return internals.exists(left) ? left : right;
    }
    if (typeof left === "string" || typeof right === "string") {
      if (operator === "+") {
        left = internals.exists(left) ? left : "";
        right = internals.exists(right) ? right : "";
        return left + right;
      }
    } else {
      switch (operator) {
        case "^":
          return Math.pow(left, right);
        case "*":
          return left * right;
        case "/":
          return left / right;
        case "%":
          return left % right;
        case "+":
          return left + right;
        case "-":
          return left - right;
      }
    }
    switch (operator) {
      case "<":
        return left < right;
      case "<=":
        return left <= right;
      case ">":
        return left > right;
      case ">=":
        return left >= right;
      case "==":
        return left === right;
      case "!=":
        return left !== right;
      case "&&":
        return left && right;
      case "||":
        return left || right;
    }
    return null;
  };
  internals.exists = function(value) {
    return value !== null && value !== undefined;
  };
});

// node_modules/joi/lib/annotate.js
var require_annotate = __commonJS((exports) => {
  var Clone = require_clone();
  var Common = require_common2();
  var internals = {
    annotations: Symbol("annotations")
  };
  exports.error = function(stripColorCodes) {
    if (!this._original || typeof this._original !== "object") {
      return this.details[0].message;
    }
    const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
    const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
    const endColor = stripColorCodes ? "" : "\x1B[0m";
    const obj = Clone(this._original);
    for (let i = this.details.length - 1;i >= 0; --i) {
      const pos = i + 1;
      const error = this.details[i];
      const path = error.path;
      let node = obj;
      for (let j = 0;; ++j) {
        const seg = path[j];
        if (Common.isSchema(node)) {
          node = node.clone();
        }
        if (j + 1 < path.length && typeof node[seg] !== "string") {
          node = node[seg];
        } else {
          const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
          node[internals.annotations] = refAnnotations;
          const cacheKey = seg || error.context.key;
          if (node[seg] !== undefined) {
            refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
            refAnnotations.errors[cacheKey].push(pos);
          } else {
            refAnnotations.missing[cacheKey] = pos;
          }
          break;
        }
      }
    }
    const replacers = {
      key: /_\$key\$_([, \d]+)_\$end\$_"/g,
      missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
      arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
      specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };
    let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
    message = `${message}\n${redFgEscape}`;
    for (let i = 0;i < this.details.length; ++i) {
      const pos = i + 1;
      message = `${message}\n[${pos}] ${this.details[i].message}`;
    }
    message = message + endColor;
    return message;
  };
  internals.safeStringify = function(obj, spaces) {
    return JSON.stringify(obj, internals.serializer(), spaces);
  };
  internals.serializer = function() {
    const keys = [];
    const stack = [];
    const cycleReplacer = (key, value) => {
      if (stack[0] === value) {
        return "[Circular ~]";
      }
      return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
    };
    return function(key, value) {
      if (stack.length > 0) {
        const thisPos = stack.indexOf(this);
        if (~thisPos) {
          stack.length = thisPos + 1;
          keys.length = thisPos + 1;
          keys[thisPos] = key;
        } else {
          stack.push(this);
          keys.push(key);
        }
        if (~stack.indexOf(value)) {
          value = cycleReplacer.call(this, key, value);
        }
      } else {
        stack.push(value);
      }
      if (value) {
        const annotations = value[internals.annotations];
        if (annotations) {
          if (Array.isArray(value)) {
            const annotated = [];
            for (let i = 0;i < value.length; ++i) {
              if (annotations.errors[i]) {
                annotated.push(`_\$idx\$_${annotations.errors[i].sort().join(", ")}_\$end\$_`);
              }
              annotated.push(value[i]);
            }
            value = annotated;
          } else {
            for (const errorKey in annotations.errors) {
              value[`${errorKey}_\$key\$_${annotations.errors[errorKey].sort().join(", ")}_\$end\$_`] = value[errorKey];
              value[errorKey] = undefined;
            }
            for (const missingKey in annotations.missing) {
              value[`_\$miss\$_${missingKey}|${annotations.missing[missingKey]}_\$end\$_`] = "__missing__";
            }
          }
          return value;
        }
      }
      if (value === Infinity || value === (-Infinity) || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
        return "[" + value.toString() + "]";
      }
      return value;
    };
  };
});

// node_modules/joi/lib/errors.js
var require_errors = __commonJS((exports) => {
  var Annotate = require_annotate();
  var Common = require_common2();
  var Template = require_template();
  exports.Report = class {
    constructor(code, value, local, flags, messages, state, prefs) {
      this.code = code;
      this.flags = flags;
      this.messages = messages;
      this.path = state.path;
      this.prefs = prefs;
      this.state = state;
      this.value = value;
      this.message = null;
      this.template = null;
      this.local = local || {};
      this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
      if (this.value !== undefined && !this.local.hasOwnProperty("value")) {
        this.local.value = this.value;
      }
      if (this.path.length) {
        const key = this.path[this.path.length - 1];
        if (typeof key !== "object") {
          this.local.key = key;
        }
      }
    }
    _setTemplate(template) {
      this.template = template;
      if (!this.flags.label && this.path.length === 0) {
        const localized = this._template(this.template, "root");
        if (localized) {
          this.local.label = localized;
        }
      }
    }
    toString() {
      if (this.message) {
        return this.message;
      }
      const code = this.code;
      if (!this.prefs.errors.render) {
        return this.code;
      }
      const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
      if (template === undefined) {
        return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
      }
      this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
      if (!this.prefs.errors.label) {
        this.message = this.message.replace(/^"" /, "").trim();
      }
      return this.message;
    }
    _template(messages, code) {
      return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
    }
  };
  exports.path = function(path) {
    let label = "";
    for (const segment of path) {
      if (typeof segment === "object") {
        continue;
      }
      if (typeof segment === "string") {
        if (label) {
          label += ".";
        }
        label += segment;
      } else {
        label += `[${segment}]`;
      }
    }
    return label;
  };
  exports.template = function(value, messages, code, state, prefs) {
    if (!messages) {
      return;
    }
    if (Template.isTemplate(messages)) {
      return code !== "root" ? messages : null;
    }
    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
      lang = lang.resolve(value, state, prefs);
    }
    if (lang && messages[lang]) {
      if (messages[lang][code] !== undefined) {
        return messages[lang][code];
      }
      if (messages[lang]["*"] !== undefined) {
        return messages[lang]["*"];
      }
    }
    if (!messages[code]) {
      return messages["*"];
    }
    return messages[code];
  };
  exports.label = function(flags, state, prefs, messages) {
    if (flags.label) {
      return flags.label;
    }
    if (!prefs.errors.label) {
      return "";
    }
    let path = state.path;
    if (prefs.errors.label === "key" && state.path.length > 1) {
      path = state.path.slice(-1);
    }
    const normalized = exports.path(path);
    if (normalized) {
      return normalized;
    }
    return exports.template(null, prefs.messages, "root", state, prefs) || messages && exports.template(null, messages, "root", state, prefs) || "value";
  };
  exports.process = function(errors, original, prefs) {
    if (!errors) {
      return null;
    }
    const { override, message, details } = exports.details(errors);
    if (override) {
      return override;
    }
    if (prefs.errors.stack) {
      return new exports.ValidationError(message, details, original);
    }
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
  };
  exports.details = function(errors, options = {}) {
    let messages = [];
    const details = [];
    for (const item of errors) {
      if (item instanceof Error) {
        if (options.override !== false) {
          return { override: item };
        }
        const message2 = item.toString();
        messages.push(message2);
        details.push({
          message: message2,
          type: "override",
          context: { error: item }
        });
        continue;
      }
      const message = item.toString();
      messages.push(message);
      details.push({
        message,
        path: item.path.filter((v) => typeof v !== "object"),
        type: item.code,
        context: item.local
      });
    }
    if (messages.length > 1) {
      messages = [...new Set(messages)];
    }
    return { message: messages.join(". "), details };
  };
  exports.ValidationError = class extends Error {
    constructor(message, details, original) {
      super(message);
      this._original = original;
      this.details = details;
    }
    static isError(err) {
      return err instanceof exports.ValidationError;
    }
  };
  exports.ValidationError.prototype.isJoi = true;
  exports.ValidationError.prototype.name = "ValidationError";
  exports.ValidationError.prototype.annotate = Annotate.error;
});

// node_modules/joi/lib/ref.js
var require_ref = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Reach = require_reach();
  var Common = require_common2();
  var Template;
  var internals = {
    symbol: Symbol("ref"),
    defaults: {
      adjust: null,
      in: false,
      iterables: null,
      map: null,
      separator: ".",
      type: "value"
    }
  };
  exports.create = function(key, options = {}) {
    Assert(typeof key === "string", "Invalid reference key:", key);
    Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
    Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;
    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;
    if (ref.type === "value") {
      if (context.root) {
        Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
        ref.ancestor = "root";
        if (!key) {
          key = null;
        }
      }
      if (separator && separator === key) {
        key = null;
        ref.ancestor = 0;
      } else {
        if (ref.ancestor !== undefined) {
          Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
        } else {
          const [ancestor, slice] = internals.ancestor(key, separator);
          if (slice) {
            key = key.slice(slice);
            if (key === "") {
              key = null;
            }
          }
          ref.ancestor = ancestor;
        }
      }
    }
    ref.path = separator ? key === null ? [] : key.split(separator) : [key];
    return new internals.Ref(ref);
  };
  exports.in = function(key, options = {}) {
    return exports.create(key, { ...options, in: true });
  };
  exports.isRef = function(ref) {
    return ref ? !!ref[Common.symbols.ref] : false;
  };
  internals.Ref = class {
    constructor(options) {
      Assert(typeof options === "object", "Invalid reference construction");
      Common.assertOptions(options, [
        "adjust",
        "ancestor",
        "in",
        "iterables",
        "map",
        "path",
        "render",
        "separator",
        "type",
        "depth",
        "key",
        "root",
        "display"
      ]);
      Assert([false, undefined].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
      Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
      Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
      Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
      Object.assign(this, internals.defaults, options);
      Assert(this.type === "value" || this.ancestor === undefined, "Non-value references cannot reference ancestors");
      if (Array.isArray(this.map)) {
        this.map = new Map(this.map);
      }
      this.depth = this.path.length;
      this.key = this.path.length ? this.path.join(this.separator) : null;
      this.root = this.path[0];
      this.updateDisplay();
    }
    resolve(value, state, prefs, local, options = {}) {
      Assert(!this.in || options.in, "Invalid in() reference usage");
      if (this.type === "global") {
        return this._resolve(prefs.context, state, options);
      }
      if (this.type === "local") {
        return this._resolve(local, state, options);
      }
      if (!this.ancestor) {
        return this._resolve(value, state, options);
      }
      if (this.ancestor === "root") {
        return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
      }
      Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
      return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }
    _resolve(target, state, options) {
      let resolved;
      if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
        resolved = state.mainstay.shadow.get(this.absolute(state));
      }
      if (resolved === undefined) {
        resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
      }
      if (this.adjust) {
        resolved = this.adjust(resolved);
      }
      if (this.map) {
        const mapped = this.map.get(resolved);
        if (mapped !== undefined) {
          resolved = mapped;
        }
      }
      if (state.mainstay) {
        state.mainstay.tracer.resolve(state, this, resolved);
      }
      return resolved;
    }
    toString() {
      return this.display;
    }
    absolute(state) {
      return [...state.path.slice(0, -this.ancestor), ...this.path];
    }
    clone() {
      return new internals.Ref(this);
    }
    describe() {
      const ref = { path: this.path };
      if (this.type !== "value") {
        ref.type = this.type;
      }
      if (this.separator !== ".") {
        ref.separator = this.separator;
      }
      if (this.type === "value" && this.ancestor !== 1) {
        ref.ancestor = this.ancestor;
      }
      if (this.map) {
        ref.map = [...this.map];
      }
      for (const key of ["adjust", "iterables", "render"]) {
        if (this[key] !== null && this[key] !== undefined) {
          ref[key] = this[key];
        }
      }
      if (this.in !== false) {
        ref.in = true;
      }
      return { ref };
    }
    updateDisplay() {
      const key = this.key !== null ? this.key : "";
      if (this.type !== "value") {
        this.display = `ref:${this.type}:${key}`;
        return;
      }
      if (!this.separator) {
        this.display = `ref:${key}`;
        return;
      }
      if (!this.ancestor) {
        this.display = `ref:${this.separator}${key}`;
        return;
      }
      if (this.ancestor === "root") {
        this.display = `ref:root:${key}`;
        return;
      }
      if (this.ancestor === 1) {
        this.display = `ref:${key || ".."}`;
        return;
      }
      const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
      this.display = `ref:${lead}${key || ""}`;
    }
  };
  internals.Ref.prototype[Common.symbols.ref] = true;
  exports.build = function(desc) {
    desc = Object.assign({}, internals.defaults, desc);
    if (desc.type === "value" && desc.ancestor === undefined) {
      desc.ancestor = 1;
    }
    return new internals.Ref(desc);
  };
  internals.context = function(key, separator, prefix = {}) {
    key = key.trim();
    if (prefix) {
      const globalp = prefix.global === undefined ? "$" : prefix.global;
      if (globalp !== separator && key.startsWith(globalp)) {
        return { key: key.slice(globalp.length), type: "global" };
      }
      const local = prefix.local === undefined ? "#" : prefix.local;
      if (local !== separator && key.startsWith(local)) {
        return { key: key.slice(local.length), type: "local" };
      }
      const root = prefix.root === undefined ? "/" : prefix.root;
      if (root !== separator && key.startsWith(root)) {
        return { key: key.slice(root.length), type: "value", root: true };
      }
    }
    return { key, type: "value" };
  };
  internals.ancestor = function(key, separator) {
    if (!separator) {
      return [1, 0];
    }
    if (key[0] !== separator) {
      return [1, 0];
    }
    if (key[1] !== separator) {
      return [0, 1];
    }
    let i = 2;
    while (key[i] === separator) {
      ++i;
    }
    return [i - 1, i];
  };
  exports.toSibling = 0;
  exports.toParent = 1;
  exports.Manager = class {
    constructor() {
      this.refs = [];
    }
    register(source, target) {
      if (!source) {
        return;
      }
      target = target === undefined ? exports.toParent : target;
      if (Array.isArray(source)) {
        for (const ref of source) {
          this.register(ref, target);
        }
        return;
      }
      if (Common.isSchema(source)) {
        for (const item of source._refs.refs) {
          if (item.ancestor - target >= 0) {
            this.refs.push({ ancestor: item.ancestor - target, root: item.root });
          }
        }
        return;
      }
      if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
        this.refs.push({ ancestor: source.ancestor - target, root: source.root });
      }
      Template = Template || require_template();
      if (Template.isTemplate(source)) {
        this.register(source.refs(), target);
      }
    }
    get length() {
      return this.refs.length;
    }
    clone() {
      const copy = new exports.Manager;
      copy.refs = Clone(this.refs);
      return copy;
    }
    reset() {
      this.refs = [];
    }
    roots() {
      return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
  };
});

// node_modules/joi/lib/template.js
var require_template = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var EscapeHtml = require_escapeHtml();
  var Formula = require_lib();
  var Common = require_common2();
  var Errors = require_errors();
  var Ref = require_ref();
  var internals = {
    symbol: Symbol("template"),
    opens: new Array(1000).join("\0"),
    closes: new Array(1000).join("\x01"),
    dateFormat: {
      date: Date.prototype.toDateString,
      iso: Date.prototype.toISOString,
      string: Date.prototype.toString,
      time: Date.prototype.toTimeString,
      utc: Date.prototype.toUTCString
    }
  };
  module.exports = exports = internals.Template = class {
    constructor(source, options) {
      Assert(typeof source === "string", "Template source must be a string");
      Assert(!source.includes("\0") && !source.includes("\x01"), "Template source cannot contain reserved control characters");
      this.source = source;
      this.rendered = source;
      this._template = null;
      if (options) {
        const { functions, ...opts } = options;
        this._settings = Object.keys(opts).length ? Clone(opts) : undefined;
        this._functions = functions;
        if (this._functions) {
          Assert(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
          Assert(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
        }
      } else {
        this._settings = undefined;
        this._functions = undefined;
      }
      this._parse();
    }
    _parse() {
      if (!this.source.includes("{")) {
        return;
      }
      const encoded = internals.encode(this.source);
      const parts = internals.split(encoded);
      let refs = false;
      const processed = [];
      const head = parts.shift();
      if (head) {
        processed.push(head);
      }
      for (const part of parts) {
        const raw = part[0] !== "{";
        const ender = raw ? "}" : "}}";
        const end = part.indexOf(ender);
        if (end === -1 || part[1] === "{") {
          processed.push(`{${internals.decode(part)}`);
          continue;
        }
        let variable = part.slice(raw ? 0 : 1, end);
        const wrapped = variable[0] === ":";
        if (wrapped) {
          variable = variable.slice(1);
        }
        const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
        processed.push(dynamic);
        if (typeof dynamic !== "string") {
          refs = true;
        }
        const rest = part.slice(end + ender.length);
        if (rest) {
          processed.push(internals.decode(rest));
        }
      }
      if (!refs) {
        this.rendered = processed.join("");
        return;
      }
      this._template = processed;
    }
    static date(date, prefs) {
      return internals.dateFormat[prefs.dateFormat].call(date);
    }
    describe(options = {}) {
      if (!this._settings && options.compact) {
        return this.source;
      }
      const desc = { template: this.source };
      if (this._settings) {
        desc.options = this._settings;
      }
      if (this._functions) {
        desc.functions = this._functions;
      }
      return desc;
    }
    static build(desc) {
      return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : undefined);
    }
    isDynamic() {
      return !!this._template;
    }
    static isTemplate(template) {
      return template ? !!template[Common.symbols.template] : false;
    }
    refs() {
      if (!this._template) {
        return;
      }
      const refs = [];
      for (const part of this._template) {
        if (typeof part !== "string") {
          refs.push(...part.refs);
        }
      }
      return refs;
    }
    resolve(value, state, prefs, local) {
      if (this._template && this._template.length === 1) {
        return this._part(this._template[0], value, state, prefs, local, {});
      }
      return this.render(value, state, prefs, local);
    }
    _part(part, ...args) {
      if (part.ref) {
        return part.ref.resolve(...args);
      }
      return part.formula.evaluate(args);
    }
    render(value, state, prefs, local, options = {}) {
      if (!this.isDynamic()) {
        return this.rendered;
      }
      const parts = [];
      for (const part of this._template) {
        if (typeof part === "string") {
          parts.push(part);
        } else {
          const rendered = this._part(part, value, state, prefs, local, options);
          const string = internals.stringify(rendered, value, state, prefs, local, options);
          if (string !== undefined) {
            const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
            parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
          }
        }
      }
      return parts.join("");
    }
    _ref(content, { raw, wrapped }) {
      const refs = [];
      const reference = (variable) => {
        const ref = Ref.create(variable, this._settings);
        refs.push(ref);
        return (context) => {
          const resolved = ref.resolve(...context);
          return resolved !== undefined ? resolved : null;
        };
      };
      try {
        const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
        var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
      } catch (err) {
        err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
        throw err;
      }
      if (formula.single) {
        if (formula.single.type === "reference") {
          const ref = refs[0];
          return { ref, raw, refs, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
        }
        return internals.stringify(formula.single.value);
      }
      return { formula, raw, refs };
    }
    toString() {
      return this.source;
    }
  };
  internals.Template.prototype[Common.symbols.template] = true;
  internals.Template.prototype.isImmutable = true;
  internals.encode = function(string) {
    return string.replace(/\\(\{+)/g, ($0, $1) => {
      return internals.opens.slice(0, $1.length);
    }).replace(/\\(\}+)/g, ($0, $1) => {
      return internals.closes.slice(0, $1.length);
    });
  };
  internals.decode = function(string) {
    return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
  };
  internals.split = function(string) {
    const parts = [];
    let current = "";
    for (let i = 0;i < string.length; ++i) {
      const char = string[i];
      if (char === "{") {
        let next = "";
        while (i + 1 < string.length && string[i + 1] === "{") {
          next += "{";
          ++i;
        }
        parts.push(current);
        current = next;
      } else {
        current += char;
      }
    }
    parts.push(current);
    return parts;
  };
  internals.wrap = function(value, ends) {
    if (!ends) {
      return value;
    }
    if (ends.length === 1) {
      return `${ends}${value}${ends}`;
    }
    return `${ends[0]}${value}${ends[1]}`;
  };
  internals.stringify = function(value, original, state, prefs, local, options = {}) {
    const type = typeof value;
    const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
    let skipWrap = false;
    if (Ref.isRef(value) && value.render) {
      skipWrap = value.in;
      value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
    }
    if (value === null) {
      return "null";
    }
    if (type === "string") {
      return internals.wrap(value, options.arrayItems && wrap.string);
    }
    if (type === "number" || type === "function" || type === "symbol") {
      return value.toString();
    }
    if (type !== "object") {
      return JSON.stringify(value);
    }
    if (value instanceof Date) {
      return internals.Template.date(value, prefs);
    }
    if (value instanceof Map) {
      const pairs = [];
      for (const [key, sym] of value.entries()) {
        pairs.push(`${key.toString()} -> ${sym.toString()}`);
      }
      value = pairs;
    }
    if (!Array.isArray(value)) {
      return value.toString();
    }
    const values = [];
    for (const item of value) {
      values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
    }
    return internals.wrap(values.join(", "), !skipWrap && wrap.array);
  };
  internals.constants = {
    true: true,
    false: false,
    null: null,
    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
  };
  internals.functions = {
    if(condition, then, otherwise) {
      return condition ? then : otherwise;
    },
    length(item) {
      if (typeof item === "string") {
        return item.length;
      }
      if (!item || typeof item !== "object") {
        return null;
      }
      if (Array.isArray(item)) {
        return item.length;
      }
      return Object.keys(item).length;
    },
    msg(code) {
      const [value, state, prefs, local, options] = this;
      const messages = options.messages;
      if (!messages) {
        return "";
      }
      const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
      if (!template) {
        return "";
      }
      return template.render(value, state, prefs, local, options);
    },
    number(value) {
      if (typeof value === "number") {
        return value;
      }
      if (typeof value === "string") {
        return parseFloat(value);
      }
      if (typeof value === "boolean") {
        return value ? 1 : 0;
      }
      if (value instanceof Date) {
        return value.getTime();
      }
      return null;
    }
  };
});

// node_modules/joi/lib/messages.js
var require_messages = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Template = require_template();
  exports.compile = function(messages, target) {
    if (typeof messages === "string") {
      Assert(!target, "Cannot set single message string");
      return new Template(messages);
    }
    if (Template.isTemplate(messages)) {
      Assert(!target, "Cannot set single message template");
      return messages;
    }
    Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
    target = target ? Clone(target) : {};
    for (let code in messages) {
      const message = messages[code];
      if (code === "root" || Template.isTemplate(message)) {
        target[code] = message;
        continue;
      }
      if (typeof message === "string") {
        target[code] = new Template(message);
        continue;
      }
      Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
      const language = code;
      target[language] = target[language] || {};
      for (code in message) {
        const localized = message[code];
        if (code === "root" || Template.isTemplate(localized)) {
          target[language][code] = localized;
          continue;
        }
        Assert(typeof localized === "string", "Invalid message for", code, "in", language);
        target[language][code] = new Template(localized);
      }
    }
    return target;
  };
  exports.decompile = function(messages) {
    const target = {};
    for (let code in messages) {
      const message = messages[code];
      if (code === "root") {
        target.root = message;
        continue;
      }
      if (Template.isTemplate(message)) {
        target[code] = message.describe({ compact: true });
        continue;
      }
      const language = code;
      target[language] = {};
      for (code in message) {
        const localized = message[code];
        if (code === "root") {
          target[language].root = localized;
          continue;
        }
        target[language][code] = localized.describe({ compact: true });
      }
    }
    return target;
  };
  exports.merge = function(base, extended) {
    if (!base) {
      return exports.compile(extended);
    }
    if (!extended) {
      return base;
    }
    if (typeof extended === "string") {
      return new Template(extended);
    }
    if (Template.isTemplate(extended)) {
      return extended;
    }
    const target = Clone(base);
    for (let code in extended) {
      const message = extended[code];
      if (code === "root" || Template.isTemplate(message)) {
        target[code] = message;
        continue;
      }
      if (typeof message === "string") {
        target[code] = new Template(message);
        continue;
      }
      Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
      const language = code;
      target[language] = target[language] || {};
      for (code in message) {
        const localized = message[code];
        if (code === "root" || Template.isTemplate(localized)) {
          target[language][code] = localized;
          continue;
        }
        Assert(typeof localized === "string", "Invalid message for", code, "in", language);
        target[language][code] = new Template(localized);
      }
    }
    return target;
  };
});

// node_modules/joi/lib/common.js
var require_common2 = __commonJS((exports) => {
  var Assert = require_assert();
  var AssertError = require_error2();
  var Pkg = require_package();
  var Messages;
  var Schemas;
  var internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
  };
  exports.version = Pkg.version;
  exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    artifacts: false,
    cache: true,
    context: null,
    convert: true,
    dateFormat: "iso",
    errors: {
      escapeHtml: false,
      label: "path",
      language: null,
      render: true,
      stack: false,
      wrap: {
        label: '"',
        array: "[]"
      }
    },
    externals: true,
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: "optional",
    skipFunctions: false,
    stripUnknown: false,
    warnings: false
  };
  exports.symbols = {
    any: Symbol.for("@hapi/joi/schema"),
    arraySingle: Symbol("arraySingle"),
    deepDefault: Symbol("deepDefault"),
    errors: Symbol("errors"),
    literal: Symbol("literal"),
    override: Symbol("override"),
    parent: Symbol("parent"),
    prefs: Symbol("prefs"),
    ref: Symbol("ref"),
    template: Symbol("template"),
    values: Symbol("values")
  };
  exports.assertOptions = function(options, keys, name = "Options") {
    Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
  };
  exports.checkPreferences = function(prefs) {
    Schemas = Schemas || require_schemas();
    const result = Schemas.preferences.validate(prefs);
    if (result.error) {
      throw new AssertError([result.error.details[0].message]);
    }
  };
  exports.compare = function(a, b, operator) {
    switch (operator) {
      case "=":
        return a === b;
      case ">":
        return a > b;
      case "<":
        return a < b;
      case ">=":
        return a >= b;
      case "<=":
        return a <= b;
    }
  };
  exports.default = function(value, defaultValue) {
    return value === undefined ? defaultValue : value;
  };
  exports.isIsoDate = function(date) {
    return internals.isoDate.test(date);
  };
  exports.isNumber = function(value) {
    return typeof value === "number" && !isNaN(value);
  };
  exports.isResolvable = function(obj) {
    if (!obj) {
      return false;
    }
    return obj[exports.symbols.ref] || obj[exports.symbols.template];
  };
  exports.isSchema = function(schema, options = {}) {
    const any = schema && schema[exports.symbols.any];
    if (!any) {
      return false;
    }
    Assert(options.legacy || any.version === exports.version, "Cannot mix different versions of joi schemas");
    return true;
  };
  exports.isValues = function(obj) {
    return obj[exports.symbols.values];
  };
  exports.limit = function(value) {
    return Number.isSafeInteger(value) && value >= 0;
  };
  exports.preferences = function(target, source) {
    Messages = Messages || require_messages();
    target = target || {};
    source = source || {};
    const merged = Object.assign({}, target, source);
    if (source.errors && target.errors) {
      merged.errors = Object.assign({}, target.errors, source.errors);
      merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
    }
    if (source.messages) {
      merged.messages = Messages.compile(source.messages, target.messages);
    }
    delete merged[exports.symbols.prefs];
    return merged;
  };
  exports.tryWithPath = function(fn, key, options = {}) {
    try {
      return fn();
    } catch (err) {
      if (err.path !== undefined) {
        err.path = key + "." + err.path;
      } else {
        err.path = key;
      }
      if (options.append) {
        err.message = `${err.message} (${err.path})`;
      }
      throw err;
    }
  };
  exports.validateArg = function(value, label, { assert, message }) {
    if (exports.isSchema(assert)) {
      const result = assert.validate(value);
      if (!result.error) {
        return;
      }
      return result.error.message;
    } else if (!assert(value)) {
      return label ? `${label} ${message}` : message;
    }
  };
  exports.verifyFlat = function(args, method) {
    for (const arg of args) {
      Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
    }
  };
});

// node_modules/joi/lib/cache.js
var require_cache = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Common = require_common2();
  var internals = {
    max: 1000,
    supported: new Set(["undefined", "boolean", "number", "string"])
  };
  exports.provider = {
    provision(options) {
      return new internals.Cache(options);
    }
  };
  internals.Cache = class {
    constructor(options = {}) {
      Common.assertOptions(options, ["max"]);
      Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
      this._max = options.max || internals.max;
      this._map = new Map;
      this._list = new internals.List;
    }
    get length() {
      return this._map.size;
    }
    set(key, value) {
      if (key !== null && !internals.supported.has(typeof key)) {
        return;
      }
      let node = this._map.get(key);
      if (node) {
        node.value = value;
        this._list.first(node);
        return;
      }
      node = this._list.unshift({ key, value });
      this._map.set(key, node);
      this._compact();
    }
    get(key) {
      const node = this._map.get(key);
      if (node) {
        this._list.first(node);
        return Clone(node.value);
      }
    }
    _compact() {
      if (this._map.size > this._max) {
        const node = this._list.pop();
        this._map.delete(node.key);
      }
    }
  };
  internals.List = class {
    constructor() {
      this.tail = null;
      this.head = null;
    }
    unshift(node) {
      node.next = null;
      node.prev = this.head;
      if (this.head) {
        this.head.next = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      return node;
    }
    first(node) {
      if (node === this.head) {
        return;
      }
      this._remove(node);
      this.unshift(node);
    }
    pop() {
      return this._remove(this.tail);
    }
    _remove(node) {
      const { next, prev } = node;
      next.prev = prev;
      if (prev) {
        prev.next = next;
      }
      if (node === this.tail) {
        this.tail = next;
      }
      node.prev = null;
      node.next = null;
      return node;
    }
  };
});

// node_modules/joi/lib/compile.js
var require_compile = __commonJS((exports) => {
  var Assert = require_assert();
  var Common = require_common2();
  var Ref = require_ref();
  var internals = {};
  exports.schema = function(Joi, config, options = {}) {
    Common.assertOptions(options, ["appendPath", "override"]);
    try {
      return internals.schema(Joi, config, options);
    } catch (err) {
      if (options.appendPath && err.path !== undefined) {
        err.message = `${err.message} (${err.path})`;
      }
      throw err;
    }
  };
  internals.schema = function(Joi, config, options) {
    Assert(config !== undefined, "Invalid undefined schema");
    if (Array.isArray(config)) {
      Assert(config.length, "Invalid empty array schema");
      if (config.length === 1) {
        config = config[0];
      }
    }
    const valid = (base, ...values) => {
      if (options.override !== false) {
        return base.valid(Joi.override, ...values);
      }
      return base.valid(...values);
    };
    if (internals.simple(config)) {
      return valid(Joi, config);
    }
    if (typeof config === "function") {
      return Joi.custom(config);
    }
    Assert(typeof config === "object", "Invalid schema content:", typeof config);
    if (Common.isResolvable(config)) {
      return valid(Joi, config);
    }
    if (Common.isSchema(config)) {
      return config;
    }
    if (Array.isArray(config)) {
      for (const item of config) {
        if (!internals.simple(item)) {
          return Joi.alternatives().try(...config);
        }
      }
      return valid(Joi, ...config);
    }
    if (config instanceof RegExp) {
      return Joi.string().regex(config);
    }
    if (config instanceof Date) {
      return valid(Joi.date(), config);
    }
    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
    return Joi.object().keys(config);
  };
  exports.ref = function(id, options) {
    return Ref.isRef(id) ? id : Ref.create(id, options);
  };
  exports.compile = function(root, schema, options = {}) {
    Common.assertOptions(options, ["legacy"]);
    const any = schema && schema[Common.symbols.any];
    if (any) {
      Assert(options.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
      return schema;
    }
    if (typeof schema !== "object" || !options.legacy) {
      return exports.schema(root, schema, { appendPath: true });
    }
    const compiler = internals.walk(schema);
    if (!compiler) {
      return exports.schema(root, schema, { appendPath: true });
    }
    return compiler.compile(compiler.root, schema);
  };
  internals.walk = function(schema) {
    if (typeof schema !== "object") {
      return null;
    }
    if (Array.isArray(schema)) {
      for (const item of schema) {
        const compiler = internals.walk(item);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    }
    const any = schema[Common.symbols.any];
    if (any) {
      return { root: schema[any.root], compile: any.compile };
    }
    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
    for (const key in schema) {
      const compiler = internals.walk(schema[key]);
      if (compiler) {
        return compiler;
      }
    }
    return null;
  };
  internals.simple = function(value) {
    return value === null || ["boolean", "string", "number"].includes(typeof value);
  };
  exports.when = function(schema, condition, options) {
    if (options === undefined) {
      Assert(condition && typeof condition === "object", "Missing options");
      options = condition;
      condition = Ref.create(".");
    }
    if (Array.isArray(options)) {
      options = { switch: options };
    }
    Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
    if (Common.isSchema(condition)) {
      Assert(options.is === undefined, '"is" can not be used with a schema condition');
      Assert(options.not === undefined, '"not" can not be used with a schema condition');
      Assert(options.switch === undefined, '"switch" can not be used with a schema condition');
      return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }
    Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
    Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');
    if (options.switch === undefined) {
      let rule2 = options;
      if (options.not !== undefined) {
        rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
      }
      let is = rule2.is !== undefined ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
      Assert(rule2.then !== undefined || rule2.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
      Assert(rule2.break === undefined || rule2.then === undefined || rule2.otherwise === undefined, "Cannot specify then, otherwise, and break all together");
      if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
        is = is.required();
      }
      return internals.condition(schema, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
    }
    Assert(Array.isArray(options.switch), '"switch" must be an array');
    Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    Assert(options.then === undefined, 'Cannot combine "switch" with "then"');
    const rule = {
      ref: exports.ref(condition),
      switch: [],
      break: options.break
    };
    for (let i = 0;i < options.switch.length; ++i) {
      const test = options.switch[i];
      const last = i === options.switch.length - 1;
      Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
      Assert(test.is !== undefined, 'Switch statement missing "is"');
      Assert(test.then !== undefined, 'Switch statement missing "then"');
      const item = {
        is: schema.$_compile(test.is),
        then: schema.$_compile(test.then)
      };
      if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
        item.is = item.is.required();
      }
      if (last) {
        Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
        const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
        if (otherwise !== undefined) {
          Assert(rule.break === undefined, "Cannot specify both otherwise and break");
          item.otherwise = schema.$_compile(otherwise);
        }
      }
      rule.switch.push(item);
    }
    return rule;
  };
  internals.condition = function(schema, condition) {
    for (const key of ["then", "otherwise"]) {
      if (condition[key] === undefined) {
        delete condition[key];
      } else {
        condition[key] = schema.$_compile(condition[key]);
      }
    }
    return condition;
  };
});

// node_modules/joi/lib/extend.js
var require_extend = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Common = require_common2();
  var Messages = require_messages();
  var internals = {};
  exports.type = function(from, options) {
    const base = Object.getPrototypeOf(from);
    const prototype = Clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);
    delete def.base;
    prototype._definition = def;
    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);
    schema.type = def.type;
    def.flags = Object.assign({}, parent.flags, def.flags);
    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
      for (const name in def.terms) {
        const term = def.terms[name];
        Assert(schema.$_terms[name] === undefined, "Invalid term override for", def.type, name);
        schema.$_terms[name] = term.init;
        terms[name] = term;
      }
    }
    def.terms = terms;
    if (!def.args) {
      def.args = parent.args;
    }
    def.prepare = internals.prepare(def.prepare, parent.prepare);
    if (def.coerce) {
      if (typeof def.coerce === "function") {
        def.coerce = { method: def.coerce };
      }
      if (def.coerce.from && !Array.isArray(def.coerce.from)) {
        def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
      }
    }
    def.coerce = internals.coerce(def.coerce, parent.coerce);
    def.validate = internals.validate(def.validate, parent.validate);
    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
      for (const name in def.rules) {
        const rule = def.rules[name];
        Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
        let method = rule.method;
        if (method === undefined) {
          method = function() {
            return this.$_addRule(name);
          };
        }
        if (method) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          prototype[name] = method;
        }
        Assert(!rules[name], "Rule conflict in", def.type, name);
        rules[name] = rule;
        if (rule.alias) {
          const aliases = [].concat(rule.alias);
          for (const alias of aliases) {
            prototype[alias] = rule.method;
          }
        }
        if (rule.args) {
          rule.argsByName = new Map;
          rule.args = rule.args.map((arg) => {
            if (typeof arg === "string") {
              arg = { name: arg };
            }
            Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
            if (Common.isSchema(arg.assert)) {
              arg.assert = arg.assert.strict().label(arg.name);
            }
            rule.argsByName.set(arg.name, arg);
            return arg;
          });
        }
      }
    }
    def.rules = rules;
    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
      for (const name in def.modifiers) {
        Assert(!prototype[name], "Rule conflict in", def.type, name);
        const modifier = def.modifiers[name];
        Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
        const method = function(arg) {
          return this.rule({ [name]: arg });
        };
        prototype[name] = method;
        modifiers[name] = modifier;
      }
    }
    def.modifiers = modifiers;
    if (def.overrides) {
      prototype._super = base;
      schema.$_super = {};
      for (const override in def.overrides) {
        Assert(base[override], "Cannot override missing", override);
        def.overrides[override][Common.symbols.parent] = base[override];
        schema.$_super[override] = base[override].bind(schema);
      }
      Object.assign(prototype, def.overrides);
    }
    def.cast = Object.assign({}, parent.cast, def.cast);
    const manifest = Object.assign({}, parent.manifest, def.manifest);
    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest;
    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
    return schema;
  };
  internals.build = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(obj, desc) {
      return parent(child(obj, desc), desc);
    };
  };
  internals.coerce = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return {
      from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,
      method(value, helpers) {
        let coerced;
        if (!parent.from || parent.from.includes(typeof value)) {
          coerced = parent.method(value, helpers);
          if (coerced) {
            if (coerced.errors || coerced.value === undefined) {
              return coerced;
            }
            value = coerced.value;
          }
        }
        if (!child.from || child.from.includes(typeof value)) {
          const own = child.method(value, helpers);
          if (own) {
            return own;
          }
        }
        return coerced;
      }
    };
  };
  internals.prepare = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(value, helpers) {
      const prepared = child(value, helpers);
      if (prepared) {
        if (prepared.errors || prepared.value === undefined) {
          return prepared;
        }
        value = prepared.value;
      }
      return parent(value, helpers) || prepared;
    };
  };
  internals.rebuild = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(schema) {
      parent(schema);
      child(schema);
    };
  };
  internals.validate = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(value, helpers) {
      const result = parent(value, helpers);
      if (result) {
        if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
          return result;
        }
        value = result.value;
      }
      return child(value, helpers) || result;
    };
  };
});

// node_modules/joi/lib/manifest.js
var require_manifest = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Common = require_common2();
  var Messages = require_messages();
  var Ref = require_ref();
  var Template = require_template();
  var Schemas;
  var internals = {};
  exports.describe = function(schema) {
    const def = schema._definition;
    const desc = {
      type: schema.type,
      flags: {},
      rules: []
    };
    for (const flag in schema._flags) {
      if (flag[0] !== "_") {
        desc.flags[flag] = internals.describe(schema._flags[flag]);
      }
    }
    if (!Object.keys(desc.flags).length) {
      delete desc.flags;
    }
    if (schema._preferences) {
      desc.preferences = Clone(schema._preferences, { shallow: ["messages"] });
      delete desc.preferences[Common.symbols.prefs];
      if (desc.preferences.messages) {
        desc.preferences.messages = Messages.decompile(desc.preferences.messages);
      }
    }
    if (schema._valids) {
      desc.allow = schema._valids.describe();
    }
    if (schema._invalids) {
      desc.invalid = schema._invalids.describe();
    }
    for (const rule of schema._rules) {
      const ruleDef = def.rules[rule.name];
      if (ruleDef.manifest === false) {
        continue;
      }
      const item = { name: rule.name };
      for (const custom in def.modifiers) {
        if (rule[custom] !== undefined) {
          item[custom] = internals.describe(rule[custom]);
        }
      }
      if (rule.args) {
        item.args = {};
        for (const key in rule.args) {
          const arg = rule.args[key];
          if (key === "options" && !Object.keys(arg).length) {
            continue;
          }
          item.args[key] = internals.describe(arg, { assign: key });
        }
        if (!Object.keys(item.args).length) {
          delete item.args;
        }
      }
      desc.rules.push(item);
    }
    if (!desc.rules.length) {
      delete desc.rules;
    }
    for (const term in schema.$_terms) {
      if (term[0] === "_") {
        continue;
      }
      Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
      const items = schema.$_terms[term];
      if (!items) {
        continue;
      }
      if (items instanceof Map) {
        if (items.size) {
          desc[term] = [...items.entries()];
        }
        continue;
      }
      if (Common.isValues(items)) {
        desc[term] = items.describe();
        continue;
      }
      Assert(def.terms[term], "Term", term, "missing configuration");
      const manifest = def.terms[term].manifest;
      const mapped = typeof manifest === "object";
      if (!items.length && !mapped) {
        continue;
      }
      const normalized = [];
      for (const item of items) {
        normalized.push(internals.describe(item));
      }
      if (mapped) {
        const { from, to } = manifest.mapped;
        desc[term] = {};
        for (const item of normalized) {
          desc[term][item[to]] = item[from];
        }
        continue;
      }
      if (manifest === "single") {
        Assert(normalized.length === 1, "Term", term, "contains more than one item");
        desc[term] = normalized[0];
        continue;
      }
      desc[term] = normalized;
    }
    internals.validate(schema.$_root, desc);
    return desc;
  };
  internals.describe = function(item, options = {}) {
    if (Array.isArray(item)) {
      return item.map(internals.describe);
    }
    if (item === Common.symbols.deepDefault) {
      return { special: "deep" };
    }
    if (typeof item !== "object" || item === null) {
      return item;
    }
    if (options.assign === "options") {
      return Clone(item);
    }
    if (Buffer && Buffer.isBuffer(item)) {
      return { buffer: item.toString("binary") };
    }
    if (item instanceof Date) {
      return item.toISOString();
    }
    if (item instanceof Error) {
      return item;
    }
    if (item instanceof RegExp) {
      if (options.assign === "regex") {
        return item.toString();
      }
      return { regex: item.toString() };
    }
    if (item[Common.symbols.literal]) {
      return { function: item.literal };
    }
    if (typeof item.describe === "function") {
      if (options.assign === "ref") {
        return item.describe().ref;
      }
      return item.describe();
    }
    const normalized = {};
    for (const key in item) {
      const value = item[key];
      if (value === undefined) {
        continue;
      }
      normalized[key] = internals.describe(value, { assign: key });
    }
    return normalized;
  };
  exports.build = function(joi, desc) {
    const builder = new internals.Builder(joi);
    return builder.parse(desc);
  };
  internals.Builder = class {
    constructor(joi) {
      this.joi = joi;
    }
    parse(desc) {
      internals.validate(this.joi, desc);
      let schema = this.joi[desc.type]()._bare();
      const def = schema._definition;
      if (desc.flags) {
        for (const flag in desc.flags) {
          const setter = def.flags[flag] && def.flags[flag].setter || flag;
          Assert(typeof schema[setter] === "function", "Invalid flag", flag, "for type", desc.type);
          schema = schema[setter](this.build(desc.flags[flag]));
        }
      }
      if (desc.preferences) {
        schema = schema.preferences(this.build(desc.preferences));
      }
      if (desc.allow) {
        schema = schema.allow(...this.build(desc.allow));
      }
      if (desc.invalid) {
        schema = schema.invalid(...this.build(desc.invalid));
      }
      if (desc.rules) {
        for (const rule of desc.rules) {
          Assert(typeof schema[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
          const args = [];
          if (rule.args) {
            const built = {};
            for (const key in rule.args) {
              built[key] = this.build(rule.args[key], { assign: key });
            }
            const keys = Object.keys(built);
            const definition = def.rules[rule.name].args;
            if (definition) {
              Assert(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
              for (const { name } of definition) {
                args.push(built[name]);
              }
            } else {
              Assert(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
              args.push(built[keys[0]]);
            }
          }
          schema = schema[rule.name](...args);
          const options = {};
          for (const custom in def.modifiers) {
            if (rule[custom] !== undefined) {
              options[custom] = this.build(rule[custom]);
            }
          }
          if (Object.keys(options).length) {
            schema = schema.rule(options);
          }
        }
      }
      const terms = {};
      for (const key in desc) {
        if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
          continue;
        }
        Assert(def.terms[key], "Term", key, "missing configuration");
        const manifest = def.terms[key].manifest;
        if (manifest === "schema") {
          terms[key] = desc[key].map((item) => this.parse(item));
          continue;
        }
        if (manifest === "values") {
          terms[key] = desc[key].map((item) => this.build(item));
          continue;
        }
        if (manifest === "single") {
          terms[key] = this.build(desc[key]);
          continue;
        }
        if (typeof manifest === "object") {
          terms[key] = {};
          for (const name in desc[key]) {
            const value = desc[key][name];
            terms[key][name] = this.parse(value);
          }
          continue;
        }
        terms[key] = this.build(desc[key]);
      }
      if (desc.whens) {
        terms.whens = desc.whens.map((when) => this.build(when));
      }
      schema = def.manifest.build(schema, terms);
      schema.$_temp.ruleset = false;
      return schema;
    }
    build(desc, options = {}) {
      if (desc === null) {
        return null;
      }
      if (Array.isArray(desc)) {
        return desc.map((item) => this.build(item));
      }
      if (desc instanceof Error) {
        return desc;
      }
      if (options.assign === "options") {
        return Clone(desc);
      }
      if (options.assign === "regex") {
        return internals.regex(desc);
      }
      if (options.assign === "ref") {
        return Ref.build(desc);
      }
      if (typeof desc !== "object") {
        return desc;
      }
      if (Object.keys(desc).length === 1) {
        if (desc.buffer) {
          Assert(Buffer, "Buffers are not supported");
          return Buffer && Buffer.from(desc.buffer, "binary");
        }
        if (desc.function) {
          return { [Common.symbols.literal]: true, literal: desc.function };
        }
        if (desc.override) {
          return Common.symbols.override;
        }
        if (desc.ref) {
          return Ref.build(desc.ref);
        }
        if (desc.regex) {
          return internals.regex(desc.regex);
        }
        if (desc.special) {
          Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
          return Common.symbols.deepDefault;
        }
        if (desc.value) {
          return Clone(desc.value);
        }
      }
      if (desc.type) {
        return this.parse(desc);
      }
      if (desc.template) {
        return Template.build(desc);
      }
      const normalized = {};
      for (const key in desc) {
        normalized[key] = this.build(desc[key], { assign: key });
      }
      return normalized;
    }
  };
  internals.regex = function(string) {
    const end = string.lastIndexOf("/");
    const exp = string.slice(1, end);
    const flags = string.slice(end + 1);
    return new RegExp(exp, flags);
  };
  internals.validate = function(joi, desc) {
    Schemas = Schemas || require_schemas();
    joi.assert(desc, Schemas.description);
  };
});

// node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS((exports, module) => {
  var Types = require_types();
  var internals = {
    mismatched: null
  };
  module.exports = function(obj, ref, options) {
    options = Object.assign({ prototype: true }, options);
    return !!internals.isDeepEqual(obj, ref, options, []);
  };
  internals.isDeepEqual = function(obj, ref, options, seen) {
    if (obj === ref) {
      return obj !== 0 || 1 / obj === 1 / ref;
    }
    const type = typeof obj;
    if (type !== typeof ref) {
      return false;
    }
    if (obj === null || ref === null) {
      return false;
    }
    if (type === "function") {
      if (!options.deepFunction || obj.toString() !== ref.toString()) {
        return false;
      }
    } else if (type !== "object") {
      return obj !== obj && ref !== ref;
    }
    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
      case Types.buffer:
        return Buffer && Buffer.prototype.equals.call(obj, ref);
      case Types.promise:
        return obj === ref;
      case Types.regex:
        return obj.toString() === ref.toString();
      case internals.mismatched:
        return false;
    }
    for (let i = seen.length - 1;i >= 0; --i) {
      if (seen[i].isSame(obj, ref)) {
        return true;
      }
    }
    seen.push(new internals.SeenEntry(obj, ref));
    try {
      return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    } finally {
      seen.pop();
    }
  };
  internals.getSharedType = function(obj, ref, checkPrototype) {
    if (checkPrototype) {
      if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
        return internals.mismatched;
      }
      return Types.getInternalProto(obj);
    }
    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
      return internals.mismatched;
    }
    return type;
  };
  internals.valueOf = function(obj) {
    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
      return obj;
    }
    try {
      return objValueOf.call(obj);
    } catch (err) {
      return err;
    }
  };
  internals.hasOwnEnumerableProperty = function(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  };
  internals.isSetSimpleEqual = function(obj, ref) {
    for (const entry of Set.prototype.values.call(obj)) {
      if (!Set.prototype.has.call(ref, entry)) {
        return false;
      }
    }
    return true;
  };
  internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;
    if (instanceType === Types.array) {
      if (options.part) {
        for (const objValue of obj) {
          for (const refValue of ref) {
            if (isDeepEqual(objValue, refValue, options, seen)) {
              return true;
            }
          }
        }
      } else {
        if (obj.length !== ref.length) {
          return false;
        }
        for (let i = 0;i < obj.length; ++i) {
          if (!isDeepEqual(obj[i], ref[i], options, seen)) {
            return false;
          }
        }
        return true;
      }
    } else if (instanceType === Types.set) {
      if (obj.size !== ref.size) {
        return false;
      }
      if (!internals.isSetSimpleEqual(obj, ref)) {
        const ref2 = new Set(Set.prototype.values.call(ref));
        for (const objEntry of Set.prototype.values.call(obj)) {
          if (ref2.delete(objEntry)) {
            continue;
          }
          let found = false;
          for (const refEntry of ref2) {
            if (isDeepEqual(objEntry, refEntry, options, seen)) {
              ref2.delete(refEntry);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
      }
    } else if (instanceType === Types.map) {
      if (obj.size !== ref.size) {
        return false;
      }
      for (const [key, value] of Map.prototype.entries.call(obj)) {
        if (value === undefined && !Map.prototype.has.call(ref, key)) {
          return false;
        }
        if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
          return false;
        }
      }
    } else if (instanceType === Types.error) {
      if (obj.name !== ref.name || obj.message !== ref.message) {
        return false;
      }
    }
    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
      return false;
    }
    const objKeys = keys(obj);
    if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
      return false;
    }
    let skipped = 0;
    for (const key of objKeys) {
      if (options.skip && options.skip.includes(key)) {
        if (ref[key] === undefined) {
          ++skipped;
        }
        continue;
      }
      if (!hasOwnEnumerableProperty(ref, key)) {
        return false;
      }
      if (!isDeepEqual(obj[key], ref[key], options, seen)) {
        return false;
      }
    }
    if (!options.part && objKeys.length - skipped !== keys(ref).length) {
      return false;
    }
    if (options.symbols !== false) {
      const objSymbols = getOwnPropertySymbols(obj);
      const refSymbols = new Set(getOwnPropertySymbols(ref));
      for (const key of objSymbols) {
        if (!options.skip || !options.skip.includes(key)) {
          if (hasOwnEnumerableProperty(obj, key)) {
            if (!hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
            if (!isDeepEqual(obj[key], ref[key], options, seen)) {
              return false;
            }
          } else if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
        refSymbols.delete(key);
      }
      for (const key of refSymbols) {
        if (hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
      }
    }
    return true;
  };
  internals.SeenEntry = class {
    constructor(obj, ref) {
      this.obj = obj;
      this.ref = ref;
    }
    isSame(obj, ref) {
      return this.obj === obj && this.ref === ref;
    }
  };
});

// node_modules/@sideway/pinpoint/lib/index.js
var require_lib2 = __commonJS((exports) => {
  exports.location = function(depth = 0) {
    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore, stack) => stack;
    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];
    Error.prepareStackTrace = orig;
    return {
      filename: line.getFileName(),
      line: line.getLineNumber()
    };
  };
});

// node_modules/joi/lib/trace.js
var require_trace = __commonJS((exports) => {
  var DeepEqual = require_deepEqual();
  var Pinpoint = require_lib2();
  var Errors = require_errors();
  var internals = {
    codes: {
      error: 1,
      pass: 2,
      full: 3
    },
    labels: {
      0: "never used",
      1: "always error",
      2: "always pass"
    }
  };
  exports.setup = function(root) {
    const trace = function() {
      root._tracer = root._tracer || new internals.Tracer;
      return root._tracer;
    };
    root.trace = trace;
    root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
    root.untrace = () => {
      root._tracer = null;
    };
  };
  exports.location = function(schema) {
    return schema.$_setFlag("_tracerLocation", Pinpoint.location(2));
  };
  internals.Tracer = class {
    constructor() {
      this.name = "Joi";
      this._schemas = new Map;
    }
    _register(schema) {
      const existing = this._schemas.get(schema);
      if (existing) {
        return existing.store;
      }
      const store = new internals.Store(schema);
      const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);
      this._schemas.set(schema, { filename, line, store });
      return store;
    }
    _combine(merged, sources) {
      for (const { store } of this._schemas.values()) {
        store._combine(merged, sources);
      }
    }
    report(file) {
      const coverage = [];
      for (const { filename, line, store } of this._schemas.values()) {
        if (file && file !== filename) {
          continue;
        }
        const missing = [];
        const skipped = [];
        for (const [schema, log] of store._sources.entries()) {
          if (internals.sub(log.paths, skipped)) {
            continue;
          }
          if (!log.entry) {
            missing.push({
              status: "never reached",
              paths: [...log.paths]
            });
            skipped.push(...log.paths);
            continue;
          }
          for (const type of ["valid", "invalid"]) {
            const set = schema[`_${type}s`];
            if (!set) {
              continue;
            }
            const values = new Set(set._values);
            const refs = new Set(set._refs);
            for (const { value, ref } of log[type]) {
              values.delete(value);
              refs.delete(ref);
            }
            if (values.size || refs.size) {
              missing.push({
                status: [...values, ...[...refs].map((ref) => ref.display)],
                rule: `${type}s`
              });
            }
          }
          const rules = schema._rules.map((rule) => rule.name);
          for (const type of ["default", "failover"]) {
            if (schema._flags[type] !== undefined) {
              rules.push(type);
            }
          }
          for (const name of rules) {
            const status = internals.labels[log.rule[name] || 0];
            if (status) {
              const report = { rule: name, status };
              if (log.paths.size) {
                report.paths = [...log.paths];
              }
              missing.push(report);
            }
          }
        }
        if (missing.length) {
          coverage.push({
            filename,
            line,
            missing,
            severity: "error",
            message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
          });
        }
      }
      return coverage.length ? coverage : null;
    }
  };
  internals.Store = class {
    constructor(schema) {
      this.active = true;
      this._sources = new Map;
      this._combos = new Map;
      this._scan(schema);
    }
    debug(state, source, name, result) {
      state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
    }
    entry(schema, state) {
      internals.debug(state, { type: "entry" });
      this._record(schema, (log) => {
        log.entry = true;
      });
    }
    filter(schema, state, source, value) {
      internals.debug(state, { type: source, ...value });
      this._record(schema, (log) => {
        log[source].add(value);
      });
    }
    log(schema, state, source, name, result) {
      internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
      this._record(schema, (log) => {
        log[source][name] = log[source][name] || 0;
        log[source][name] |= internals.codes[result];
      });
    }
    resolve(state, ref, to) {
      if (!state.mainstay.debug) {
        return;
      }
      const log = { type: "resolve", ref: ref.display, to, path: state.path };
      state.mainstay.debug.push(log);
    }
    value(state, by, from, to, name) {
      if (!state.mainstay.debug || DeepEqual(from, to)) {
        return;
      }
      const log = { type: "value", by, from, to, path: state.path };
      if (name) {
        log.name = name;
      }
      state.mainstay.debug.push(log);
    }
    _record(schema, each) {
      const log = this._sources.get(schema);
      if (log) {
        each(log);
        return;
      }
      const sources = this._combos.get(schema);
      for (const source of sources) {
        this._record(source, each);
      }
    }
    _scan(schema, _path) {
      const path = _path || [];
      let log = this._sources.get(schema);
      if (!log) {
        log = {
          paths: new Set,
          entry: false,
          rule: {},
          valid: new Set,
          invalid: new Set
        };
        this._sources.set(schema, log);
      }
      if (path.length) {
        log.paths.add(path);
      }
      const each = (sub, source) => {
        const subId = internals.id(sub, source);
        this._scan(sub, path.concat(subId));
      };
      schema.$_modify({ each, ref: false });
    }
    _combine(merged, sources) {
      this._combos.set(merged, sources);
    }
  };
  internals.message = function(item) {
    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
    return `${path}${item.rule || ""} (${item.status})`;
  };
  internals.id = function(schema, { source, name, path, key }) {
    if (schema._flags.id) {
      return schema._flags.id;
    }
    if (key) {
      return key;
    }
    name = `@${name}`;
    if (source === "terms") {
      return [name, path[Math.min(path.length - 1, 1)]];
    }
    return name;
  };
  internals.sub = function(paths, skipped) {
    for (const path of paths) {
      for (const skip of skipped) {
        if (DeepEqual(path.slice(0, skip.length), skip)) {
          return true;
        }
      }
    }
    return false;
  };
  internals.debug = function(state, event) {
    if (state.mainstay.debug) {
      event.path = state.debug ? [...state.path, state.debug] : state.path;
      state.mainstay.debug.push(event);
    }
  };
});

// node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Utils = require_utils();
  var internals = {};
  module.exports = internals.merge = function(target, source, options) {
    Assert(target && typeof target === "object", "Invalid target value: must be an object");
    Assert(source === null || source === undefined || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
    if (!source) {
      return target;
    }
    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
    if (Array.isArray(source)) {
      Assert(Array.isArray(target), "Cannot merge array onto an object");
      if (!options.mergeArrays) {
        target.length = 0;
      }
      for (let i = 0;i < source.length; ++i) {
        target.push(Clone(source[i], { symbols: options.symbols }));
      }
      return target;
    }
    const keys = Utils.keys(source, options);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
        continue;
      }
      const value = source[key];
      if (value && typeof value === "object") {
        if (target[key] === value) {
          continue;
        }
        if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || value instanceof RegExp) {
          target[key] = Clone(value, { symbols: options.symbols });
        } else {
          internals.merge(target[key], value, options);
        }
      } else {
        if (value !== null && value !== undefined) {
          target[key] = value;
        } else if (options.nullOverride) {
          target[key] = value;
        }
      }
    }
    return target;
  };
});

// node_modules/joi/lib/modify.js
var require_modify = __commonJS((exports) => {
  var Assert = require_assert();
  var Common = require_common2();
  var Ref = require_ref();
  var internals = {};
  exports.Ids = internals.Ids = class {
    constructor() {
      this._byId = new Map;
      this._byKey = new Map;
      this._schemaChain = false;
    }
    clone() {
      const clone = new internals.Ids;
      clone._byId = new Map(this._byId);
      clone._byKey = new Map(this._byKey);
      clone._schemaChain = this._schemaChain;
      return clone;
    }
    concat(source) {
      if (source._schemaChain) {
        this._schemaChain = true;
      }
      for (const [id, value] of source._byId.entries()) {
        Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
        this._byId.set(id, value);
      }
      for (const [key, value] of source._byKey.entries()) {
        Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
        this._byKey.set(key, value);
      }
    }
    fork(path, adjuster, root) {
      const chain = this._collect(path);
      chain.push({ schema: root });
      const tail = chain.shift();
      let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
      Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
      for (const node of chain) {
        adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
      }
      return adjusted.schema;
    }
    labels(path, behind = []) {
      const current = path[0];
      const node = this._get(current);
      if (!node) {
        return [...behind, ...path].join(".");
      }
      const forward = path.slice(1);
      behind = [...behind, node.schema._flags.label || current];
      if (!forward.length) {
        return behind.join(".");
      }
      return node.schema._ids.labels(forward, behind);
    }
    reach(path, behind = []) {
      const current = path[0];
      const node = this._get(current);
      Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
      const forward = path.slice(1);
      if (!forward.length) {
        return node.schema;
      }
      return node.schema._ids.reach(forward, [...behind, current]);
    }
    register(schema, { key } = {}) {
      if (!schema || !Common.isSchema(schema)) {
        return;
      }
      if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
        this._schemaChain = true;
      }
      const id = schema._flags.id;
      if (id) {
        const existing = this._byId.get(id);
        Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
        Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
        this._byId.set(id, { schema, id });
      }
      if (key) {
        Assert(!this._byKey.has(key), "Schema already contains key:", key);
        Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
        this._byKey.set(key, { schema, id: key });
      }
    }
    reset() {
      this._byId = new Map;
      this._byKey = new Map;
      this._schemaChain = false;
    }
    _collect(path, behind = [], nodes = []) {
      const current = path[0];
      const node = this._get(current);
      Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
      nodes = [node, ...nodes];
      const forward = path.slice(1);
      if (!forward.length) {
        return nodes;
      }
      return node.schema._ids._collect(forward, [...behind, current], nodes);
    }
    _get(id) {
      return this._byId.get(id) || this._byKey.get(id);
    }
  };
  internals.fork = function(schema, id, replacement) {
    const each = (item, { key }) => {
      if (id === (item._flags.id || key)) {
        return replacement;
      }
    };
    const obj = exports.schema(schema, { each, ref: false });
    return obj ? obj.$_mutateRebuild() : schema;
  };
  exports.schema = function(schema, options) {
    let obj;
    for (const name in schema._flags) {
      if (name[0] === "_") {
        continue;
      }
      const result = internals.scan(schema._flags[name], { source: "flags", name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        obj._flags[name] = result;
      }
    }
    for (let i = 0;i < schema._rules.length; ++i) {
      const rule = schema._rules[i];
      const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        const clone = Object.assign({}, rule);
        clone.args = result;
        obj._rules[i] = clone;
        const existingUnique = obj._singleRules.get(rule.name);
        if (existingUnique === rule) {
          obj._singleRules.set(rule.name, clone);
        }
      }
    }
    for (const name in schema.$_terms) {
      if (name[0] === "_") {
        continue;
      }
      const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        obj.$_terms[name] = result;
      }
    }
    return obj;
  };
  internals.scan = function(item, source, options, _path, _key) {
    const path = _path || [];
    if (item === null || typeof item !== "object") {
      return;
    }
    let clone;
    if (Array.isArray(item)) {
      for (let i = 0;i < item.length; ++i) {
        const key = source.source === "terms" && source.name === "keys" && item[i].key;
        const result = internals.scan(item[i], source, options, [i, ...path], key);
        if (result !== undefined) {
          clone = clone || item.slice();
          clone[i] = result;
        }
      }
      return clone;
    }
    if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
      const result = options.each(item, { ...source, path, key: _key });
      if (result === item) {
        return;
      }
      return result;
    }
    for (const key in item) {
      if (key[0] === "_") {
        continue;
      }
      const result = internals.scan(item[key], source, options, [key, ...path], _key);
      if (result !== undefined) {
        clone = clone || Object.assign({}, item);
        clone[key] = result;
      }
    }
    return clone;
  };
});

// node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS((exports, module) => {
  module.exports = function() {
  };
});

// node_modules/joi/lib/state.js
var require_state = __commonJS((exports, module) => {
  var Clone = require_clone();
  var Reach = require_reach();
  var Common = require_common2();
  var internals = {
    value: Symbol("value")
  };
  module.exports = internals.State = class {
    constructor(path, ancestors, state) {
      this.path = path;
      this.ancestors = ancestors;
      this.mainstay = state.mainstay;
      this.schemas = state.schemas;
      this.debug = null;
    }
    localize(path, ancestors = null, schema = null) {
      const state = new internals.State(path, ancestors, this);
      if (schema && state.schemas) {
        state.schemas = [internals.schemas(schema), ...state.schemas];
      }
      return state;
    }
    nest(schema, debug) {
      const state = new internals.State(this.path, this.ancestors, this);
      state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
      state.debug = debug;
      return state;
    }
    shadow(value, reason) {
      this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow;
      this.mainstay.shadow.set(this.path, value, reason);
    }
    snapshot() {
      if (this.mainstay.shadow) {
        this._snapshot = Clone(this.mainstay.shadow.node(this.path));
      }
      this.mainstay.snapshot();
    }
    restore() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = undefined;
      }
      this.mainstay.restore();
    }
    commit() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = undefined;
      }
      this.mainstay.commit();
    }
  };
  internals.schemas = function(schema) {
    if (Common.isSchema(schema)) {
      return { schema };
    }
    return schema;
  };
  internals.Shadow = class {
    constructor() {
      this._values = null;
    }
    set(path, value, reason) {
      if (!path.length) {
        return;
      }
      if (reason === "strip" && typeof path[path.length - 1] === "number") {
        return;
      }
      this._values = this._values || new Map;
      let node = this._values;
      for (let i = 0;i < path.length; ++i) {
        const segment = path[i];
        let next = node.get(segment);
        if (!next) {
          next = new Map;
          node.set(segment, next);
        }
        node = next;
      }
      node[internals.value] = value;
    }
    get(path) {
      const node = this.node(path);
      if (node) {
        return node[internals.value];
      }
    }
    node(path) {
      if (!this._values) {
        return;
      }
      return Reach(this._values, path, { iterables: true });
    }
    override(path, node) {
      if (!this._values) {
        return;
      }
      const parents = path.slice(0, -1);
      const own = path[path.length - 1];
      const parent = Reach(this._values, parents, { iterables: true });
      if (node) {
        parent.set(own, node);
        return;
      }
      if (parent) {
        parent.delete(own);
      }
    }
  };
});

// node_modules/joi/lib/validator.js
var require_validator = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Ignore = require_ignore();
  var Reach = require_reach();
  var Common = require_common2();
  var Errors = require_errors();
  var State = require_state();
  var internals = {
    result: Symbol("result")
  };
  exports.entry = function(value, schema, prefs) {
    let settings = Common.defaults;
    if (prefs) {
      Assert(prefs.warnings === undefined, "Cannot override warnings preference in synchronous validation");
      Assert(prefs.artifacts === undefined, "Cannot override artifacts preference in synchronous validation");
      settings = Common.preferences(Common.defaults, prefs);
    }
    const result = internals.entry(value, schema, settings);
    Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
    const outcome = { value: result.value };
    if (result.error) {
      outcome.error = result.error;
    }
    if (result.mainstay.warnings.length) {
      outcome.warning = Errors.details(result.mainstay.warnings);
    }
    if (result.mainstay.debug) {
      outcome.debug = result.mainstay.debug;
    }
    if (result.mainstay.artifacts) {
      outcome.artifacts = result.mainstay.artifacts;
    }
    return outcome;
  };
  exports.entryAsync = async function(value, schema, prefs) {
    let settings = Common.defaults;
    if (prefs) {
      settings = Common.preferences(Common.defaults, prefs);
    }
    const result = internals.entry(value, schema, settings);
    const mainstay = result.mainstay;
    if (result.error) {
      if (mainstay.debug) {
        result.error.debug = mainstay.debug;
      }
      throw result.error;
    }
    if (mainstay.externals.length) {
      let root = result.value;
      const errors = [];
      for (const external of mainstay.externals) {
        const path = external.state.path;
        const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
        let node = root;
        let key;
        let parent;
        const ancestors = path.length ? [root] : [];
        const original = path.length ? Reach(value, path) : value;
        if (path.length) {
          key = path[path.length - 1];
          let current = root;
          for (const segment of path.slice(0, -1)) {
            current = current[segment];
            ancestors.unshift(current);
          }
          parent = ancestors[0];
          node = parent[key];
        }
        try {
          const createError = (code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings);
          const output = await external.method(node, {
            schema: external.schema,
            linked,
            state: external.state,
            prefs,
            original,
            error: createError,
            errorsArray: internals.errorsArray,
            warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),
            message: (messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, { messages })
          });
          if (output === undefined || output === node) {
            continue;
          }
          if (output instanceof Errors.Report) {
            mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
            errors.push(output);
            if (settings.abortEarly) {
              break;
            }
            continue;
          }
          if (Array.isArray(output) && output[Common.symbols.errors]) {
            mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
            errors.push(...output);
            if (settings.abortEarly) {
              break;
            }
            continue;
          }
          if (parent) {
            mainstay.tracer.value(external.state, "rule", node, output, "external");
            parent[key] = output;
          } else {
            mainstay.tracer.value(external.state, "rule", root, output, "external");
            root = output;
          }
        } catch (err) {
          if (settings.errors.label) {
            err.message += ` (${external.label})`;
          }
          throw err;
        }
      }
      result.value = root;
      if (errors.length) {
        result.error = Errors.process(errors, value, settings);
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
    }
    if (!settings.warnings && !settings.debug && !settings.artifacts) {
      return result.value;
    }
    const outcome = { value: result.value };
    if (mainstay.warnings.length) {
      outcome.warning = Errors.details(mainstay.warnings);
    }
    if (mainstay.debug) {
      outcome.debug = mainstay.debug;
    }
    if (mainstay.artifacts) {
      outcome.artifacts = mainstay.artifacts;
    }
    return outcome;
  };
  internals.Mainstay = class {
    constructor(tracer, debug, links) {
      this.externals = [];
      this.warnings = [];
      this.tracer = tracer;
      this.debug = debug;
      this.links = links;
      this.shadow = null;
      this.artifacts = null;
      this._snapshots = [];
    }
    snapshot() {
      this._snapshots.push({
        externals: this.externals.slice(),
        warnings: this.warnings.slice()
      });
    }
    restore() {
      const snapshot = this._snapshots.pop();
      this.externals = snapshot.externals;
      this.warnings = snapshot.warnings;
    }
    commit() {
      this._snapshots.pop();
    }
  };
  internals.entry = function(value, schema, prefs) {
    const { tracer, cleanup } = internals.tracer(schema, prefs);
    const debug = prefs.debug ? [] : null;
    const links = schema._ids._schemaChain ? new Map : null;
    const mainstay = new internals.Mainstay(tracer, debug, links);
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });
    const result = exports.validate(value, schema, state, prefs);
    if (cleanup) {
      schema.$_root.untrace();
    }
    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
  };
  internals.tracer = function(schema, prefs) {
    if (schema.$_root._tracer) {
      return { tracer: schema.$_root._tracer._register(schema) };
    }
    if (prefs.debug) {
      Assert(schema.$_root.trace, "Debug mode not supported");
      return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
    }
    return { tracer: internals.ignore };
  };
  exports.validate = function(value, schema, state, prefs, overrides = {}) {
    if (schema.$_terms.whens) {
      schema = schema._generate(value, state, prefs).schema;
    }
    if (schema._preferences) {
      prefs = internals.prefs(schema, prefs);
    }
    if (schema._cache && prefs.cache) {
      const result = schema._cache.get(value);
      state.mainstay.tracer.debug(state, "validate", "cached", !!result);
      if (result) {
        return result;
      }
    }
    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
      original: value,
      prefs,
      schema,
      state,
      error: createError,
      errorsArray: internals.errorsArray,
      warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
      message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, { messages })
    };
    state.mainstay.tracer.entry(schema, state);
    const def = schema._definition;
    if (def.prepare && value !== undefined && prefs.convert) {
      const prepared = def.prepare(value, helpers);
      if (prepared) {
        state.mainstay.tracer.value(state, "prepare", value, prepared.value);
        if (prepared.errors) {
          return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
        }
        value = prepared.value;
      }
    }
    if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
      const coerced = def.coerce.method(value, helpers);
      if (coerced) {
        state.mainstay.tracer.value(state, "coerced", value, coerced.value);
        if (coerced.errors) {
          return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
        }
        value = coerced.value;
      }
    }
    const empty = schema._flags.empty;
    if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {
      state.mainstay.tracer.value(state, "empty", value, undefined);
      value = undefined;
    }
    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
    if (value === undefined) {
      if (presence === "forbidden") {
        return internals.finalize(value, null, helpers);
      }
      if (presence === "required") {
        return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
      }
      if (presence === "optional") {
        if (schema._flags.default !== Common.symbols.deepDefault) {
          return internals.finalize(value, null, helpers);
        }
        state.mainstay.tracer.value(state, "default", value, {});
        value = {};
      }
    } else if (presence === "forbidden") {
      return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
    }
    const errors = [];
    if (schema._valids) {
      const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
      if (match) {
        if (prefs.convert) {
          state.mainstay.tracer.value(state, "valids", value, match.value);
          value = match.value;
        }
        state.mainstay.tracer.filter(schema, state, "valid", match);
        return internals.finalize(value, null, helpers);
      }
      if (schema._flags.only) {
        const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
        if (prefs.abortEarly) {
          return internals.finalize(value, [report], helpers);
        }
        errors.push(report);
      }
    }
    if (schema._invalids) {
      const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
      if (match) {
        state.mainstay.tracer.filter(schema, state, "invalid", match);
        const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
        if (prefs.abortEarly) {
          return internals.finalize(value, [report], helpers);
        }
        errors.push(report);
      }
    }
    if (def.validate) {
      const base = def.validate(value, helpers);
      if (base) {
        state.mainstay.tracer.value(state, "base", value, base.value);
        value = base.value;
        if (base.errors) {
          if (!Array.isArray(base.errors)) {
            errors.push(base.errors);
            return internals.finalize(value, errors, helpers);
          }
          if (base.errors.length) {
            errors.push(...base.errors);
            return internals.finalize(value, errors, helpers);
          }
        }
      }
    }
    if (!schema._rules.length) {
      return internals.finalize(value, errors, helpers);
    }
    return internals.rules(value, errors, helpers);
  };
  internals.rules = function(value, errors, helpers) {
    const { schema, state, prefs } = helpers;
    for (const rule of schema._rules) {
      const definition = schema._definition.rules[rule.method];
      if (definition.convert && prefs.convert) {
        state.mainstay.tracer.log(schema, state, "rule", rule.name, "full");
        continue;
      }
      let ret;
      let args = rule.args;
      if (rule._resolve.length) {
        args = Object.assign({}, args);
        for (const key of rule._resolve) {
          const resolver = definition.argsByName.get(key);
          const resolved = args[key].resolve(value, state, prefs);
          const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
          const invalid = Common.validateArg(normalized, null, resolver);
          if (invalid) {
            ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
            break;
          }
          args[key] = normalized;
        }
      }
      ret = ret || definition.validate(value, helpers, args, rule);
      const result = internals.rule(ret, rule);
      if (result.errors) {
        state.mainstay.tracer.log(schema, state, "rule", rule.name, "error");
        if (rule.warn) {
          state.mainstay.warnings.push(...result.errors);
          continue;
        }
        if (prefs.abortEarly) {
          return internals.finalize(value, result.errors, helpers);
        }
        errors.push(...result.errors);
      } else {
        state.mainstay.tracer.log(schema, state, "rule", rule.name, "pass");
        state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
        value = result.value;
      }
    }
    return internals.finalize(value, errors, helpers);
  };
  internals.rule = function(ret, rule) {
    if (ret instanceof Errors.Report) {
      internals.error(ret, rule);
      return { errors: [ret], value: null };
    }
    if (Array.isArray(ret) && ret[Common.symbols.errors]) {
      ret.forEach((report) => internals.error(report, rule));
      return { errors: ret, value: null };
    }
    return { errors: null, value: ret };
  };
  internals.error = function(report, rule) {
    if (rule.message) {
      report._setTemplate(rule.message);
    }
    return report;
  };
  internals.finalize = function(value, errors, helpers) {
    errors = errors || [];
    const { schema, state, prefs } = helpers;
    if (errors.length) {
      const failover = internals.default("failover", undefined, errors, helpers);
      if (failover !== undefined) {
        state.mainstay.tracer.value(state, "failover", value, failover);
        value = failover;
        errors = [];
      }
    }
    if (errors.length && schema._flags.error) {
      if (typeof schema._flags.error === "function") {
        errors = schema._flags.error(errors);
        if (!Array.isArray(errors)) {
          errors = [errors];
        }
        for (const error of errors) {
          Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
        }
      } else {
        errors = [schema._flags.error];
      }
    }
    if (value === undefined) {
      const defaulted = internals.default("default", value, errors, helpers);
      state.mainstay.tracer.value(state, "default", value, defaulted);
      value = defaulted;
    }
    if (schema._flags.cast && value !== undefined) {
      const caster = schema._definition.cast[schema._flags.cast];
      if (caster.from(value)) {
        const casted = caster.to(value, helpers);
        state.mainstay.tracer.value(state, "cast", value, casted, schema._flags.cast);
        value = casted;
      }
    }
    if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
      for (const { method } of schema.$_terms.externals) {
        state.mainstay.externals.push({ method, schema, state, label: Errors.label(schema._flags, state, prefs) });
      }
    }
    const result = { value, errors: errors.length ? errors : null };
    if (schema._flags.result) {
      result.value = schema._flags.result === "strip" ? undefined : helpers.original;
      state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
      state.shadow(value, schema._flags.result);
    }
    if (schema._cache && prefs.cache !== false && !schema._refs.length) {
      schema._cache.set(helpers.original, result);
    }
    if (value !== undefined && !result.errors && schema._flags.artifact !== undefined) {
      state.mainstay.artifacts = state.mainstay.artifacts || new Map;
      if (!state.mainstay.artifacts.has(schema._flags.artifact)) {
        state.mainstay.artifacts.set(schema._flags.artifact, []);
      }
      state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);
    }
    return result;
  };
  internals.prefs = function(schema, prefs) {
    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
      return schema._preferences[Common.symbols.prefs];
    }
    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
      schema._preferences[Common.symbols.prefs] = prefs;
    }
    return prefs;
  };
  internals.default = function(flag, value, errors, helpers) {
    const { schema, state, prefs } = helpers;
    const source = schema._flags[flag];
    if (prefs.noDefaults || source === undefined) {
      return value;
    }
    state.mainstay.tracer.log(schema, state, "rule", flag, "full");
    if (!source) {
      return source;
    }
    if (typeof source === "function") {
      const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
      try {
        return source(...args);
      } catch (err) {
        errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
        return;
      }
    }
    if (typeof source !== "object") {
      return source;
    }
    if (source[Common.symbols.literal]) {
      return source.literal;
    }
    if (Common.isResolvable(source)) {
      return source.resolve(value, state, prefs);
    }
    return Clone(source);
  };
  internals.trim = function(value, schema) {
    if (typeof value !== "string") {
      return value;
    }
    const trim = schema.$_getRule("trim");
    if (!trim || !trim.args.enabled) {
      return value;
    }
    return value.trim();
  };
  internals.ignore = {
    active: false,
    debug: Ignore,
    entry: Ignore,
    filter: Ignore,
    log: Ignore,
    resolve: Ignore,
    value: Ignore
  };
  internals.errorsArray = function() {
    const errors = [];
    errors[Common.symbols.errors] = true;
    return errors;
  };
});

// node_modules/joi/lib/values.js
var require_values = __commonJS((exports, module) => {
  var Assert = require_assert();
  var DeepEqual = require_deepEqual();
  var Common = require_common2();
  var internals = {};
  module.exports = internals.Values = class {
    constructor(values, refs) {
      this._values = new Set(values);
      this._refs = new Set(refs);
      this._lowercase = internals.lowercases(values);
      this._override = false;
    }
    get length() {
      return this._values.size + this._refs.size;
    }
    add(value, refs) {
      if (Common.isResolvable(value)) {
        if (!this._refs.has(value)) {
          this._refs.add(value);
          if (refs) {
            refs.register(value);
          }
        }
        return;
      }
      if (!this.has(value, null, null, false)) {
        this._values.add(value);
        if (typeof value === "string") {
          this._lowercase.set(value.toLowerCase(), value);
        }
      }
    }
    static merge(target, source, remove) {
      target = target || new internals.Values;
      if (source) {
        if (source._override) {
          return source.clone();
        }
        for (const item of [...source._values, ...source._refs]) {
          target.add(item);
        }
      }
      if (remove) {
        for (const item of [...remove._values, ...remove._refs]) {
          target.remove(item);
        }
      }
      return target.length ? target : null;
    }
    remove(value) {
      if (Common.isResolvable(value)) {
        this._refs.delete(value);
        return;
      }
      this._values.delete(value);
      if (typeof value === "string") {
        this._lowercase.delete(value.toLowerCase());
      }
    }
    has(value, state, prefs, insensitive) {
      return !!this.get(value, state, prefs, insensitive);
    }
    get(value, state, prefs, insensitive) {
      if (!this.length) {
        return false;
      }
      if (this._values.has(value)) {
        return { value };
      }
      if (typeof value === "string" && value && insensitive) {
        const found = this._lowercase.get(value.toLowerCase());
        if (found) {
          return { value: found };
        }
      }
      if (!this._refs.size && typeof value !== "object") {
        return false;
      }
      if (typeof value === "object") {
        for (const item of this._values) {
          if (DeepEqual(item, value)) {
            return { value: item };
          }
        }
      }
      if (state) {
        for (const ref of this._refs) {
          const resolved = ref.resolve(value, state, prefs, null, { in: true });
          if (resolved === undefined) {
            continue;
          }
          const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
          for (const item of items) {
            if (typeof item !== typeof value) {
              continue;
            }
            if (insensitive && value && typeof value === "string") {
              if (item.toLowerCase() === value.toLowerCase()) {
                return { value: item, ref };
              }
            } else {
              if (DeepEqual(item, value)) {
                return { value: item, ref };
              }
            }
          }
        }
      }
      return false;
    }
    override() {
      this._override = true;
    }
    values(options) {
      if (options && options.display) {
        const values = [];
        for (const item of [...this._values, ...this._refs]) {
          if (item !== undefined) {
            values.push(item);
          }
        }
        return values;
      }
      return Array.from([...this._values, ...this._refs]);
    }
    clone() {
      const set = new internals.Values(this._values, this._refs);
      set._override = this._override;
      return set;
    }
    concat(source) {
      Assert(!source._override, "Cannot concat override set of values");
      const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
      set._override = this._override;
      return set;
    }
    describe() {
      const normalized = [];
      if (this._override) {
        normalized.push({ override: true });
      }
      for (const value of this._values.values()) {
        normalized.push(value && typeof value === "object" ? { value } : value);
      }
      for (const value of this._refs.values()) {
        normalized.push(value.describe());
      }
      return normalized;
    }
  };
  internals.Values.prototype[Common.symbols.values] = true;
  internals.Values.prototype.slice = internals.Values.prototype.clone;
  internals.lowercases = function(from) {
    const map = new Map;
    if (from) {
      for (const value of from) {
        if (typeof value === "string") {
          map.set(value.toLowerCase(), value);
        }
      }
    }
    return map;
  };
});

// node_modules/joi/lib/base.js
var require_base = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var DeepEqual = require_deepEqual();
  var Merge = require_merge();
  var Cache = require_cache();
  var Common = require_common2();
  var Compile = require_compile();
  var Errors = require_errors();
  var Extend = require_extend();
  var Manifest = require_manifest();
  var Messages = require_messages();
  var Modify = require_modify();
  var Ref = require_ref();
  var Trace = require_trace();
  var Validator = require_validator();
  var Values = require_values();
  var internals = {};
  internals.Base = class {
    constructor(type) {
      this.type = type;
      this.$_root = null;
      this._definition = {};
      this._reset();
    }
    _reset() {
      this._ids = new Modify.Ids;
      this._preferences = null;
      this._refs = new Ref.Manager;
      this._cache = null;
      this._valids = null;
      this._invalids = null;
      this._flags = {};
      this._rules = [];
      this._singleRules = new Map;
      this.$_terms = {};
      this.$_temp = {
        ruleset: null,
        whens: {}
      };
    }
    describe() {
      Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
      return Manifest.describe(this);
    }
    allow(...values) {
      Common.verifyFlat(values, "allow");
      return this._values(values, "_valids");
    }
    alter(targets) {
      Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
      Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
      const obj = this.clone();
      obj.$_terms.alterations = obj.$_terms.alterations || [];
      for (const target in targets) {
        const adjuster = targets[target];
        Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
        obj.$_terms.alterations.push({ target, adjuster });
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    artifact(id) {
      Assert(id !== undefined, "Artifact cannot be undefined");
      Assert(!this._cache, "Cannot set an artifact with a rule cache");
      return this.$_setFlag("artifact", id);
    }
    cast(to) {
      Assert(to === false || typeof to === "string", "Invalid to value");
      Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
      return this.$_setFlag("cast", to === false ? undefined : to);
    }
    default(value, options) {
      return this._default("default", value, options);
    }
    description(desc) {
      Assert(desc && typeof desc === "string", "Description must be a non-empty string");
      return this.$_setFlag("description", desc);
    }
    empty(schema) {
      const obj = this.clone();
      if (schema !== undefined) {
        schema = obj.$_compile(schema, { override: false });
      }
      return obj.$_setFlag("empty", schema, { clone: false });
    }
    error(err) {
      Assert(err, "Missing error");
      Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
      return this.$_setFlag("error", err);
    }
    example(example, options = {}) {
      Assert(example !== undefined, "Missing example");
      Common.assertOptions(options, ["override"]);
      return this._inner("examples", example, { single: true, override: options.override });
    }
    external(method, description) {
      if (typeof method === "object") {
        Assert(!description, "Cannot combine options with description");
        description = method.description;
        method = method.method;
      }
      Assert(typeof method === "function", "Method must be a function");
      Assert(description === undefined || description && typeof description === "string", "Description must be a non-empty string");
      return this._inner("externals", { method, description }, { single: true });
    }
    failover(value, options) {
      return this._default("failover", value, options);
    }
    forbidden() {
      return this.presence("forbidden");
    }
    id(id) {
      if (!id) {
        return this.$_setFlag("id", undefined);
      }
      Assert(typeof id === "string", "id must be a non-empty string");
      Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
      return this.$_setFlag("id", id);
    }
    invalid(...values) {
      return this._values(values, "_invalids");
    }
    label(name) {
      Assert(name && typeof name === "string", "Label name must be a non-empty string");
      return this.$_setFlag("label", name);
    }
    meta(meta) {
      Assert(meta !== undefined, "Meta cannot be undefined");
      return this._inner("metas", meta, { single: true });
    }
    note(...notes) {
      Assert(notes.length, "Missing notes");
      for (const note of notes) {
        Assert(note && typeof note === "string", "Notes must be non-empty strings");
      }
      return this._inner("notes", notes);
    }
    only(mode = true) {
      Assert(typeof mode === "boolean", "Invalid mode:", mode);
      return this.$_setFlag("only", mode);
    }
    optional() {
      return this.presence("optional");
    }
    prefs(prefs) {
      Assert(prefs, "Missing preferences");
      Assert(prefs.context === undefined, "Cannot override context");
      Assert(prefs.externals === undefined, "Cannot override externals");
      Assert(prefs.warnings === undefined, "Cannot override warnings");
      Assert(prefs.debug === undefined, "Cannot override debug");
      Common.checkPreferences(prefs);
      const obj = this.clone();
      obj._preferences = Common.preferences(obj._preferences, prefs);
      return obj;
    }
    presence(mode) {
      Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
      return this.$_setFlag("presence", mode);
    }
    raw(enabled = true) {
      return this.$_setFlag("result", enabled ? "raw" : undefined);
    }
    result(mode) {
      Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
      return this.$_setFlag("result", mode);
    }
    required() {
      return this.presence("required");
    }
    strict(enabled) {
      const obj = this.clone();
      const convert = enabled === undefined ? false : !enabled;
      obj._preferences = Common.preferences(obj._preferences, { convert });
      return obj;
    }
    strip(enabled = true) {
      return this.$_setFlag("result", enabled ? "strip" : undefined);
    }
    tag(...tags) {
      Assert(tags.length, "Missing tags");
      for (const tag of tags) {
        Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
      }
      return this._inner("tags", tags);
    }
    unit(name) {
      Assert(name && typeof name === "string", "Unit name must be a non-empty string");
      return this.$_setFlag("unit", name);
    }
    valid(...values) {
      Common.verifyFlat(values, "valid");
      const obj = this.allow(...values);
      obj.$_setFlag("only", !!obj._valids, { clone: false });
      return obj;
    }
    when(condition, options) {
      const obj = this.clone();
      if (!obj.$_terms.whens) {
        obj.$_terms.whens = [];
      }
      const when = Compile.when(obj, condition, options);
      if (!["any", "link"].includes(obj.type)) {
        const conditions = when.is ? [when] : when.switch;
        for (const item of conditions) {
          Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
          Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
        }
      }
      obj.$_terms.whens.push(when);
      return obj.$_mutateRebuild();
    }
    cache(cache) {
      Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
      Assert(!this._cache, "Cannot override schema cache");
      Assert(this._flags.artifact === undefined, "Cannot cache a rule with an artifact");
      const obj = this.clone();
      obj._cache = cache || Cache.provider.provision();
      obj.$_temp.ruleset = false;
      return obj;
    }
    clone() {
      const obj = Object.create(Object.getPrototypeOf(this));
      return this._assign(obj);
    }
    concat(source) {
      Assert(Common.isSchema(source), "Invalid schema object");
      Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
      Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
      Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
      let obj = this.clone();
      if (this.type === "any" && source.type !== "any") {
        const tmpObj = source.clone();
        for (const key of Object.keys(obj)) {
          if (key !== "type") {
            tmpObj[key] = obj[key];
          }
        }
        obj = tmpObj;
      }
      obj._ids.concat(source._ids);
      obj._refs.register(source, Ref.toSibling);
      obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
      obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
      obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
      for (const name of source._singleRules.keys()) {
        if (obj._singleRules.has(name)) {
          obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
          obj._singleRules.delete(name);
        }
      }
      for (const test of source._rules) {
        if (!source._definition.rules[test.method].multi) {
          obj._singleRules.set(test.name, test);
        }
        obj._rules.push(test);
      }
      if (obj._flags.empty && source._flags.empty) {
        obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else if (source._flags.empty) {
        obj._flags.empty = source._flags.empty;
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else {
        Merge(obj._flags, source._flags);
      }
      for (const key in source.$_terms) {
        const terms = source.$_terms[key];
        if (!terms) {
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms;
          }
          continue;
        }
        if (!obj.$_terms[key]) {
          obj.$_terms[key] = terms.slice();
          continue;
        }
        obj.$_terms[key] = obj.$_terms[key].concat(terms);
      }
      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, source]);
      }
      return obj.$_mutateRebuild();
    }
    extend(options) {
      Assert(!options.base, "Cannot extend type with another base");
      return Extend.type(this, options);
    }
    extract(path) {
      path = Array.isArray(path) ? path : path.split(".");
      return this._ids.reach(path);
    }
    fork(paths, adjuster) {
      Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
      let obj = this;
      for (let path of [].concat(paths)) {
        path = Array.isArray(path) ? path : path.split(".");
        obj = obj._ids.fork(path, adjuster, obj);
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    rule(options) {
      const def = this._definition;
      Common.assertOptions(options, Object.keys(def.modifiers));
      Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
      const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
      Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
      const obj = this.clone();
      for (let i = start;i < obj._rules.length; ++i) {
        const original = obj._rules[i];
        const rule = Clone(original);
        for (const name in options) {
          def.modifiers[name](rule, options[name]);
          Assert(rule.name === original.name, "Cannot change rule name");
        }
        obj._rules[i] = rule;
        if (obj._singleRules.get(rule.name) === original) {
          obj._singleRules.set(rule.name, rule);
        }
      }
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
    get ruleset() {
      Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
      const obj = this.clone();
      obj.$_temp.ruleset = obj._rules.length;
      return obj;
    }
    get $() {
      return this.ruleset;
    }
    tailor(targets) {
      targets = [].concat(targets);
      Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
      let obj = this;
      if (this.$_terms.alterations) {
        for (const { target, adjuster } of this.$_terms.alterations) {
          if (targets.includes(target)) {
            obj = adjuster(obj);
            Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
          }
        }
      }
      obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
    tracer() {
      return Trace.location ? Trace.location(this) : this;
    }
    validate(value, options) {
      return Validator.entry(value, this, options);
    }
    validateAsync(value, options) {
      return Validator.entryAsync(value, this, options);
    }
    $_addRule(options) {
      if (typeof options === "string") {
        options = { name: options };
      }
      Assert(options && typeof options === "object", "Invalid options");
      Assert(options.name && typeof options.name === "string", "Invalid rule name");
      for (const key in options) {
        Assert(key[0] !== "_", "Cannot set private rule properties");
      }
      const rule = Object.assign({}, options);
      rule._resolve = [];
      rule.method = rule.method || rule.name;
      const definition = this._definition.rules[rule.method];
      const args = rule.args;
      Assert(definition, "Unknown rule", rule.method);
      const obj = this.clone();
      if (args) {
        Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
        for (const key in args) {
          let arg = args[key];
          if (definition.argsByName) {
            const resolver = definition.argsByName.get(key);
            if (resolver.ref && Common.isResolvable(arg)) {
              rule._resolve.push(key);
              obj.$_mutateRegister(arg);
            } else {
              if (resolver.normalize) {
                arg = resolver.normalize(arg);
                args[key] = arg;
              }
              if (resolver.assert) {
                const error = Common.validateArg(arg, key, resolver);
                Assert(!error, error, "or reference");
              }
            }
          }
          if (arg === undefined) {
            delete args[key];
            continue;
          }
          args[key] = arg;
        }
      }
      if (!definition.multi) {
        obj._ruleRemove(rule.name, { clone: false });
        obj._singleRules.set(rule.name, rule);
      }
      if (obj.$_temp.ruleset === false) {
        obj.$_temp.ruleset = null;
      }
      if (definition.priority) {
        obj._rules.unshift(rule);
      } else {
        obj._rules.push(rule);
      }
      return obj;
    }
    $_compile(schema, options) {
      return Compile.schema(this.$_root, schema, options);
    }
    $_createError(code, value, local, state, prefs, options = {}) {
      const flags = options.flags !== false ? this._flags : {};
      const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
      return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }
    $_getFlag(name) {
      return this._flags[name];
    }
    $_getRule(name) {
      return this._singleRules.get(name);
    }
    $_mapLabels(path) {
      path = Array.isArray(path) ? path : path.split(".");
      return this._ids.labels(path);
    }
    $_match(value, state, prefs, overrides) {
      prefs = Object.assign({}, prefs);
      prefs.abortEarly = true;
      prefs._externals = false;
      state.snapshot();
      const result = !Validator.validate(value, this, state, prefs, overrides).errors;
      state.restore();
      return result;
    }
    $_modify(options) {
      Common.assertOptions(options, ["each", "once", "ref", "schema"]);
      return Modify.schema(this, options) || this;
    }
    $_mutateRebuild() {
      Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
      this._refs.reset();
      this._ids.reset();
      const each = (item, { source, name, path, key }) => {
        const family = this._definition[source][name] && this._definition[source][name].register;
        if (family !== false) {
          this.$_mutateRegister(item, { family, key });
        }
      };
      this.$_modify({ each });
      if (this._definition.rebuild) {
        this._definition.rebuild(this);
      }
      this.$_temp.ruleset = false;
      return this;
    }
    $_mutateRegister(schema, { family, key } = {}) {
      this._refs.register(schema, family);
      this._ids.register(schema, { key });
    }
    $_property(name) {
      return this._definition.properties[name];
    }
    $_reach(path) {
      return this._ids.reach(path);
    }
    $_rootReferences() {
      return this._refs.roots();
    }
    $_setFlag(name, value, options = {}) {
      Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
      const flag = this._definition.flags[name] || {};
      if (DeepEqual(value, flag.default)) {
        value = undefined;
      }
      if (DeepEqual(value, this._flags[name])) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      if (value !== undefined) {
        obj._flags[name] = value;
        obj.$_mutateRegister(value);
      } else {
        delete obj._flags[name];
      }
      if (name[0] !== "_") {
        obj.$_temp.ruleset = false;
      }
      return obj;
    }
    $_parent(method, ...args) {
      return this[method][Common.symbols.parent].call(this, ...args);
    }
    $_validate(value, state, prefs) {
      return Validator.validate(value, this, state, prefs);
    }
    _assign(target) {
      target.type = this.type;
      target.$_root = this.$_root;
      target.$_temp = Object.assign({}, this.$_temp);
      target.$_temp.whens = {};
      target._ids = this._ids.clone();
      target._preferences = this._preferences;
      target._valids = this._valids && this._valids.clone();
      target._invalids = this._invalids && this._invalids.clone();
      target._rules = this._rules.slice();
      target._singleRules = Clone(this._singleRules, { shallow: true });
      target._refs = this._refs.clone();
      target._flags = Object.assign({}, this._flags);
      target._cache = null;
      target.$_terms = {};
      for (const key in this.$_terms) {
        target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
      }
      target.$_super = {};
      for (const override in this.$_super) {
        target.$_super[override] = this._super[override].bind(target);
      }
      return target;
    }
    _bare() {
      const obj = this.clone();
      obj._reset();
      const terms = obj._definition.terms;
      for (const name in terms) {
        const term = terms[name];
        obj.$_terms[name] = term.init;
      }
      return obj.$_mutateRebuild();
    }
    _default(flag, value, options = {}) {
      Common.assertOptions(options, "literal");
      Assert(value !== undefined, "Missing", flag, "value");
      Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
      if (typeof value === "function" && options.literal) {
        value = {
          [Common.symbols.literal]: true,
          literal: value
        };
      }
      const obj = this.$_setFlag(flag, value);
      return obj;
    }
    _generate(value, state, prefs) {
      if (!this.$_terms.whens) {
        return { schema: this };
      }
      const whens = [];
      const ids = [];
      for (let i = 0;i < this.$_terms.whens.length; ++i) {
        const when = this.$_terms.whens[i];
        if (when.concat) {
          whens.push(when.concat);
          ids.push(`${i}.concat`);
          continue;
        }
        const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
        const tests = when.is ? [when] : when.switch;
        const before = ids.length;
        for (let j = 0;j < tests.length; ++j) {
          const { is, then, otherwise } = tests[j];
          const baseId = `${i}${when.switch ? "." + j : ""}`;
          if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
            if (then) {
              const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
              break;
            }
          } else if (otherwise) {
            const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
            const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
            whens.push(generated);
            ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
            break;
          }
        }
        if (when.break && ids.length > before) {
          break;
        }
      }
      const id = ids.join(", ");
      state.mainstay.tracer.debug(state, "rule", "when", id);
      if (!id) {
        return { schema: this };
      }
      if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
        return { schema: this.$_temp.whens[id], id };
      }
      let obj = this;
      if (this._definition.generate) {
        obj = this._definition.generate(this, value, state, prefs);
      }
      for (const when of whens) {
        obj = obj.concat(when);
      }
      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, ...whens]);
      }
      this.$_temp.whens[id] = obj;
      return { schema: obj, id };
    }
    _inner(type, values, options = {}) {
      Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
      const obj = this.clone();
      if (!obj.$_terms[type] || options.override) {
        obj.$_terms[type] = [];
      }
      if (options.single) {
        obj.$_terms[type].push(values);
      } else {
        obj.$_terms[type].push(...values);
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    _inRuleset() {
      return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }
    _ruleRemove(name, options = {}) {
      if (!this._singleRules.has(name)) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      obj._singleRules.delete(name);
      const filtered = [];
      for (let i = 0;i < obj._rules.length; ++i) {
        const test = obj._rules[i];
        if (test.name === name && !test.keep) {
          if (obj._inRuleset() && i < obj.$_temp.ruleset) {
            --obj.$_temp.ruleset;
          }
          continue;
        }
        filtered.push(test);
      }
      obj._rules = filtered;
      return obj;
    }
    _values(values, key) {
      Common.verifyFlat(values, key.slice(1, -1));
      const obj = this.clone();
      const override = values[0] === Common.symbols.override;
      if (override) {
        values = values.slice(1);
      }
      if (!obj[key] && values.length) {
        obj[key] = new Values;
      } else if (override) {
        obj[key] = values.length ? new Values : null;
        obj.$_mutateRebuild();
      }
      if (!obj[key]) {
        return obj;
      }
      if (override) {
        obj[key].override();
      }
      for (const value of values) {
        Assert(value !== undefined, "Cannot call allow/valid/invalid with undefined");
        Assert(value !== Common.symbols.override, "Override must be the first value");
        const other = key === "_invalids" ? "_valids" : "_invalids";
        if (obj[other]) {
          obj[other].remove(value);
          if (!obj[other].length) {
            Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
            obj[other] = null;
          }
        }
        obj[key].add(value, obj._refs);
      }
      return obj;
    }
  };
  internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: "$_root"
  };
  internals.Base.prototype.isImmutable = true;
  internals.Base.prototype.deny = internals.Base.prototype.invalid;
  internals.Base.prototype.disallow = internals.Base.prototype.invalid;
  internals.Base.prototype.equal = internals.Base.prototype.valid;
  internals.Base.prototype.exist = internals.Base.prototype.required;
  internals.Base.prototype.not = internals.Base.prototype.invalid;
  internals.Base.prototype.options = internals.Base.prototype.prefs;
  internals.Base.prototype.preferences = internals.Base.prototype.prefs;
  module.exports = new internals.Base;
});

// node_modules/joi/lib/types/any.js
var require_any = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Base = require_base();
  var Common = require_common2();
  var Messages = require_messages();
  module.exports = Base.extend({
    type: "any",
    flags: {
      only: { default: false }
    },
    terms: {
      alterations: { init: null },
      examples: { init: null },
      externals: { init: null },
      metas: { init: [] },
      notes: { init: [] },
      shared: { init: null },
      tags: { init: [] },
      whens: { init: null }
    },
    rules: {
      custom: {
        method(method, description) {
          Assert(typeof method === "function", "Method must be a function");
          Assert(description === undefined || description && typeof description === "string", "Description must be a non-empty string");
          return this.$_addRule({ name: "custom", args: { method, description } });
        },
        validate(value, helpers, { method }) {
          try {
            return method(value, helpers);
          } catch (err) {
            return helpers.error("any.custom", { error: err });
          }
        },
        args: ["method", "description"],
        multi: true
      },
      messages: {
        method(messages) {
          return this.prefs({ messages });
        }
      },
      shared: {
        method(schema) {
          Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
          const obj = this.clone();
          obj.$_terms.shared = obj.$_terms.shared || [];
          obj.$_terms.shared.push(schema);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      warning: {
        method(code, local) {
          Assert(code && typeof code === "string", "Invalid warning code");
          return this.$_addRule({ name: "warning", args: { code, local }, warn: true });
        },
        validate(value, helpers, { code, local }) {
          return helpers.error(code, local);
        },
        args: ["code", "local"],
        multi: true
      }
    },
    modifiers: {
      keep(rule, enabled = true) {
        rule.keep = enabled;
      },
      message(rule, message) {
        rule.message = Messages.compile(message);
      },
      warn(rule, enabled = true) {
        rule.warn = enabled;
      }
    },
    manifest: {
      build(obj, desc) {
        for (const key in desc) {
          const values = desc[key];
          if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
            for (const value of values) {
              obj = obj[key.slice(0, -1)](value);
            }
            continue;
          }
          if (key === "alterations") {
            const alter = {};
            for (const { target, adjuster } of values) {
              alter[target] = adjuster;
            }
            obj = obj.alter(alter);
            continue;
          }
          if (key === "whens") {
            for (const value of values) {
              const { ref, is, not, then, otherwise, concat } = value;
              if (concat) {
                obj = obj.concat(concat);
              } else if (ref) {
                obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
              } else {
                obj = obj.when(is, { then, otherwise, break: value.break });
              }
            }
            continue;
          }
          if (key === "shared") {
            for (const value of values) {
              obj = obj.shared(value);
            }
          }
        }
        return obj;
      }
    },
    messages: {
      "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
      "any.default": "{{#label}} threw an error when running default method",
      "any.failover": "{{#label}} threw an error when running failover method",
      "any.invalid": "{{#label}} contains an invalid value",
      "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
      "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
      "any.required": "{{#label}} is required",
      "any.unknown": "{{#label}} is not allowed"
    }
  });
});

// node_modules/joi/lib/types/alternatives.js
var require_alternatives = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Merge = require_merge();
  var Any = require_any();
  var Common = require_common2();
  var Compile = require_compile();
  var Errors = require_errors();
  var Ref = require_ref();
  var internals = {};
  module.exports = Any.extend({
    type: "alternatives",
    flags: {
      match: { default: "any" }
    },
    terms: {
      matches: { init: [], register: Ref.toSibling }
    },
    args(schema, ...schemas) {
      if (schemas.length === 1) {
        if (Array.isArray(schemas[0])) {
          return schema.try(...schemas[0]);
        }
      }
      return schema.try(...schemas);
    },
    validate(value, helpers) {
      const { schema, error, state, prefs } = helpers;
      if (schema._flags.match) {
        const matched = [];
        const failed = [];
        for (let i = 0;i < schema.$_terms.matches.length; ++i) {
          const item = schema.$_terms.matches[i];
          const localState = state.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            matched.push(result.value);
            localState.commit();
          } else {
            failed.push(result.errors);
            localState.restore();
          }
        }
        if (matched.length === 0) {
          const context = {
            details: failed.map((f) => Errors.details(f, { override: false }))
          };
          return { errors: error("alternatives.any", context) };
        }
        if (schema._flags.match === "one") {
          return matched.length === 1 ? { value: matched[0] } : { errors: error("alternatives.one") };
        }
        if (matched.length !== schema.$_terms.matches.length) {
          const context = {
            details: failed.map((f) => Errors.details(f, { override: false }))
          };
          return { errors: error("alternatives.all", context) };
        }
        const isAnyObj = (alternative) => {
          return alternative.$_terms.matches.some((v) => {
            return v.schema.type === "object" || v.schema.type === "alternatives" && isAnyObj(v.schema);
          });
        };
        return isAnyObj(schema) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
      }
      const errors = [];
      for (let i = 0;i < schema.$_terms.matches.length; ++i) {
        const item = schema.$_terms.matches[i];
        if (item.schema) {
          const localState = state.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            localState.commit();
            return result;
          }
          localState.restore();
          errors.push({ schema: item.schema, reports: result.errors });
          continue;
        }
        const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
        const tests = item.is ? [item] : item.switch;
        for (let j = 0;j < tests.length; ++j) {
          const test = tests[j];
          const { is, then, otherwise } = test;
          const id = `match.${i}${item.switch ? "." + j : ""}`;
          if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
            if (otherwise) {
              return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
            }
          } else if (then) {
            return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
          }
        }
      }
      return internals.errors(errors, helpers);
    },
    rules: {
      conditional: {
        method(condition, options) {
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
          Assert(options.break === undefined, "Cannot use break option with alternatives conditional");
          const obj = this.clone();
          const match = Compile.when(obj, condition, options);
          const conditions = match.is ? [match] : match.switch;
          for (const item of conditions) {
            if (item.then && item.otherwise) {
              obj.$_setFlag("_endedSwitch", true, { clone: false });
              break;
            }
          }
          obj.$_terms.matches.push(match);
          return obj.$_mutateRebuild();
        }
      },
      match: {
        method(mode) {
          Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
          if (mode !== "any") {
            for (const match of this.$_terms.matches) {
              Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
            }
          }
          return this.$_setFlag("match", mode);
        }
      },
      try: {
        method(...schemas) {
          Assert(schemas.length, "Missing alternative schemas");
          Common.verifyFlat(schemas, "try");
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          const obj = this.clone();
          for (const schema of schemas) {
            obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
          }
          return obj.$_mutateRebuild();
        }
      }
    },
    overrides: {
      label(name) {
        const obj = this.$_parent("label", name);
        const each = (item, source) => source.path[0] !== "is" ? item.label(name) : undefined;
        return obj.$_modify({ each, ref: false });
      }
    },
    rebuild(schema) {
      const each = (item) => {
        if (Common.isSchema(item) && item.type === "array") {
          schema.$_setFlag("_arrayItems", true, { clone: false });
        }
      };
      schema.$_modify({ each });
    },
    manifest: {
      build(obj, desc) {
        if (desc.matches) {
          for (const match of desc.matches) {
            const { schema, ref, is, not, then, otherwise } = match;
            if (schema) {
              obj = obj.try(schema);
            } else if (ref) {
              obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
            } else {
              obj = obj.conditional(is, { then, otherwise });
            }
          }
        }
        return obj;
      }
    },
    messages: {
      "alternatives.all": "{{#label}} does not match all of the required types",
      "alternatives.any": "{{#label}} does not match any of the allowed types",
      "alternatives.match": "{{#label}} does not match any of the allowed types",
      "alternatives.one": "{{#label}} matches more than one allowed type",
      "alternatives.types": "{{#label}} must be one of {{#types}}"
    }
  });
  internals.errors = function(failures, { error, state }) {
    if (!failures.length) {
      return { errors: error("alternatives.any") };
    }
    if (failures.length === 1) {
      return { errors: failures[0].reports };
    }
    const valids = new Set;
    const complex = [];
    for (const { reports, schema } of failures) {
      if (reports.length > 1) {
        return internals.unmatched(failures, error);
      }
      const report = reports[0];
      if (report instanceof Errors.Report === false) {
        return internals.unmatched(failures, error);
      }
      if (report.state.path.length !== state.path.length) {
        complex.push({ type: schema.type, report });
        continue;
      }
      if (report.code === "any.only") {
        for (const valid of report.local.valids) {
          valids.add(valid);
        }
        continue;
      }
      const [type, code] = report.code.split(".");
      if (code !== "base") {
        complex.push({ type: schema.type, report });
        continue;
      }
      valids.add(type);
    }
    if (!complex.length) {
      return { errors: error("alternatives.types", { types: [...valids] }) };
    }
    if (complex.length === 1) {
      return { errors: complex[0].report };
    }
    return internals.unmatched(failures, error);
  };
  internals.unmatched = function(failures, error) {
    const errors = [];
    for (const failure of failures) {
      errors.push(...failure.reports);
    }
    return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
  };
});

// node_modules/joi/lib/types/array.js
var require_array = __commonJS((exports, module) => {
  var Assert = require_assert();
  var DeepEqual = require_deepEqual();
  var Reach = require_reach();
  var Any = require_any();
  var Common = require_common2();
  var Compile = require_compile();
  var internals = {};
  module.exports = Any.extend({
    type: "array",
    flags: {
      single: { default: false },
      sparse: { default: false }
    },
    terms: {
      items: { init: [], manifest: "schema" },
      ordered: { init: [], manifest: "schema" },
      _exclusions: { init: [] },
      _inclusions: { init: [] },
      _requireds: { init: [] }
    },
    coerce: {
      from: "object",
      method(value, { schema, state, prefs }) {
        if (!Array.isArray(value)) {
          return;
        }
        const sort = schema.$_getRule("sort");
        if (!sort) {
          return;
        }
        return internals.sort(schema, value, sort.args.options, state, prefs);
      }
    },
    validate(value, { schema, error }) {
      if (!Array.isArray(value)) {
        if (schema._flags.single) {
          const single = [value];
          single[Common.symbols.arraySingle] = true;
          return { value: single };
        }
        return { errors: error("array.base") };
      }
      if (!schema.$_getRule("items") && !schema.$_terms.externals) {
        return;
      }
      return { value: value.slice() };
    },
    rules: {
      has: {
        method(schema) {
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "has", args: { schema } });
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { state, prefs, error }, { schema: has }) {
          const ancestors = [value, ...state.ancestors];
          for (let i = 0;i < value.length; ++i) {
            const localState = state.localize([...state.path, i], ancestors, has);
            if (has.$_match(value[i], localState, prefs)) {
              return value;
            }
          }
          const patternLabel = has._flags.label;
          if (patternLabel) {
            return error("array.hasKnown", { patternLabel });
          }
          return error("array.hasUnknown", null);
        },
        multi: true
      },
      items: {
        method(...schemas) {
          Common.verifyFlat(schemas, "items");
          const obj = this.$_addRule("items");
          for (let i = 0;i < schemas.length; ++i) {
            const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
            obj.$_terms.items.push(type);
          }
          return obj.$_mutateRebuild();
        },
        validate(value, { schema, error, state, prefs, errorsArray }) {
          const requireds = schema.$_terms._requireds.slice();
          const ordereds = schema.$_terms.ordered.slice();
          const inclusions = [...schema.$_terms._inclusions, ...requireds];
          const wasArray = !value[Common.symbols.arraySingle];
          delete value[Common.symbols.arraySingle];
          const errors = errorsArray();
          let il = value.length;
          for (let i = 0;i < il; ++i) {
            const item = value[i];
            let errored = false;
            let isValid = false;
            const key = wasArray ? i : new Number(i);
            const path = [...state.path, key];
            if (!schema._flags.sparse && item === undefined) {
              errors.push(error("array.sparse", { key, path, pos: i, value: undefined }, state.localize(path)));
              if (prefs.abortEarly) {
                return errors;
              }
              ordereds.shift();
              continue;
            }
            const ancestors = [value, ...state.ancestors];
            for (const exclusion of schema.$_terms._exclusions) {
              if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                continue;
              }
              errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path)));
              if (prefs.abortEarly) {
                return errors;
              }
              errored = true;
              ordereds.shift();
              break;
            }
            if (errored) {
              continue;
            }
            if (schema.$_terms.ordered.length) {
              if (ordereds.length) {
                const ordered = ordereds.shift();
                const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                if (!res.errors) {
                  if (ordered._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === undefined) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: undefined }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                    continue;
                  } else {
                    value[i] = res.value;
                  }
                } else {
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                }
                continue;
              } else if (!schema.$_terms.items.length) {
                errors.push(error("array.orderedLength", { pos: i, limit: schema.$_terms.ordered.length }));
                if (prefs.abortEarly) {
                  return errors;
                }
                break;
              }
            }
            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0;j < jl; ++j) {
              const localState = state.localize(path, ancestors, requireds[j]);
              localState.snapshot();
              const res = requireds[j].$_validate(item, localState, prefs);
              requiredChecks[j] = res;
              if (!res.errors) {
                localState.commit();
                value[i] = res.value;
                isValid = true;
                internals.fastSplice(requireds, j);
                --j;
                --jl;
                if (!schema._flags.sparse && res.value === undefined) {
                  errors.push(error("array.sparse", { key, path, pos: i, value: undefined }, state.localize(path)));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                }
                break;
              }
              localState.restore();
            }
            if (isValid) {
              continue;
            }
            const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
            jl = inclusions.length;
            for (const inclusion of inclusions) {
              let res;
              const previousCheck = requireds.indexOf(inclusion);
              if (previousCheck !== -1) {
                res = requiredChecks[previousCheck];
              } else {
                const localState = state.localize(path, ancestors, inclusion);
                localState.snapshot();
                res = inclusion.$_validate(item, localState, prefs);
                if (!res.errors) {
                  localState.commit();
                  if (inclusion._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === undefined) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: undefined }, state.localize(path)));
                    errored = true;
                  } else {
                    value[i] = res.value;
                  }
                  isValid = true;
                  break;
                }
                localState.restore();
              }
              if (jl === 1) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  isValid = true;
                  break;
                }
                errors.push(...res.errors);
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                break;
              }
            }
            if (errored) {
              continue;
            }
            if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {
              if (stripUnknown) {
                internals.fastSplice(value, i);
                --i;
                --il;
                continue;
              }
              errors.push(error("array.includes", { pos: i, value: item }, state.localize(path)));
              if (prefs.abortEarly) {
                return errors;
              }
            }
          }
          if (requireds.length) {
            internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
          }
          if (ordereds.length) {
            internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
            if (!errors.length) {
              internals.fillDefault(ordereds, value, state, prefs);
            }
          }
          return errors.length ? errors : value;
        },
        priority: true,
        manifest: false
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("array." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      ordered: {
        method(...schemas) {
          Common.verifyFlat(schemas, "ordered");
          const obj = this.$_addRule("items");
          for (let i = 0;i < schemas.length; ++i) {
            const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
            internals.validateSingle(type, obj);
            obj.$_mutateRegister(type);
            obj.$_terms.ordered.push(type);
          }
          return obj.$_mutateRebuild();
        }
      },
      single: {
        method(enabled) {
          const value = enabled === undefined ? true : !!enabled;
          Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
          return this.$_setFlag("single", value);
        }
      },
      sort: {
        method(options = {}) {
          Common.assertOptions(options, ["by", "order"]);
          const settings = {
            order: options.order || "ascending"
          };
          if (options.by) {
            settings.by = Compile.ref(options.by, { ancestor: 0 });
            Assert(!settings.by.ancestor, "Cannot sort by ancestor");
          }
          return this.$_addRule({ name: "sort", args: { options: settings } });
        },
        validate(value, { error, state, prefs, schema }, { options }) {
          const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
          if (errors) {
            return errors;
          }
          for (let i = 0;i < value.length; ++i) {
            if (value[i] !== sorted[i]) {
              return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
            }
          }
          return value;
        },
        convert: true
      },
      sparse: {
        method(enabled) {
          const value = enabled === undefined ? true : !!enabled;
          if (this._flags.sparse === value) {
            return this;
          }
          const obj = value ? this.clone() : this.$_addRule("items");
          return obj.$_setFlag("sparse", value, { clone: false });
        }
      },
      unique: {
        method(comparator, options = {}) {
          Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
          Common.assertOptions(options, ["ignoreUndefined", "separator"]);
          const rule = { name: "unique", args: { options, comparator } };
          if (comparator) {
            if (typeof comparator === "string") {
              const separator = Common.default(options.separator, ".");
              rule.path = separator ? comparator.split(separator) : [comparator];
            } else {
              rule.comparator = comparator;
            }
          }
          return this.$_addRule(rule);
        },
        validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {
          const found = {
            string: Object.create(null),
            number: Object.create(null),
            undefined: Object.create(null),
            boolean: Object.create(null),
            object: new Map,
            function: new Map,
            custom: new Map
          };
          const compare = comparator || DeepEqual;
          const ignoreUndefined = options.ignoreUndefined;
          for (let i = 0;i < value.length; ++i) {
            const item = path ? Reach(value[i], path) : value[i];
            const records = comparator ? found.custom : found[typeof item];
            Assert(records, "Failed to find unique map container for type", typeof item);
            if (records instanceof Map) {
              const entries = records.entries();
              let current;
              while (!(current = entries.next()).done) {
                if (compare(current.value[0], item)) {
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: current.value[1],
                    dupeValue: value[current.value[1]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  return error("array.unique", context, localState);
                }
              }
              records.set(item, i);
            } else {
              if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {
                const context = {
                  pos: i,
                  value: value[i],
                  dupePos: records[item],
                  dupeValue: value[records[item]]
                };
                if (path) {
                  context.path = raw;
                }
                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                return error("array.unique", context, localState);
              }
              records[item] = i;
            }
          }
          return value;
        },
        args: ["comparator", "options"],
        multi: true
      }
    },
    cast: {
      set: {
        from: Array.isArray,
        to(value, helpers) {
          return new Set(value);
        }
      }
    },
    rebuild(schema) {
      schema.$_terms._inclusions = [];
      schema.$_terms._exclusions = [];
      schema.$_terms._requireds = [];
      for (const type of schema.$_terms.items) {
        internals.validateSingle(type, schema);
        if (type._flags.presence === "required") {
          schema.$_terms._requireds.push(type);
        } else if (type._flags.presence === "forbidden") {
          schema.$_terms._exclusions.push(type);
        } else {
          schema.$_terms._inclusions.push(type);
        }
      }
      for (const type of schema.$_terms.ordered) {
        internals.validateSingle(type, schema);
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.items) {
          obj = obj.items(...desc.items);
        }
        if (desc.ordered) {
          obj = obj.ordered(...desc.ordered);
        }
        return obj;
      }
    },
    messages: {
      "array.base": "{{#label}} must be an array",
      "array.excludes": "{{#label}} contains an excluded value",
      "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
      "array.hasUnknown": "{{#label}} does not contain at least one required match",
      "array.includes": "{{#label}} does not match any of the allowed types",
      "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
      "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
      "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
      "array.length": "{{#label}} must contain {{#limit}} items",
      "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
      "array.min": "{{#label}} must contain at least {{#limit}} items",
      "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
      "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
      "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
      "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
      "array.sparse": "{{#label}} must not be a sparse array item",
      "array.unique": "{{#label}} contains a duplicate value"
    }
  });
  internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
      const label = required._flags.label;
      if (label) {
        knownMisses.push(label);
      } else {
        ++unknownMisses;
      }
    }
    if (knownMisses.length) {
      if (unknownMisses) {
        errors.push(schema.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
      } else {
        errors.push(schema.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
      }
    } else {
      errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
    }
  };
  internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
    const requiredOrdereds = [];
    for (const ordered of ordereds) {
      if (ordered._flags.presence === "required") {
        requiredOrdereds.push(ordered);
      }
    }
    if (requiredOrdereds.length) {
      internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
  };
  internals.fillDefault = function(ordereds, value, state, prefs) {
    const overrides = [];
    let trailingUndefined = true;
    for (let i = ordereds.length - 1;i >= 0; --i) {
      const ordered = ordereds[i];
      const ancestors = [value, ...state.ancestors];
      const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;
      if (trailingUndefined) {
        if (override === undefined) {
          continue;
        }
        trailingUndefined = false;
      }
      overrides.unshift(override);
    }
    if (overrides.length) {
      value.push(...overrides);
    }
  };
  internals.fastSplice = function(arr, i) {
    let pos = i;
    while (pos < arr.length) {
      arr[pos++] = arr[pos];
    }
    --arr.length;
  };
  internals.validateSingle = function(type, obj) {
    if (type.type === "array" || type._flags._arrayItems) {
      Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
      obj.$_setFlag("_arrayItems", true, { clone: false });
    }
  };
  internals.sort = function(schema, value, settings, state, prefs) {
    const order = settings.order === "ascending" ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;
    const sort = (a, b) => {
      let compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      if (settings.by) {
        a = settings.by.resolve(a, state, prefs);
        b = settings.by.resolve(b, state, prefs);
      }
      compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      const type = typeof a;
      if (type !== typeof b) {
        throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
      }
      if (type !== "number" && type !== "string") {
        throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
      }
      if (type === "number") {
        return (a - b) * order;
      }
      return a < b ? aFirst : bFirst;
    };
    try {
      return { value: value.slice().sort(sort) };
    } catch (err) {
      return { errors: err };
    }
  };
  internals.compare = function(a, b, aFirst, bFirst) {
    if (a === b) {
      return 0;
    }
    if (a === undefined) {
      return 1;
    }
    if (b === undefined) {
      return -1;
    }
    if (a === null) {
      return bFirst;
    }
    if (b === null) {
      return aFirst;
    }
    return null;
  };
});

// node_modules/joi/lib/types/boolean.js
var require_boolean = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common2();
  var Values = require_values();
  var internals = {};
  internals.isBool = function(value) {
    return typeof value === "boolean";
  };
  module.exports = Any.extend({
    type: "boolean",
    flags: {
      sensitive: { default: false }
    },
    terms: {
      falsy: {
        init: null,
        manifest: "values"
      },
      truthy: {
        init: null,
        manifest: "values"
      }
    },
    coerce(value, { schema }) {
      if (typeof value === "boolean") {
        return;
      }
      if (typeof value === "string") {
        const normalized = schema._flags.sensitive ? value : value.toLowerCase();
        value = normalized === "true" ? true : normalized === "false" ? false : value;
      }
      if (typeof value !== "boolean") {
        value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
      }
      return { value };
    },
    validate(value, { error }) {
      if (typeof value !== "boolean") {
        return { value, errors: error("boolean.base") };
      }
    },
    rules: {
      truthy: {
        method(...values) {
          Common.verifyFlat(values, "truthy");
          const obj = this.clone();
          obj.$_terms.truthy = obj.$_terms.truthy || new Values;
          for (let i = 0;i < values.length; ++i) {
            const value = values[i];
            Assert(value !== undefined, "Cannot call truthy with undefined");
            obj.$_terms.truthy.add(value);
          }
          return obj;
        }
      },
      falsy: {
        method(...values) {
          Common.verifyFlat(values, "falsy");
          const obj = this.clone();
          obj.$_terms.falsy = obj.$_terms.falsy || new Values;
          for (let i = 0;i < values.length; ++i) {
            const value = values[i];
            Assert(value !== undefined, "Cannot call falsy with undefined");
            obj.$_terms.falsy.add(value);
          }
          return obj;
        }
      },
      sensitive: {
        method(enabled = true) {
          return this.$_setFlag("sensitive", enabled);
        }
      }
    },
    cast: {
      number: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? 1 : 0;
        }
      },
      string: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? "true" : "false";
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.truthy) {
          obj = obj.truthy(...desc.truthy);
        }
        if (desc.falsy) {
          obj = obj.falsy(...desc.falsy);
        }
        return obj;
      }
    },
    messages: {
      "boolean.base": "{{#label}} must be a boolean"
    }
  });
});

// node_modules/joi/lib/types/date.js
var require_date = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common2();
  var Template = require_template();
  var internals = {};
  internals.isDate = function(value) {
    return value instanceof Date;
  };
  module.exports = Any.extend({
    type: "date",
    coerce: {
      from: ["number", "string"],
      method(value, { schema }) {
        return { value: internals.parse(value, schema._flags.format) || value };
      }
    },
    validate(value, { schema, error, prefs }) {
      if (value instanceof Date && !isNaN(value.getTime())) {
        return;
      }
      const format = schema._flags.format;
      if (!prefs.convert || !format || typeof value !== "string") {
        return { value, errors: error("date.base") };
      }
      return { value, errors: error("date.format", { format }) };
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { date }, { name, operator, args }) {
          const to = date === "now" ? Date.now() : date.getTime();
          if (Common.compare(value.getTime(), to, operator)) {
            return value;
          }
          return helpers.error("date." + name, { limit: args.date, value });
        },
        args: [
          {
            name: "date",
            ref: true,
            normalize: (date) => {
              return date === "now" ? date : internals.parse(date);
            },
            assert: (date) => date !== null,
            message: "must have a valid date format"
          }
        ]
      },
      format: {
        method(format) {
          Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
          return this.$_setFlag("format", format);
        }
      },
      greater: {
        method(date) {
          return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
        }
      },
      iso: {
        method() {
          return this.format("iso");
        }
      },
      less: {
        method(date) {
          return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
        }
      },
      max: {
        method(date) {
          return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
        }
      },
      min: {
        method(date) {
          return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
        }
      },
      timestamp: {
        method(type = "javascript") {
          Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
          return this.format(type);
        }
      }
    },
    cast: {
      number: {
        from: internals.isDate,
        to(value, helpers) {
          return value.getTime();
        }
      },
      string: {
        from: internals.isDate,
        to(value, { prefs }) {
          return Template.date(value, prefs);
        }
      }
    },
    messages: {
      "date.base": "{{#label}} must be a valid date",
      "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
      "date.greater": "{{#label}} must be greater than {{:#limit}}",
      "date.less": "{{#label}} must be less than {{:#limit}}",
      "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
      "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
      "date.format.iso": "ISO 8601 date",
      "date.format.javascript": "timestamp or number of milliseconds",
      "date.format.unix": "timestamp or number of seconds"
    }
  });
  internals.parse = function(value, format) {
    if (value instanceof Date) {
      return value;
    }
    if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
      return null;
    }
    if (/^\s*$/.test(value)) {
      return null;
    }
    if (format === "iso") {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      return internals.date(value.toString());
    }
    const original = value;
    if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
      value = parseFloat(value);
    }
    if (format) {
      if (format === "javascript") {
        return internals.date(1 * value);
      }
      if (format === "unix") {
        return internals.date(1000 * value);
      }
      if (typeof original === "string") {
        return null;
      }
    }
    return internals.date(value);
  };
  internals.date = function(value) {
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
      return date;
    }
    return null;
  };
});

// node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Merge = require_merge();
  var Reach = require_reach();
  var internals = {};
  module.exports = function(defaults, source, options = {}) {
    Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
    Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
    Assert(typeof options === "object", "Invalid options: must be an object");
    if (!source) {
      return null;
    }
    if (options.shallow) {
      return internals.applyToDefaultsWithShallow(defaults, source, options);
    }
    const copy = Clone(defaults);
    if (source === true) {
      return copy;
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.applyToDefaultsWithShallow = function(defaults, source, options) {
    const keys = options.shallow;
    Assert(Array.isArray(keys), "Invalid keys");
    const seen = new Map;
    const merge = source === true ? null : new Set;
    for (let key of keys) {
      key = Array.isArray(key) ? key : key.split(".");
      const ref = Reach(defaults, key);
      if (ref && typeof ref === "object") {
        seen.set(ref, merge && Reach(source, key) || ref);
      } else if (merge) {
        merge.add(key);
      }
    }
    const copy = Clone(defaults, {}, seen);
    if (!merge) {
      return copy;
    }
    for (const key of merge) {
      internals.reachCopy(copy, source, key);
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.reachCopy = function(dst, src, path) {
    for (const segment of path) {
      if (!(segment in src)) {
        return;
      }
      const val2 = src[segment];
      if (typeof val2 !== "object" || val2 === null) {
        return;
      }
      src = val2;
    }
    const value = src;
    let ref = dst;
    for (let i = 0;i < path.length - 1; ++i) {
      const segment = path[i];
      if (typeof ref[segment] !== "object") {
        ref[segment] = {};
      }
      ref = ref[segment];
    }
    ref[path[path.length - 1]] = value;
  };
});

// node_modules/@hapi/topo/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var Assert = require_assert();
  var internals = {};
  exports.Sorter = class {
    constructor() {
      this._items = [];
      this.nodes = [];
    }
    add(nodes, options) {
      options = options || {};
      const before = [].concat(options.before || []);
      const after = [].concat(options.after || []);
      const group = options.group || "?";
      const sort = options.sort || 0;
      Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
      Assert(!before.includes("?"), "Item cannot come before unassociated items");
      Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
      Assert(!after.includes("?"), "Item cannot come after unassociated items");
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (const node of nodes) {
        const item = {
          seq: this._items.length,
          sort,
          before,
          after,
          group,
          node
        };
        this._items.push(item);
      }
      if (!options.manual) {
        const valid = this._sort();
        Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
      }
      return this.nodes;
    }
    merge(others) {
      if (!Array.isArray(others)) {
        others = [others];
      }
      for (const other of others) {
        if (other) {
          for (const item of other._items) {
            this._items.push(Object.assign({}, item));
          }
        }
      }
      this._items.sort(internals.mergeSort);
      for (let i = 0;i < this._items.length; ++i) {
        this._items[i].seq = i;
      }
      const valid = this._sort();
      Assert(valid, "merge created a dependencies error");
      return this.nodes;
    }
    sort() {
      const valid = this._sort();
      Assert(valid, "sort created a dependencies error");
      return this.nodes;
    }
    _sort() {
      const graph = {};
      const graphAfters = Object.create(null);
      const groups = Object.create(null);
      for (const item of this._items) {
        const seq = item.seq;
        const group = item.group;
        groups[group] = groups[group] || [];
        groups[group].push(seq);
        graph[seq] = item.before;
        for (const after of item.after) {
          graphAfters[after] = graphAfters[after] || [];
          graphAfters[after].push(seq);
        }
      }
      for (const node in graph) {
        const expandedGroups = [];
        for (const graphNodeItem in graph[node]) {
          const group = graph[node][graphNodeItem];
          groups[group] = groups[group] || [];
          expandedGroups.push(...groups[group]);
        }
        graph[node] = expandedGroups;
      }
      for (const group in graphAfters) {
        if (groups[group]) {
          for (const node of groups[group]) {
            graph[node].push(...graphAfters[group]);
          }
        }
      }
      const ancestors = {};
      for (const node in graph) {
        const children = graph[node];
        for (const child of children) {
          ancestors[child] = ancestors[child] || [];
          ancestors[child].push(node);
        }
      }
      const visited = {};
      const sorted = [];
      for (let i = 0;i < this._items.length; ++i) {
        let next = i;
        if (ancestors[i]) {
          next = null;
          for (let j = 0;j < this._items.length; ++j) {
            if (visited[j] === true) {
              continue;
            }
            if (!ancestors[j]) {
              ancestors[j] = [];
            }
            const shouldSeeCount = ancestors[j].length;
            let seenCount = 0;
            for (let k = 0;k < shouldSeeCount; ++k) {
              if (visited[ancestors[j][k]]) {
                ++seenCount;
              }
            }
            if (seenCount === shouldSeeCount) {
              next = j;
              break;
            }
          }
        }
        if (next !== null) {
          visited[next] = true;
          sorted.push(next);
        }
      }
      if (sorted.length !== this._items.length) {
        return false;
      }
      const seqIndex = {};
      for (const item of this._items) {
        seqIndex[item.seq] = item;
      }
      this._items = [];
      this.nodes = [];
      for (const value of sorted) {
        const sortedItem = seqIndex[value];
        this.nodes.push(sortedItem.node);
        this._items.push(sortedItem);
      }
      return true;
    }
  };
  internals.mergeSort = (a, b) => {
    return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
  };
});

// node_modules/joi/lib/types/keys.js
var require_keys = __commonJS((exports, module) => {
  var ApplyToDefaults = require_applyToDefaults();
  var Assert = require_assert();
  var Clone = require_clone();
  var Topo = require_lib3();
  var Any = require_any();
  var Common = require_common2();
  var Compile = require_compile();
  var Errors = require_errors();
  var Ref = require_ref();
  var Template = require_template();
  var internals = {
    renameDefaults: {
      alias: false,
      multiple: false,
      override: false
    }
  };
  module.exports = Any.extend({
    type: "_keys",
    properties: {
      typeof: "object"
    },
    flags: {
      unknown: { default: false }
    },
    terms: {
      dependencies: { init: null },
      keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
      patterns: { init: null },
      renames: { init: null }
    },
    args(schema, keys) {
      return schema.keys(keys);
    },
    validate(value, { schema, error, state, prefs }) {
      if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
        return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
      }
      if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.externals) {
        return;
      }
      value = internals.clone(value, prefs);
      const errors = [];
      if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
        return { value, errors };
      }
      if (!schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.dependencies) {
        return { value, errors };
      }
      const unprocessed = new Set(Object.keys(value));
      if (schema.$_terms.keys) {
        const ancestors = [value, ...state.ancestors];
        for (const child of schema.$_terms.keys) {
          const key = child.key;
          const item = value[key];
          unprocessed.delete(key);
          const localState = state.localize([...state.path, key], ancestors, child);
          const result = child.schema.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            if (result.value !== undefined) {
              value[key] = result.value;
            }
            errors.push(...result.errors);
          } else if (child.schema._flags.result === "strip" || result.value === undefined && item !== undefined) {
            delete value[key];
          } else if (result.value !== undefined) {
            value[key] = result.value;
          }
        }
      }
      if (unprocessed.size || schema._flags._hasPatternMatch) {
        const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
        if (early) {
          return early;
        }
      }
      if (schema.$_terms.dependencies) {
        for (const dep of schema.$_terms.dependencies) {
          if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false) {
            continue;
          }
          const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
          if (failed) {
            const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors.push(report);
          }
        }
      }
      return { value, errors };
    },
    rules: {
      and: {
        method(...peers) {
          Common.verifyFlat(peers, "and");
          return internals.dependency(this, "and", null, peers);
        }
      },
      append: {
        method(schema) {
          if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
            return this;
          }
          return this.keys(schema);
        }
      },
      assert: {
        method(subject, schema, message) {
          if (!Template.isTemplate(subject)) {
            subject = Compile.ref(subject);
          }
          Assert(message === undefined || typeof message === "string", "Message must be a string");
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
          obj.$_mutateRegister(subject);
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { error, prefs, state }, { subject, schema, message }) {
          const about = subject.resolve(value, state, prefs);
          const path = Ref.isRef(subject) ? subject.absolute(state) : [];
          if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
            return value;
          }
          return error("object.assert", { subject, message });
        },
        args: ["subject", "schema", "message"],
        multi: true
      },
      instance: {
        method(constructor, name) {
          Assert(typeof constructor === "function", "constructor must be a function");
          name = name || constructor.name;
          return this.$_addRule({ name: "instance", args: { constructor, name } });
        },
        validate(value, helpers, { constructor, name }) {
          if (value instanceof constructor) {
            return value;
          }
          return helpers.error("object.instance", { type: name, value });
        },
        args: ["constructor", "name"]
      },
      keys: {
        method(schema) {
          Assert(schema === undefined || typeof schema === "object", "Object schema must be a valid object");
          Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
          const obj = this.clone();
          if (!schema) {
            obj.$_terms.keys = null;
          } else if (!Object.keys(schema).length) {
            obj.$_terms.keys = new internals.Keys;
          } else {
            obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys;
            for (const key in schema) {
              Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
            }
          }
          return obj.$_mutateRebuild();
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(Object.keys(value).length, limit, operator)) {
            return value;
          }
          return helpers.error("object." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      nand: {
        method(...peers) {
          Common.verifyFlat(peers, "nand");
          return internals.dependency(this, "nand", null, peers);
        }
      },
      or: {
        method(...peers) {
          Common.verifyFlat(peers, "or");
          return internals.dependency(this, "or", null, peers);
        }
      },
      oxor: {
        method(...peers) {
          return internals.dependency(this, "oxor", null, peers);
        }
      },
      pattern: {
        method(pattern, schema, options = {}) {
          const isRegExp = pattern instanceof RegExp;
          if (!isRegExp) {
            pattern = this.$_compile(pattern, { appendPath: true });
          }
          Assert(schema !== undefined, "Invalid rule");
          Common.assertOptions(options, ["fallthrough", "matches"]);
          if (isRegExp) {
            Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
          }
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.clone();
          obj.$_terms.patterns = obj.$_terms.patterns || [];
          const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
          if (options.matches) {
            config.matches = this.$_compile(options.matches);
            if (config.matches.type !== "array") {
              config.matches = config.matches.$_root.array().items(config.matches);
            }
            obj.$_mutateRegister(config.matches);
            obj.$_setFlag("_hasPatternMatch", true, { clone: false });
          }
          if (options.fallthrough) {
            config.fallthrough = true;
          }
          obj.$_terms.patterns.push(config);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      ref: {
        method() {
          return this.$_addRule("ref");
        },
        validate(value, helpers) {
          if (Ref.isRef(value)) {
            return value;
          }
          return helpers.error("object.refType", { value });
        }
      },
      regex: {
        method() {
          return this.$_addRule("regex");
        },
        validate(value, helpers) {
          if (value instanceof RegExp) {
            return value;
          }
          return helpers.error("object.regex", { value });
        }
      },
      rename: {
        method(from, to, options = {}) {
          Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
          Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
          Assert(to !== from, "Cannot rename key to same name:", from);
          Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
          const obj = this.clone();
          obj.$_terms.renames = obj.$_terms.renames || [];
          for (const rename of obj.$_terms.renames) {
            Assert(rename.from !== from, "Cannot rename the same key multiple times");
          }
          if (to instanceof Template) {
            obj.$_mutateRegister(to);
          }
          obj.$_terms.renames.push({
            from,
            to,
            options: ApplyToDefaults(internals.renameDefaults, options)
          });
          return obj;
        }
      },
      schema: {
        method(type = "any") {
          return this.$_addRule({ name: "schema", args: { type } });
        },
        validate(value, helpers, { type }) {
          if (Common.isSchema(value) && (type === "any" || value.type === type)) {
            return value;
          }
          return helpers.error("object.schema", { type });
        }
      },
      unknown: {
        method(allow) {
          return this.$_setFlag("unknown", allow !== false);
        }
      },
      with: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "with", key, peers, options);
        }
      },
      without: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "without", key, peers, options);
        }
      },
      xor: {
        method(...peers) {
          Common.verifyFlat(peers, "xor");
          return internals.dependency(this, "xor", null, peers);
        }
      }
    },
    overrides: {
      default(value, options) {
        if (value === undefined) {
          value = Common.symbols.deepDefault;
        }
        return this.$_parent("default", value, options);
      }
    },
    rebuild(schema) {
      if (schema.$_terms.keys) {
        const topo = new Topo.Sorter;
        for (const child of schema.$_terms.keys) {
          Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
        }
        schema.$_terms.keys = new internals.Keys(...topo.nodes);
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.keys) {
          obj = obj.keys(desc.keys);
        }
        if (desc.dependencies) {
          for (const { rel, key = null, peers, options } of desc.dependencies) {
            obj = internals.dependency(obj, rel, key, peers, options);
          }
        }
        if (desc.patterns) {
          for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
            obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
          }
        }
        if (desc.renames) {
          for (const { from, to, options } of desc.renames) {
            obj = obj.rename(from, to, options);
          }
        }
        return obj;
      }
    },
    messages: {
      "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
      "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
      "object.base": "{{#label}} must be of type {{#type}}",
      "object.instance": "{{#label}} must be an instance of {{:#type}}",
      "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
      "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
      "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
      "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
      "object.refType": "{{#label}} must be a Joi reference",
      "object.regex": "{{#label}} must be a RegExp object",
      "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
      "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
      "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
      "object.unknown": "{{#label}} is not allowed",
      "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
      "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
      "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
    }
  });
  internals.clone = function(value, prefs) {
    if (typeof value === "object") {
      if (prefs.nonEnumerables) {
        return Clone(value, { shallow: true });
      }
      const clone2 = Object.create(Object.getPrototypeOf(value));
      Object.assign(clone2, value);
      return clone2;
    }
    const clone = function(...args) {
      return value.apply(this, args);
    };
    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, "name", { value: value.name, writable: false });
    Object.defineProperty(clone, "length", { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
  };
  internals.dependency = function(schema, rel, key, peers, options) {
    Assert(key === null || typeof key === "string", rel, "key must be a strings");
    if (!options) {
      options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
    }
    Common.assertOptions(options, ["separator", "isPresent"]);
    peers = [].concat(peers);
    const separator = Common.default(options.separator, ".");
    const paths = [];
    for (const peer of peers) {
      Assert(typeof peer === "string", rel, "peers must be strings");
      paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
    }
    if (key !== null) {
      key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
    }
    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
    return obj;
  };
  internals.dependencies = {
    and(schema, dep, value, state, prefs) {
      const missing = [];
      const present = [];
      const count = dep.peers.length;
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
          missing.push(peer.key);
        } else {
          present.push(peer.key);
        }
      }
      if (missing.length !== count && present.length !== count) {
        return {
          code: "object.and",
          context: {
            present,
            presentWithLabels: internals.keysToLabels(schema, present),
            missing,
            missingWithLabels: internals.keysToLabels(schema, missing)
          }
        };
      }
    },
    nand(schema, dep, value, state, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (present.length !== dep.peers.length) {
        return;
      }
      const main = dep.paths[0];
      const values = dep.paths.slice(1);
      return {
        code: "object.nand",
        context: {
          main,
          mainWithLabel: internals.keysToLabels(schema, main),
          peers: values,
          peersWithLabels: internals.keysToLabels(schema, values)
        }
      };
    },
    or(schema, dep, value, state, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          return;
        }
      }
      return {
        code: "object.missing",
        context: {
          peers: dep.paths,
          peersWithLabels: internals.keysToLabels(schema, dep.paths)
        }
      };
    },
    oxor(schema, dep, value, state, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (!present.length || present.length === 1) {
        return;
      }
      const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
      context.present = present;
      context.presentWithLabels = internals.keysToLabels(schema, present);
      return { code: "object.oxor", context };
    },
    with(schema, dep, value, state, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
          return {
            code: "object.with",
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    },
    without(schema, dep, value, state, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          return {
            code: "object.without",
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    },
    xor(schema, dep, value, state, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (present.length === 1) {
        return;
      }
      const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
      if (present.length === 0) {
        return { code: "object.missing", context };
      }
      context.present = present;
      context.presentWithLabels = internals.keysToLabels(schema, present);
      return { code: "object.xor", context };
    }
  };
  internals.keysToLabels = function(schema, keys) {
    if (Array.isArray(keys)) {
      return keys.map((key) => schema.$_mapLabels(key));
    }
    return schema.$_mapLabels(keys);
  };
  internals.isPresent = function(options) {
    return typeof options.isPresent === "function" ? options.isPresent : (resolved) => resolved !== undefined;
  };
  internals.rename = function(schema, value, state, prefs, errors) {
    const renamed = {};
    for (const rename of schema.$_terms.renames) {
      const matches = [];
      const pattern = typeof rename.from !== "string";
      if (!pattern) {
        if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {
          matches.push(rename);
        }
      } else {
        for (const from in value) {
          if (value[from] === undefined && rename.options.ignoreUndefined) {
            continue;
          }
          if (from === rename.to) {
            continue;
          }
          const match = rename.from.exec(from);
          if (!match) {
            continue;
          }
          matches.push({ from, to: rename.to, match });
        }
      }
      for (const match of matches) {
        const from = match.from;
        let to = match.to;
        if (to instanceof Template) {
          to = to.render(value, state, prefs, match.match);
        }
        if (from === to) {
          continue;
        }
        if (!rename.options.multiple && renamed[to]) {
          errors.push(schema.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
          errors.push(schema.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (value[from] === undefined) {
          delete value[to];
        } else {
          value[to] = value[from];
        }
        renamed[to] = true;
        if (!rename.options.alias) {
          delete value[from];
        }
      }
    }
    return true;
  };
  internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
    if (schema.$_terms.patterns) {
      let hasMatches = false;
      const matches = schema.$_terms.patterns.map((pattern) => {
        if (pattern.matches) {
          hasMatches = true;
          return [];
        }
      });
      const ancestors = [value, ...state.ancestors];
      for (const key of unprocessed) {
        const item = value[key];
        const path = [...state.path, key];
        for (let i = 0;i < schema.$_terms.patterns.length; ++i) {
          const pattern = schema.$_terms.patterns[i];
          if (pattern.regex) {
            const match = pattern.regex.test(key);
            state.mainstay.tracer.debug(state, "rule", `pattern.${i}`, match ? "pass" : "error");
            if (!match) {
              continue;
            }
          } else {
            if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
              continue;
            }
          }
          unprocessed.delete(key);
          const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
          const result = pattern.rule.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            errors.push(...result.errors);
          }
          if (pattern.matches) {
            matches[i].push(key);
          }
          value[key] = result.value;
          if (!pattern.fallthrough) {
            break;
          }
        }
      }
      if (hasMatches) {
        for (let i = 0;i < matches.length; ++i) {
          const match = matches[i];
          if (!match) {
            continue;
          }
          const stpm = schema.$_terms.patterns[i].matches;
          const localState = state.localize(state.path, ancestors, stpm);
          const result = stpm.$_validate(match, localState, prefs);
          if (result.errors) {
            const details = Errors.details(result.errors, { override: false });
            details.matches = match;
            const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors.push(report);
          }
        }
      }
    }
    if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
      return;
    }
    if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
      const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
      for (const key of unprocessed) {
        if (stripUnknown) {
          delete value[key];
          unprocessed.delete(key);
        } else if (typeof value[key] === "function") {
          unprocessed.delete(key);
        }
      }
    }
    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
      for (const unprocessedKey of unprocessed) {
        const localState = state.localize([...state.path, unprocessedKey], []);
        const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
        if (prefs.abortEarly) {
          return { value, errors: report };
        }
        errors.push(report);
      }
    }
  };
  internals.Dependency = class {
    constructor(rel, key, peers, paths, options) {
      this.rel = rel;
      this.key = key;
      this.peers = peers;
      this.paths = paths;
      this.options = options;
    }
    describe() {
      const desc = {
        rel: this.rel,
        peers: this.paths
      };
      if (this.key !== null) {
        desc.key = this.key.key;
      }
      if (this.peers[0].separator !== ".") {
        desc.options = { ...desc.options, separator: this.peers[0].separator };
      }
      if (this.options.isPresent) {
        desc.options = { ...desc.options, isPresent: this.options.isPresent };
      }
      return desc;
    }
  };
  internals.Keys = class extends Array {
    concat(source) {
      const result = this.slice();
      const keys = new Map;
      for (let i = 0;i < result.length; ++i) {
        keys.set(result[i].key, i);
      }
      for (const item of source) {
        const key = item.key;
        const pos = keys.get(key);
        if (pos !== undefined) {
          result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
        } else {
          result.push(item);
        }
      }
      return result;
    }
  };
});

// node_modules/joi/lib/types/function.js
var require_function = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Keys = require_keys();
  module.exports = Keys.extend({
    type: "function",
    properties: {
      typeof: "function"
    },
    rules: {
      arity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "arity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length === n) {
            return value;
          }
          return helpers.error("function.arity", { n });
        }
      },
      class: {
        method() {
          return this.$_addRule("class");
        },
        validate(value, helpers) {
          if (/^\s*class\s/.test(value.toString())) {
            return value;
          }
          return helpers.error("function.class", { value });
        }
      },
      minArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
          return this.$_addRule({ name: "minArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length >= n) {
            return value;
          }
          return helpers.error("function.minArity", { n });
        }
      },
      maxArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "maxArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length <= n) {
            return value;
          }
          return helpers.error("function.maxArity", { n });
        }
      }
    },
    messages: {
      "function.arity": "{{#label}} must have an arity of {{#n}}",
      "function.class": "{{#label}} must be a class",
      "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
      "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
    }
  });
});

// node_modules/joi/lib/types/link.js
var require_link = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common2();
  var Compile = require_compile();
  var Errors = require_errors();
  var internals = {};
  module.exports = Any.extend({
    type: "link",
    properties: {
      schemaChain: true
    },
    terms: {
      link: { init: null, manifest: "single", register: false }
    },
    args(schema, ref) {
      return schema.ref(ref);
    },
    validate(value, { schema, state, prefs }) {
      Assert(schema.$_terms.link, "Uninitialized link schema");
      const linked = internals.generate(schema, value, state, prefs);
      const ref = schema.$_terms.link[0].ref;
      return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },
    generate(schema, value, state, prefs) {
      return internals.generate(schema, value, state, prefs);
    },
    rules: {
      ref: {
        method(ref) {
          Assert(!this.$_terms.link, "Cannot reinitialize schema");
          ref = Compile.ref(ref);
          Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
          Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
          const obj = this.clone();
          obj.$_terms.link = [{ ref }];
          return obj;
        }
      },
      relative: {
        method(enabled = true) {
          return this.$_setFlag("relative", enabled);
        }
      }
    },
    overrides: {
      concat(source) {
        Assert(this.$_terms.link, "Uninitialized link schema");
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(source.type !== "link", "Cannot merge type link with another link");
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        obj.$_terms.whens.push({ concat: source });
        return obj.$_mutateRebuild();
      }
    },
    manifest: {
      build(obj, desc) {
        Assert(desc.link, "Invalid link description missing link");
        return obj.ref(desc.link);
      }
    }
  });
  internals.generate = function(schema, value, state, prefs) {
    let linked = state.mainstay.links.get(schema);
    if (linked) {
      return linked._generate(value, state, prefs).schema;
    }
    const ref = schema.$_terms.link[0].ref;
    const { perspective, path } = internals.perspective(ref, state);
    internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
    try {
      linked = path.length ? perspective.$_reach(path) : perspective;
    } catch (ignoreErr) {
      internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
    }
    internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
    if (!schema._flags.relative) {
      state.mainstay.links.set(schema, linked);
    }
    return linked._generate(value, state, prefs).schema;
  };
  internals.perspective = function(ref, state) {
    if (ref.type === "local") {
      for (const { schema, key } of state.schemas) {
        const id = schema._flags.id || key;
        if (id === ref.path[0]) {
          return { perspective: schema, path: ref.path.slice(1) };
        }
        if (schema.$_terms.shared) {
          for (const shared of schema.$_terms.shared) {
            if (shared._flags.id === ref.path[0]) {
              return { perspective: shared, path: ref.path.slice(1) };
            }
          }
        }
      }
      return { perspective: null, path: null };
    }
    if (ref.ancestor === "root") {
      return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }
    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
  };
  internals.assert = function(condition, message, ref, schema, state, prefs) {
    if (condition) {
      return;
    }
    Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
  };
});

// node_modules/joi/lib/types/number.js
var require_number = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common2();
  var internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    exponentialPartRegex: /[eE][+-]?\d+$/,
    leadingSignAndZerosRegex: /^[+-]?(0*)?/,
    dotRegex: /\./,
    trailingZerosRegex: /0+$/
  };
  module.exports = Any.extend({
    type: "number",
    flags: {
      unsafe: { default: false }
    },
    coerce: {
      from: "string",
      method(value, { schema, error }) {
        const matches = value.match(internals.numberRx);
        if (!matches) {
          return;
        }
        value = value.trim();
        const result = { value: parseFloat(value) };
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe) {
          if (value.match(/e/i)) {
            if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
              result.errors = error("number.unsafe");
              return result;
            }
          } else {
            const string = result.value.toString();
            if (string.match(/e/i)) {
              return result;
            }
            if (string !== internals.normalizeDecimal(value)) {
              result.errors = error("number.unsafe");
              return result;
            }
          }
        }
        return result;
      }
    },
    validate(value, { schema, error, prefs }) {
      if (value === Infinity || value === (-Infinity)) {
        return { value, errors: error("number.infinity") };
      }
      if (!Common.isNumber(value)) {
        return { value, errors: error("number.base") };
      }
      const result = { value };
      if (prefs.convert) {
        const rule = schema.$_getRule("precision");
        if (rule) {
          const precision = Math.pow(10, rule.args.limit);
          result.value = Math.round(result.value * precision) / precision;
        }
      }
      if (result.value === 0) {
        result.value = 0;
      }
      if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
        result.errors = error("number.unsafe");
      }
      return result;
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value, limit, operator)) {
            return value;
          }
          return helpers.error("number." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.isNumber,
            message: "must be a number"
          }
        ]
      },
      greater: {
        method(limit) {
          return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
        }
      },
      integer: {
        method() {
          return this.$_addRule("integer");
        },
        validate(value, helpers) {
          if (Math.trunc(value) - value === 0) {
            return value;
          }
          return helpers.error("number.integer");
        }
      },
      less: {
        method(limit) {
          return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
        }
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
        }
      },
      multiple: {
        method(base) {
          return this.$_addRule({ name: "multiple", args: { base } });
        },
        validate(value, helpers, { base }, options) {
          if (value * (1 / base) % 1 === 0) {
            return value;
          }
          return helpers.error("number.multiple", { multiple: options.args.base, value });
        },
        args: [
          {
            name: "base",
            ref: true,
            assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
            message: "must be a positive number"
          }
        ],
        multi: true
      },
      negative: {
        method() {
          return this.sign("negative");
        }
      },
      port: {
        method() {
          return this.$_addRule("port");
        },
        validate(value, helpers) {
          if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
            return value;
          }
          return helpers.error("number.port");
        }
      },
      positive: {
        method() {
          return this.sign("positive");
        }
      },
      precision: {
        method(limit) {
          Assert(Number.isSafeInteger(limit), "limit must be an integer");
          return this.$_addRule({ name: "precision", args: { limit } });
        },
        validate(value, helpers, { limit }) {
          const places = value.toString().match(internals.precisionRx);
          const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
          if (decimals <= limit) {
            return value;
          }
          return helpers.error("number.precision", { limit, value });
        },
        convert: true
      },
      sign: {
        method(sign) {
          Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
          return this.$_addRule({ name: "sign", args: { sign } });
        },
        validate(value, helpers, { sign }) {
          if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
            return value;
          }
          return helpers.error(`number.${sign}`);
        }
      },
      unsafe: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("unsafe", enabled);
        }
      }
    },
    cast: {
      string: {
        from: (value) => typeof value === "number",
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "number.base": "{{#label}} must be a number",
      "number.greater": "{{#label}} must be greater than {{#limit}}",
      "number.infinity": "{{#label}} cannot be infinity",
      "number.integer": "{{#label}} must be an integer",
      "number.less": "{{#label}} must be less than {{#limit}}",
      "number.max": "{{#label}} must be less than or equal to {{#limit}}",
      "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
      "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
      "number.negative": "{{#label}} must be a negative number",
      "number.port": "{{#label}} must be a valid port",
      "number.positive": "{{#label}} must be a positive number",
      "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
      "number.unsafe": "{{#label}} must be a safe number"
    }
  });
  internals.extractSignificantDigits = function(value) {
    return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
  };
  internals.normalizeDecimal = function(str) {
    str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
    if (str.includes(".") && str.endsWith("0")) {
      str = str.replace(/0+$/, "");
    }
    if (str === "-0") {
      return "0";
    }
    return str;
  };
});

// node_modules/joi/lib/types/object.js
var require_object = __commonJS((exports, module) => {
  var Keys = require_keys();
  module.exports = Keys.extend({
    type: "object",
    cast: {
      map: {
        from: (value) => value && typeof value === "object",
        to(value, helpers) {
          return new Map(Object.entries(value));
        }
      }
    }
  });
});

// node_modules/@sideway/address/lib/errors.js
var require_errors2 = __commonJS((exports) => {
  exports.codes = {
    EMPTY_STRING: "Address must be a non-empty string",
    FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
    MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
    MISSING_AT_CHAR: "Address must contain one @ character",
    EMPTY_LOCAL: "Address local part cannot be empty",
    ADDRESS_TOO_LONG: "Address too long",
    LOCAL_TOO_LONG: "Address local part too long",
    EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
    INVALID_LOCAL_CHARS: "Address local part contains invalid character",
    DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
    DOMAIN_TOO_LONG: "Domain too long",
    DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
    DOMAIN_INVALID_CHARS: "Domain contains invalid character",
    DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
    DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
    DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
    DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
    DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
    DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
  };
  exports.code = function(code) {
    return { code, error: exports.codes[code] };
  };
});

// node_modules/@sideway/address/lib/domain.js
var require_domain = __commonJS((exports) => {
  var Url = __require("url");
  var Errors = require_errors2();
  var internals = {
    minDomainSegments: 2,
    nonAsciiRx: /[^\x00-\x7f]/,
    domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    URL: Url.URL || URL
  };
  exports.analyze = function(domain, options = {}) {
    if (!domain) {
      return Errors.code("DOMAIN_NON_EMPTY_STRING");
    }
    if (typeof domain !== "string") {
      throw new Error("Invalid input: domain must be a string");
    }
    if (domain.length > 256) {
      return Errors.code("DOMAIN_TOO_LONG");
    }
    const ascii = !internals.nonAsciiRx.test(domain);
    if (!ascii) {
      if (options.allowUnicode === false) {
        return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
      }
      domain = domain.normalize("NFC");
    }
    if (internals.domainControlRx.test(domain)) {
      return Errors.code("DOMAIN_INVALID_CHARS");
    }
    domain = internals.punycode(domain);
    if (options.allowFullyQualified && domain[domain.length - 1] === ".") {
      domain = domain.slice(0, -1);
    }
    const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
    const segments = domain.split(".");
    if (segments.length < minDomainSegments) {
      return Errors.code("DOMAIN_SEGMENTS_COUNT");
    }
    if (options.maxDomainSegments) {
      if (segments.length > options.maxDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
      }
    }
    const tlds = options.tlds;
    if (tlds) {
      const tld = segments[segments.length - 1].toLowerCase();
      if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {
        return Errors.code("DOMAIN_FORBIDDEN_TLDS");
      }
    }
    for (let i = 0;i < segments.length; ++i) {
      const segment = segments[i];
      if (!segment.length) {
        return Errors.code("DOMAIN_EMPTY_SEGMENT");
      }
      if (segment.length > 63) {
        return Errors.code("DOMAIN_LONG_SEGMENT");
      }
      if (i < segments.length - 1) {
        if (!internals.domainSegmentRx.test(segment)) {
          return Errors.code("DOMAIN_INVALID_CHARS");
        }
      } else {
        if (!internals.tldSegmentRx.test(segment)) {
          return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
        }
      }
    }
    return null;
  };
  exports.isValid = function(domain, options) {
    return !exports.analyze(domain, options);
  };
  internals.punycode = function(domain) {
    if (domain.includes("%")) {
      domain = domain.replace(/%/g, "%25");
    }
    try {
      return new internals.URL(`http://${domain}`).host;
    } catch (err) {
      return domain;
    }
  };
});

// node_modules/@sideway/address/lib/email.js
var require_email = __commonJS((exports) => {
  var Util = __require("util");
  var Domain = require_domain();
  var Errors = require_errors2();
  var internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    encoder: new (Util.TextEncoder || TextEncoder)
  };
  exports.analyze = function(email, options) {
    return internals.email(email, options);
  };
  exports.isValid = function(email, options) {
    return !internals.email(email, options);
  };
  internals.email = function(email, options = {}) {
    if (typeof email !== "string") {
      throw new Error("Invalid input: email must be a string");
    }
    if (!email) {
      return Errors.code("EMPTY_STRING");
    }
    const ascii = !internals.nonAsciiRx.test(email);
    if (!ascii) {
      if (options.allowUnicode === false) {
        return Errors.code("FORBIDDEN_UNICODE");
      }
      email = email.normalize("NFC");
    }
    const parts = email.split("@");
    if (parts.length !== 2) {
      return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
    }
    const [local, domain] = parts;
    if (!local) {
      return Errors.code("EMPTY_LOCAL");
    }
    if (!options.ignoreLength) {
      if (email.length > 254) {
        return Errors.code("ADDRESS_TOO_LONG");
      }
      if (internals.encoder.encode(local).length > 64) {
        return Errors.code("LOCAL_TOO_LONG");
      }
    }
    return internals.local(local, ascii) || Domain.analyze(domain, options);
  };
  internals.local = function(local, ascii) {
    const segments = local.split(".");
    for (const segment of segments) {
      if (!segment.length) {
        return Errors.code("EMPTY_LOCAL_SEGMENT");
      }
      if (ascii) {
        if (!internals.atextRx.test(segment)) {
          return Errors.code("INVALID_LOCAL_CHARS");
        }
        continue;
      }
      for (const char of segment) {
        if (internals.atextRx.test(char)) {
          continue;
        }
        const binary = internals.binary(char);
        if (!internals.atomRx.test(binary)) {
          return Errors.code("INVALID_LOCAL_CHARS");
        }
      }
    }
  };
  internals.binary = function(char) {
    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
  };
  internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
  internals.atomRx = new RegExp([
    "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
    "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
    "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
  ].join("|"));
});

// node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS((exports, module) => {
  module.exports = function(string) {
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  };
});

// node_modules/@sideway/address/lib/uri.js
var require_uri = __commonJS((exports) => {
  var Assert = require_assert();
  var EscapeRegex = require_escapeRegex();
  var internals = {};
  internals.generate = function() {
    const rfc3986 = {};
    const hexDigit = "\\dA-Fa-f";
    const hexDigitOnly = "[" + hexDigit + "]";
    const unreserved = "\\w-\\.~";
    const subDelims = "!\\$&\'\\(\\)\\*\\+,;=";
    const pctEncoded = "%" + hexDigit;
    const pchar = unreserved + pctEncoded + subDelims + ":@";
    const pcharOnly = "[" + pchar + "]";
    const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
    rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
    const h16 = hexDigitOnly + "{1,4}";
    const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
    const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
    const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
    const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
    const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
    const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
    const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
    const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
    const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
    const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
    rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
    rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
    rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
    rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
    rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
    const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
    const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
    const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
    const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
    const port = "\\d*";
    const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
    const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
    const segment = pcharOnly + "*";
    const segmentNz = pcharOnly + "+";
    const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
    const pathEmpty = "";
    const pathAbEmpty = "(?:\\/" + segment + ")*";
    const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
    rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
    rfc3986.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
    rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
    rfc3986.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
    rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
    rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
    rfc3986.fragment = "[" + pchar + "\\/\\?]*";
    return rfc3986;
  };
  internals.rfc3986 = internals.generate();
  exports.ip = {
    v4Cidr: internals.rfc3986.ipv4Cidr,
    v6Cidr: internals.rfc3986.ipv6Cidr,
    ipv4: internals.rfc3986.ipv4address,
    ipv6: internals.rfc3986.ipv6address,
    ipvfuture: internals.rfc3986.ipvFuture
  };
  internals.createRegex = function(options) {
    const rfc = internals.rfc3986;
    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
    const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
    if (options.relativeOnly) {
      return internals.wrap(relative + suffix);
    }
    let customScheme = "";
    if (options.scheme) {
      Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
      const schemes = [].concat(options.scheme);
      Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
      const selections = [];
      for (let i = 0;i < schemes.length; ++i) {
        const scheme2 = schemes[i];
        Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
        if (scheme2 instanceof RegExp) {
          selections.push(scheme2.source.toString());
        } else {
          Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
          selections.push(EscapeRegex(scheme2));
        }
      }
      customScheme = selections.join("|");
    }
    const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
    const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
    const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
    return internals.wrap(prefix + suffix, customScheme);
  };
  internals.wrap = function(raw, scheme) {
    raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
    return {
      raw,
      regex: new RegExp(`^${raw}\$`),
      scheme
    };
  };
  internals.uriRegex = internals.createRegex({});
  exports.regex = function(options = {}) {
    if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
      return internals.createRegex(options);
    }
    return internals.uriRegex;
  };
});

// node_modules/@sideway/address/lib/ip.js
var require_ip = __commonJS((exports) => {
  var Assert = require_assert();
  var Uri = require_uri();
  exports.regex = function(options = {}) {
    Assert(options.cidr === undefined || typeof options.cidr === "string", "options.cidr must be a string");
    const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
    Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
    Assert(options.version === undefined || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
    let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
    if (!Array.isArray(versions)) {
      versions = [versions];
    }
    Assert(versions.length >= 1, "options.version must have at least 1 version specified");
    for (let i = 0;i < versions.length; ++i) {
      Assert(typeof versions[i] === "string", "options.version must only contain strings");
      versions[i] = versions[i].toLowerCase();
      Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
    }
    versions = Array.from(new Set(versions));
    const parts = versions.map((version) => {
      if (cidr === "forbidden") {
        return Uri.ip[version];
      }
      const cidrpart = `\\/${version === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
      if (cidr === "required") {
        return `${Uri.ip[version]}${cidrpart}`;
      }
      return `${Uri.ip[version]}(?:${cidrpart})?`;
    });
    const raw = `(?:${parts.join("|")})`;
    const regex = new RegExp(`^${raw}\$`);
    return { cidr, versions, regex, raw };
  };
});

// node_modules/@sideway/address/lib/tlds.js
var require_tlds = __commonJS((exports, module) => {
  var internals = {};
  internals.tlds = [
    "AAA",
    "AARP",
    "ABARTH",
    "ABB",
    "ABBOTT",
    "ABBVIE",
    "ABC",
    "ABLE",
    "ABOGADO",
    "ABUDHABI",
    "AC",
    "ACADEMY",
    "ACCENTURE",
    "ACCOUNTANT",
    "ACCOUNTANTS",
    "ACO",
    "ACTOR",
    "AD",
    "ADAC",
    "ADS",
    "ADULT",
    "AE",
    "AEG",
    "AERO",
    "AETNA",
    "AF",
    "AFL",
    "AFRICA",
    "AG",
    "AGAKHAN",
    "AGENCY",
    "AI",
    "AIG",
    "AIRBUS",
    "AIRFORCE",
    "AIRTEL",
    "AKDN",
    "AL",
    "ALFAROMEO",
    "ALIBABA",
    "ALIPAY",
    "ALLFINANZ",
    "ALLSTATE",
    "ALLY",
    "ALSACE",
    "ALSTOM",
    "AM",
    "AMAZON",
    "AMERICANEXPRESS",
    "AMERICANFAMILY",
    "AMEX",
    "AMFAM",
    "AMICA",
    "AMSTERDAM",
    "ANALYTICS",
    "ANDROID",
    "ANQUAN",
    "ANZ",
    "AO",
    "AOL",
    "APARTMENTS",
    "APP",
    "APPLE",
    "AQ",
    "AQUARELLE",
    "AR",
    "ARAB",
    "ARAMCO",
    "ARCHI",
    "ARMY",
    "ARPA",
    "ART",
    "ARTE",
    "AS",
    "ASDA",
    "ASIA",
    "ASSOCIATES",
    "AT",
    "ATHLETA",
    "ATTORNEY",
    "AU",
    "AUCTION",
    "AUDI",
    "AUDIBLE",
    "AUDIO",
    "AUSPOST",
    "AUTHOR",
    "AUTO",
    "AUTOS",
    "AVIANCA",
    "AW",
    "AWS",
    "AX",
    "AXA",
    "AZ",
    "AZURE",
    "BA",
    "BABY",
    "BAIDU",
    "BANAMEX",
    "BANANAREPUBLIC",
    "BAND",
    "BANK",
    "BAR",
    "BARCELONA",
    "BARCLAYCARD",
    "BARCLAYS",
    "BAREFOOT",
    "BARGAINS",
    "BASEBALL",
    "BASKETBALL",
    "BAUHAUS",
    "BAYERN",
    "BB",
    "BBC",
    "BBT",
    "BBVA",
    "BCG",
    "BCN",
    "BD",
    "BE",
    "BEATS",
    "BEAUTY",
    "BEER",
    "BENTLEY",
    "BERLIN",
    "BEST",
    "BESTBUY",
    "BET",
    "BF",
    "BG",
    "BH",
    "BHARTI",
    "BI",
    "BIBLE",
    "BID",
    "BIKE",
    "BING",
    "BINGO",
    "BIO",
    "BIZ",
    "BJ",
    "BLACK",
    "BLACKFRIDAY",
    "BLOCKBUSTER",
    "BLOG",
    "BLOOMBERG",
    "BLUE",
    "BM",
    "BMS",
    "BMW",
    "BN",
    "BNPPARIBAS",
    "BO",
    "BOATS",
    "BOEHRINGER",
    "BOFA",
    "BOM",
    "BOND",
    "BOO",
    "BOOK",
    "BOOKING",
    "BOSCH",
    "BOSTIK",
    "BOSTON",
    "BOT",
    "BOUTIQUE",
    "BOX",
    "BR",
    "BRADESCO",
    "BRIDGESTONE",
    "BROADWAY",
    "BROKER",
    "BROTHER",
    "BRUSSELS",
    "BS",
    "BT",
    "BUGATTI",
    "BUILD",
    "BUILDERS",
    "BUSINESS",
    "BUY",
    "BUZZ",
    "BV",
    "BW",
    "BY",
    "BZ",
    "BZH",
    "CA",
    "CAB",
    "CAFE",
    "CAL",
    "CALL",
    "CALVINKLEIN",
    "CAM",
    "CAMERA",
    "CAMP",
    "CANCERRESEARCH",
    "CANON",
    "CAPETOWN",
    "CAPITAL",
    "CAPITALONE",
    "CAR",
    "CARAVAN",
    "CARDS",
    "CARE",
    "CAREER",
    "CAREERS",
    "CARS",
    "CASA",
    "CASE",
    "CASH",
    "CASINO",
    "CAT",
    "CATERING",
    "CATHOLIC",
    "CBA",
    "CBN",
    "CBRE",
    "CBS",
    "CC",
    "CD",
    "CENTER",
    "CEO",
    "CERN",
    "CF",
    "CFA",
    "CFD",
    "CG",
    "CH",
    "CHANEL",
    "CHANNEL",
    "CHARITY",
    "CHASE",
    "CHAT",
    "CHEAP",
    "CHINTAI",
    "CHRISTMAS",
    "CHROME",
    "CHURCH",
    "CI",
    "CIPRIANI",
    "CIRCLE",
    "CISCO",
    "CITADEL",
    "CITI",
    "CITIC",
    "CITY",
    "CITYEATS",
    "CK",
    "CL",
    "CLAIMS",
    "CLEANING",
    "CLICK",
    "CLINIC",
    "CLINIQUE",
    "CLOTHING",
    "CLOUD",
    "CLUB",
    "CLUBMED",
    "CM",
    "CN",
    "CO",
    "COACH",
    "CODES",
    "COFFEE",
    "COLLEGE",
    "COLOGNE",
    "COM",
    "COMCAST",
    "COMMBANK",
    "COMMUNITY",
    "COMPANY",
    "COMPARE",
    "COMPUTER",
    "COMSEC",
    "CONDOS",
    "CONSTRUCTION",
    "CONSULTING",
    "CONTACT",
    "CONTRACTORS",
    "COOKING",
    "COOKINGCHANNEL",
    "COOL",
    "COOP",
    "CORSICA",
    "COUNTRY",
    "COUPON",
    "COUPONS",
    "COURSES",
    "CPA",
    "CR",
    "CREDIT",
    "CREDITCARD",
    "CREDITUNION",
    "CRICKET",
    "CROWN",
    "CRS",
    "CRUISE",
    "CRUISES",
    "CU",
    "CUISINELLA",
    "CV",
    "CW",
    "CX",
    "CY",
    "CYMRU",
    "CYOU",
    "CZ",
    "DABUR",
    "DAD",
    "DANCE",
    "DATA",
    "DATE",
    "DATING",
    "DATSUN",
    "DAY",
    "DCLK",
    "DDS",
    "DE",
    "DEAL",
    "DEALER",
    "DEALS",
    "DEGREE",
    "DELIVERY",
    "DELL",
    "DELOITTE",
    "DELTA",
    "DEMOCRAT",
    "DENTAL",
    "DENTIST",
    "DESI",
    "DESIGN",
    "DEV",
    "DHL",
    "DIAMONDS",
    "DIET",
    "DIGITAL",
    "DIRECT",
    "DIRECTORY",
    "DISCOUNT",
    "DISCOVER",
    "DISH",
    "DIY",
    "DJ",
    "DK",
    "DM",
    "DNP",
    "DO",
    "DOCS",
    "DOCTOR",
    "DOG",
    "DOMAINS",
    "DOT",
    "DOWNLOAD",
    "DRIVE",
    "DTV",
    "DUBAI",
    "DUNLOP",
    "DUPONT",
    "DURBAN",
    "DVAG",
    "DVR",
    "DZ",
    "EARTH",
    "EAT",
    "EC",
    "ECO",
    "EDEKA",
    "EDU",
    "EDUCATION",
    "EE",
    "EG",
    "EMAIL",
    "EMERCK",
    "ENERGY",
    "ENGINEER",
    "ENGINEERING",
    "ENTERPRISES",
    "EPSON",
    "EQUIPMENT",
    "ER",
    "ERICSSON",
    "ERNI",
    "ES",
    "ESQ",
    "ESTATE",
    "ET",
    "ETISALAT",
    "EU",
    "EUROVISION",
    "EUS",
    "EVENTS",
    "EXCHANGE",
    "EXPERT",
    "EXPOSED",
    "EXPRESS",
    "EXTRASPACE",
    "FAGE",
    "FAIL",
    "FAIRWINDS",
    "FAITH",
    "FAMILY",
    "FAN",
    "FANS",
    "FARM",
    "FARMERS",
    "FASHION",
    "FAST",
    "FEDEX",
    "FEEDBACK",
    "FERRARI",
    "FERRERO",
    "FI",
    "FIAT",
    "FIDELITY",
    "FIDO",
    "FILM",
    "FINAL",
    "FINANCE",
    "FINANCIAL",
    "FIRE",
    "FIRESTONE",
    "FIRMDALE",
    "FISH",
    "FISHING",
    "FIT",
    "FITNESS",
    "FJ",
    "FK",
    "FLICKR",
    "FLIGHTS",
    "FLIR",
    "FLORIST",
    "FLOWERS",
    "FLY",
    "FM",
    "FO",
    "FOO",
    "FOOD",
    "FOODNETWORK",
    "FOOTBALL",
    "FORD",
    "FOREX",
    "FORSALE",
    "FORUM",
    "FOUNDATION",
    "FOX",
    "FR",
    "FREE",
    "FRESENIUS",
    "FRL",
    "FROGANS",
    "FRONTDOOR",
    "FRONTIER",
    "FTR",
    "FUJITSU",
    "FUN",
    "FUND",
    "FURNITURE",
    "FUTBOL",
    "FYI",
    "GA",
    "GAL",
    "GALLERY",
    "GALLO",
    "GALLUP",
    "GAME",
    "GAMES",
    "GAP",
    "GARDEN",
    "GAY",
    "GB",
    "GBIZ",
    "GD",
    "GDN",
    "GE",
    "GEA",
    "GENT",
    "GENTING",
    "GEORGE",
    "GF",
    "GG",
    "GGEE",
    "GH",
    "GI",
    "GIFT",
    "GIFTS",
    "GIVES",
    "GIVING",
    "GL",
    "GLASS",
    "GLE",
    "GLOBAL",
    "GLOBO",
    "GM",
    "GMAIL",
    "GMBH",
    "GMO",
    "GMX",
    "GN",
    "GODADDY",
    "GOLD",
    "GOLDPOINT",
    "GOLF",
    "GOO",
    "GOODYEAR",
    "GOOG",
    "GOOGLE",
    "GOP",
    "GOT",
    "GOV",
    "GP",
    "GQ",
    "GR",
    "GRAINGER",
    "GRAPHICS",
    "GRATIS",
    "GREEN",
    "GRIPE",
    "GROCERY",
    "GROUP",
    "GS",
    "GT",
    "GU",
    "GUARDIAN",
    "GUCCI",
    "GUGE",
    "GUIDE",
    "GUITARS",
    "GURU",
    "GW",
    "GY",
    "HAIR",
    "HAMBURG",
    "HANGOUT",
    "HAUS",
    "HBO",
    "HDFC",
    "HDFCBANK",
    "HEALTH",
    "HEALTHCARE",
    "HELP",
    "HELSINKI",
    "HERE",
    "HERMES",
    "HGTV",
    "HIPHOP",
    "HISAMITSU",
    "HITACHI",
    "HIV",
    "HK",
    "HKT",
    "HM",
    "HN",
    "HOCKEY",
    "HOLDINGS",
    "HOLIDAY",
    "HOMEDEPOT",
    "HOMEGOODS",
    "HOMES",
    "HOMESENSE",
    "HONDA",
    "HORSE",
    "HOSPITAL",
    "HOST",
    "HOSTING",
    "HOT",
    "HOTELES",
    "HOTELS",
    "HOTMAIL",
    "HOUSE",
    "HOW",
    "HR",
    "HSBC",
    "HT",
    "HU",
    "HUGHES",
    "HYATT",
    "HYUNDAI",
    "IBM",
    "ICBC",
    "ICE",
    "ICU",
    "ID",
    "IE",
    "IEEE",
    "IFM",
    "IKANO",
    "IL",
    "IM",
    "IMAMAT",
    "IMDB",
    "IMMO",
    "IMMOBILIEN",
    "IN",
    "INC",
    "INDUSTRIES",
    "INFINITI",
    "INFO",
    "ING",
    "INK",
    "INSTITUTE",
    "INSURANCE",
    "INSURE",
    "INT",
    "INTERNATIONAL",
    "INTUIT",
    "INVESTMENTS",
    "IO",
    "IPIRANGA",
    "IQ",
    "IR",
    "IRISH",
    "IS",
    "ISMAILI",
    "IST",
    "ISTANBUL",
    "IT",
    "ITAU",
    "ITV",
    "JAGUAR",
    "JAVA",
    "JCB",
    "JE",
    "JEEP",
    "JETZT",
    "JEWELRY",
    "JIO",
    "JLL",
    "JM",
    "JMP",
    "JNJ",
    "JO",
    "JOBS",
    "JOBURG",
    "JOT",
    "JOY",
    "JP",
    "JPMORGAN",
    "JPRS",
    "JUEGOS",
    "JUNIPER",
    "KAUFEN",
    "KDDI",
    "KE",
    "KERRYHOTELS",
    "KERRYLOGISTICS",
    "KERRYPROPERTIES",
    "KFH",
    "KG",
    "KH",
    "KI",
    "KIA",
    "KIM",
    "KINDER",
    "KINDLE",
    "KITCHEN",
    "KIWI",
    "KM",
    "KN",
    "KOELN",
    "KOMATSU",
    "KOSHER",
    "KP",
    "KPMG",
    "KPN",
    "KR",
    "KRD",
    "KRED",
    "KUOKGROUP",
    "KW",
    "KY",
    "KYOTO",
    "KZ",
    "LA",
    "LACAIXA",
    "LAMBORGHINI",
    "LAMER",
    "LANCASTER",
    "LANCIA",
    "LAND",
    "LANDROVER",
    "LANXESS",
    "LASALLE",
    "LAT",
    "LATINO",
    "LATROBE",
    "LAW",
    "LAWYER",
    "LB",
    "LC",
    "LDS",
    "LEASE",
    "LECLERC",
    "LEFRAK",
    "LEGAL",
    "LEGO",
    "LEXUS",
    "LGBT",
    "LI",
    "LIDL",
    "LIFE",
    "LIFEINSURANCE",
    "LIFESTYLE",
    "LIGHTING",
    "LIKE",
    "LILLY",
    "LIMITED",
    "LIMO",
    "LINCOLN",
    "LINDE",
    "LINK",
    "LIPSY",
    "LIVE",
    "LIVING",
    "LK",
    "LLC",
    "LLP",
    "LOAN",
    "LOANS",
    "LOCKER",
    "LOCUS",
    "LOFT",
    "LOL",
    "LONDON",
    "LOTTE",
    "LOTTO",
    "LOVE",
    "LPL",
    "LPLFINANCIAL",
    "LR",
    "LS",
    "LT",
    "LTD",
    "LTDA",
    "LU",
    "LUNDBECK",
    "LUXE",
    "LUXURY",
    "LV",
    "LY",
    "MA",
    "MACYS",
    "MADRID",
    "MAIF",
    "MAISON",
    "MAKEUP",
    "MAN",
    "MANAGEMENT",
    "MANGO",
    "MAP",
    "MARKET",
    "MARKETING",
    "MARKETS",
    "MARRIOTT",
    "MARSHALLS",
    "MASERATI",
    "MATTEL",
    "MBA",
    "MC",
    "MCKINSEY",
    "MD",
    "ME",
    "MED",
    "MEDIA",
    "MEET",
    "MELBOURNE",
    "MEME",
    "MEMORIAL",
    "MEN",
    "MENU",
    "MERCKMSD",
    "MG",
    "MH",
    "MIAMI",
    "MICROSOFT",
    "MIL",
    "MINI",
    "MINT",
    "MIT",
    "MITSUBISHI",
    "MK",
    "ML",
    "MLB",
    "MLS",
    "MM",
    "MMA",
    "MN",
    "MO",
    "MOBI",
    "MOBILE",
    "MODA",
    "MOE",
    "MOI",
    "MOM",
    "MONASH",
    "MONEY",
    "MONSTER",
    "MORMON",
    "MORTGAGE",
    "MOSCOW",
    "MOTO",
    "MOTORCYCLES",
    "MOV",
    "MOVIE",
    "MP",
    "MQ",
    "MR",
    "MS",
    "MSD",
    "MT",
    "MTN",
    "MTR",
    "MU",
    "MUSEUM",
    "MUSIC",
    "MUTUAL",
    "MV",
    "MW",
    "MX",
    "MY",
    "MZ",
    "NA",
    "NAB",
    "NAGOYA",
    "NAME",
    "NATURA",
    "NAVY",
    "NBA",
    "NC",
    "NE",
    "NEC",
    "NET",
    "NETBANK",
    "NETFLIX",
    "NETWORK",
    "NEUSTAR",
    "NEW",
    "NEWS",
    "NEXT",
    "NEXTDIRECT",
    "NEXUS",
    "NF",
    "NFL",
    "NG",
    "NGO",
    "NHK",
    "NI",
    "NICO",
    "NIKE",
    "NIKON",
    "NINJA",
    "NISSAN",
    "NISSAY",
    "NL",
    "NO",
    "NOKIA",
    "NORTHWESTERNMUTUAL",
    "NORTON",
    "NOW",
    "NOWRUZ",
    "NOWTV",
    "NP",
    "NR",
    "NRA",
    "NRW",
    "NTT",
    "NU",
    "NYC",
    "NZ",
    "OBI",
    "OBSERVER",
    "OFFICE",
    "OKINAWA",
    "OLAYAN",
    "OLAYANGROUP",
    "OLDNAVY",
    "OLLO",
    "OM",
    "OMEGA",
    "ONE",
    "ONG",
    "ONL",
    "ONLINE",
    "OOO",
    "OPEN",
    "ORACLE",
    "ORANGE",
    "ORG",
    "ORGANIC",
    "ORIGINS",
    "OSAKA",
    "OTSUKA",
    "OTT",
    "OVH",
    "PA",
    "PAGE",
    "PANASONIC",
    "PARIS",
    "PARS",
    "PARTNERS",
    "PARTS",
    "PARTY",
    "PASSAGENS",
    "PAY",
    "PCCW",
    "PE",
    "PET",
    "PF",
    "PFIZER",
    "PG",
    "PH",
    "PHARMACY",
    "PHD",
    "PHILIPS",
    "PHONE",
    "PHOTO",
    "PHOTOGRAPHY",
    "PHOTOS",
    "PHYSIO",
    "PICS",
    "PICTET",
    "PICTURES",
    "PID",
    "PIN",
    "PING",
    "PINK",
    "PIONEER",
    "PIZZA",
    "PK",
    "PL",
    "PLACE",
    "PLAY",
    "PLAYSTATION",
    "PLUMBING",
    "PLUS",
    "PM",
    "PN",
    "PNC",
    "POHL",
    "POKER",
    "POLITIE",
    "PORN",
    "POST",
    "PR",
    "PRAMERICA",
    "PRAXI",
    "PRESS",
    "PRIME",
    "PRO",
    "PROD",
    "PRODUCTIONS",
    "PROF",
    "PROGRESSIVE",
    "PROMO",
    "PROPERTIES",
    "PROPERTY",
    "PROTECTION",
    "PRU",
    "PRUDENTIAL",
    "PS",
    "PT",
    "PUB",
    "PW",
    "PWC",
    "PY",
    "QA",
    "QPON",
    "QUEBEC",
    "QUEST",
    "RACING",
    "RADIO",
    "RE",
    "READ",
    "REALESTATE",
    "REALTOR",
    "REALTY",
    "RECIPES",
    "RED",
    "REDSTONE",
    "REDUMBRELLA",
    "REHAB",
    "REISE",
    "REISEN",
    "REIT",
    "RELIANCE",
    "REN",
    "RENT",
    "RENTALS",
    "REPAIR",
    "REPORT",
    "REPUBLICAN",
    "REST",
    "RESTAURANT",
    "REVIEW",
    "REVIEWS",
    "REXROTH",
    "RICH",
    "RICHARDLI",
    "RICOH",
    "RIL",
    "RIO",
    "RIP",
    "RO",
    "ROCHER",
    "ROCKS",
    "RODEO",
    "ROGERS",
    "ROOM",
    "RS",
    "RSVP",
    "RU",
    "RUGBY",
    "RUHR",
    "RUN",
    "RW",
    "RWE",
    "RYUKYU",
    "SA",
    "SAARLAND",
    "SAFE",
    "SAFETY",
    "SAKURA",
    "SALE",
    "SALON",
    "SAMSCLUB",
    "SAMSUNG",
    "SANDVIK",
    "SANDVIKCOROMANT",
    "SANOFI",
    "SAP",
    "SARL",
    "SAS",
    "SAVE",
    "SAXO",
    "SB",
    "SBI",
    "SBS",
    "SC",
    "SCA",
    "SCB",
    "SCHAEFFLER",
    "SCHMIDT",
    "SCHOLARSHIPS",
    "SCHOOL",
    "SCHULE",
    "SCHWARZ",
    "SCIENCE",
    "SCOT",
    "SD",
    "SE",
    "SEARCH",
    "SEAT",
    "SECURE",
    "SECURITY",
    "SEEK",
    "SELECT",
    "SENER",
    "SERVICES",
    "SES",
    "SEVEN",
    "SEW",
    "SEX",
    "SEXY",
    "SFR",
    "SG",
    "SH",
    "SHANGRILA",
    "SHARP",
    "SHAW",
    "SHELL",
    "SHIA",
    "SHIKSHA",
    "SHOES",
    "SHOP",
    "SHOPPING",
    "SHOUJI",
    "SHOW",
    "SHOWTIME",
    "SI",
    "SILK",
    "SINA",
    "SINGLES",
    "SITE",
    "SJ",
    "SK",
    "SKI",
    "SKIN",
    "SKY",
    "SKYPE",
    "SL",
    "SLING",
    "SM",
    "SMART",
    "SMILE",
    "SN",
    "SNCF",
    "SO",
    "SOCCER",
    "SOCIAL",
    "SOFTBANK",
    "SOFTWARE",
    "SOHU",
    "SOLAR",
    "SOLUTIONS",
    "SONG",
    "SONY",
    "SOY",
    "SPA",
    "SPACE",
    "SPORT",
    "SPOT",
    "SR",
    "SRL",
    "SS",
    "ST",
    "STADA",
    "STAPLES",
    "STAR",
    "STATEBANK",
    "STATEFARM",
    "STC",
    "STCGROUP",
    "STOCKHOLM",
    "STORAGE",
    "STORE",
    "STREAM",
    "STUDIO",
    "STUDY",
    "STYLE",
    "SU",
    "SUCKS",
    "SUPPLIES",
    "SUPPLY",
    "SUPPORT",
    "SURF",
    "SURGERY",
    "SUZUKI",
    "SV",
    "SWATCH",
    "SWISS",
    "SX",
    "SY",
    "SYDNEY",
    "SYSTEMS",
    "SZ",
    "TAB",
    "TAIPEI",
    "TALK",
    "TAOBAO",
    "TARGET",
    "TATAMOTORS",
    "TATAR",
    "TATTOO",
    "TAX",
    "TAXI",
    "TC",
    "TCI",
    "TD",
    "TDK",
    "TEAM",
    "TECH",
    "TECHNOLOGY",
    "TEL",
    "TEMASEK",
    "TENNIS",
    "TEVA",
    "TF",
    "TG",
    "TH",
    "THD",
    "THEATER",
    "THEATRE",
    "TIAA",
    "TICKETS",
    "TIENDA",
    "TIFFANY",
    "TIPS",
    "TIRES",
    "TIROL",
    "TJ",
    "TJMAXX",
    "TJX",
    "TK",
    "TKMAXX",
    "TL",
    "TM",
    "TMALL",
    "TN",
    "TO",
    "TODAY",
    "TOKYO",
    "TOOLS",
    "TOP",
    "TORAY",
    "TOSHIBA",
    "TOTAL",
    "TOURS",
    "TOWN",
    "TOYOTA",
    "TOYS",
    "TR",
    "TRADE",
    "TRADING",
    "TRAINING",
    "TRAVEL",
    "TRAVELCHANNEL",
    "TRAVELERS",
    "TRAVELERSINSURANCE",
    "TRUST",
    "TRV",
    "TT",
    "TUBE",
    "TUI",
    "TUNES",
    "TUSHU",
    "TV",
    "TVS",
    "TW",
    "TZ",
    "UA",
    "UBANK",
    "UBS",
    "UG",
    "UK",
    "UNICOM",
    "UNIVERSITY",
    "UNO",
    "UOL",
    "UPS",
    "US",
    "UY",
    "UZ",
    "VA",
    "VACATIONS",
    "VANA",
    "VANGUARD",
    "VC",
    "VE",
    "VEGAS",
    "VENTURES",
    "VERISIGN",
    "VERSICHERUNG",
    "VET",
    "VG",
    "VI",
    "VIAJES",
    "VIDEO",
    "VIG",
    "VIKING",
    "VILLAS",
    "VIN",
    "VIP",
    "VIRGIN",
    "VISA",
    "VISION",
    "VIVA",
    "VIVO",
    "VLAANDEREN",
    "VN",
    "VODKA",
    "VOLKSWAGEN",
    "VOLVO",
    "VOTE",
    "VOTING",
    "VOTO",
    "VOYAGE",
    "VU",
    "VUELOS",
    "WALES",
    "WALMART",
    "WALTER",
    "WANG",
    "WANGGOU",
    "WATCH",
    "WATCHES",
    "WEATHER",
    "WEATHERCHANNEL",
    "WEBCAM",
    "WEBER",
    "WEBSITE",
    "WED",
    "WEDDING",
    "WEIBO",
    "WEIR",
    "WF",
    "WHOSWHO",
    "WIEN",
    "WIKI",
    "WILLIAMHILL",
    "WIN",
    "WINDOWS",
    "WINE",
    "WINNERS",
    "WME",
    "WOLTERSKLUWER",
    "WOODSIDE",
    "WORK",
    "WORKS",
    "WORLD",
    "WOW",
    "WS",
    "WTC",
    "WTF",
    "XBOX",
    "XEROX",
    "XFINITY",
    "XIHUAN",
    "XIN",
    "XN--11B4C3D",
    "XN--1CK2E1B",
    "XN--1QQW23A",
    "XN--2SCRJ9C",
    "XN--30RR7Y",
    "XN--3BST00M",
    "XN--3DS443G",
    "XN--3E0B707E",
    "XN--3HCRJ9C",
    "XN--3PXU8K",
    "XN--42C2D9A",
    "XN--45BR5CYL",
    "XN--45BRJ9C",
    "XN--45Q11C",
    "XN--4DBRK0CE",
    "XN--4GBRIM",
    "XN--54B7FTA0CC",
    "XN--55QW42G",
    "XN--55QX5D",
    "XN--5SU34J936BGSG",
    "XN--5TZM5G",
    "XN--6FRZ82G",
    "XN--6QQ986B3XL",
    "XN--80ADXHKS",
    "XN--80AO21A",
    "XN--80AQECDR1A",
    "XN--80ASEHDB",
    "XN--80ASWG",
    "XN--8Y0A063A",
    "XN--90A3AC",
    "XN--90AE",
    "XN--90AIS",
    "XN--9DBQ2A",
    "XN--9ET52U",
    "XN--9KRT00A",
    "XN--B4W605FERD",
    "XN--BCK1B9A5DRE4C",
    "XN--C1AVG",
    "XN--C2BR7G",
    "XN--CCK2B3B",
    "XN--CCKWCXETD",
    "XN--CG4BKI",
    "XN--CLCHC0EA0B2G2A9GCD",
    "XN--CZR694B",
    "XN--CZRS0T",
    "XN--CZRU2D",
    "XN--D1ACJ3B",
    "XN--D1ALF",
    "XN--E1A4C",
    "XN--ECKVDTC9D",
    "XN--EFVY88H",
    "XN--FCT429K",
    "XN--FHBEI",
    "XN--FIQ228C5HS",
    "XN--FIQ64B",
    "XN--FIQS8S",
    "XN--FIQZ9S",
    "XN--FJQ720A",
    "XN--FLW351E",
    "XN--FPCRJ9C3D",
    "XN--FZC2C9E2C",
    "XN--FZYS8D69UVGM",
    "XN--G2XX48C",
    "XN--GCKR3F0F",
    "XN--GECRJ9C",
    "XN--GK3AT1E",
    "XN--H2BREG3EVE",
    "XN--H2BRJ9C",
    "XN--H2BRJ9C8C",
    "XN--HXT814E",
    "XN--I1B6B1A6A2E",
    "XN--IMR513N",
    "XN--IO0A7I",
    "XN--J1AEF",
    "XN--J1AMH",
    "XN--J6W193G",
    "XN--JLQ480N2RG",
    "XN--JLQ61U9W7B",
    "XN--JVR189M",
    "XN--KCRX77D1X4A",
    "XN--KPRW13D",
    "XN--KPRY57D",
    "XN--KPUT3I",
    "XN--L1ACC",
    "XN--LGBBAT1AD8J",
    "XN--MGB9AWBF",
    "XN--MGBA3A3EJT",
    "XN--MGBA3A4F16A",
    "XN--MGBA7C0BBN0A",
    "XN--MGBAAKC7DVF",
    "XN--MGBAAM7A8H",
    "XN--MGBAB2BD",
    "XN--MGBAH1A3HJKRD",
    "XN--MGBAI9AZGQP6J",
    "XN--MGBAYH7GPA",
    "XN--MGBBH1A",
    "XN--MGBBH1A71E",
    "XN--MGBC0A9AZCG",
    "XN--MGBCA7DZDO",
    "XN--MGBCPQ6GPA1A",
    "XN--MGBERP4A5D4AR",
    "XN--MGBGU82A",
    "XN--MGBI4ECEXP",
    "XN--MGBPL2FH",
    "XN--MGBT3DHD",
    "XN--MGBTX2B",
    "XN--MGBX4CD0AB",
    "XN--MIX891F",
    "XN--MK1BU44C",
    "XN--MXTQ1M",
    "XN--NGBC5AZD",
    "XN--NGBE9E0A",
    "XN--NGBRX",
    "XN--NODE",
    "XN--NQV7F",
    "XN--NQV7FS00EMA",
    "XN--NYQY26A",
    "XN--O3CW4H",
    "XN--OGBPF8FL",
    "XN--OTU796D",
    "XN--P1ACF",
    "XN--P1AI",
    "XN--PGBS0DH",
    "XN--PSSY2U",
    "XN--Q7CE6A",
    "XN--Q9JYB4C",
    "XN--QCKA1PMC",
    "XN--QXA6A",
    "XN--QXAM",
    "XN--RHQV96G",
    "XN--ROVU88B",
    "XN--RVC1E0AM3E",
    "XN--S9BRJ9C",
    "XN--SES554G",
    "XN--T60B56A",
    "XN--TCKWE",
    "XN--TIQ49XQYJ",
    "XN--UNUP4Y",
    "XN--VERMGENSBERATER-CTB",
    "XN--VERMGENSBERATUNG-PWB",
    "XN--VHQUV",
    "XN--VUQ861B",
    "XN--W4R85EL8FHU5DNRA",
    "XN--W4RS40L",
    "XN--WGBH1C",
    "XN--WGBL6A",
    "XN--XHQ521B",
    "XN--XKC2AL3HYE2A",
    "XN--XKC2DL3A5EE0H",
    "XN--Y9A3AQ",
    "XN--YFRO4I67O",
    "XN--YGBI2AMMX",
    "XN--ZFR164B",
    "XXX",
    "XYZ",
    "YACHTS",
    "YAHOO",
    "YAMAXUN",
    "YANDEX",
    "YE",
    "YODOBASHI",
    "YOGA",
    "YOKOHAMA",
    "YOU",
    "YOUTUBE",
    "YT",
    "YUN",
    "ZA",
    "ZAPPOS",
    "ZARA",
    "ZERO",
    "ZIP",
    "ZM",
    "ZONE",
    "ZUERICH",
    "ZW"
  ];
  module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
});

// node_modules/joi/lib/types/string.js
var require_string = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Domain = require_domain();
  var Email = require_email();
  var Ip = require_ip();
  var EscapeRegex = require_escapeRegex();
  var Tlds = require_tlds();
  var Uri = require_uri();
  var Any = require_any();
  var Common = require_common2();
  var internals = {
    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
    base64Regex: {
      true: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
      },
      false: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
      }
    },
    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    hexRegex: /^[a-f0-9]+$/i,
    ipRegex: Ip.regex({ cidr: "forbidden" }).regex,
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
    guidBrackets: {
      "{": "}",
      "[": "]",
      "(": ")",
      "": ""
    },
    guidVersions: {
      uuidv1: "1",
      uuidv2: "2",
      uuidv3: "3",
      uuidv4: "4",
      uuidv5: "5",
      uuidv6: "6",
      uuidv7: "7",
      uuidv8: "8"
    },
    guidSeparators: new Set([undefined, true, false, "-", ":"]),
    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
  };
  module.exports = Any.extend({
    type: "string",
    flags: {
      insensitive: { default: false },
      truncate: { default: false }
    },
    terms: {
      replacements: { init: null }
    },
    coerce: {
      from: "string",
      method(value, { schema, state, prefs }) {
        const normalize = schema.$_getRule("normalize");
        if (normalize) {
          value = value.normalize(normalize.args.form);
        }
        const casing = schema.$_getRule("case");
        if (casing) {
          value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
        }
        const trim = schema.$_getRule("trim");
        if (trim && trim.args.enabled) {
          value = value.trim();
        }
        if (schema.$_terms.replacements) {
          for (const replacement of schema.$_terms.replacements) {
            value = value.replace(replacement.pattern, replacement.replacement);
          }
        }
        const hex = schema.$_getRule("hex");
        if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
          value = `0${value}`;
        }
        if (schema.$_getRule("isoDate")) {
          const iso = internals.isoDate(value);
          if (iso) {
            value = iso;
          }
        }
        if (schema._flags.truncate) {
          const rule = schema.$_getRule("max");
          if (rule) {
            let limit = rule.args.limit;
            if (Common.isResolvable(limit)) {
              limit = limit.resolve(value, state, prefs);
              if (!Common.limit(limit)) {
                return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
              }
            }
            value = value.slice(0, limit);
          }
        }
        return { value };
      }
    },
    validate(value, { schema, error }) {
      if (typeof value !== "string") {
        return { value, errors: error("string.base") };
      }
      if (value === "") {
        const min = schema.$_getRule("min");
        if (min && min.args.limit === 0) {
          return;
        }
        return { value, errors: error("string.empty") };
      }
    },
    rules: {
      alphanum: {
        method() {
          return this.$_addRule("alphanum");
        },
        validate(value, helpers) {
          if (/^[a-zA-Z0-9]+$/.test(value)) {
            return value;
          }
          return helpers.error("string.alphanum");
        }
      },
      base64: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
          options = { urlSafe: false, paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
          return this.$_addRule({ name: "base64", args: { options } });
        },
        validate(value, helpers, { options }) {
          const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
          if (regex.test(value)) {
            return value;
          }
          return helpers.error("string.base64");
        }
      },
      case: {
        method(direction) {
          Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
          return this.$_addRule({ name: "case", args: { direction } });
        },
        validate(value, helpers, { direction }) {
          if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
            return value;
          }
          return helpers.error(`string.${direction}case`);
        },
        convert: true
      },
      creditCard: {
        method() {
          return this.$_addRule("creditCard");
        },
        validate(value, helpers) {
          let i = value.length;
          let sum = 0;
          let mul = 1;
          while (i--) {
            const char = value.charAt(i) * mul;
            sum = sum + (char - (char > 9) * 9);
            mul = mul ^ 3;
          }
          if (sum > 0 && sum % 10 === 0) {
            return value;
          }
          return helpers.error("string.creditCard");
        }
      },
      dataUri: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired"]);
          options = { paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          return this.$_addRule({ name: "dataUri", args: { options } });
        },
        validate(value, helpers, { options }) {
          const matches = value.match(internals.dataUriRegex);
          if (matches) {
            if (!matches[2]) {
              return value;
            }
            if (matches[2] !== "base64") {
              return value;
            }
            const base64regex = internals.base64Regex[options.paddingRequired].false;
            if (base64regex.test(matches[3])) {
              return value;
            }
          }
          return helpers.error("string.dataUri");
        }
      },
      domain: {
        method(options) {
          if (options) {
            Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          }
          const address = internals.addressOptions(options);
          return this.$_addRule({ name: "domain", args: { options }, address });
        },
        validate(value, helpers, args, { address }) {
          if (Domain.isValid(value, address)) {
            return value;
          }
          return helpers.error("string.domain");
        }
      },
      email: {
        method(options = {}) {
          Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
          Assert(options.multiple === undefined || typeof options.multiple === "boolean", "multiple option must be an boolean");
          const address = internals.addressOptions(options);
          const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
          return this.$_addRule({ name: "email", args: { options }, regex, address });
        },
        validate(value, helpers, { options }, { regex, address }) {
          const emails = options.multiple ? value.split(regex) : [value];
          const invalids = [];
          for (const email of emails) {
            if (!Email.isValid(email, address)) {
              invalids.push(email);
            }
          }
          if (!invalids.length) {
            return value;
          }
          return helpers.error("string.email", { value, invalids });
        }
      },
      guid: {
        alias: "uuid",
        method(options = {}) {
          Common.assertOptions(options, ["version", "separator"]);
          let versionNumbers = "";
          if (options.version) {
            const versions = [].concat(options.version);
            Assert(versions.length >= 1, "version must have at least 1 valid version specified");
            const set = new Set;
            for (let i = 0;i < versions.length; ++i) {
              const version = versions[i];
              Assert(typeof version === "string", "version at position " + i + " must be a string");
              const versionNumber = internals.guidVersions[version.toLowerCase()];
              Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
              Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
              versionNumbers += versionNumber;
              set.add(versionNumber);
            }
          }
          Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
          const separator = options.separator === undefined ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
          const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)\$`, "i");
          return this.$_addRule({ name: "guid", args: { options }, regex });
        },
        validate(value, helpers, args, { regex }) {
          const results = regex.exec(value);
          if (!results) {
            return helpers.error("string.guid");
          }
          if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
            return helpers.error("string.guid");
          }
          return value;
        }
      },
      hex: {
        method(options = {}) {
          Common.assertOptions(options, ["byteAligned"]);
          options = { byteAligned: false, ...options };
          Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
          return this.$_addRule({ name: "hex", args: { options } });
        },
        validate(value, helpers, { options }) {
          if (!internals.hexRegex.test(value)) {
            return helpers.error("string.hex");
          }
          if (options.byteAligned && value.length % 2 !== 0) {
            return helpers.error("string.hexAlign");
          }
          return value;
        }
      },
      hostname: {
        method() {
          return this.$_addRule("hostname");
        },
        validate(value, helpers) {
          if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
            return value;
          }
          return helpers.error("string.hostname");
        }
      },
      insensitive: {
        method() {
          return this.$_setFlag("insensitive", true);
        }
      },
      ip: {
        method(options = {}) {
          Common.assertOptions(options, ["cidr", "version"]);
          const { cidr, versions, regex } = Ip.regex(options);
          const version = options.version ? versions : undefined;
          return this.$_addRule({ name: "ip", args: { options: { cidr, version } }, regex });
        },
        validate(value, helpers, { options }, { regex }) {
          if (regex.test(value)) {
            return value;
          }
          if (options.version) {
            return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
          }
          return helpers.error("string.ip", { value, cidr: options.cidr });
        }
      },
      isoDate: {
        method() {
          return this.$_addRule("isoDate");
        },
        validate(value, { error }) {
          if (internals.isoDate(value)) {
            return value;
          }
          return error("string.isoDate");
        }
      },
      isoDuration: {
        method() {
          return this.$_addRule("isoDuration");
        },
        validate(value, helpers) {
          if (internals.isoDurationRegex.test(value)) {
            return value;
          }
          return helpers.error("string.isoDuration");
        }
      },
      length: {
        method(limit, encoding) {
          return internals.length(this, "length", limit, "=", encoding);
        },
        validate(value, helpers, { limit, encoding }, { name, operator, args }) {
          const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
          if (Common.compare(length, limit, operator)) {
            return value;
          }
          return helpers.error("string." + name, { limit: args.limit, value, encoding });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          },
          "encoding"
        ]
      },
      lowercase: {
        method() {
          return this.case("lower");
        }
      },
      max: {
        method(limit, encoding) {
          return internals.length(this, "max", limit, "<=", encoding);
        },
        args: ["limit", "encoding"]
      },
      min: {
        method(limit, encoding) {
          return internals.length(this, "min", limit, ">=", encoding);
        },
        args: ["limit", "encoding"]
      },
      normalize: {
        method(form = "NFC") {
          Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
          return this.$_addRule({ name: "normalize", args: { form } });
        },
        validate(value, { error }, { form }) {
          if (value === value.normalize(form)) {
            return value;
          }
          return error("string.normalize", { value, form });
        },
        convert: true
      },
      pattern: {
        alias: "regex",
        method(regex, options = {}) {
          Assert(regex instanceof RegExp, "regex must be a RegExp");
          Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
          if (typeof options === "string") {
            options = { name: options };
          }
          Common.assertOptions(options, ["invert", "name"]);
          const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
          return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
        },
        validate(value, helpers, { regex, options }, { errorCode }) {
          const patternMatch = regex.test(value);
          if (patternMatch ^ options.invert) {
            return value;
          }
          return helpers.error(errorCode, { name: options.name, regex, value });
        },
        args: ["regex", "options"],
        multi: true
      },
      replace: {
        method(pattern, replacement) {
          if (typeof pattern === "string") {
            pattern = new RegExp(EscapeRegex(pattern), "g");
          }
          Assert(pattern instanceof RegExp, "pattern must be a RegExp");
          Assert(typeof replacement === "string", "replacement must be a String");
          const obj = this.clone();
          if (!obj.$_terms.replacements) {
            obj.$_terms.replacements = [];
          }
          obj.$_terms.replacements.push({ pattern, replacement });
          return obj;
        }
      },
      token: {
        method() {
          return this.$_addRule("token");
        },
        validate(value, helpers) {
          if (/^\w+$/.test(value)) {
            return value;
          }
          return helpers.error("string.token");
        }
      },
      trim: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_addRule({ name: "trim", args: { enabled } });
        },
        validate(value, helpers, { enabled }) {
          if (!enabled || value === value.trim()) {
            return value;
          }
          return helpers.error("string.trim");
        },
        convert: true
      },
      truncate: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("truncate", enabled);
        }
      },
      uppercase: {
        method() {
          return this.case("upper");
        }
      },
      uri: {
        method(options = {}) {
          Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]);
          if (options.domain) {
            Common.assertOptions(options.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          }
          const { regex, scheme } = Uri.regex(options);
          const domain = options.domain ? internals.addressOptions(options.domain) : null;
          return this.$_addRule({ name: "uri", args: { options }, regex, domain, scheme });
        },
        validate(value, helpers, { options }, { regex, domain, scheme }) {
          if (["http:/", "https:/"].includes(value)) {
            return helpers.error("string.uri");
          }
          const match = regex.exec(value);
          if (match) {
            const matched = match[1] || match[2];
            if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {
              return helpers.error("string.domain", { value: matched });
            }
            return value;
          }
          if (options.relativeOnly) {
            return helpers.error("string.uriRelativeOnly");
          }
          if (options.scheme) {
            return helpers.error("string.uriCustomScheme", { scheme, value });
          }
          return helpers.error("string.uri");
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.replacements) {
          for (const { pattern, replacement } of desc.replacements) {
            obj = obj.replace(pattern, replacement);
          }
        }
        return obj;
      }
    },
    messages: {
      "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
      "string.base": "{{#label}} must be a string",
      "string.base64": "{{#label}} must be a valid base64 string",
      "string.creditCard": "{{#label}} must be a credit card",
      "string.dataUri": "{{#label}} must be a valid dataUri string",
      "string.domain": "{{#label}} must contain a valid domain name",
      "string.email": "{{#label}} must be a valid email",
      "string.empty": "{{#label}} is not allowed to be empty",
      "string.guid": "{{#label}} must be a valid GUID",
      "string.hex": "{{#label}} must only contain hexadecimal characters",
      "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
      "string.hostname": "{{#label}} must be a valid hostname",
      "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
      "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
      "string.isoDate": "{{#label}} must be in iso format",
      "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
      "string.length": "{{#label}} length must be {{#limit}} characters long",
      "string.lowercase": "{{#label}} must only contain lowercase characters",
      "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
      "string.min": "{{#label}} length must be at least {{#limit}} characters long",
      "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
      "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
      "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
      "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
      "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
      "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
      "string.trim": "{{#label}} must not have leading or trailing whitespace",
      "string.uri": "{{#label}} must be a valid uri",
      "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
      "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
      "string.uppercase": "{{#label}} must only contain uppercase characters"
    }
  });
  internals.addressOptions = function(options) {
    if (!options) {
      return options;
    }
    Assert(options.minDomainSegments === undefined || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
    Assert(options.maxDomainSegments === undefined || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
    if (options.tlds === false) {
      return options;
    }
    if (options.tlds === true || options.tlds === undefined) {
      Assert(internals.tlds, "Built-in TLD list disabled");
      return Object.assign({}, options, internals.tlds);
    }
    Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
    const deny = options.tlds.deny;
    if (deny) {
      if (Array.isArray(deny)) {
        options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
      }
      Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
      Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
      internals.validateTlds(options.tlds.deny, "tlds.deny");
      return options;
    }
    const allow = options.tlds.allow;
    if (!allow) {
      return options;
    }
    if (allow === true) {
      Assert(internals.tlds, "Built-in TLD list disabled");
      return Object.assign({}, options, internals.tlds);
    }
    if (Array.isArray(allow)) {
      options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }
    Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
    internals.validateTlds(options.tlds.allow, "tlds.allow");
    return options;
  };
  internals.validateTlds = function(set, source) {
    for (const tld of set) {
      Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
    }
  };
  internals.isoDate = function(value) {
    if (!Common.isIsoDate(value)) {
      return null;
    }
    if (/.*T.*[+-]\d\d$/.test(value)) {
      value += "00";
    }
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return null;
    }
    return date.toISOString();
  };
  internals.length = function(schema, name, limit, operator, encoding) {
    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
    return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
  };
});

// node_modules/joi/lib/types/symbol.js
var require_symbol = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var internals = {};
  internals.Map = class extends Map {
    slice() {
      return new internals.Map(this);
    }
  };
  module.exports = Any.extend({
    type: "symbol",
    terms: {
      map: { init: new internals.Map }
    },
    coerce: {
      method(value, { schema, error }) {
        const lookup = schema.$_terms.map.get(value);
        if (lookup) {
          value = lookup;
        }
        if (!schema._flags.only || typeof value === "symbol") {
          return { value };
        }
        return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
      }
    },
    validate(value, { error }) {
      if (typeof value !== "symbol") {
        return { value, errors: error("symbol.base") };
      }
    },
    rules: {
      map: {
        method(iterable) {
          if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
            iterable = Object.entries(iterable);
          }
          Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
          const obj = this.clone();
          const symbols = [];
          for (const entry of iterable) {
            Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
            const [key, value] = entry;
            Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
            Assert(typeof value === "symbol", "Value must be a Symbol");
            obj.$_terms.map.set(key, value);
            symbols.push(value);
          }
          return obj.valid(...symbols);
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.map) {
          obj = obj.map(desc.map);
        }
        return obj;
      }
    },
    messages: {
      "symbol.base": "{{#label}} must be a symbol",
      "symbol.map": "{{#label}} must be one of {{#map}}"
    }
  });
});

// node_modules/joi/lib/types/binary.js
var require_binary = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common2();
  module.exports = Any.extend({
    type: "binary",
    coerce: {
      from: ["string", "object"],
      method(value, { schema }) {
        if (typeof value === "string" || value !== null && value.type === "Buffer") {
          try {
            return { value: Buffer.from(value, schema._flags.encoding) };
          } catch (ignoreErr) {
          }
        }
      }
    },
    validate(value, { error }) {
      if (!Buffer.isBuffer(value)) {
        return { value, errors: error("binary.base") };
      }
    },
    rules: {
      encoding: {
        method(encoding) {
          Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
          return this.$_setFlag("encoding", encoding);
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("binary." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      }
    },
    cast: {
      string: {
        from: (value) => Buffer.isBuffer(value),
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "binary.base": "{{#label}} must be a buffer or a string",
      "binary.length": "{{#label}} must be {{#limit}} bytes",
      "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
      "binary.min": "{{#label}} must be at least {{#limit}} bytes"
    }
  });
});

// node_modules/joi/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Cache = require_cache();
  var Common = require_common2();
  var Compile = require_compile();
  var Errors = require_errors();
  var Extend = require_extend();
  var Manifest = require_manifest();
  var Ref = require_ref();
  var Template = require_template();
  var Trace = require_trace();
  var Schemas;
  var internals = {
    types: {
      alternatives: require_alternatives(),
      any: require_any(),
      array: require_array(),
      boolean: require_boolean(),
      date: require_date(),
      function: require_function(),
      link: require_link(),
      number: require_number(),
      object: require_object(),
      string: require_string(),
      symbol: require_symbol()
    },
    aliases: {
      alt: "alternatives",
      bool: "boolean",
      func: "function"
    }
  };
  if (Buffer) {
    internals.types.binary = require_binary();
  }
  internals.root = function() {
    const root = {
      _types: new Set(Object.keys(internals.types))
    };
    for (const type of root._types) {
      root[type] = function(...args) {
        Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
        return internals.generate(this, internals.types[type], args);
      };
    }
    for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
      root[method] = function(...args) {
        return this.any()[method](...args);
      };
    }
    Object.assign(root, internals.methods);
    for (const alias in internals.aliases) {
      const target = internals.aliases[alias];
      root[alias] = root[target];
    }
    root.x = root.expression;
    if (Trace.setup) {
      Trace.setup(root);
    }
    return root;
  };
  internals.methods = {
    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,
    assert(value, schema, ...args) {
      internals.assert(value, schema, true, args);
    },
    attempt(value, schema, ...args) {
      return internals.assert(value, schema, false, args);
    },
    build(desc) {
      Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
      return Manifest.build(this, desc);
    },
    checkPreferences(prefs) {
      Common.checkPreferences(prefs);
    },
    compile(schema, options) {
      return Compile.compile(this, schema, options);
    },
    defaults(modifier) {
      Assert(typeof modifier === "function", "modifier must be a function");
      const joi = Object.assign({}, this);
      for (const type of joi._types) {
        const schema = modifier(joi[type]());
        Assert(Common.isSchema(schema), "modifier must return a valid schema object");
        joi[type] = function(...args) {
          return internals.generate(this, schema, args);
        };
      }
      return joi;
    },
    expression(...args) {
      return new Template(...args);
    },
    extend(...extensions) {
      Common.verifyFlat(extensions, "extend");
      Schemas = Schemas || require_schemas();
      Assert(extensions.length, "You need to provide at least one extension");
      this.assert(extensions, Schemas.extensions);
      const joi = Object.assign({}, this);
      joi._types = new Set(joi._types);
      for (let extension of extensions) {
        if (typeof extension === "function") {
          extension = extension(joi);
        }
        this.assert(extension, Schemas.extension);
        const expanded = internals.expandExtension(extension, joi);
        for (const item of expanded) {
          Assert(joi[item.type] === undefined || joi._types.has(item.type), "Cannot override name", item.type);
          const base = item.base || this.any();
          const schema = Extend.type(base, item);
          joi._types.add(item.type);
          joi[item.type] = function(...args) {
            return internals.generate(this, schema, args);
          };
        }
      }
      return joi;
    },
    isError: Errors.ValidationError.isError,
    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,
    in(...args) {
      return Ref.in(...args);
    },
    override: Common.symbols.override,
    ref(...args) {
      return Ref.create(...args);
    },
    types() {
      const types = {};
      for (const type of this._types) {
        types[type] = this[type]();
      }
      for (const target in internals.aliases) {
        types[target] = this[target]();
      }
      return types;
    }
  };
  internals.assert = function(value, schema, annotate, args) {
    const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
    const options = message !== null ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
    let error = result.error;
    if (!error) {
      return result.value;
    }
    if (message instanceof Error) {
      throw message;
    }
    const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
    if (error instanceof Errors.ValidationError === false) {
      error = Clone(error);
    }
    error.message = message ? `${message} ${display}` : display;
    throw error;
  };
  internals.generate = function(root, schema, args) {
    Assert(root, "Must be invoked on a Joi instance.");
    schema.$_root = root;
    if (!schema._definition.args || !args.length) {
      return schema;
    }
    return schema._definition.args(schema, ...args);
  };
  internals.expandExtension = function(extension, joi) {
    if (typeof extension.type === "string") {
      return [extension];
    }
    const extended = [];
    for (const type of joi._types) {
      if (extension.type.test(type)) {
        const item = Object.assign({}, extension);
        item.type = type;
        item.base = joi[type]();
        extended.push(item);
      }
    }
    return extended;
  };
  module.exports = internals.root();
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS((exports, module) => {
  var reusify = function(Constructor) {
    var head = new Constructor;
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor;
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  };
  module.exports = reusify;
});

// node_modules/fastq/queue.js
var require_queue = __commonJS((exports, module) => {
  var fastqueue = function(context, worker, concurrency) {
    if (typeof context === "function") {
      concurrency = worker;
      worker = context;
      context = null;
    }
    if (concurrency < 1) {
      throw new Error("fastqueue concurrency must be greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push,
      drain: noop,
      saturated: noop,
      pause,
      paused: false,
      concurrency,
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop,
      kill,
      killAndDrain,
      error
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter = 0;
      while (current) {
        current = current.next;
        counter++;
      }
      return counter;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      for (var i = 0;i < self2.concurrency; i++) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running === self2.concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      if (_running === self2.concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop;
    }
    function error(handler) {
      errorHandler = handler;
    }
  };
  var noop = function() {
  };
  var Task = function() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val2 = self2.value;
      self2.value = null;
      self2.callback = noop;
      if (self2.errorHandler) {
        errorHandler(err, val2);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  };
  var queueAsPromised = function(context, worker, concurrency) {
    if (typeof context === "function") {
      concurrency = worker;
      worker = context;
      context = null;
    }
    function asyncWrapper(arg, cb) {
      worker.call(this, arg).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    queue.drained = drained;
    return queue;
    function push(value) {
      var p = new Promise(function(resolve, reject) {
        pushCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      p.catch(noop);
      return p;
    }
    function unshift(value) {
      var p = new Promise(function(resolve, reject) {
        unshiftCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      p.catch(noop);
      return p;
    }
    function drained() {
      if (queue.idle()) {
        return new Promise(function(resolve) {
          resolve();
        });
      }
      var previousDrain = queue.drain;
      var p = new Promise(function(resolve) {
        queue.drain = function() {
          previousDrain();
          resolve();
        };
      });
      return p;
    }
  };
  var reusify = require_reusify();
  module.exports = fastqueue;
  module.exports.promise = queueAsPromised;
});

// node_modules/defer-to-connect/dist/source/index.js
var require_source = __commonJS((exports, module) => {
  var isTLSSocket = function(socket) {
    return socket.encrypted;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var deferToConnect = (socket, fn) => {
    let listeners;
    if (typeof fn === "function") {
      const connect = fn;
      listeners = { connect };
    } else {
      listeners = fn;
    }
    const hasConnectListener = typeof listeners.connect === "function";
    const hasSecureConnectListener = typeof listeners.secureConnect === "function";
    const hasCloseListener = typeof listeners.close === "function";
    const onConnect = () => {
      if (hasConnectListener) {
        listeners.connect();
      }
      if (isTLSSocket(socket) && hasSecureConnectListener) {
        if (socket.authorized) {
          listeners.secureConnect();
        } else if (!socket.authorizationError) {
          socket.once("secureConnect", listeners.secureConnect);
        }
      }
      if (hasCloseListener) {
        socket.once("close", listeners.close);
      }
    };
    if (socket.writable && !socket.connecting) {
      onConnect();
    } else if (socket.connecting) {
      socket.once("connect", onConnect);
    } else if (socket.destroyed && hasCloseListener) {
      listeners.close(socket._hadError);
    }
  };
  exports.default = deferToConnect;
  module.exports = deferToConnect;
  module.exports.default = deferToConnect;
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports, module) => {
  var { PassThrough: PassThroughStream } = __require("stream");
  module.exports = (options) => {
    options = { ...options };
    const { array } = options;
    let { encoding } = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({ objectMode });
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports, module) => {
  async function getStream(inputStream, options) {
    if (!inputStream) {
      throw new Error("Expected a stream");
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const { maxBuffer } = options;
    const stream2 = bufferStream(options);
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream2.getBufferedValue();
        }
        reject(error);
      };
      (async () => {
        try {
          await streamPipelinePromisified(inputStream, stream2);
          resolve();
        } catch (error) {
          rejectPromise(error);
        }
      })();
      stream2.on("data", () => {
        if (stream2.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError);
        }
      });
    });
    return stream2.getBufferedValue();
  }
  var { constants: BufferConstants } = __require("buffer");
  var stream = __require("stream");
  var { promisify } = __require("util");
  var bufferStream = require_buffer_stream();
  var streamPipelinePromisified = promisify(stream.pipeline);

  class MaxBufferError extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  }
  module.exports = getStream;
  module.exports.buffer = (stream2, options) => getStream(stream2, { ...options, encoding: "buffer" });
  module.exports.array = (stream2, options) => getStream(stream2, { ...options, array: true });
  module.exports.MaxBufferError = MaxBufferError;
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS((exports, module) => {
  var toNumberOrZero = function(s) {
    const n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
  };
  var isErrorResponse = function(response) {
    if (!response) {
      return true;
    }
    return errorStatusCodes.has(response.status);
  };
  var parseCacheControl = function(header) {
    const cc = {};
    if (!header)
      return cc;
    const parts = header.trim().split(/,/);
    for (const part2 of parts) {
      const [k, v] = part2.split(/=/, 2);
      cc[k.trim()] = v === undefined ? true : v.trim().replace(/^"|"$/g, "");
    }
    return cc;
  };
  var formatCacheControl = function(cc) {
    let parts = [];
    for (const k in cc) {
      const v = cc[k];
      parts.push(v === true ? k : k + "=" + v);
    }
    if (!parts.length) {
      return;
    }
    return parts.join(", ");
  };
  var statusCodeCacheableByDefault = new Set([
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501
  ]);
  var understoodStatuses = new Set([
    200,
    203,
    204,
    300,
    301,
    302,
    303,
    307,
    308,
    404,
    405,
    410,
    414,
    501
  ]);
  var errorStatusCodes = new Set([
    500,
    502,
    503,
    504
  ]);
  var hopByHopHeaders = {
    date: true,
    connection: true,
    "keep-alive": true,
    "proxy-authenticate": true,
    "proxy-authorization": true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true
  };
  var excludedFromRevalidationUpdate = {
    "content-length": true,
    "content-encoding": true,
    "transfer-encoding": true,
    "content-range": true
  };
  module.exports = class CachePolicy {
    constructor(req, res, {
      shared,
      cacheHeuristic,
      immutableMinTimeToLive,
      ignoreCargoCult,
      _fromObject
    } = {}) {
      if (_fromObject) {
        this._fromObject(_fromObject);
        return;
      }
      if (!res || !res.headers) {
        throw Error("Response headers missing");
      }
      this._assertRequestHasHeaders(req);
      this._responseTime = this.now();
      this._isShared = shared !== false;
      this._cacheHeuristic = cacheHeuristic !== undefined ? cacheHeuristic : 0.1;
      this._immutableMinTtl = immutableMinTimeToLive !== undefined ? immutableMinTimeToLive : 24 * 3600 * 1000;
      this._status = ("status" in res) ? res.status : 200;
      this._resHeaders = res.headers;
      this._rescc = parseCacheControl(res.headers["cache-control"]);
      this._method = ("method" in req) ? req.method : "GET";
      this._url = req.url;
      this._host = req.headers.host;
      this._noAuthorization = !req.headers.authorization;
      this._reqHeaders = res.headers.vary ? req.headers : null;
      this._reqcc = parseCacheControl(req.headers["cache-control"]);
      if (ignoreCargoCult && ("pre-check" in this._rescc) && ("post-check" in this._rescc)) {
        delete this._rescc["pre-check"];
        delete this._rescc["post-check"];
        delete this._rescc["no-cache"];
        delete this._rescc["no-store"];
        delete this._rescc["must-revalidate"];
        this._resHeaders = Object.assign({}, this._resHeaders, {
          "cache-control": formatCacheControl(this._rescc)
        });
        delete this._resHeaders.expires;
        delete this._resHeaders.pragma;
      }
      if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
        this._rescc["no-cache"] = true;
      }
    }
    now() {
      return Date.now();
    }
    storable() {
      return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
    }
    _hasExplicitExpiration() {
      return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
    }
    _assertRequestHasHeaders(req) {
      if (!req || !req.headers) {
        throw Error("Request headers missing");
      }
    }
    satisfiesWithoutRevalidation(req) {
      this._assertRequestHasHeaders(req);
      const requestCC = parseCacheControl(req.headers["cache-control"]);
      if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
        return false;
      }
      if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
        return false;
      }
      if (requestCC["min-fresh"] && this.timeToLive() < 1000 * requestCC["min-fresh"]) {
        return false;
      }
      if (this.stale()) {
        const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
        if (!allowsStale) {
          return false;
        }
      }
      return this._requestMatches(req, false);
    }
    _requestMatches(req, allowHeadMethod) {
      return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
    }
    _allowsStoringAuthenticated() {
      return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
    }
    _varyMatches(req) {
      if (!this._resHeaders.vary) {
        return true;
      }
      if (this._resHeaders.vary === "*") {
        return false;
      }
      const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
      for (const name of fields) {
        if (req.headers[name] !== this._reqHeaders[name])
          return false;
      }
      return true;
    }
    _copyWithoutHopByHopHeaders(inHeaders) {
      const headers = {};
      for (const name in inHeaders) {
        if (hopByHopHeaders[name])
          continue;
        headers[name] = inHeaders[name];
      }
      if (inHeaders.connection) {
        const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
        for (const name of tokens) {
          delete headers[name];
        }
      }
      if (headers.warning) {
        const warnings = headers.warning.split(/,/).filter((warning) => {
          return !/^\s*1[0-9][0-9]/.test(warning);
        });
        if (!warnings.length) {
          delete headers.warning;
        } else {
          headers.warning = warnings.join(",").trim();
        }
      }
      return headers;
    }
    responseHeaders() {
      const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
      const age = this.age();
      if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
        headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
      }
      headers.age = `${Math.round(age)}`;
      headers.date = new Date(this.now()).toUTCString();
      return headers;
    }
    date() {
      const serverDate = Date.parse(this._resHeaders.date);
      if (isFinite(serverDate)) {
        return serverDate;
      }
      return this._responseTime;
    }
    age() {
      let age = this._ageValue();
      const residentTime = (this.now() - this._responseTime) / 1000;
      return age + residentTime;
    }
    _ageValue() {
      return toNumberOrZero(this._resHeaders.age);
    }
    maxAge() {
      if (!this.storable() || this._rescc["no-cache"]) {
        return 0;
      }
      if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
        return 0;
      }
      if (this._resHeaders.vary === "*") {
        return 0;
      }
      if (this._isShared) {
        if (this._rescc["proxy-revalidate"]) {
          return 0;
        }
        if (this._rescc["s-maxage"]) {
          return toNumberOrZero(this._rescc["s-maxage"]);
        }
      }
      if (this._rescc["max-age"]) {
        return toNumberOrZero(this._rescc["max-age"]);
      }
      const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
      const serverDate = this.date();
      if (this._resHeaders.expires) {
        const expires = Date.parse(this._resHeaders.expires);
        if (Number.isNaN(expires) || expires < serverDate) {
          return 0;
        }
        return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
      }
      if (this._resHeaders["last-modified"]) {
        const lastModified = Date.parse(this._resHeaders["last-modified"]);
        if (isFinite(lastModified) && serverDate > lastModified) {
          return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);
        }
      }
      return defaultMinTtl;
    }
    timeToLive() {
      const age = this.maxAge() - this.age();
      const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
      const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;
    }
    stale() {
      return this.maxAge() <= this.age();
    }
    _useStaleIfError() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
    }
    useStaleWhileRevalidate() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
    }
    static fromObject(obj) {
      return new this(undefined, undefined, { _fromObject: obj });
    }
    _fromObject(obj) {
      if (this._responseTime)
        throw Error("Reinitialized");
      if (!obj || obj.v !== 1)
        throw Error("Invalid serialization");
      this._responseTime = obj.t;
      this._isShared = obj.sh;
      this._cacheHeuristic = obj.ch;
      this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
      this._status = obj.st;
      this._resHeaders = obj.resh;
      this._rescc = obj.rescc;
      this._method = obj.m;
      this._url = obj.u;
      this._host = obj.h;
      this._noAuthorization = obj.a;
      this._reqHeaders = obj.reqh;
      this._reqcc = obj.reqcc;
    }
    toObject() {
      return {
        v: 1,
        t: this._responseTime,
        sh: this._isShared,
        ch: this._cacheHeuristic,
        imm: this._immutableMinTtl,
        st: this._status,
        resh: this._resHeaders,
        rescc: this._rescc,
        m: this._method,
        u: this._url,
        h: this._host,
        a: this._noAuthorization,
        reqh: this._reqHeaders,
        reqcc: this._reqcc
      };
    }
    revalidationHeaders(incomingReq) {
      this._assertRequestHasHeaders(incomingReq);
      const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
      delete headers["if-range"];
      if (!this._requestMatches(incomingReq, true) || !this.storable()) {
        delete headers["if-none-match"];
        delete headers["if-modified-since"];
        return headers;
      }
      if (this._resHeaders.etag) {
        headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
      }
      const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
      if (forbidsWeakValidators) {
        delete headers["if-modified-since"];
        if (headers["if-none-match"]) {
          const etags = headers["if-none-match"].split(/,/).filter((etag) => {
            return !/^\s*W\//.test(etag);
          });
          if (!etags.length) {
            delete headers["if-none-match"];
          } else {
            headers["if-none-match"] = etags.join(",").trim();
          }
        }
      } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
        headers["if-modified-since"] = this._resHeaders["last-modified"];
      }
      return headers;
    }
    revalidatedPolicy(request, response) {
      this._assertRequestHasHeaders(request);
      if (this._useStaleIfError() && isErrorResponse(response)) {
        return {
          modified: false,
          matches: false,
          policy: this
        };
      }
      if (!response || !response.headers) {
        throw Error("Response headers missing");
      }
      let matches = false;
      if (response.status !== undefined && response.status != 304) {
        matches = false;
      } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
      } else if (this._resHeaders.etag && response.headers.etag) {
        matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
      } else if (this._resHeaders["last-modified"]) {
        matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
      } else {
        if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
          matches = true;
        }
      }
      if (!matches) {
        return {
          policy: new this.constructor(request, response),
          modified: response.status != 304,
          matches: false
        };
      }
      const headers = {};
      for (const k in this._resHeaders) {
        headers[k] = (k in response.headers) && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
      }
      const newResponse = Object.assign({}, response, {
        status: this._status,
        method: this._method,
        headers
      });
      return {
        policy: new this.constructor(request, newResponse, {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl
        }),
        modified: false,
        matches: true
      };
    }
  };
});

// node_modules/json-buffer/index.js
var require_json_buffer = __commonJS((exports) => {
  exports.stringify = function stringify(o) {
    if (typeof o == "undefined")
      return o;
    if (o && Buffer.isBuffer(o))
      return JSON.stringify(":base64:" + o.toString("base64"));
    if (o && o.toJSON)
      o = o.toJSON();
    if (o && typeof o === "object") {
      var s = "";
      var array = Array.isArray(o);
      s = array ? "[" : "{";
      var first = true;
      for (var k in o) {
        var ignore = typeof o[k] == "function" || !array && typeof o[k] === "undefined";
        if (Object.hasOwnProperty.call(o, k) && !ignore) {
          if (!first)
            s += ",";
          first = false;
          if (array) {
            if (o[k] == undefined)
              s += "null";
            else
              s += stringify(o[k]);
          } else if (o[k] !== undefined) {
            s += stringify(k) + ":" + stringify(o[k]);
          }
        }
      }
      s += array ? "]" : "}";
      return s;
    } else if (typeof o === "string") {
      return JSON.stringify(/^:/.test(o) ? ":" + o : o);
    } else if (typeof o === "undefined") {
      return "null";
    } else
      return JSON.stringify(o);
  };
  exports.parse = function(s) {
    return JSON.parse(s, function(key, value) {
      if (typeof value === "string") {
        if (/^:base64:/.test(value))
          return Buffer.from(value.substring(8), "base64");
        else
          return /^:/.test(value) ? value.substring(1) : value;
      }
      return value;
    });
  };
});

// node_modules/keyv/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var JSONB = require_json_buffer();
  var loadStore = (options) => {
    const adapters = {
      redis: "@keyv/redis",
      rediss: "@keyv/redis",
      mongodb: "@keyv/mongo",
      mongo: "@keyv/mongo",
      sqlite: "@keyv/sqlite",
      postgresql: "@keyv/postgres",
      postgres: "@keyv/postgres",
      mysql: "@keyv/mysql",
      etcd: "@keyv/etcd",
      offline: "@keyv/offline",
      tiered: "@keyv/tiered"
    };
    if (options.adapter || options.uri) {
      const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
      return new (require(adapters[adapter]))(options);
    }
    return new Map;
  };
  var iterableAdapters = [
    "sqlite",
    "postgres",
    "mysql",
    "mongo",
    "redis",
    "tiered"
  ];

  class Keyv extends EventEmitter {
    constructor(uri, { emitErrors = true, ...options } = {}) {
      super();
      this.opts = {
        namespace: "keyv",
        serialize: JSONB.stringify,
        deserialize: JSONB.parse,
        ...typeof uri === "string" ? { uri } : uri,
        ...options
      };
      if (!this.opts.store) {
        const adapterOptions = { ...this.opts };
        this.opts.store = loadStore(adapterOptions);
      }
      if (this.opts.compression) {
        const compression = this.opts.compression;
        this.opts.serialize = compression.serialize.bind(compression);
        this.opts.deserialize = compression.deserialize.bind(compression);
      }
      if (typeof this.opts.store.on === "function" && emitErrors) {
        this.opts.store.on("error", (error) => this.emit("error", error));
      }
      this.opts.store.namespace = this.opts.namespace;
      const generateIterator = (iterator) => async function* () {
        for await (const [key, raw] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
          const data = await this.opts.deserialize(raw);
          if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
            continue;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            this.delete(key);
            continue;
          }
          yield [this._getKeyUnprefix(key), data.value];
        }
      };
      if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
        this.iterator = generateIterator(this.opts.store);
      } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
        this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
      }
    }
    _checkIterableAdaptar() {
      return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
    }
    _getKeyPrefix(key) {
      return `${this.opts.namespace}:${key}`;
    }
    _getKeyPrefixArray(keys) {
      return keys.map((key) => `${this.opts.namespace}:${key}`);
    }
    _getKeyUnprefix(key) {
      return key.split(":").splice(1).join(":");
    }
    get(key, options) {
      const { store } = this.opts;
      const isArray = Array.isArray(key);
      const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
      if (isArray && store.getMany === undefined) {
        const promises4 = [];
        for (const key2 of keyPrefixed) {
          promises4.push(Promise.resolve().then(() => store.get(key2)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
            if (data === undefined || data === null) {
              return;
            }
            if (typeof data.expires === "number" && Date.now() > data.expires) {
              return this.delete(key2).then(() => {
                return;
              });
            }
            return options && options.raw ? data : data.value;
          }));
        }
        return Promise.allSettled(promises4).then((values) => {
          const data = [];
          for (const value of values) {
            data.push(value.value);
          }
          return data;
        });
      }
      return Promise.resolve().then(() => isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
        if (data === undefined || data === null) {
          return;
        }
        if (isArray) {
          return data.map((row, index) => {
            if (typeof row === "string") {
              row = this.opts.deserialize(row);
            }
            if (row === undefined || row === null) {
              return;
            }
            if (typeof row.expires === "number" && Date.now() > row.expires) {
              this.delete(key[index]).then(() => {
                return;
              });
              return;
            }
            return options && options.raw ? row : row.value;
          });
        }
        if (typeof data.expires === "number" && Date.now() > data.expires) {
          return this.delete(key).then(() => {
            return;
          });
        }
        return options && options.raw ? data : data.value;
      });
    }
    set(key, value, ttl) {
      const keyPrefixed = this._getKeyPrefix(key);
      if (typeof ttl === "undefined") {
        ttl = this.opts.ttl;
      }
      if (ttl === 0) {
        ttl = undefined;
      }
      const { store } = this.opts;
      return Promise.resolve().then(() => {
        const expires = typeof ttl === "number" ? Date.now() + ttl : null;
        if (typeof value === "symbol") {
          this.emit("error", "symbol cannot be serialized");
        }
        value = { value, expires };
        return this.opts.serialize(value);
      }).then((value2) => store.set(keyPrefixed, value2, ttl)).then(() => true);
    }
    delete(key) {
      const { store } = this.opts;
      if (Array.isArray(key)) {
        const keyPrefixed2 = this._getKeyPrefixArray(key);
        if (store.deleteMany === undefined) {
          const promises4 = [];
          for (const key2 of keyPrefixed2) {
            promises4.push(store.delete(key2));
          }
          return Promise.allSettled(promises4).then((values) => values.every((x) => x.value === true));
        }
        return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
      }
      const keyPrefixed = this._getKeyPrefix(key);
      return Promise.resolve().then(() => store.delete(keyPrefixed));
    }
    clear() {
      const { store } = this.opts;
      return Promise.resolve().then(() => store.clear());
    }
    has(key) {
      const keyPrefixed = this._getKeyPrefix(key);
      const { store } = this.opts;
      return Promise.resolve().then(async () => {
        if (typeof store.has === "function") {
          return store.has(keyPrefixed);
        }
        const value = await store.get(keyPrefixed);
        return value !== undefined;
      });
    }
    disconnect() {
      const { store } = this.opts;
      if (typeof store.disconnect === "function") {
        return store.disconnect();
      }
    }
  }
  module.exports = Keyv;
});

// node_modules/decompress-response/node_modules/mimic-response/index.js
var require_mimic_response = __commonJS((exports, module) => {
  var knownProperties2 = [
    "aborted",
    "complete",
    "headers",
    "httpVersion",
    "httpVersionMinor",
    "httpVersionMajor",
    "method",
    "rawHeaders",
    "rawTrailers",
    "setTimeout",
    "socket",
    "statusCode",
    "statusMessage",
    "trailers",
    "url"
  ];
  module.exports = (fromStream, toStream) => {
    if (toStream._readableState.autoDestroy) {
      throw new Error("The second stream must have the `autoDestroy` option set to `false`");
    }
    const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties2));
    const properties = {};
    for (const property of fromProperties) {
      if (property in toStream) {
        continue;
      }
      properties[property] = {
        get() {
          const value = fromStream[property];
          const isFunction = typeof value === "function";
          return isFunction ? value.bind(fromStream) : value;
        },
        set(value) {
          fromStream[property] = value;
        },
        enumerable: true,
        configurable: false
      };
    }
    Object.defineProperties(toStream, properties);
    fromStream.once("aborted", () => {
      toStream.destroy();
      toStream.emit("aborted");
    });
    fromStream.once("close", () => {
      if (fromStream.complete) {
        if (toStream.readable) {
          toStream.once("end", () => {
            toStream.emit("close");
          });
        } else {
          toStream.emit("close");
        }
      } else {
        toStream.emit("close");
      }
    });
    return toStream;
  };
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS((exports, module) => {
  var { Transform, PassThrough } = __require("stream");
  var zlib = __require("zlib");
  var mimicResponse2 = require_mimic_response();
  module.exports = (response) => {
    const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
    if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
      return response;
    }
    const isBrotli = contentEncoding === "br";
    if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
      response.destroy(new Error("Brotli is not supported on Node.js < 12"));
      return response;
    }
    let isEmpty = true;
    const checker = new Transform({
      transform(data, _encoding, callback) {
        isEmpty = false;
        callback(null, data);
      },
      flush(callback) {
        callback();
      }
    });
    const finalStream = new PassThrough({
      autoDestroy: false,
      destroy(error, callback) {
        response.destroy();
        callback(error);
      }
    });
    const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
    decompressStream.once("error", (error) => {
      if (isEmpty && !response.readable) {
        finalStream.end();
        return;
      }
      finalStream.destroy(error);
    });
    mimicResponse2(response, finalStream);
    response.pipe(checker).pipe(decompressStream).pipe(finalStream);
    return finalStream;
  };
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS((exports, module) => {
  class QuickLRU {
    constructor(options = {}) {
      if (!(options.maxSize && options.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      this.maxSize = options.maxSize;
      this.onEviction = options.onEviction;
      this.cache = new Map;
      this.oldCache = new Map;
      this._size = 0;
    }
    _set(key, value) {
      this.cache.set(key, value);
      this._size++;
      if (this._size >= this.maxSize) {
        this._size = 0;
        if (typeof this.onEviction === "function") {
          for (const [key2, value2] of this.oldCache.entries()) {
            this.onEviction(key2, value2);
          }
        }
        this.oldCache = this.cache;
        this.cache = new Map;
      }
    }
    get(key) {
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }
      if (this.oldCache.has(key)) {
        const value = this.oldCache.get(key);
        this.oldCache.delete(key);
        this._set(key, value);
        return value;
      }
    }
    set(key, value) {
      if (this.cache.has(key)) {
        this.cache.set(key, value);
      } else {
        this._set(key, value);
      }
      return this;
    }
    has(key) {
      return this.cache.has(key) || this.oldCache.has(key);
    }
    peek(key) {
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }
      if (this.oldCache.has(key)) {
        return this.oldCache.get(key);
      }
    }
    delete(key) {
      const deleted = this.cache.delete(key);
      if (deleted) {
        this._size--;
      }
      return this.oldCache.delete(key) || deleted;
    }
    clear() {
      this.cache.clear();
      this.oldCache.clear();
      this._size = 0;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.cache) {
        yield item;
      }
      for (const item of this.oldCache) {
        const [key] = item;
        if (!this.cache.has(key)) {
          yield item;
        }
      }
    }
    get size() {
      let oldCacheSize = 0;
      for (const key of this.oldCache.keys()) {
        if (!this.cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this._size + oldCacheSize, this.maxSize);
    }
  }
  module.exports = QuickLRU;
});

// node_modules/http2-wrapper/source/utils/delay-async-destroy.js
var require_delay_async_destroy = __commonJS((exports, module) => {
  module.exports = (stream2) => {
    if (stream2.listenerCount("error") !== 0) {
      return stream2;
    }
    stream2.__destroy = stream2._destroy;
    stream2._destroy = (...args) => {
      const callback = args.pop();
      stream2.__destroy(...args, async (error) => {
        await Promise.resolve();
        callback(error);
      });
    };
    const onError = (error) => {
      Promise.resolve().then(() => {
        stream2.emit("error", error);
      });
    };
    stream2.once("error", onError);
    Promise.resolve().then(() => {
      stream2.off("error", onError);
    });
    return stream2;
  };
});

// node_modules/http2-wrapper/source/agent.js
var require_agent = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("url");
  var EventEmitter2 = __require("events");
  var tls = __require("tls");
  var http2 = __require("http2");
  var QuickLRU = require_quick_lru();
  var delayAsyncDestroy = require_delay_async_destroy();
  var kCurrentStreamCount = Symbol("currentStreamCount");
  var kRequest = Symbol("request");
  var kOriginSet = Symbol("cachedOriginSet");
  var kGracefullyClosing = Symbol("gracefullyClosing");
  var kLength = Symbol("length");
  var nameKeys = [
    "createConnection",
    "maxDeflateDynamicTableSize",
    "maxSettings",
    "maxSessionMemory",
    "maxHeaderListPairs",
    "maxOutstandingPings",
    "maxReservedRemoteStreams",
    "maxSendHeaderBlockLength",
    "paddingStrategy",
    "peerMaxConcurrentStreams",
    "settings",
    "family",
    "localAddress",
    "rejectUnauthorized",
    "pskCallback",
    "minDHSize",
    "path",
    "socket",
    "ca",
    "cert",
    "sigalgs",
    "ciphers",
    "clientCertEngine",
    "crl",
    "dhparam",
    "ecdhCurve",
    "honorCipherOrder",
    "key",
    "privateKeyEngine",
    "privateKeyIdentifier",
    "maxVersion",
    "minVersion",
    "pfx",
    "secureOptions",
    "secureProtocol",
    "sessionIdContext",
    "ticketKeys"
  ];
  var getSortedIndex = (array, value, compare) => {
    let low = 0;
    let high = array.length;
    while (low < high) {
      const mid = low + high >>> 1;
      if (compare(array[mid], value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  };
  var compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
  var closeCoveredSessions = (where, session) => {
    for (let index = 0;index < where.length; index++) {
      const coveredSession = where[index];
      if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
        gracefullyClose(coveredSession);
      }
    }
  };
  var closeSessionIfCovered = (where, coveredSession) => {
    for (let index = 0;index < where.length; index++) {
      const session = where[index];
      if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
        gracefullyClose(coveredSession);
        return true;
      }
    }
    return false;
  };
  var gracefullyClose = (session) => {
    session[kGracefullyClosing] = true;
    if (session[kCurrentStreamCount] === 0) {
      session.close();
    }
  };

  class Agent extends EventEmitter2 {
    constructor({ timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100 } = {}) {
      super();
      this.sessions = {};
      this.queue = {};
      this.timeout = timeout;
      this.maxSessions = maxSessions;
      this.maxEmptySessions = maxEmptySessions;
      this._emptySessionCount = 0;
      this._sessionCount = 0;
      this.settings = {
        enablePush: false,
        initialWindowSize: 1024 * 1024 * 32
      };
      this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
    }
    get protocol() {
      return "https:";
    }
    normalizeOptions(options) {
      let normalized = "";
      for (let index = 0;index < nameKeys.length; index++) {
        const key = nameKeys[index];
        normalized += ":";
        if (options && options[key] !== undefined) {
          normalized += options[key];
        }
      }
      return normalized;
    }
    _processQueue() {
      if (this._sessionCount >= this.maxSessions) {
        this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
        return;
      }
      for (const normalizedOptions in this.queue) {
        for (const normalizedOrigin in this.queue[normalizedOptions]) {
          const item = this.queue[normalizedOptions][normalizedOrigin];
          if (!item.completed) {
            item.completed = true;
            item();
          }
        }
      }
    }
    _isBetterSession(thisStreamCount, thatStreamCount) {
      return thisStreamCount > thatStreamCount;
    }
    _accept(session, listeners, normalizedOrigin, options) {
      let index = 0;
      while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {
        listeners[index].resolve(session);
        index++;
      }
      listeners.splice(0, index);
      if (listeners.length > 0) {
        this.getSession(normalizedOrigin, options, listeners);
        listeners.length = 0;
      }
    }
    getSession(origin, options, listeners) {
      return new Promise((resolve, reject) => {
        if (Array.isArray(listeners) && listeners.length > 0) {
          listeners = [...listeners];
          resolve();
        } else {
          listeners = [{ resolve, reject }];
        }
        try {
          if (typeof origin === "string") {
            origin = new URL2(origin);
          } else if (!(origin instanceof URL2)) {
            throw new TypeError("The `origin` argument needs to be a string or an URL object");
          }
          if (options) {
            const { servername } = options;
            const { hostname } = origin;
            if (servername && hostname !== servername) {
              throw new Error(`Origin ${hostname} differs from servername ${servername}`);
            }
          }
        } catch (error) {
          for (let index = 0;index < listeners.length; index++) {
            listeners[index].reject(error);
          }
          return;
        }
        const normalizedOptions = this.normalizeOptions(options);
        const normalizedOrigin = origin.origin;
        if (normalizedOptions in this.sessions) {
          const sessions = this.sessions[normalizedOptions];
          let maxConcurrentStreams = -1;
          let currentStreamsCount = -1;
          let optimalSession;
          for (let index = 0;index < sessions.length; index++) {
            const session = sessions[index];
            const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
            if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
              break;
            }
            if (!session[kOriginSet].includes(normalizedOrigin)) {
              continue;
            }
            const sessionCurrentStreamsCount = session[kCurrentStreamCount];
            if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
              continue;
            }
            if (!optimalSession) {
              maxConcurrentStreams = sessionMaxConcurrentStreams;
            }
            if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
              optimalSession = session;
              currentStreamsCount = sessionCurrentStreamsCount;
            }
          }
          if (optimalSession) {
            this._accept(optimalSession, listeners, normalizedOrigin, options);
            return;
          }
        }
        if (normalizedOptions in this.queue) {
          if (normalizedOrigin in this.queue[normalizedOptions]) {
            this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
            return;
          }
        } else {
          this.queue[normalizedOptions] = {
            [kLength]: 0
          };
        }
        const removeFromQueue = () => {
          if ((normalizedOptions in this.queue) && this.queue[normalizedOptions][normalizedOrigin] === entry) {
            delete this.queue[normalizedOptions][normalizedOrigin];
            if (--this.queue[normalizedOptions][kLength] === 0) {
              delete this.queue[normalizedOptions];
            }
          }
        };
        const entry = async () => {
          this._sessionCount++;
          const name = `${normalizedOrigin}:${normalizedOptions}`;
          let receivedSettings = false;
          let socket;
          try {
            const computedOptions = { ...options };
            if (computedOptions.settings === undefined) {
              computedOptions.settings = this.settings;
            }
            if (computedOptions.session === undefined) {
              computedOptions.session = this.tlsSessionCache.get(name);
            }
            const createConnection = computedOptions.createConnection || this.createConnection;
            socket = await createConnection.call(this, origin, computedOptions);
            computedOptions.createConnection = () => socket;
            const session = http2.connect(origin, computedOptions);
            session[kCurrentStreamCount] = 0;
            session[kGracefullyClosing] = false;
            const getOriginSet = () => {
              const { socket: socket2 } = session;
              let originSet;
              if (socket2.servername === false) {
                socket2.servername = socket2.remoteAddress;
                originSet = session.originSet;
                socket2.servername = false;
              } else {
                originSet = session.originSet;
              }
              return originSet;
            };
            const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;
            session.socket.once("session", (tlsSession) => {
              this.tlsSessionCache.set(name, tlsSession);
            });
            session.once("error", (error) => {
              for (let index = 0;index < listeners.length; index++) {
                listeners[index].reject(error);
              }
              this.tlsSessionCache.delete(name);
            });
            session.setTimeout(this.timeout, () => {
              session.destroy();
            });
            session.once("close", () => {
              this._sessionCount--;
              if (receivedSettings) {
                this._emptySessionCount--;
                const where = this.sessions[normalizedOptions];
                if (where.length === 1) {
                  delete this.sessions[normalizedOptions];
                } else {
                  where.splice(where.indexOf(session), 1);
                }
              } else {
                removeFromQueue();
                const error = new Error("Session closed without receiving a SETTINGS frame");
                error.code = "HTTP2WRAPPER_NOSETTINGS";
                for (let index = 0;index < listeners.length; index++) {
                  listeners[index].reject(error);
                }
              }
              this._processQueue();
            });
            const processListeners = () => {
              const queue = this.queue[normalizedOptions];
              if (!queue) {
                return;
              }
              const originSet = session[kOriginSet];
              for (let index = 0;index < originSet.length; index++) {
                const origin2 = originSet[index];
                if (origin2 in queue) {
                  const { listeners: listeners2, completed } = queue[origin2];
                  let index2 = 0;
                  while (index2 < listeners2.length && isFree()) {
                    listeners2[index2].resolve(session);
                    index2++;
                  }
                  queue[origin2].listeners.splice(0, index2);
                  if (queue[origin2].listeners.length === 0 && !completed) {
                    delete queue[origin2];
                    if (--queue[kLength] === 0) {
                      delete this.queue[normalizedOptions];
                      break;
                    }
                  }
                  if (!isFree()) {
                    break;
                  }
                }
              }
            };
            session.on("origin", () => {
              session[kOriginSet] = getOriginSet() || [];
              session[kGracefullyClosing] = false;
              closeSessionIfCovered(this.sessions[normalizedOptions], session);
              if (session[kGracefullyClosing] || !isFree()) {
                return;
              }
              processListeners();
              if (!isFree()) {
                return;
              }
              closeCoveredSessions(this.sessions[normalizedOptions], session);
            });
            session.once("remoteSettings", () => {
              if (entry.destroyed) {
                const error = new Error("Agent has been destroyed");
                for (let index = 0;index < listeners.length; index++) {
                  listeners[index].reject(error);
                }
                session.destroy();
                return;
              }
              if (session.setLocalWindowSize) {
                session.setLocalWindowSize(1024 * 1024 * 4);
              }
              session[kOriginSet] = getOriginSet() || [];
              if (session.socket.encrypted) {
                const mainOrigin = session[kOriginSet][0];
                if (mainOrigin !== normalizedOrigin) {
                  const error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                  for (let index = 0;index < listeners.length; index++) {
                    listeners[index].reject(error);
                  }
                  session.destroy();
                  return;
                }
              }
              removeFromQueue();
              {
                const where = this.sessions;
                if (normalizedOptions in where) {
                  const sessions = where[normalizedOptions];
                  sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                } else {
                  where[normalizedOptions] = [session];
                }
              }
              receivedSettings = true;
              this._emptySessionCount++;
              this.emit("session", session);
              this._accept(session, listeners, normalizedOrigin, options);
              if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {
                this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
              }
              session.on("remoteSettings", () => {
                if (!isFree()) {
                  return;
                }
                processListeners();
                if (!isFree()) {
                  return;
                }
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
            });
            session[kRequest] = session.request;
            session.request = (headers, streamOptions) => {
              if (session[kGracefullyClosing]) {
                throw new Error("The session is gracefully closing. No new streams are allowed.");
              }
              const stream2 = session[kRequest](headers, streamOptions);
              session.ref();
              if (session[kCurrentStreamCount]++ === 0) {
                this._emptySessionCount--;
              }
              stream2.once("close", () => {
                if (--session[kCurrentStreamCount] === 0) {
                  this._emptySessionCount++;
                  session.unref();
                  if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {
                    session.close();
                    return;
                  }
                }
                if (session.destroyed || session.closed) {
                  return;
                }
                if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                  processListeners();
                  if (session[kCurrentStreamCount] === 0) {
                    this._processQueue();
                  }
                }
              });
              return stream2;
            };
          } catch (error) {
            removeFromQueue();
            this._sessionCount--;
            for (let index = 0;index < listeners.length; index++) {
              listeners[index].reject(error);
            }
          }
        };
        entry.listeners = listeners;
        entry.completed = false;
        entry.destroyed = false;
        this.queue[normalizedOptions][normalizedOrigin] = entry;
        this.queue[normalizedOptions][kLength]++;
        this._processQueue();
      });
    }
    request(origin, options, headers, streamOptions) {
      return new Promise((resolve, reject) => {
        this.getSession(origin, options, [{
          reject,
          resolve: (session) => {
            try {
              const stream2 = session.request(headers, streamOptions);
              delayAsyncDestroy(stream2);
              resolve(stream2);
            } catch (error) {
              reject(error);
            }
          }
        }]);
      });
    }
    async createConnection(origin, options) {
      return Agent.connect(origin, options);
    }
    static connect(origin, options) {
      options.ALPNProtocols = ["h2"];
      const port = origin.port || 443;
      const host = origin.hostname;
      if (typeof options.servername === "undefined") {
        options.servername = host;
      }
      const socket = tls.connect(port, host, options);
      if (options.socket) {
        socket._peername = {
          family: undefined,
          address: undefined,
          port
        };
      }
      return socket;
    }
    closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
      let closedCount = 0;
      const { sessions } = this;
      for (const key in sessions) {
        const thisSessions = sessions[key];
        for (let index = 0;index < thisSessions.length; index++) {
          const session = thisSessions[index];
          if (session[kCurrentStreamCount] === 0) {
            closedCount++;
            session.close();
            if (closedCount >= maxCount) {
              return closedCount;
            }
          }
        }
      }
      return closedCount;
    }
    destroy(reason) {
      const { sessions, queue } = this;
      for (const key in sessions) {
        const thisSessions = sessions[key];
        for (let index = 0;index < thisSessions.length; index++) {
          thisSessions[index].destroy(reason);
        }
      }
      for (const normalizedOptions in queue) {
        const entries2 = queue[normalizedOptions];
        for (const normalizedOrigin in entries2) {
          entries2[normalizedOrigin].destroyed = true;
        }
      }
      this.queue = {};
      this.tlsSessionCache.clear();
    }
    get emptySessionCount() {
      return this._emptySessionCount;
    }
    get pendingSessionCount() {
      return this._sessionCount - this._emptySessionCount;
    }
    get sessionCount() {
      return this._sessionCount;
    }
  }
  Agent.kCurrentStreamCount = kCurrentStreamCount;
  Agent.kGracefullyClosing = kGracefullyClosing;
  module.exports = {
    Agent,
    globalAgent: new Agent
  };
});

// node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS((exports, module) => {
  var { Readable } = __require("stream");

  class IncomingMessage extends Readable {
    constructor(socket, highWaterMark) {
      super({
        emitClose: false,
        autoDestroy: true,
        highWaterMark
      });
      this.statusCode = null;
      this.statusMessage = "";
      this.httpVersion = "2.0";
      this.httpVersionMajor = 2;
      this.httpVersionMinor = 0;
      this.headers = {};
      this.trailers = {};
      this.req = null;
      this.aborted = false;
      this.complete = false;
      this.upgrade = null;
      this.rawHeaders = [];
      this.rawTrailers = [];
      this.socket = socket;
      this._dumped = false;
    }
    get connection() {
      return this.socket;
    }
    set connection(value) {
      this.socket = value;
    }
    _destroy(error, callback) {
      if (!this.readableEnded) {
        this.aborted = true;
      }
      callback();
      this.req._request.destroy(error);
    }
    setTimeout(ms, callback) {
      this.req.setTimeout(ms, callback);
      return this;
    }
    _dump() {
      if (!this._dumped) {
        this._dumped = true;
        this.removeAllListeners("data");
        this.resume();
      }
    }
    _read() {
      if (this.req) {
        this.req._request.resume();
      }
    }
  }
  module.exports = IncomingMessage;
});

// node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS((exports, module) => {
  module.exports = (from, to, events) => {
    for (const event of events) {
      from.on(event, (...args) => to.emit(event, ...args));
    }
  };
});

// node_modules/http2-wrapper/source/utils/errors.js
var require_errors3 = __commonJS((exports, module) => {
  var makeError = (Base, key, getMessage) => {
    exports[key] = class NodeError extends Base {
      constructor(...args) {
        super(typeof getMessage === "string" ? getMessage : getMessage(args));
        this.name = `${super.name} [${key}]`;
        this.code = key;
      }
    };
  };
  makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
    const type = args[0].includes(".") ? "property" : "argument";
    let valid = args[1];
    const isManyTypes = Array.isArray(valid);
    if (isManyTypes) {
      valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
    }
    return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
  });
  makeError(TypeError, "ERR_INVALID_PROTOCOL", (args) => `Protocol "${args[0]}" not supported. Expected "${args[1]}"`);
  makeError(Error, "ERR_HTTP_HEADERS_SENT", (args) => `Cannot ${args[0]} headers after they are sent to the client`);
  makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => `${args[0]} must be a valid HTTP token [${args[1]}]`);
  makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => `Invalid value "${args[0]} for header "${args[1]}"`);
  makeError(TypeError, "ERR_INVALID_CHAR", (args) => `Invalid character in ${args[0]} [${args[1]}]`);
  makeError(Error, "ERR_HTTP2_NO_SOCKET_MANIPULATION", "HTTP/2 sockets should not be directly manipulated (e.g. read and written)");
});

// node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS((exports, module) => {
  module.exports = (header) => {
    switch (header) {
      case ":method":
      case ":scheme":
      case ":authority":
      case ":path":
        return true;
      default:
        return false;
    }
  };
});

// node_modules/http2-wrapper/source/utils/validate-header-name.js
var require_validate_header_name = __commonJS((exports, module) => {
  var { ERR_INVALID_HTTP_TOKEN } = require_errors3();
  var isRequestPseudoHeader = require_is_request_pseudo_header();
  var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
  module.exports = (name) => {
    if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
      throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
    }
  };
});

// node_modules/http2-wrapper/source/utils/validate-header-value.js
var require_validate_header_value = __commonJS((exports, module) => {
  var {
    ERR_HTTP_INVALID_HEADER_VALUE,
    ERR_INVALID_CHAR
  } = require_errors3();
  var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
  module.exports = (name, value) => {
    if (typeof value === "undefined") {
      throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
    }
    if (isInvalidHeaderValue.test(value)) {
      throw new ERR_INVALID_CHAR("header content", name);
    }
  };
});

// node_modules/http2-wrapper/source/utils/proxy-socket-handler.js
var require_proxy_socket_handler = __commonJS((exports, module) => {
  var { ERR_HTTP2_NO_SOCKET_MANIPULATION } = require_errors3();
  var proxySocketHandler = {
    has(stream2, property) {
      const reference = stream2.session === undefined ? stream2 : stream2.session.socket;
      return (property in stream2) || (property in reference);
    },
    get(stream2, property) {
      switch (property) {
        case "on":
        case "once":
        case "end":
        case "emit":
        case "destroy":
          return stream2[property].bind(stream2);
        case "writable":
        case "destroyed":
          return stream2[property];
        case "readable":
          if (stream2.destroyed) {
            return false;
          }
          return stream2.readable;
        case "setTimeout": {
          const { session } = stream2;
          if (session !== undefined) {
            return session.setTimeout.bind(session);
          }
          return stream2.setTimeout.bind(stream2);
        }
        case "write":
        case "read":
        case "pause":
        case "resume":
          throw new ERR_HTTP2_NO_SOCKET_MANIPULATION;
        default: {
          const reference = stream2.session === undefined ? stream2 : stream2.session.socket;
          const value = reference[property];
          return typeof value === "function" ? value.bind(reference) : value;
        }
      }
    },
    getPrototypeOf(stream2) {
      if (stream2.session !== undefined) {
        return Reflect.getPrototypeOf(stream2.session.socket);
      }
      return Reflect.getPrototypeOf(stream2);
    },
    set(stream2, property, value) {
      switch (property) {
        case "writable":
        case "readable":
        case "destroyed":
        case "on":
        case "once":
        case "end":
        case "emit":
        case "destroy":
          stream2[property] = value;
          return true;
        case "setTimeout": {
          const { session } = stream2;
          if (session === undefined) {
            stream2.setTimeout = value;
          } else {
            session.setTimeout = value;
          }
          return true;
        }
        case "write":
        case "read":
        case "pause":
        case "resume":
          throw new ERR_HTTP2_NO_SOCKET_MANIPULATION;
        default: {
          const reference = stream2.session === undefined ? stream2 : stream2.session.socket;
          reference[property] = value;
          return true;
        }
      }
    }
  };
  module.exports = proxySocketHandler;
});

// node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS((exports, module) => {
  var { URL: URL2, urlToHttpOptions } = __require("url");
  var http2 = __require("http2");
  var { Writable } = __require("stream");
  var { Agent, globalAgent } = require_agent();
  var IncomingMessage = require_incoming_message();
  var proxyEvents2 = require_proxy_events();
  var {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_PROTOCOL,
    ERR_HTTP_HEADERS_SENT
  } = require_errors3();
  var validateHeaderName = require_validate_header_name();
  var validateHeaderValue = require_validate_header_value();
  var proxySocketHandler = require_proxy_socket_handler();
  var {
    HTTP2_HEADER_STATUS,
    HTTP2_HEADER_METHOD,
    HTTP2_HEADER_PATH,
    HTTP2_HEADER_AUTHORITY,
    HTTP2_METHOD_CONNECT
  } = http2.constants;
  var kHeaders = Symbol("headers");
  var kOrigin = Symbol("origin");
  var kSession = Symbol("session");
  var kOptions = Symbol("options");
  var kFlushedHeaders = Symbol("flushedHeaders");
  var kJobs = Symbol("jobs");
  var kPendingAgentPromise = Symbol("pendingAgentPromise");

  class ClientRequest extends Writable {
    constructor(input, options, callback) {
      super({
        autoDestroy: false,
        emitClose: false
      });
      if (typeof input === "string") {
        input = urlToHttpOptions(new URL2(input));
      } else if (input instanceof URL2) {
        input = urlToHttpOptions(input);
      } else {
        input = { ...input };
      }
      if (typeof options === "function" || options === undefined) {
        callback = options;
        options = input;
      } else {
        options = Object.assign(input, options);
      }
      if (options.h2session) {
        this[kSession] = options.h2session;
        if (this[kSession].destroyed) {
          throw new Error("The session has been closed already");
        }
        this.protocol = this[kSession].socket.encrypted ? "https:" : "http:";
      } else if (options.agent === false) {
        this.agent = new Agent({ maxEmptySessions: 0 });
      } else if (typeof options.agent === "undefined" || options.agent === null) {
        this.agent = globalAgent;
      } else if (typeof options.agent.request === "function") {
        this.agent = options.agent;
      } else {
        throw new ERR_INVALID_ARG_TYPE("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], options.agent);
      }
      if (this.agent) {
        this.protocol = this.agent.protocol;
      }
      if (options.protocol && options.protocol !== this.protocol) {
        throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
      }
      if (!options.port) {
        options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;
      }
      options.host = options.hostname || options.host || "localhost";
      delete options.hostname;
      const { timeout } = options;
      options.timeout = undefined;
      this[kHeaders] = Object.create(null);
      this[kJobs] = [];
      this[kPendingAgentPromise] = undefined;
      this.socket = null;
      this.connection = null;
      this.method = options.method || "GET";
      if (!(this.method === "CONNECT" && (options.path === "/" || options.path === undefined))) {
        this.path = options.path;
      }
      this.res = null;
      this.aborted = false;
      this.reusedSocket = false;
      const { headers } = options;
      if (headers) {
        for (const header in headers) {
          this.setHeader(header, headers[header]);
        }
      }
      if (options.auth && !("authorization" in this[kHeaders])) {
        this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
      }
      options.session = options.tlsSession;
      options.path = options.socketPath;
      this[kOptions] = options;
      this[kOrigin] = new URL2(`${this.protocol}//${options.servername || options.host}:${options.port}`);
      const reuseSocket = options._reuseSocket;
      if (reuseSocket) {
        options.createConnection = (...args) => {
          if (reuseSocket.destroyed) {
            return this.agent.createConnection(...args);
          }
          return reuseSocket;
        };
        this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {
        });
      }
      if (timeout) {
        this.setTimeout(timeout);
      }
      if (callback) {
        this.once("response", callback);
      }
      this[kFlushedHeaders] = false;
    }
    get method() {
      return this[kHeaders][HTTP2_HEADER_METHOD];
    }
    set method(value) {
      if (value) {
        this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
      }
    }
    get path() {
      const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
      return this[kHeaders][header];
    }
    set path(value) {
      if (value) {
        const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
        this[kHeaders][header] = value;
      }
    }
    get host() {
      return this[kOrigin].hostname;
    }
    set host(_value) {
    }
    get _mustNotHaveABody() {
      return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
    }
    _write(chunk, encoding, callback) {
      if (this._mustNotHaveABody) {
        callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
        return;
      }
      this.flushHeaders();
      const callWrite = () => this._request.write(chunk, encoding, callback);
      if (this._request) {
        callWrite();
      } else {
        this[kJobs].push(callWrite);
      }
    }
    _final(callback) {
      this.flushHeaders();
      const callEnd = () => {
        if (this._mustNotHaveABody || this.method === "CONNECT") {
          callback();
          return;
        }
        this._request.end(callback);
      };
      if (this._request) {
        callEnd();
      } else {
        this[kJobs].push(callEnd);
      }
    }
    abort() {
      if (this.res && this.res.complete) {
        return;
      }
      if (!this.aborted) {
        process.nextTick(() => this.emit("abort"));
      }
      this.aborted = true;
      this.destroy();
    }
    async _destroy(error, callback) {
      if (this.res) {
        this.res._dump();
      }
      if (this._request) {
        this._request.destroy();
      } else {
        process.nextTick(() => {
          this.emit("close");
        });
      }
      try {
        await this[kPendingAgentPromise];
      } catch (internalError) {
        if (this.aborted) {
          error = internalError;
        }
      }
      callback(error);
    }
    async flushHeaders() {
      if (this[kFlushedHeaders] || this.destroyed) {
        return;
      }
      this[kFlushedHeaders] = true;
      const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
      const onStream = (stream2) => {
        this._request = stream2;
        if (this.destroyed) {
          stream2.destroy();
          return;
        }
        if (!isConnectMethod) {
          proxyEvents2(stream2, this, ["timeout", "continue"]);
        }
        stream2.once("error", (error) => {
          this.destroy(error);
        });
        stream2.once("aborted", () => {
          const { res } = this;
          if (res) {
            res.aborted = true;
            res.emit("aborted");
            res.destroy();
          } else {
            this.destroy(new Error("The server aborted the HTTP/2 stream"));
          }
        });
        const onResponse = (headers, flags, rawHeaders) => {
          const response = new IncomingMessage(this.socket, stream2.readableHighWaterMark);
          this.res = response;
          response.url = `${this[kOrigin].origin}${this.path}`;
          response.req = this;
          response.statusCode = headers[HTTP2_HEADER_STATUS];
          response.headers = headers;
          response.rawHeaders = rawHeaders;
          response.once("end", () => {
            response.complete = true;
            response.socket = null;
            response.connection = null;
          });
          if (isConnectMethod) {
            response.upgrade = true;
            if (this.emit("connect", response, stream2, Buffer.alloc(0))) {
              this.emit("close");
            } else {
              stream2.destroy();
            }
          } else {
            stream2.on("data", (chunk) => {
              if (!response._dumped && !response.push(chunk)) {
                stream2.pause();
              }
            });
            stream2.once("end", () => {
              if (!this.aborted) {
                response.push(null);
              }
            });
            if (!this.emit("response", response)) {
              response._dump();
            }
          }
        };
        stream2.once("response", onResponse);
        stream2.once("headers", (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] }));
        stream2.once("trailers", (trailers, flags, rawTrailers) => {
          const { res } = this;
          if (res === null) {
            onResponse(trailers, flags, rawTrailers);
            return;
          }
          res.trailers = trailers;
          res.rawTrailers = rawTrailers;
        });
        stream2.once("close", () => {
          const { aborted, res } = this;
          if (res) {
            if (aborted) {
              res.aborted = true;
              res.emit("aborted");
              res.destroy();
            }
            const finish = () => {
              res.emit("close");
              this.destroy();
              this.emit("close");
            };
            if (res.readable) {
              res.once("end", finish);
            } else {
              finish();
            }
            return;
          }
          if (!this.destroyed) {
            this.destroy(new Error("The HTTP/2 stream has been early terminated"));
            this.emit("close");
            return;
          }
          this.destroy();
          this.emit("close");
        });
        this.socket = new Proxy(stream2, proxySocketHandler);
        for (const job of this[kJobs]) {
          job();
        }
        this[kJobs].length = 0;
        this.emit("socket", this.socket);
      };
      if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {
        this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;
      }
      if (this[kSession]) {
        try {
          onStream(this[kSession].request(this[kHeaders]));
        } catch (error) {
          this.destroy(error);
        }
      } else {
        this.reusedSocket = true;
        try {
          const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
          this[kPendingAgentPromise] = promise;
          onStream(await promise);
          this[kPendingAgentPromise] = false;
        } catch (error) {
          this[kPendingAgentPromise] = false;
          this.destroy(error);
        }
      }
    }
    get connection() {
      return this.socket;
    }
    set connection(value) {
      this.socket = value;
    }
    getHeaderNames() {
      return Object.keys(this[kHeaders]);
    }
    hasHeader(name) {
      if (typeof name !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", name);
      }
      return Boolean(this[kHeaders][name.toLowerCase()]);
    }
    getHeader(name) {
      if (typeof name !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", name);
      }
      return this[kHeaders][name.toLowerCase()];
    }
    get headersSent() {
      return this[kFlushedHeaders];
    }
    removeHeader(name) {
      if (typeof name !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", name);
      }
      if (this.headersSent) {
        throw new ERR_HTTP_HEADERS_SENT("remove");
      }
      delete this[kHeaders][name.toLowerCase()];
    }
    setHeader(name, value) {
      if (this.headersSent) {
        throw new ERR_HTTP_HEADERS_SENT("set");
      }
      validateHeaderName(name);
      validateHeaderValue(name, value);
      const lowercased = name.toLowerCase();
      if (lowercased === "connection") {
        if (value.toLowerCase() === "keep-alive") {
          return;
        }
        throw new Error(`Invalid 'connection' header: ${value}`);
      }
      if (lowercased === "host" && this.method === "CONNECT") {
        this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;
      } else {
        this[kHeaders][lowercased] = value;
      }
    }
    setNoDelay() {
    }
    setSocketKeepAlive() {
    }
    setTimeout(ms, callback) {
      const applyTimeout = () => this._request.setTimeout(ms, callback);
      if (this._request) {
        applyTimeout();
      } else {
        this[kJobs].push(applyTimeout);
      }
      return this;
    }
    get maxHeadersCount() {
      if (!this.destroyed && this._request) {
        return this._request.session.localSettings.maxHeaderListSize;
      }
      return;
    }
    set maxHeadersCount(_value) {
    }
  }
  module.exports = ClientRequest;
});

// node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS((exports, module) => {
  var tls = __require("tls");
  module.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
    let timeout = false;
    let socket;
    const callback = async () => {
      await socketPromise;
      socket.off("timeout", onTimeout);
      socket.off("error", reject);
      if (options.resolveSocket) {
        resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
        if (timeout) {
          await Promise.resolve();
          socket.emit("timeout");
        }
      } else {
        socket.destroy();
        resolve({ alpnProtocol: socket.alpnProtocol, timeout });
      }
    };
    const onTimeout = async () => {
      timeout = true;
      callback();
    };
    const socketPromise = (async () => {
      try {
        socket = await connect(options, callback);
        socket.on("error", reject);
        socket.once("timeout", onTimeout);
      } catch (error) {
        reject(error);
      }
    })();
  });
});

// node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS((exports, module) => {
  var { isIP } = __require("net");
  var assert2 = __require("assert");
  var getHost = (host) => {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert2(idx2 !== -1);
      return host.slice(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1) {
      return host;
    }
    return host.slice(0, idx);
  };
  module.exports = (host) => {
    const servername = getHost(host);
    if (isIP(servername)) {
      return "";
    }
    return servername;
  };
});

// node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS((exports, module) => {
  var { URL: URL2, urlToHttpOptions } = __require("url");
  var http = __require("http");
  var https = __require("https");
  var resolveALPN = require_resolve_alpn();
  var QuickLRU = require_quick_lru();
  var { Agent, globalAgent } = require_agent();
  var Http2ClientRequest = require_client_request();
  var calculateServerName = require_calculate_server_name();
  var delayAsyncDestroy = require_delay_async_destroy();
  var cache = new QuickLRU({ maxSize: 100 });
  var queue = new Map;
  var installSocket = (agent, socket, options) => {
    socket._httpMessage = { shouldKeepAlive: true };
    const onFree = () => {
      agent.emit("free", socket, options);
    };
    socket.on("free", onFree);
    const onClose = () => {
      agent.removeSocket(socket, options);
    };
    socket.on("close", onClose);
    const onTimeout = () => {
      const { freeSockets } = agent;
      for (const sockets of Object.values(freeSockets)) {
        if (sockets.includes(socket)) {
          socket.destroy();
          return;
        }
      }
    };
    socket.on("timeout", onTimeout);
    const onRemove = () => {
      agent.removeSocket(socket, options);
      socket.off("close", onClose);
      socket.off("free", onFree);
      socket.off("timeout", onTimeout);
      socket.off("agentRemove", onRemove);
    };
    socket.on("agentRemove", onRemove);
    agent.emit("free", socket, options);
  };
  var createResolveProtocol = (cache2, queue2 = new Map, connect = undefined) => {
    return async (options) => {
      const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
      if (!cache2.has(name)) {
        if (queue2.has(name)) {
          const result = await queue2.get(name);
          return { alpnProtocol: result.alpnProtocol };
        }
        const { path } = options;
        options.path = options.socketPath;
        const resultPromise = resolveALPN(options, connect);
        queue2.set(name, resultPromise);
        try {
          const result = await resultPromise;
          cache2.set(name, result.alpnProtocol);
          queue2.delete(name);
          options.path = path;
          return result;
        } catch (error) {
          queue2.delete(name);
          options.path = path;
          throw error;
        }
      }
      return { alpnProtocol: cache2.get(name) };
    };
  };
  var defaultResolveProtocol = createResolveProtocol(cache, queue);
  module.exports = async (input, options, callback) => {
    if (typeof input === "string") {
      input = urlToHttpOptions(new URL2(input));
    } else if (input instanceof URL2) {
      input = urlToHttpOptions(input);
    } else {
      input = { ...input };
    }
    if (typeof options === "function" || options === undefined) {
      callback = options;
      options = input;
    } else {
      options = Object.assign(input, options);
    }
    options.ALPNProtocols = options.ALPNProtocols || ["h2", "http/1.1"];
    if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
      throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
    }
    options.protocol = options.protocol || "https:";
    const isHttps = options.protocol === "https:";
    options.host = options.hostname || options.host || "localhost";
    options.session = options.tlsSession;
    options.servername = options.servername || calculateServerName(options.headers && options.headers.host || options.host);
    options.port = options.port || (isHttps ? 443 : 80);
    options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;
    const resolveProtocol = options.resolveProtocol || defaultResolveProtocol;
    let { agent } = options;
    if (agent !== undefined && agent !== false && agent.constructor.name !== "Object") {
      throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
    }
    if (isHttps) {
      options.resolveSocket = true;
      let { socket, alpnProtocol, timeout } = await resolveProtocol(options);
      if (timeout) {
        if (socket) {
          socket.destroy();
        }
        const error = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
        error.code = "ETIMEDOUT";
        error.ms = options.timeout;
        throw error;
      }
      if (socket && options.createConnection) {
        socket.destroy();
        socket = undefined;
      }
      delete options.resolveSocket;
      const isHttp2 = alpnProtocol === "h2";
      if (agent) {
        agent = isHttp2 ? agent.http2 : agent.https;
        options.agent = agent;
      }
      if (agent === undefined) {
        agent = isHttp2 ? globalAgent : https.globalAgent;
      }
      if (socket) {
        if (agent === false) {
          socket.destroy();
        } else {
          const defaultCreateConnection = (isHttp2 ? Agent : https.Agent).prototype.createConnection;
          if (agent.createConnection === defaultCreateConnection) {
            if (isHttp2) {
              options._reuseSocket = socket;
            } else {
              installSocket(agent, socket, options);
            }
          } else {
            socket.destroy();
          }
        }
      }
      if (isHttp2) {
        return delayAsyncDestroy(new Http2ClientRequest(options, callback));
      }
    } else if (agent) {
      options.agent = agent.http;
    }
    return delayAsyncDestroy(http.request(options, callback));
  };
  module.exports.protocolCache = cache;
  module.exports.resolveProtocol = defaultResolveProtocol;
  module.exports.createResolveProtocol = createResolveProtocol;
});

// node_modules/http2-wrapper/source/utils/js-stream-socket.js
var require_js_stream_socket = __commonJS((exports, module) => {
  var stream2 = __require("stream");
  var tls = __require("tls");
  var JSStreamSocket = new tls.TLSSocket(new stream2.PassThrough)._handle._parentWrap.constructor;
  module.exports = JSStreamSocket;
});

// node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js
var require_unexpected_status_code_error = __commonJS((exports, module) => {
  class UnexpectedStatusCodeError extends Error {
    constructor(statusCode, statusMessage = "") {
      super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || "empty status message"})`);
      this.statusCode = statusCode;
      this.statusMessage = statusMessage;
    }
  }
  module.exports = UnexpectedStatusCodeError;
});

// node_modules/http2-wrapper/source/utils/check-type.js
var require_check_type = __commonJS((exports, module) => {
  var checkType = (name, value, types4) => {
    const valid = types4.some((type) => {
      const typeofType = typeof type;
      if (typeofType === "string") {
        return typeof value === type;
      }
      return value instanceof type;
    });
    if (!valid) {
      const names = types4.map((type) => typeof type === "string" ? type : type.name);
      throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
    }
  };
  module.exports = checkType;
});

// node_modules/http2-wrapper/source/proxies/initialize.js
var require_initialize = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("url");
  var checkType = require_check_type();
  module.exports = (self2, proxyOptions) => {
    checkType("proxyOptions", proxyOptions, ["object"]);
    checkType("proxyOptions.headers", proxyOptions.headers, ["object", "undefined"]);
    checkType("proxyOptions.raw", proxyOptions.raw, ["boolean", "undefined"]);
    checkType("proxyOptions.url", proxyOptions.url, [URL2, "string"]);
    const url = new URL2(proxyOptions.url);
    self2.proxyOptions = {
      raw: true,
      ...proxyOptions,
      headers: { ...proxyOptions.headers },
      url
    };
  };
});

// node_modules/http2-wrapper/source/proxies/get-auth-headers.js
var require_get_auth_headers = __commonJS((exports, module) => {
  module.exports = (self2) => {
    const { username, password } = self2.proxyOptions.url;
    if (username || password) {
      const data = `${username}:${password}`;
      const authorization = `Basic ${Buffer.from(data).toString("base64")}`;
      return {
        "proxy-authorization": authorization,
        authorization
      };
    }
    return {};
  };
});

// node_modules/http2-wrapper/source/proxies/h1-over-h2.js
var require_h1_over_h2 = __commonJS((exports, module) => {
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var JSStreamSocket = require_js_stream_socket();
  var { globalAgent } = require_agent();
  var UnexpectedStatusCodeError = require_unexpected_status_code_error();
  var initialize = require_initialize();
  var getAuthorizationHeaders = require_get_auth_headers();
  var createConnection = (self2, options, callback) => {
    (async () => {
      try {
        const { proxyOptions } = self2;
        const { url, headers, raw } = proxyOptions;
        const stream2 = await globalAgent.request(url, proxyOptions, {
          ...getAuthorizationHeaders(self2),
          ...headers,
          ":method": "CONNECT",
          ":authority": `${options.host}:${options.port}`
        });
        stream2.once("error", callback);
        stream2.once("response", (headers2) => {
          const statusCode = headers2[":status"];
          if (statusCode !== 200) {
            callback(new UnexpectedStatusCodeError(statusCode, ""));
            return;
          }
          const encrypted = self2 instanceof https.Agent;
          if (raw && encrypted) {
            options.socket = stream2;
            const secureStream = tls.connect(options);
            secureStream.once("close", () => {
              stream2.destroy();
            });
            callback(null, secureStream);
            return;
          }
          const socket = new JSStreamSocket(stream2);
          socket.encrypted = false;
          socket._handle.getpeername = (out) => {
            out.family = undefined;
            out.address = undefined;
            out.port = undefined;
          };
          callback(null, socket);
        });
      } catch (error) {
        callback(error);
      }
    })();
  };

  class HttpOverHttp2 extends http.Agent {
    constructor(options) {
      super(options);
      initialize(this, options.proxyOptions);
    }
    createConnection(options, callback) {
      createConnection(this, options, callback);
    }
  }

  class HttpsOverHttp2 extends https.Agent {
    constructor(options) {
      super(options);
      initialize(this, options.proxyOptions);
    }
    createConnection(options, callback) {
      createConnection(this, options, callback);
    }
  }
  module.exports = {
    HttpOverHttp2,
    HttpsOverHttp2
  };
});

// node_modules/http2-wrapper/source/proxies/h2-over-hx.js
var require_h2_over_hx = __commonJS((exports, module) => {
  var { Agent } = require_agent();
  var JSStreamSocket = require_js_stream_socket();
  var UnexpectedStatusCodeError = require_unexpected_status_code_error();
  var initialize = require_initialize();

  class Http2OverHttpX extends Agent {
    constructor(options) {
      super(options);
      initialize(this, options.proxyOptions);
    }
    async createConnection(origin, options) {
      const authority = `${origin.hostname}:${origin.port || 443}`;
      const [stream2, statusCode, statusMessage] = await this._getProxyStream(authority);
      if (statusCode !== 200) {
        throw new UnexpectedStatusCodeError(statusCode, statusMessage);
      }
      if (this.proxyOptions.raw) {
        options.socket = stream2;
      } else {
        const socket = new JSStreamSocket(stream2);
        socket.encrypted = false;
        socket._handle.getpeername = (out) => {
          out.family = undefined;
          out.address = undefined;
          out.port = undefined;
        };
        return socket;
      }
      return super.createConnection(origin, options);
    }
  }
  module.exports = Http2OverHttpX;
});

// node_modules/http2-wrapper/source/proxies/h2-over-h2.js
var require_h2_over_h2 = __commonJS((exports, module) => {
  var { globalAgent } = require_agent();
  var Http2OverHttpX = require_h2_over_hx();
  var getAuthorizationHeaders = require_get_auth_headers();
  var getStatusCode = (stream2) => new Promise((resolve, reject) => {
    stream2.once("error", reject);
    stream2.once("response", (headers) => {
      stream2.off("error", reject);
      resolve(headers[":status"]);
    });
  });

  class Http2OverHttp2 extends Http2OverHttpX {
    async _getProxyStream(authority) {
      const { proxyOptions } = this;
      const headers = {
        ...getAuthorizationHeaders(this),
        ...proxyOptions.headers,
        ":method": "CONNECT",
        ":authority": authority
      };
      const stream2 = await globalAgent.request(proxyOptions.url, proxyOptions, headers);
      const statusCode = await getStatusCode(stream2);
      return [stream2, statusCode, ""];
    }
  }
  module.exports = Http2OverHttp2;
});

// node_modules/http2-wrapper/source/proxies/h2-over-h1.js
var require_h2_over_h1 = __commonJS((exports, module) => {
  var http = __require("http");
  var https = __require("https");
  var Http2OverHttpX = require_h2_over_hx();
  var getAuthorizationHeaders = require_get_auth_headers();
  var getStream2 = (request) => new Promise((resolve, reject) => {
    const onConnect = (response, socket, head) => {
      socket.unshift(head);
      request.off("error", reject);
      resolve([socket, response.statusCode, response.statusMessage]);
    };
    request.once("error", reject);
    request.once("connect", onConnect);
  });

  class Http2OverHttp extends Http2OverHttpX {
    async _getProxyStream(authority) {
      const { proxyOptions } = this;
      const { url, headers } = this.proxyOptions;
      const network = url.protocol === "https:" ? https : http;
      const request = network.request({
        ...proxyOptions,
        hostname: url.hostname,
        port: url.port,
        path: authority,
        headers: {
          ...getAuthorizationHeaders(this),
          ...headers,
          host: authority
        },
        method: "CONNECT"
      }).end();
      return getStream2(request);
    }
  }
  module.exports = {
    Http2OverHttp,
    Http2OverHttps: Http2OverHttp
  };
});

// node_modules/http2-wrapper/source/index.js
var require_source2 = __commonJS((exports, module) => {
  var http2 = __require("http2");
  var {
    Agent,
    globalAgent
  } = require_agent();
  var ClientRequest = require_client_request();
  var IncomingMessage = require_incoming_message();
  var auto = require_auto();
  var {
    HttpOverHttp2,
    HttpsOverHttp2
  } = require_h1_over_h2();
  var Http2OverHttp2 = require_h2_over_h2();
  var {
    Http2OverHttp,
    Http2OverHttps
  } = require_h2_over_h1();
  var validateHeaderName = require_validate_header_name();
  var validateHeaderValue = require_validate_header_value();
  var request = (url, options, callback) => new ClientRequest(url, options, callback);
  var get = (url, options, callback) => {
    const req = new ClientRequest(url, options, callback);
    req.end();
    return req;
  };
  module.exports = {
    ...http2,
    ClientRequest,
    IncomingMessage,
    Agent,
    globalAgent,
    request,
    get,
    auto,
    proxies: {
      HttpOverHttp2,
      HttpsOverHttp2,
      Http2OverHttp2,
      Http2OverHttp,
      Http2OverHttps
    },
    validateHeaderName,
    validateHeaderValue
  };
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS((exports) => {
  async function toBuffer(stream2) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream2) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  async function json(stream2) {
    const buf = await toBuffer(stream2);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  var req = function(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https2 : http3).request(url, opts);
    const promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http3 = __importStar(__require("http"));
  var https2 = __importStar(__require("https"));
  exports.toBuffer = toBuffer;
  exports.json = json;
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var http3 = __importStar(__require("http"));
  __exportStar(require_helpers(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http3.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options5) {
      if (options5) {
        if (typeof options5.secureEndpoint === "boolean") {
          return options5.secureEndpoint;
        }
        if (typeof options5.protocol === "string") {
          return options5.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    createSocket(req, options5, cb) {
      const connectOpts = {
        ...options5,
        secureEndpoint: this.isSecureEndpoint(options5)
      };
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        if (socket instanceof http3.Agent) {
          return socket.addRequest(req, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options5, cb);
      }, cb);
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var parseProxyResponse = function(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug2("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug2("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug2("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug2("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault(require_src());
  var debug2 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var resume = function(socket) {
    socket.resume();
  };
  var omit = function(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net2 = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_dist();
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug2 = (0, debug_1.default)("https-proxy-agent");

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug2("Creating `tls.Socket`: %o", this.connectOpts);
        const servername = this.connectOpts.servername || this.connectOpts.host;
        socket = tls.connect({
          ...this.connectOpts,
          servername: servername && net2.isIP(servername) ? undefined : servername
        });
      } else {
        debug2("Creating `net.Socket`: %o", this.connectOpts);
        socket = net2.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net2.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload2 = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload2 += `${name}: ${headers[name]}\r\n`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload2}\r\n`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug2("Upgrading socket connection to TLS");
          const servername = opts.servername || opts.host;
          return tls.connect({
            ...omit(opts, "host", "path", "port"),
            socket,
            servername: net2.isIP(servername) ? undefined : servername
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net2.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug2("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
});

// node_modules/bytes/index.js
var require_bytes = __commonJS((exports, module) => {
  var bytes = function(value, options5) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format(value, options5);
    }
    return null;
  };
  var format = function(value, options5) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options5 && options5.thousandsSeparator || "";
    var unitSeparator = options5 && options5.unitSeparator || "";
    var decimalPlaces = options5 && options5.decimalPlaces !== undefined ? options5.decimalPlaces : 2;
    var fixedDecimals = Boolean(options5 && options5.fixedDecimals);
    var unit = options5 && options5.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val2 = value / map[unit.toLowerCase()];
    var str = val2.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join(".");
    }
    return str + unitSeparator + unit;
  };
  var parse2 = function(val2) {
    if (typeof val2 === "number" && !isNaN(val2)) {
      return val2;
    }
    if (typeof val2 !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val2);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val2, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map[unit] * floatValue);
  };
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  module.exports = bytes;
  module.exports.format = format;
  module.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
});

// node_modules/format-duration/format-duration.js
var require_format_duration = __commonJS((exports, module) => {
  var parseMs = function(ms) {
    if (typeof ms !== "number") {
      throw new TypeError("Expected a number");
    }
    return {
      days: Math.trunc(ms / 86400000),
      hours: Math.trunc(ms / 3600000) % 24,
      minutes: Math.trunc(ms / 60000) % 60,
      seconds: Math.trunc(ms / 1000) % 60,
      ms: Math.trunc(ms) % 1000
    };
  };
  var addZero = function(value, digits) {
    digits = digits || 2;
    let str = value.toString();
    let size = 0;
    size = digits - str.length + 1;
    str = new Array(size).join("0").concat(str);
    return str;
  };
  var getSign = function(duration, showMs) {
    if (showMs)
      return duration < 0 ? "-" : "";
    return duration <= -1000 ? "-" : "";
  };
  var formatDuration = function(ms, options5) {
    const leading = options5 && options5.leading;
    const showMs = options5 && options5.ms;
    const unsignedMs = ms < 0 ? -ms : ms;
    const sign = getSign(ms, showMs);
    const t = parseMs(unsignedMs);
    const seconds = addZero(t.seconds);
    let output = "";
    if (t.days && !output)
      output = sign + t.days + ":" + addZero(t.hours) + ":" + addZero(t.minutes) + ":" + seconds;
    if (t.hours && !output)
      output = sign + (leading ? addZero(t.hours) : t.hours) + ":" + addZero(t.minutes) + ":" + seconds;
    if (!output)
      output = sign + (leading ? addZero(t.minutes) : t.minutes) + ":" + seconds;
    if (showMs)
      output += "." + addZero(t.ms, 3);
    return output;
  };
  module.exports = formatDuration;
});

// node_modules/console-control-strings/index.js
var require_console_control_strings = __commonJS((exports) => {
  var colorNameToCode = function(color) {
    if (colors[color] != null)
      return colors[color];
    throw new Error("Unknown color or style name: " + color);
  };
  var prefix = "\x1B[";
  exports.up = function up(num) {
    return prefix + (num || "") + "A";
  };
  exports.down = function down(num) {
    return prefix + (num || "") + "B";
  };
  exports.forward = function forward(num) {
    return prefix + (num || "") + "C";
  };
  exports.back = function back(num) {
    return prefix + (num || "") + "D";
  };
  exports.nextLine = function nextLine(num) {
    return prefix + (num || "") + "E";
  };
  exports.previousLine = function previousLine(num) {
    return prefix + (num || "") + "F";
  };
  exports.horizontalAbsolute = function horizontalAbsolute(num) {
    if (num == null)
      throw new Error("horizontalAboslute requires a column to position to");
    return prefix + num + "G";
  };
  exports.eraseData = function eraseData() {
    return prefix + "J";
  };
  exports.eraseLine = function eraseLine() {
    return prefix + "K";
  };
  exports.goto = function(x, y) {
    return prefix + y + ";" + x + "H";
  };
  exports.gotoSOL = function() {
    return "\r";
  };
  exports.beep = function() {
    return "\x07";
  };
  exports.hideCursor = function hideCursor() {
    return prefix + "?25l";
  };
  exports.showCursor = function showCursor() {
    return prefix + "?25h";
  };
  var colors = {
    reset: 0,
    bold: 1,
    italic: 3,
    underline: 4,
    inverse: 7,
    stopBold: 22,
    stopItalic: 23,
    stopUnderline: 24,
    stopInverse: 27,
    white: 37,
    black: 30,
    blue: 34,
    cyan: 36,
    green: 32,
    magenta: 35,
    red: 31,
    yellow: 33,
    bgWhite: 47,
    bgBlack: 40,
    bgBlue: 44,
    bgCyan: 46,
    bgGreen: 42,
    bgMagenta: 45,
    bgRed: 41,
    bgYellow: 43,
    grey: 90,
    brightBlack: 90,
    brightRed: 91,
    brightGreen: 92,
    brightYellow: 93,
    brightBlue: 94,
    brightMagenta: 95,
    brightCyan: 96,
    brightWhite: 97,
    bgGrey: 100,
    bgBrightBlack: 100,
    bgBrightRed: 101,
    bgBrightGreen: 102,
    bgBrightYellow: 103,
    bgBrightBlue: 104,
    bgBrightMagenta: 105,
    bgBrightCyan: 106,
    bgBrightWhite: 107
  };
  exports.color = function color(colorWith) {
    if (arguments.length !== 1 || !Array.isArray(colorWith)) {
      colorWith = Array.prototype.slice.call(arguments);
    }
    return prefix + colorWith.map(colorNameToCode).join(";") + "m";
  };
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0;i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// node_modules/wide-align/align.js
var require_align = __commonJS((exports) => {
  var createPadding = function(width) {
    var result = "";
    var string = " ";
    var n = width;
    do {
      if (n % 2) {
        result += string;
      }
      n = Math.floor(n / 2);
      string += string;
    } while (n);
    return result;
  };
  var alignLeft = function(str, width) {
    var trimmed = str.trimRight();
    if (trimmed.length === 0 && str.length >= width)
      return str;
    var padding = "";
    var strWidth = stringWidth(trimmed);
    if (strWidth < width) {
      padding = createPadding(width - strWidth);
    }
    return trimmed + padding;
  };
  var alignRight = function(str, width) {
    var trimmed = str.trimLeft();
    if (trimmed.length === 0 && str.length >= width)
      return str;
    var padding = "";
    var strWidth = stringWidth(trimmed);
    if (strWidth < width) {
      padding = createPadding(width - strWidth);
    }
    return padding + trimmed;
  };
  var alignCenter = function(str, width) {
    var trimmed = str.trim();
    if (trimmed.length === 0 && str.length >= width)
      return str;
    var padLeft = "";
    var padRight = "";
    var strWidth = stringWidth(trimmed);
    if (strWidth < width) {
      var padLeftBy = parseInt((width - strWidth) / 2, 10);
      padLeft = createPadding(padLeftBy);
      padRight = createPadding(width - (strWidth + padLeftBy));
    }
    return padLeft + trimmed + padRight;
  };
  var stringWidth = require_string_width();
  exports.center = alignCenter;
  exports.left = alignLeft;
  exports.right = alignRight;
});

// node_modules/aproba/index.js
var require_aproba = __commonJS((exports, module) => {
  var isArguments = function(thingy) {
    return thingy != null && typeof thingy === "object" && thingy.hasOwnProperty("callee");
  };
  var addSchema = function(schema, arity) {
    const group = arity[schema.length] = arity[schema.length] || [];
    if (group.indexOf(schema) === -1)
      group.push(schema);
  };
  var validate3 = function(rawSchemas, args) {
    if (arguments.length !== 2)
      throw wrongNumberOfArgs(["SA"], arguments.length);
    if (!rawSchemas)
      throw missingRequiredArg(0, "rawSchemas");
    if (!args)
      throw missingRequiredArg(1, "args");
    if (!types7.S.check(rawSchemas))
      throw invalidType(0, ["string"], rawSchemas);
    if (!types7.A.check(args))
      throw invalidType(1, ["array"], args);
    const schemas = rawSchemas.split("|");
    const arity = {};
    schemas.forEach((schema) => {
      for (let ii = 0;ii < schema.length; ++ii) {
        const type = schema[ii];
        if (!types7[type])
          throw unknownType(ii, type);
      }
      if (/E.*E/.test(schema))
        throw moreThanOneError(schema);
      addSchema(schema, arity);
      if (/E/.test(schema)) {
        addSchema(schema.replace(/E.*$/, "E"), arity);
        addSchema(schema.replace(/E/, "Z"), arity);
        if (schema.length === 1)
          addSchema("", arity);
      }
    });
    let matching = arity[args.length];
    if (!matching) {
      throw wrongNumberOfArgs(Object.keys(arity), args.length);
    }
    for (let ii = 0;ii < args.length; ++ii) {
      let newMatching = matching.filter((schema) => {
        const type = schema[ii];
        const typeCheck = types7[type].check;
        return typeCheck(args[ii]);
      });
      if (!newMatching.length) {
        const labels = matching.map((_) => types7[_[ii]].label).filter((_) => _ != null);
        throw invalidType(ii, labels, args[ii]);
      }
      matching = newMatching;
    }
  };
  var missingRequiredArg = function(num) {
    return newException("EMISSINGARG", "Missing required argument #" + (num + 1));
  };
  var unknownType = function(num, type) {
    return newException("EUNKNOWNTYPE", "Unknown type " + type + " in argument #" + (num + 1));
  };
  var invalidType = function(num, expectedTypes, value) {
    let valueType;
    Object.keys(types7).forEach((typeCode) => {
      if (types7[typeCode].check(value))
        valueType = types7[typeCode].label;
    });
    return newException("EINVALIDTYPE", "Argument #" + (num + 1) + ": Expected " + englishList(expectedTypes) + " but got " + valueType);
  };
  var englishList = function(list) {
    return list.join(", ").replace(/, ([^,]+)$/, " or $1");
  };
  var wrongNumberOfArgs = function(expected, got2) {
    const english = englishList(expected);
    const args = expected.every((ex) => ex.length === 1) ? "argument" : "arguments";
    return newException("EWRONGARGCOUNT", "Expected " + english + " " + args + " but got " + got2);
  };
  var moreThanOneError = function(schema) {
    return newException("ETOOMANYERRORTYPES", 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
  };
  var newException = function(code, msg) {
    const err = new Error(msg);
    err.code = code;
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, validate3);
    return err;
  };
  module.exports = validate3;
  var types7 = {
    "*": { label: "any", check: () => true },
    A: { label: "array", check: (_) => Array.isArray(_) || isArguments(_) },
    S: { label: "string", check: (_) => typeof _ === "string" },
    N: { label: "number", check: (_) => typeof _ === "number" },
    F: { label: "function", check: (_) => typeof _ === "function" },
    O: { label: "object", check: (_) => typeof _ === "object" && _ != null && !types7.A.check(_) && !types7.E.check(_) },
    B: { label: "boolean", check: (_) => typeof _ === "boolean" },
    E: { label: "error", check: (_) => _ instanceof Error },
    Z: { label: "null", check: (_) => _ == null }
  };
});

// node_modules/gauge/lib/wide-truncate.js
var require_wide_truncate = __commonJS((exports, module) => {
  var wideTruncate = function(str, target) {
    if (stringWidth(str) === 0) {
      return str;
    }
    if (target <= 0) {
      return "";
    }
    if (stringWidth(str) <= target) {
      return str;
    }
    var noAnsi = stripAnsi(str);
    var ansiSize = str.length + noAnsi.length;
    var truncated = str.slice(0, target + ansiSize);
    while (stringWidth(truncated) > target) {
      truncated = truncated.slice(0, -1);
    }
    return truncated;
  };
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  module.exports = wideTruncate;
});

// node_modules/gauge/lib/error.js
var require_error3 = __commonJS((exports) => {
  var util = __require("util");
  var User = exports.User = function User(msg) {
    var err = new Error(msg);
    Error.captureStackTrace(err, User);
    err.code = "EGAUGE";
    return err;
  };
  exports.MissingTemplateValue = function MissingTemplateValue(item, values) {
    var err = new User(util.format('Missing template value "%s"', item.type));
    Error.captureStackTrace(err, MissingTemplateValue);
    err.template = item;
    err.values = values;
    return err;
  };
  exports.Internal = function Internal(msg) {
    var err = new Error(msg);
    Error.captureStackTrace(err, Internal);
    err.code = "EGAUGEINTERNAL";
    return err;
  };
});

// node_modules/gauge/lib/template-item.js
var require_template_item = __commonJS((exports, module) => {
  var isPercent = function(num) {
    if (typeof num !== "string") {
      return false;
    }
    return num.slice(-1) === "%";
  };
  var percent = function(num) {
    return Number(num.slice(0, -1)) / 100;
  };
  var TemplateItem = function(values, outputLength) {
    this.overallOutputLength = outputLength;
    this.finished = false;
    this.type = null;
    this.value = null;
    this.length = null;
    this.maxLength = null;
    this.minLength = null;
    this.kerning = null;
    this.align = "left";
    this.padLeft = 0;
    this.padRight = 0;
    this.index = null;
    this.first = null;
    this.last = null;
    if (typeof values === "string") {
      this.value = values;
    } else {
      for (var prop in values) {
        this[prop] = values[prop];
      }
    }
    if (isPercent(this.length)) {
      this.length = Math.round(this.overallOutputLength * percent(this.length));
    }
    if (isPercent(this.minLength)) {
      this.minLength = Math.round(this.overallOutputLength * percent(this.minLength));
    }
    if (isPercent(this.maxLength)) {
      this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength));
    }
    return this;
  };
  var stringWidth = require_string_width();
  module.exports = TemplateItem;
  TemplateItem.prototype = {};
  TemplateItem.prototype.getBaseLength = function() {
    var length = this.length;
    if (length == null && typeof this.value === "string" && this.maxLength == null && this.minLength == null) {
      length = stringWidth(this.value);
    }
    return length;
  };
  TemplateItem.prototype.getLength = function() {
    var length = this.getBaseLength();
    if (length == null) {
      return null;
    }
    return length + this.padLeft + this.padRight;
  };
  TemplateItem.prototype.getMaxLength = function() {
    if (this.maxLength == null) {
      return null;
    }
    return this.maxLength + this.padLeft + this.padRight;
  };
  TemplateItem.prototype.getMinLength = function() {
    if (this.minLength == null) {
      return null;
    }
    return this.minLength + this.padLeft + this.padRight;
  };
});

// node_modules/gauge/lib/render-template.js
var require_render_template = __commonJS((exports, module) => {
  var renderValueWithValues = function(values) {
    return function(item) {
      return renderValue(item, values);
    };
  };
  var preType = function(item) {
    var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
    return "pre" + cappedTypeName;
  };
  var postType = function(item) {
    var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
    return "post" + cappedTypeName;
  };
  var hasPreOrPost = function(item, values) {
    if (!item.type) {
      return;
    }
    return values[preType(item)] || values[postType(item)];
  };
  var generatePreAndPost = function(baseItem, parentValues) {
    var item = Object.assign({}, baseItem);
    var values = Object.create(parentValues);
    var template = [];
    var pre = preType(item);
    var post = postType(item);
    if (values[pre]) {
      template.push({ value: values[pre] });
      values[pre] = null;
    }
    item.minLength = null;
    item.length = null;
    item.maxLength = null;
    template.push(item);
    values[item.type] = values[item.type];
    if (values[post]) {
      template.push({ value: values[post] });
      values[post] = null;
    }
    return function($1, $2, length) {
      return renderTemplate(length, template, values);
    };
  };
  var prepareItems = function(width, template, values) {
    function cloneAndObjectify(item, index, arr) {
      var cloned = new TemplateItem(item, width);
      var type = cloned.type;
      if (cloned.value == null) {
        if (!(type in values)) {
          if (cloned.default == null) {
            throw new error.MissingTemplateValue(cloned, values);
          } else {
            cloned.value = cloned.default;
          }
        } else {
          cloned.value = values[type];
        }
      }
      if (cloned.value == null || cloned.value === "") {
        return null;
      }
      cloned.index = index;
      cloned.first = index === 0;
      cloned.last = index === arr.length - 1;
      if (hasPreOrPost(cloned, values)) {
        cloned.value = generatePreAndPost(cloned, values);
      }
      return cloned;
    }
    var output = template.map(cloneAndObjectify).filter(function(item) {
      return item != null;
    });
    var remainingSpace = width;
    var variableCount = output.length;
    function consumeSpace(length) {
      if (length > remainingSpace) {
        length = remainingSpace;
      }
      remainingSpace -= length;
    }
    function finishSizing(item, length) {
      if (item.finished) {
        throw new error.Internal("Tried to finish template item that was already finished");
      }
      if (length === Infinity) {
        throw new error.Internal("Length of template item cannot be infinity");
      }
      if (length != null) {
        item.length = length;
      }
      item.minLength = null;
      item.maxLength = null;
      --variableCount;
      item.finished = true;
      if (item.length == null) {
        item.length = item.getBaseLength();
      }
      if (item.length == null) {
        throw new error.Internal("Finished template items must have a length");
      }
      consumeSpace(item.getLength());
    }
    output.forEach(function(item) {
      if (!item.kerning) {
        return;
      }
      var prevPadRight = item.first ? 0 : output[item.index - 1].padRight;
      if (!item.first && prevPadRight < item.kerning) {
        item.padLeft = item.kerning - prevPadRight;
      }
      if (!item.last) {
        item.padRight = item.kerning;
      }
    });
    output.forEach(function(item) {
      if (item.getBaseLength() == null) {
        return;
      }
      finishSizing(item);
    });
    var resized = 0;
    var resizing;
    var hunkSize;
    do {
      resizing = false;
      hunkSize = Math.round(remainingSpace / variableCount);
      output.forEach(function(item) {
        if (item.finished) {
          return;
        }
        if (!item.maxLength) {
          return;
        }
        if (item.getMaxLength() < hunkSize) {
          finishSizing(item, item.maxLength);
          resizing = true;
        }
      });
    } while (resizing && resized++ < output.length);
    if (resizing) {
      throw new error.Internal("Resize loop iterated too many times while determining maxLength");
    }
    resized = 0;
    do {
      resizing = false;
      hunkSize = Math.round(remainingSpace / variableCount);
      output.forEach(function(item) {
        if (item.finished) {
          return;
        }
        if (!item.minLength) {
          return;
        }
        if (item.getMinLength() >= hunkSize) {
          finishSizing(item, item.minLength);
          resizing = true;
        }
      });
    } while (resizing && resized++ < output.length);
    if (resizing) {
      throw new error.Internal("Resize loop iterated too many times while determining minLength");
    }
    hunkSize = Math.round(remainingSpace / variableCount);
    output.forEach(function(item) {
      if (item.finished) {
        return;
      }
      finishSizing(item, hunkSize);
    });
    return output;
  };
  var renderFunction = function(item, values, length) {
    validate3("OON", arguments);
    if (item.type) {
      return item.value(values, values[item.type + "Theme"] || {}, length);
    } else {
      return item.value(values, {}, length);
    }
  };
  var renderValue = function(item, values) {
    var length = item.getBaseLength();
    var value = typeof item.value === "function" ? renderFunction(item, values, length) : item.value;
    if (value == null || value === "") {
      return "";
    }
    var alignWith = align[item.align] || align.left;
    var leftPadding = item.padLeft ? align.left("", item.padLeft) : "";
    var rightPadding = item.padRight ? align.right("", item.padRight) : "";
    var truncated = wideTruncate(String(value), length);
    var aligned = alignWith(truncated, length);
    return leftPadding + aligned + rightPadding;
  };
  var align = require_align();
  var validate3 = require_aproba();
  var wideTruncate = require_wide_truncate();
  var error = require_error3();
  var TemplateItem = require_template_item();
  var renderTemplate = module.exports = function(width, template, values) {
    var items = prepareItems(width, template, values);
    var rendered = items.map(renderValueWithValues(values)).join("");
    return align.left(wideTruncate(rendered, width), width);
  };
});

// node_modules/gauge/lib/plumbing.js
var require_plumbing = __commonJS((exports, module) => {
  var consoleControl = require_console_control_strings();
  var renderTemplate = require_render_template();
  var validate3 = require_aproba();
  var Plumbing = module.exports = function(theme, template, width) {
    if (!width) {
      width = 80;
    }
    validate3("OAN", [theme, template, width]);
    this.showing = false;
    this.theme = theme;
    this.width = width;
    this.template = template;
  };
  Plumbing.prototype = {};
  Plumbing.prototype.setTheme = function(theme) {
    validate3("O", [theme]);
    this.theme = theme;
  };
  Plumbing.prototype.setTemplate = function(template) {
    validate3("A", [template]);
    this.template = template;
  };
  Plumbing.prototype.setWidth = function(width) {
    validate3("N", [width]);
    this.width = width;
  };
  Plumbing.prototype.hide = function() {
    return consoleControl.gotoSOL() + consoleControl.eraseLine();
  };
  Plumbing.prototype.hideCursor = consoleControl.hideCursor;
  Plumbing.prototype.showCursor = consoleControl.showCursor;
  Plumbing.prototype.show = function(status) {
    var values = Object.create(this.theme);
    for (var key in status) {
      values[key] = status[key];
    }
    return renderTemplate(this.width, this.template, values).trim() + consoleControl.color("reset") + consoleControl.eraseLine() + consoleControl.gotoSOL();
  };
});

// node_modules/has-unicode/index.js
var require_has_unicode = __commonJS((exports, module) => {
  var os2 = __require("os");
  var hasUnicode = module.exports = function() {
    if (os2.type() == "Windows_NT") {
      return false;
    }
    var isUTF8 = /UTF-?8$/i;
    var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG;
    return isUTF8.test(ctype);
  };
});

// node_modules/color-support/index.js
var require_color_support = __commonJS((exports, module) => {
  var hasNone = function(obj, options5) {
    obj.level = 0;
    obj.hasBasic = false;
    obj.has256 = false;
    obj.has16m = false;
    if (!options5.alwaysReturn) {
      return false;
    }
    return obj;
  };
  var hasBasic = function(obj) {
    obj.hasBasic = true;
    obj.has256 = false;
    obj.has16m = false;
    obj.level = 1;
    return obj;
  };
  var has256 = function(obj) {
    obj.hasBasic = true;
    obj.has256 = true;
    obj.has16m = false;
    obj.level = 2;
    return obj;
  };
  var has16m = function(obj) {
    obj.hasBasic = true;
    obj.has256 = true;
    obj.has16m = true;
    obj.level = 3;
    return obj;
  };
  var colorSupport = function(options5, obj) {
    options5 = options5 || {};
    obj = obj || {};
    if (typeof options5.level === "number") {
      switch (options5.level) {
        case 0:
          return hasNone(obj, options5);
        case 1:
          return hasBasic(obj);
        case 2:
          return has256(obj);
        case 3:
          return has16m(obj);
      }
    }
    obj.level = 0;
    obj.hasBasic = false;
    obj.has256 = false;
    obj.has16m = false;
    if (typeof process === "undefined" || !process || !process.stdout || !process.env || !process.platform) {
      return hasNone(obj, options5);
    }
    var env = options5.env || process.env;
    var stream2 = options5.stream || process.stdout;
    var term = options5.term || env.TERM || "";
    var platform = options5.platform || process.platform;
    if (!options5.ignoreTTY && !stream2.isTTY) {
      return hasNone(obj, options5);
    }
    if (!options5.ignoreDumb && term === "dumb" && !env.COLORTERM) {
      return hasNone(obj, options5);
    }
    if (platform === "win32") {
      return hasBasic(obj);
    }
    if (env.TMUX) {
      return has256(obj);
    }
    if (!options5.ignoreCI && (env.CI || env.TEAMCITY_VERSION)) {
      if (env.TRAVIS) {
        return has256(obj);
      } else {
        return hasNone(obj, options5);
      }
    }
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        var ver = env.TERM_PROGRAM_VERSION || "0.";
        if (/^[0-2]\./.test(ver)) {
          return has256(obj);
        } else {
          return has16m(obj);
        }
      case "HyperTerm":
      case "Hyper":
        return has16m(obj);
      case "MacTerm":
        return has16m(obj);
      case "Apple_Terminal":
        return has256(obj);
    }
    if (/^xterm-256/.test(term)) {
      return has256(obj);
    }
    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(term)) {
      return hasBasic(obj);
    }
    if (env.COLORTERM) {
      return hasBasic(obj);
    }
    return hasNone(obj, options5);
  };
  module.exports = colorSupport({ alwaysReturn: true }, colorSupport);
});

// node_modules/gauge/lib/has-color.js
var require_has_color = __commonJS((exports, module) => {
  var colorSupport = require_color_support();
  module.exports = colorSupport().hasBasic;
});

// node_modules/signal-exit/dist/cjs/signals.js
var require_signals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signals = undefined;
  exports.signals = [];
  exports.signals.push("SIGHUP", "SIGINT", "SIGTERM");
  if (process.platform !== "win32") {
    exports.signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    exports.signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
  }
});

// node_modules/signal-exit/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unload = exports.load = exports.onExit = exports.signals = undefined;
  var signals_js_1 = require_signals();
  Object.defineProperty(exports, "signals", { enumerable: true, get: function() {
    return signals_js_1.signals;
  } });
  var processOk = (process5) => !!process5 && typeof process5 === "object" && typeof process5.removeListener === "function" && typeof process5.emit === "function" && typeof process5.reallyExit === "function" && typeof process5.listeners === "function" && typeof process5.kill === "function" && typeof process5.pid === "number" && typeof process5.on === "function";
  var kExitEmitter = Symbol.for("signal-exit emitter");
  var global2 = globalThis;
  var ObjectDefineProperty = Object.defineProperty.bind(Object);

  class Emitter {
    emitted = {
      afterExit: false,
      exit: false
    };
    listeners = {
      afterExit: [],
      exit: []
    };
    count = 0;
    id = Math.random();
    constructor() {
      if (global2[kExitEmitter]) {
        return global2[kExitEmitter];
      }
      ObjectDefineProperty(global2, kExitEmitter, {
        value: this,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    on(ev, fn) {
      this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
      const list = this.listeners[ev];
      const i = list.indexOf(fn);
      if (i === -1) {
        return;
      }
      if (i === 0 && list.length === 1) {
        list.length = 0;
      } else {
        list.splice(i, 1);
      }
    }
    emit(ev, code, signal) {
      if (this.emitted[ev]) {
        return false;
      }
      this.emitted[ev] = true;
      let ret = false;
      for (const fn of this.listeners[ev]) {
        ret = fn(code, signal) === true || ret;
      }
      if (ev === "exit") {
        ret = this.emit("afterExit", code, signal) || ret;
      }
      return ret;
    }
  }

  class SignalExitBase {
  }
  var signalExitWrap = (handler) => {
    return {
      onExit(cb, opts) {
        return handler.onExit(cb, opts);
      },
      load() {
        return handler.load();
      },
      unload() {
        return handler.unload();
      }
    };
  };

  class SignalExitFallback extends SignalExitBase {
    onExit() {
      return () => {
      };
    }
    load() {
    }
    unload() {
    }
  }

  class SignalExit extends SignalExitBase {
    #hupSig = process4.platform === "win32" ? "SIGINT" : "SIGHUP";
    #emitter = new Emitter;
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process5) {
      super();
      this.#process = process5;
      this.#sigListeners = {};
      for (const sig of signals_js_1.signals) {
        this.#sigListeners[sig] = () => {
          const listeners = this.#process.listeners(sig);
          let { count } = this.#emitter;
          const p = process5;
          if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
            count += p.__signal_exit_emitter__.count;
          }
          if (listeners.length === count) {
            this.unload();
            const ret = this.#emitter.emit("exit", null, sig);
            const s = sig === "SIGHUP" ? this.#hupSig : sig;
            if (!ret)
              process5.kill(process5.pid, s);
          }
        };
      }
      this.#originalProcessReallyExit = process5.reallyExit;
      this.#originalProcessEmit = process5.emit;
    }
    onExit(cb, opts) {
      if (!processOk(this.#process)) {
        return () => {
        };
      }
      if (this.#loaded === false) {
        this.load();
      }
      const ev = opts?.alwaysLast ? "afterExit" : "exit";
      this.#emitter.on(ev, cb);
      return () => {
        this.#emitter.removeListener(ev, cb);
        if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
          this.unload();
        }
      };
    }
    load() {
      if (this.#loaded) {
        return;
      }
      this.#loaded = true;
      this.#emitter.count += 1;
      for (const sig of signals_js_1.signals) {
        try {
          const fn = this.#sigListeners[sig];
          if (fn)
            this.#process.on(sig, fn);
        } catch (_) {
        }
      }
      this.#process.emit = (ev, ...a) => {
        return this.#processEmit(ev, ...a);
      };
      this.#process.reallyExit = (code) => {
        return this.#processReallyExit(code);
      };
    }
    unload() {
      if (!this.#loaded) {
        return;
      }
      this.#loaded = false;
      signals_js_1.signals.forEach((sig) => {
        const listener = this.#sigListeners[sig];
        if (!listener) {
          throw new Error("Listener not defined for signal: " + sig);
        }
        try {
          this.#process.removeListener(sig, listener);
        } catch (_) {
        }
      });
      this.#process.emit = this.#originalProcessEmit;
      this.#process.reallyExit = this.#originalProcessReallyExit;
      this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
      if (!processOk(this.#process)) {
        return 0;
      }
      this.#process.exitCode = code || 0;
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
      const og = this.#originalProcessEmit;
      if (ev === "exit" && processOk(this.#process)) {
        if (typeof args[0] === "number") {
          this.#process.exitCode = args[0];
        }
        const ret = og.call(this.#process, ev, ...args);
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return ret;
      } else {
        return og.call(this.#process, ev, ...args);
      }
    }
  }
  var process4 = globalThis.process;
  _a = signalExitWrap(processOk(process4) ? new SignalExit(process4) : new SignalExitFallback), exports.onExit = _a.onExit, exports.load = _a.load, exports.unload = _a.unload;
});

// node_modules/gauge/lib/spin.js
var require_spin = __commonJS((exports, module) => {
  module.exports = function spin(spinstr, spun) {
    return spinstr[spun % spinstr.length];
  };
});

// node_modules/gauge/lib/progress-bar.js
var require_progress_bar = __commonJS((exports, module) => {
  var repeat = function(string, width) {
    var result = "";
    var n = width;
    do {
      if (n % 2) {
        result += string;
      }
      n = Math.floor(n / 2);
      string += string;
    } while (n && stringWidth(result) < width);
    return wideTruncate(result, width);
  };
  var validate3 = require_aproba();
  var renderTemplate = require_render_template();
  var wideTruncate = require_wide_truncate();
  var stringWidth = require_string_width();
  module.exports = function(theme, width, completed) {
    validate3("ONN", [theme, width, completed]);
    if (completed < 0) {
      completed = 0;
    }
    if (completed > 1) {
      completed = 1;
    }
    if (width <= 0) {
      return "";
    }
    var sofar = Math.round(width * completed);
    var rest = width - sofar;
    var template = [
      { type: "complete", value: repeat(theme.complete, sofar), length: sofar },
      { type: "remaining", value: repeat(theme.remaining, rest), length: rest }
    ];
    return renderTemplate(width, template, theme);
  };
});

// node_modules/gauge/lib/base-theme.js
var require_base_theme = __commonJS((exports, module) => {
  var spin = require_spin();
  var progressBar = require_progress_bar();
  module.exports = {
    activityIndicator: function(values, theme, width) {
      if (values.spun == null) {
        return;
      }
      return spin(theme, values.spun);
    },
    progressbar: function(values, theme, width) {
      if (values.completed == null) {
        return;
      }
      return progressBar(theme, width, values.completed);
    }
  };
});

// node_modules/gauge/lib/theme-set.js
var require_theme_set = __commonJS((exports, module) => {
  module.exports = function() {
    return ThemeSetProto.newThemeSet();
  };
  var ThemeSetProto = {};
  ThemeSetProto.baseTheme = require_base_theme();
  ThemeSetProto.newTheme = function(parent, theme) {
    if (!theme) {
      theme = parent;
      parent = this.baseTheme;
    }
    return Object.assign({}, parent, theme);
  };
  ThemeSetProto.getThemeNames = function() {
    return Object.keys(this.themes);
  };
  ThemeSetProto.addTheme = function(name, parent, theme) {
    this.themes[name] = this.newTheme(parent, theme);
  };
  ThemeSetProto.addToAllThemes = function(theme) {
    var themes = this.themes;
    Object.keys(themes).forEach(function(name) {
      Object.assign(themes[name], theme);
    });
    Object.assign(this.baseTheme, theme);
  };
  ThemeSetProto.getTheme = function(name) {
    if (!this.themes[name]) {
      throw this.newMissingThemeError(name);
    }
    return this.themes[name];
  };
  ThemeSetProto.setDefault = function(opts, name) {
    if (name == null) {
      name = opts;
      opts = {};
    }
    var platform = opts.platform == null ? "fallback" : opts.platform;
    var hasUnicode = !!opts.hasUnicode;
    var hasColor = !!opts.hasColor;
    if (!this.defaults[platform]) {
      this.defaults[platform] = { true: {}, false: {} };
    }
    this.defaults[platform][hasUnicode][hasColor] = name;
  };
  ThemeSetProto.getDefault = function(opts) {
    if (!opts) {
      opts = {};
    }
    var platformName = opts.platform || process.platform;
    var platform = this.defaults[platformName] || this.defaults.fallback;
    var hasUnicode = !!opts.hasUnicode;
    var hasColor = !!opts.hasColor;
    if (!platform) {
      throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
    }
    if (!platform[hasUnicode][hasColor]) {
      if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
        hasUnicode = false;
      } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
        hasColor = false;
      } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
        hasUnicode = false;
        hasColor = false;
      } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
        hasUnicode = false;
      } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
        hasColor = false;
      } else if (platform === this.defaults.fallback) {
        throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
      }
    }
    if (platform[hasUnicode][hasColor]) {
      return this.getTheme(platform[hasUnicode][hasColor]);
    } else {
      return this.getDefault(Object.assign({}, opts, { platform: "fallback" }));
    }
  };
  ThemeSetProto.newMissingThemeError = function newMissingThemeError(name) {
    var err = new Error('Could not find a gauge theme named "' + name + '"');
    Error.captureStackTrace.call(err, newMissingThemeError);
    err.theme = name;
    err.code = "EMISSINGTHEME";
    return err;
  };
  ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError(platformName, hasUnicode, hasColor) {
    var err = new Error("Could not find a gauge theme for your platform/unicode/color use combo:\n    platform = " + platformName + "\n    hasUnicode = " + hasUnicode + "\n    hasColor = " + hasColor);
    Error.captureStackTrace.call(err, newMissingDefaultThemeError);
    err.platform = platformName;
    err.hasUnicode = hasUnicode;
    err.hasColor = hasColor;
    err.code = "EMISSINGTHEME";
    return err;
  };
  ThemeSetProto.newThemeSet = function() {
    var themeset = function(opts) {
      return themeset.getDefault(opts);
    };
    return Object.assign(themeset, ThemeSetProto, {
      themes: Object.assign({}, this.themes),
      baseTheme: Object.assign({}, this.baseTheme),
      defaults: JSON.parse(JSON.stringify(this.defaults || {}))
    });
  };
});

// node_modules/gauge/lib/themes.js
var require_themes = __commonJS((exports, module) => {
  var color = require_console_control_strings().color;
  var ThemeSet = require_theme_set();
  var themes = module.exports = new ThemeSet;
  themes.addTheme("ASCII", {
    preProgressbar: "[",
    postProgressbar: "]",
    progressbarTheme: {
      complete: "#",
      remaining: "."
    },
    activityIndicatorTheme: "-\\|/",
    preSubsection: ">"
  });
  themes.addTheme("colorASCII", themes.getTheme("ASCII"), {
    progressbarTheme: {
      preComplete: color("bgBrightWhite", "brightWhite"),
      complete: "#",
      postComplete: color("reset"),
      preRemaining: color("bgBrightBlack", "brightBlack"),
      remaining: ".",
      postRemaining: color("reset")
    }
  });
  themes.addTheme("brailleSpinner", {
    preProgressbar: "(",
    postProgressbar: ")",
    progressbarTheme: {
      complete: "#",
      remaining: "\u2802"
    },
    activityIndicatorTheme: "\u280B\u2819\u2839\u2838\u283C\u2834\u2826\u2827\u2807\u280F",
    preSubsection: ">"
  });
  themes.addTheme("colorBrailleSpinner", themes.getTheme("brailleSpinner"), {
    progressbarTheme: {
      preComplete: color("bgBrightWhite", "brightWhite"),
      complete: "#",
      postComplete: color("reset"),
      preRemaining: color("bgBrightBlack", "brightBlack"),
      remaining: "\u2802",
      postRemaining: color("reset")
    }
  });
  themes.setDefault({}, "ASCII");
  themes.setDefault({ hasColor: true }, "colorASCII");
  themes.setDefault({ platform: "darwin", hasUnicode: true }, "brailleSpinner");
  themes.setDefault({ platform: "darwin", hasUnicode: true, hasColor: true }, "colorBrailleSpinner");
  themes.setDefault({ platform: "linux", hasUnicode: true }, "brailleSpinner");
  themes.setDefault({ platform: "linux", hasUnicode: true, hasColor: true }, "colorBrailleSpinner");
});

// node_modules/gauge/lib/set-interval.js
var require_set_interval = __commonJS((exports, module) => {
  module.exports = setInterval;
});

// node_modules/gauge/lib/process.js
var require_process = __commonJS((exports, module) => {
  module.exports = process;
});

// node_modules/gauge/lib/set-immediate.js
var require_set_immediate = __commonJS((exports, module) => {
  var process4 = require_process();
  try {
    module.exports = setImmediate;
  } catch (ex) {
    module.exports = process4.nextTick;
  }
});

// node_modules/gauge/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  var callWith = function(obj, method) {
    return function() {
      return method.call(obj);
    };
  };
  var Gauge = function(arg1, arg2) {
    var options5, writeTo;
    if (arg1 && arg1.write) {
      writeTo = arg1;
      options5 = arg2 || {};
    } else if (arg2 && arg2.write) {
      writeTo = arg2;
      options5 = arg1 || {};
    } else {
      writeTo = process4.stderr;
      options5 = arg1 || arg2 || {};
    }
    this._status = {
      spun: 0,
      section: "",
      subsection: ""
    };
    this._paused = false;
    this._disabled = true;
    this._showing = false;
    this._onScreen = false;
    this._needsRedraw = false;
    this._hideCursor = options5.hideCursor == null ? true : options5.hideCursor;
    this._fixedFramerate = options5.fixedFramerate == null ? !/^v0\.8\./.test(process4.version) : options5.fixedFramerate;
    this._lastUpdateAt = null;
    this._updateInterval = options5.updateInterval == null ? 50 : options5.updateInterval;
    this._themes = options5.themes || defaultThemes;
    this._theme = options5.theme;
    var theme = this._computeTheme(options5.theme);
    var template = options5.template || [
      { type: "progressbar", length: 20 },
      { type: "activityIndicator", kerning: 1, length: 1 },
      { type: "section", kerning: 1, default: "" },
      { type: "subsection", kerning: 1, default: "" }
    ];
    this.setWriteTo(writeTo, options5.tty);
    var PlumbingClass = options5.Plumbing || Plumbing;
    this._gauge = new PlumbingClass(theme, template, this.getWidth());
    this._$$doRedraw = callWith(this, this._doRedraw);
    this._$$handleSizeChange = callWith(this, this._handleSizeChange);
    this._cleanupOnExit = options5.cleanupOnExit == null || options5.cleanupOnExit;
    this._removeOnExit = null;
    if (options5.enabled || options5.enabled == null && this._tty && this._tty.isTTY) {
      this.enable();
    } else {
      this.disable();
    }
  };
  var Plumbing = require_plumbing();
  var hasUnicode = require_has_unicode();
  var hasColor = require_has_color();
  var onExit = require_cjs().onExit;
  var defaultThemes = require_themes();
  var setInterval2 = require_set_interval();
  var process4 = require_process();
  var setImmediate2 = require_set_immediate();
  module.exports = Gauge;
  Gauge.prototype = {};
  Gauge.prototype.isEnabled = function() {
    return !this._disabled;
  };
  Gauge.prototype.setTemplate = function(template) {
    this._gauge.setTemplate(template);
    if (this._showing) {
      this._requestRedraw();
    }
  };
  Gauge.prototype._computeTheme = function(theme) {
    if (!theme) {
      theme = {};
    }
    if (typeof theme === "string") {
      theme = this._themes.getTheme(theme);
    } else if (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null) {
      var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;
      var useColor = theme.hasColor == null ? hasColor : theme.hasColor;
      theme = this._themes.getDefault({
        hasUnicode: useUnicode,
        hasColor: useColor,
        platform: theme.platform
      });
    }
    return theme;
  };
  Gauge.prototype.setThemeset = function(themes) {
    this._themes = themes;
    this.setTheme(this._theme);
  };
  Gauge.prototype.setTheme = function(theme) {
    this._gauge.setTheme(this._computeTheme(theme));
    if (this._showing) {
      this._requestRedraw();
    }
    this._theme = theme;
  };
  Gauge.prototype._requestRedraw = function() {
    this._needsRedraw = true;
    if (!this._fixedFramerate) {
      this._doRedraw();
    }
  };
  Gauge.prototype.getWidth = function() {
    return (this._tty && this._tty.columns || 80) - 1;
  };
  Gauge.prototype.setWriteTo = function(writeTo, tty) {
    var enabled = !this._disabled;
    if (enabled) {
      this.disable();
    }
    this._writeTo = writeTo;
    this._tty = tty || writeTo === process4.stderr && process4.stdout.isTTY && process4.stdout || writeTo.isTTY && writeTo || this._tty;
    if (this._gauge) {
      this._gauge.setWidth(this.getWidth());
    }
    if (enabled) {
      this.enable();
    }
  };
  Gauge.prototype.enable = function() {
    if (!this._disabled) {
      return;
    }
    this._disabled = false;
    if (this._tty) {
      this._enableEvents();
    }
    if (this._showing) {
      this.show();
    }
  };
  Gauge.prototype.disable = function() {
    if (this._disabled) {
      return;
    }
    if (this._showing) {
      this._lastUpdateAt = null;
      this._showing = false;
      this._doRedraw();
      this._showing = true;
    }
    this._disabled = true;
    if (this._tty) {
      this._disableEvents();
    }
  };
  Gauge.prototype._enableEvents = function() {
    if (this._cleanupOnExit) {
      this._removeOnExit = onExit(callWith(this, this.disable));
    }
    this._tty.on("resize", this._$$handleSizeChange);
    if (this._fixedFramerate) {
      this.redrawTracker = setInterval2(this._$$doRedraw, this._updateInterval);
      if (this.redrawTracker.unref) {
        this.redrawTracker.unref();
      }
    }
  };
  Gauge.prototype._disableEvents = function() {
    this._tty.removeListener("resize", this._$$handleSizeChange);
    if (this._fixedFramerate) {
      clearInterval(this.redrawTracker);
    }
    if (this._removeOnExit) {
      this._removeOnExit();
    }
  };
  Gauge.prototype.hide = function(cb) {
    if (this._disabled) {
      return cb && process4.nextTick(cb);
    }
    if (!this._showing) {
      return cb && process4.nextTick(cb);
    }
    this._showing = false;
    this._doRedraw();
    cb && setImmediate2(cb);
  };
  Gauge.prototype.show = function(section, completed) {
    this._showing = true;
    if (typeof section === "string") {
      this._status.section = section;
    } else if (typeof section === "object") {
      var sectionKeys = Object.keys(section);
      for (var ii = 0;ii < sectionKeys.length; ++ii) {
        var key = sectionKeys[ii];
        this._status[key] = section[key];
      }
    }
    if (completed != null) {
      this._status.completed = completed;
    }
    if (this._disabled) {
      return;
    }
    this._requestRedraw();
  };
  Gauge.prototype.pulse = function(subsection) {
    this._status.subsection = subsection || "";
    this._status.spun++;
    if (this._disabled) {
      return;
    }
    if (!this._showing) {
      return;
    }
    this._requestRedraw();
  };
  Gauge.prototype._handleSizeChange = function() {
    this._gauge.setWidth(this._tty.columns - 1);
    this._requestRedraw();
  };
  Gauge.prototype._doRedraw = function() {
    if (this._disabled || this._paused) {
      return;
    }
    if (!this._fixedFramerate) {
      var now = Date.now();
      if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) {
        return;
      }
      this._lastUpdateAt = now;
    }
    if (!this._showing && this._onScreen) {
      this._onScreen = false;
      var result = this._gauge.hide();
      if (this._hideCursor) {
        result += this._gauge.showCursor();
      }
      return this._writeTo.write(result);
    }
    if (!this._showing && !this._onScreen) {
      return;
    }
    if (this._showing && !this._onScreen) {
      this._onScreen = true;
      this._needsRedraw = true;
      if (this._hideCursor) {
        this._writeTo.write(this._gauge.hideCursor());
      }
    }
    if (!this._needsRedraw) {
      return;
    }
    if (!this._writeTo.write(this._gauge.show(this._status))) {
      this._paused = true;
      this._writeTo.on("drain", callWith(this, function() {
        this._paused = false;
        this._doRedraw();
      }));
    }
  };
});

// node_modules/@socket.io/component-emitter/index.js
var require_component_emitter = __commonJS((exports) => {
  var Emitter = function(obj) {
    if (obj)
      return mixin(obj);
  };
  var mixin = function(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  };
  exports.Emitter = Emitter;
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter.prototype.once = function(event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (arguments.length == 0) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (arguments.length == 1) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i = 0;i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i = 1;i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length;i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.emitReserved = Emitter.prototype.emit;
  Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
});

// node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js
var require_XMLHttpRequest = __commonJS((exports, module) => {
  var XMLHttpRequest = function(opts) {
    opts = opts || {};
    var self2 = this;
    var http3 = __require("http");
    var https2 = __require("https");
    var request;
    var response4;
    var settings = {};
    var disableHeaderCheck = false;
    var defaultHeaders = {
      "User-Agent": "node-XMLHttpRequest",
      Accept: "*/*"
    };
    var headers = Object.assign({}, defaultHeaders);
    var forbiddenRequestHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "content-transfer-encoding",
      "cookie",
      "cookie2",
      "date",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
    var forbiddenRequestMethods = [
      "TRACE",
      "TRACK",
      "CONNECT"
    ];
    var sendFlag = false;
    var errorFlag = false;
    var abortedFlag = false;
    var listeners = {};
    this.UNSENT = 0;
    this.OPENED = 1;
    this.HEADERS_RECEIVED = 2;
    this.LOADING = 3;
    this.DONE = 4;
    this.readyState = this.UNSENT;
    this.onreadystatechange = null;
    this.responseText = "";
    this.responseXML = "";
    this.status = null;
    this.statusText = null;
    var isAllowedHttpHeader = function(header) {
      return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;
    };
    var isAllowedHttpMethod = function(method) {
      return method && forbiddenRequestMethods.indexOf(method) === -1;
    };
    this.open = function(method, url, async, user, password) {
      this.abort();
      errorFlag = false;
      abortedFlag = false;
      if (!isAllowedHttpMethod(method)) {
        throw new Error("SecurityError: Request method not allowed");
      }
      settings = {
        method,
        url: url.toString(),
        async: typeof async !== "boolean" ? true : async,
        user: user || null,
        password: password || null
      };
      setState(this.OPENED);
    };
    this.setDisableHeaderCheck = function(state) {
      disableHeaderCheck = state;
    };
    this.setRequestHeader = function(header, value) {
      if (this.readyState != this.OPENED) {
        throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
      }
      if (!isAllowedHttpHeader(header)) {
        console.warn('Refused to set unsafe header "' + header + '"');
        return false;
      }
      if (sendFlag) {
        throw new Error("INVALID_STATE_ERR: send flag is true");
      }
      headers[header] = value;
      return true;
    };
    this.getResponseHeader = function(header) {
      if (typeof header === "string" && this.readyState > this.OPENED && response4.headers[header.toLowerCase()] && !errorFlag) {
        return response4.headers[header.toLowerCase()];
      }
      return null;
    };
    this.getAllResponseHeaders = function() {
      if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
        return "";
      }
      var result = "";
      for (var i2 in response4.headers) {
        if (i2 !== "set-cookie" && i2 !== "set-cookie2") {
          result += i2 + ": " + response4.headers[i2] + "\r\n";
        }
      }
      return result.substr(0, result.length - 2);
    };
    this.getRequestHeader = function(name) {
      if (typeof name === "string" && headers[name]) {
        return headers[name];
      }
      return "";
    };
    this.send = function(data) {
      if (this.readyState != this.OPENED) {
        throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
      }
      if (sendFlag) {
        throw new Error("INVALID_STATE_ERR: send has already been called");
      }
      var ssl = false, local = false;
      var url = Url.parse(settings.url);
      var host;
      switch (url.protocol) {
        case "https:":
          ssl = true;
        case "http:":
          host = url.hostname;
          break;
        case "file:":
          local = true;
          break;
        case undefined:
        case "":
          host = "localhost";
          break;
        default:
          throw new Error("Protocol not supported.");
      }
      if (local) {
        if (settings.method !== "GET") {
          throw new Error("XMLHttpRequest: Only GET method is supported");
        }
        if (settings.async) {
          fs2.readFile(unescape(url.pathname), "utf8", function(error, data2) {
            if (error) {
              self2.handleError(error, error.errno || -1);
            } else {
              self2.status = 200;
              self2.responseText = data2;
              setState(self2.DONE);
            }
          });
        } else {
          try {
            this.responseText = fs2.readFileSync(unescape(url.pathname), "utf8");
            this.status = 200;
            setState(self2.DONE);
          } catch (e) {
            this.handleError(e, e.errno || -1);
          }
        }
        return;
      }
      var port = url.port || (ssl ? 443 : 80);
      var uri = url.pathname + (url.search ? url.search : "");
      headers["Host"] = host;
      if (!(ssl && port === 443 || port === 80)) {
        headers["Host"] += ":" + url.port;
      }
      if (settings.user) {
        if (typeof settings.password == "undefined") {
          settings.password = "";
        }
        var authBuf = new Buffer(settings.user + ":" + settings.password);
        headers["Authorization"] = "Basic " + authBuf.toString("base64");
      }
      if (settings.method === "GET" || settings.method === "HEAD") {
        data = null;
      } else if (data) {
        headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
        if (!headers["Content-Type"]) {
          headers["Content-Type"] = "text/plain;charset=UTF-8";
        }
      } else if (settings.method === "POST") {
        headers["Content-Length"] = 0;
      }
      var agent2 = opts.agent || false;
      var options5 = {
        host,
        port,
        path: uri,
        method: settings.method,
        headers,
        agent: agent2
      };
      if (ssl) {
        options5.pfx = opts.pfx;
        options5.key = opts.key;
        options5.passphrase = opts.passphrase;
        options5.cert = opts.cert;
        options5.ca = opts.ca;
        options5.ciphers = opts.ciphers;
        options5.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;
      }
      errorFlag = false;
      if (settings.async) {
        var doRequest = ssl ? https2.request : http3.request;
        sendFlag = true;
        self2.dispatchEvent("readystatechange");
        var responseHandler = function(resp) {
          response4 = resp;
          if (response4.statusCode === 302 || response4.statusCode === 303 || response4.statusCode === 307) {
            settings.url = response4.headers.location;
            var url2 = Url.parse(settings.url);
            host = url2.hostname;
            var newOptions = {
              hostname: url2.hostname,
              port: url2.port,
              path: url2.path,
              method: response4.statusCode === 303 ? "GET" : settings.method,
              headers
            };
            if (ssl) {
              newOptions.pfx = opts.pfx;
              newOptions.key = opts.key;
              newOptions.passphrase = opts.passphrase;
              newOptions.cert = opts.cert;
              newOptions.ca = opts.ca;
              newOptions.ciphers = opts.ciphers;
              newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;
            }
            request = doRequest(newOptions, responseHandler).on("error", errorHandler);
            request.end();
            return;
          }
          if (response4 && response4.setEncoding) {
            response4.setEncoding("utf8");
          }
          setState(self2.HEADERS_RECEIVED);
          self2.status = response4.statusCode;
          response4.on("data", function(chunk) {
            if (chunk) {
              self2.responseText += chunk;
            }
            if (sendFlag) {
              setState(self2.LOADING);
            }
          });
          response4.on("end", function() {
            if (sendFlag) {
              sendFlag = false;
              setState(self2.DONE);
            }
          });
          response4.on("error", function(error) {
            self2.handleError(error);
          });
        };
        var errorHandler = function(error) {
          self2.handleError(error);
        };
        request = doRequest(options5, responseHandler).on("error", errorHandler);
        if (opts.autoUnref) {
          request.on("socket", (socket) => {
            socket.unref();
          });
        }
        if (data) {
          request.write(data);
        }
        request.end();
        self2.dispatchEvent("loadstart");
      } else {
        var contentFile = ".node-xmlhttprequest-content-" + process.pid;
        var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
        fs2.writeFileSync(syncFile, "", "utf8");
        var execString = "var http = require('http'), https = require('https'), fs = require('fs');var doRequest = http" + (ssl ? "s" : "") + ".request;var options = " + JSON.stringify(options5) + ";var responseText = '';var req = doRequest(options, function(response) {response.setEncoding('utf8');response.on('data', function(chunk) {  responseText += chunk;});response.on('end', function() {fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');fs.unlinkSync('" + syncFile + "');});response.on('error', function(error) {fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');fs.unlinkSync('" + syncFile + "');});}).on('error', function(error) {fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');fs.unlinkSync('" + syncFile + "');});" + (data ? "req.write('" + JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'") + "');" : "") + "req.end();";
        var syncProc = spawn(process.argv[0], ["-e", execString]);
        var statusText;
        while (fs2.existsSync(syncFile)) {
        }
        self2.responseText = fs2.readFileSync(contentFile, "utf8");
        syncProc.stdin.end();
        fs2.unlinkSync(contentFile);
        if (self2.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
          var errorObj = self2.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");
          self2.handleError(errorObj, 503);
        } else {
          self2.status = self2.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
          self2.responseText = self2.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");
          setState(self2.DONE);
        }
      }
    };
    this.handleError = function(error, status) {
      this.status = status || 0;
      this.statusText = error;
      this.responseText = error.stack;
      errorFlag = true;
      setState(this.DONE);
    };
    this.abort = function() {
      if (request) {
        request.abort();
        request = null;
      }
      headers = Object.assign({}, defaultHeaders);
      this.responseText = "";
      this.responseXML = "";
      errorFlag = abortedFlag = true;
      if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {
        sendFlag = false;
        setState(this.DONE);
      }
      this.readyState = this.UNSENT;
    };
    this.addEventListener = function(event, callback) {
      if (!(event in listeners)) {
        listeners[event] = [];
      }
      listeners[event].push(callback);
    };
    this.removeEventListener = function(event, callback) {
      if (event in listeners) {
        listeners[event] = listeners[event].filter(function(ev) {
          return ev !== callback;
        });
      }
    };
    this.dispatchEvent = function(event) {
      if (typeof self2["on" + event] === "function") {
        if (this.readyState === this.DONE)
          setImmediate(function() {
            self2["on" + event]();
          });
        else
          self2["on" + event]();
      }
      if (event in listeners) {
        for (let i2 = 0, len = listeners[event].length;i2 < len; i2++) {
          if (this.readyState === this.DONE)
            setImmediate(function() {
              listeners[event][i2].call(self2);
            });
          else
            listeners[event][i2].call(self2);
        }
      }
    };
    var setState = function(state) {
      if (self2.readyState === state || self2.readyState === self2.UNSENT && abortedFlag)
        return;
      self2.readyState = state;
      if (settings.async || self2.readyState < self2.OPENED || self2.readyState === self2.DONE) {
        self2.dispatchEvent("readystatechange");
      }
      if (self2.readyState === self2.DONE) {
        let fire;
        if (abortedFlag)
          fire = "abort";
        else if (errorFlag)
          fire = "error";
        else
          fire = "load";
        self2.dispatchEvent(fire);
        self2.dispatchEvent("loadend");
      }
    };
  };
  var fs2 = __require("fs");
  var Url = __require("url");
  var spawn = __require("child_process").spawn;
  module.exports = XMLHttpRequest;
  XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var emitClose = function(stream2) {
    stream2.emit("close");
  };
  var duplexOnEnd = function() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  };
  var duplexOnError = function(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  };
  var createWebSocketStream = function(ws, options5) {
    let terminateOnDestroy = true;
    const duplex = new Duplex2({
      ...options5,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  };
  var { Duplex: Duplex2 } = __require("stream");
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  var load = function(dir) {
    return runtimeRequire(load.resolve(dir));
  };
  var readdirSync = function(dir) {
    try {
      return fs2.readdirSync(dir);
    } catch (err) {
      return [];
    }
  };
  var getFirst = function(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  };
  var matchBuild = function(name) {
    return /\.node$/.test(name);
  };
  var parseTuple = function(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  };
  var matchTuple = function(platform2, arch2) {
    return function(tuple) {
      if (tuple == null)
        return false;
      if (tuple.platform !== platform2)
        return false;
      return tuple.architectures.includes(arch2);
    };
  };
  var compareTuples = function(a, b) {
    return a.architectures.length - b.architectures.length;
  };
  var parseTags = function(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i2 = 0;i2 < arr.length; i2++) {
      var tag = arr[i2];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  };
  var matchTags = function(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  };
  var runtimeAgnostic = function(tags) {
    return tags.runtime === "node" && tags.napi;
  };
  var compareTags = function(runtime2) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime2 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  };
  var isNwjs = function() {
    return !!(process.versions && process.versions.nw);
  };
  var isElectron = function() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  };
  var isAlpine = function(platform2) {
    return platform2 === "linux" && fs2.existsSync("/etc/alpine-release");
  };
  var fs2 = __require("fs");
  var path = __require("path");
  var os2 = __require("os");
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os2.arch();
  var platform = process.env.npm_config_platform || os2.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  module.exports = load;
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {
    }
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug5 = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug5)
        return debug5;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple)
        return;
      var prebuilds = path.join(dir2, "prebuilds", tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS((exports, module) => {
  if (typeof process.addon === "function") {
    module.exports = process.addon.bind(process);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// node_modules/bufferutil/fallback.js
var require_fallback = __commonJS((exports, module) => {
  var mask = (source, mask2, output, offset, length2) => {
    for (var i2 = 0;i2 < length2; i2++) {
      output[offset + i2] = source[i2] ^ mask2[i2 & 3];
    }
  };
  var unmask = (buffer, mask2) => {
    const length2 = buffer.length;
    for (var i2 = 0;i2 < length2; i2++) {
      buffer[i2] ^= mask2[i2 & 3];
    }
  };
  module.exports = { mask, unmask };
});

// node_modules/bufferutil/index.js
var require_bufferutil = __commonJS((exports, module) => {
  var __dirname = "/work/charite/src/upload/node_modules/bufferutil";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e) {
    module.exports = require_fallback();
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var concat = function(list, totalLength2) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength2);
    let offset = 0;
    for (let i2 = 0;i2 < list.length; i2++) {
      const buf = list[i2];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength2)
      return target.slice(0, offset);
    return target;
  };
  var _mask = function(source, mask, output, offset, length2) {
    for (let i2 = 0;i2 < length2; i2++) {
      output[offset + i2] = source[i2] ^ mask[i2 & 3];
    }
  };
  var _unmask = function(buffer, mask) {
    for (let i2 = 0;i2 < buffer.length; i2++) {
      buffer[i2] ^= mask[i2 & 3];
    }
  };
  var toArrayBuffer = function(buf) {
    if (buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  };
  var toBuffer2 = function(data) {
    toBuffer2.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = Buffer.from(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer2.readOnly = false;
    }
    return buf;
  };
  var { EMPTY_BUFFER } = require_constants2();
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer: toBuffer2,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = require_bufferutil();
      module.exports.mask = function(source, mask, output, offset, length2) {
        if (length2 < 48)
          _mask(source, mask, output, offset, length2);
        else
          bufferUtil.mask(source, mask, output, offset, length2);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var deflateOnData = function(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  };
  var inflateOnData = function(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  };
  var inflateOnError = function(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  };
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants2();
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options5, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options5 || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response4) {
      const params = response4[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin)
          data2 = data2.slice(0, data2.length - 4);
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS((exports, module) => {
  var isValidUTF8 = function(buf) {
    const len = buf.length;
    let i2 = 0;
    while (i2 < len) {
      if ((buf[i2] & 128) === 0) {
        i2++;
      } else if ((buf[i2] & 224) === 192) {
        if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
          return false;
        }
        i2 += 2;
      } else if ((buf[i2] & 240) === 224) {
        if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
          return false;
        }
        i2 += 3;
      } else if ((buf[i2] & 248) === 240) {
        if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
          return false;
        }
        i2 += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  module.exports = isValidUTF8;
});

// node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS((exports, module) => {
  var __dirname = "/work/charite/src/upload/node_modules/utf-8-validate";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e) {
    module.exports = require_fallback2();
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var isValidStatusCode = function(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  };
  var _isValidUTF8 = function(buf) {
    const len = buf.length;
    let i2 = 0;
    while (i2 < len) {
      if ((buf[i2] & 128) === 0) {
        i2++;
      } else if ((buf[i2] & 224) === 192) {
        if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
          return false;
        }
        i2 += 2;
      } else if ((buf[i2] & 240) === 224) {
        if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
          return false;
        }
        i2 += 3;
      } else if ((buf[i2] & 248) === 240) {
        if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
          return false;
        }
        i2 += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = require_utf_8_validate();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var error = function(ErrorCtor, message, prefix, statusCode, errorCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  };
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants2();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;

  class Receiver extends Writable {
    constructor(options5 = {}) {
      super();
      this._binaryType = options5.binaryType || BINARY_TYPES[0];
      this._extensions = options5.extensions || {};
      this._isServer = !!options5.isServer;
      this._maxPayload = options5.maxPayload | 0;
      this._skipUTF8Validation = !!options5.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = buf.slice(n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      let err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          default:
            this._loop = false;
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (this._payloadLength > 125) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data, true);
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("message", buf, false);
        }
      }
      this._state = GET_INFO;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else if (data.length === 1) {
          return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
          }
          const buf = data.slice(2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("conclude", code, buf);
          this.end();
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
      } else {
        this.emit("pong", data);
      }
      this._state = GET_INFO;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var net2 = __require("net");
  var tls = __require("tls");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants2();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer: toBuffer2 } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options5) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options5.mask) {
        mask = options5.maskBuffer || maskBuffer;
        if (options5.generateMask) {
          options5.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options5.mask || skipMasking) && options5[kByteLength] !== undefined) {
          dataLength = options5[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options5.mask && options5.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options5.fin ? options5.opcode | 128 : options5.opcode;
      if (options5.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options5.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length2 = Buffer.byteLength(data);
        if (length2 > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length2);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options5 = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options5, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options5), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength2;
      let readOnly;
      if (typeof data === "string") {
        byteLength2 = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer2(data);
        byteLength2 = data.length;
        readOnly = toBuffer2.readOnly;
      }
      if (byteLength2 > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options5 = {
        [kByteLength]: byteLength2,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options5, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options5), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength2;
      let readOnly;
      if (typeof data === "string") {
        byteLength2 = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer2(data);
        byteLength2 = data.length;
        readOnly = toBuffer2.readOnly;
      }
      if (byteLength2 > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options5 = {
        [kByteLength]: byteLength2,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options5, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options5), cb);
      }
    }
    send(data, options5, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options5.binary ? 2 : 1;
      let rsv1 = options5.compress;
      let byteLength2;
      let readOnly;
      if (typeof data === "string") {
        byteLength2 = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer2(data);
        byteLength2 = data.length;
        readOnly = toBuffer2.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength2 >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options5.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength2,
          fin: options5.fin,
          generateMask: this._generateMask,
          mask: options5.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength2,
          fin: options5.fin,
          generateMask: this._generateMask,
          mask: options5.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options5, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options5), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options5[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options5.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i2 = 0;i2 < this._queue.length; i2++) {
            const params = this._queue[i2];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options5[kByteLength];
        this._deflating = false;
        options5.readOnly = false;
        this.sendFrame(Sender.frame(buf, options5), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var callListener = function(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  };
  var { kForOnEventAttribute, kListener } = require_constants2();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options5 = {}) {
      super(type);
      this[kCode] = options5.code === undefined ? 0 : options5.code;
      this[kReason] = options5.reason === undefined ? "" : options5.reason;
      this[kWasClean] = options5.wasClean === undefined ? false : options5.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options5 = {}) {
      super(type);
      this[kError] = options5.error === undefined ? null : options5.error;
      this[kMessage] = options5.message === undefined ? "" : options5.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options5 = {}) {
      super(type);
      this[kData] = options5.data === undefined ? null : options5.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options5 = {}) {
      for (const listener of this.listeners(type)) {
        if (!options5[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options5[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options5.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var push = function(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  };
  var parse3 = function(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i2 = 0;
    for (;i2 < header.length; i2++) {
      code = header.charCodeAt(i2);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (i2 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i2;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1)
            end = i2;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i2;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1)
            end = i2;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (start === -1)
            start = i2;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i2;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i2;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1)
            end = i2;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i2;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  };
  var format2 = function(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  };
  var { tokenChars } = require_validation();
  module.exports = { format: format2, parse: parse3 };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var initAsClient = function(websocket, address, protocols, options5) {
    const opts = {
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options5,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
      websocket._url = address.href;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
      websocket._url = address;
    }
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https2.request : http3.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format2({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol2 of protocols) {
        if (typeof protocol2 !== "string" || !subprotocolRegex.test(protocol2) || protocolSet.has(protocol2)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol2);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options5 && options5.headers;
        options5 = { ...options5, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options5.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options5.headers.authorization) {
        options5.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location2 = res.headers.location;
      const statusCode = res.statusCode;
      if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location2, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location2}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options5);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash2("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse3(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    req.end();
  };
  var emitErrorAndClose = function(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  };
  var netConnect = function(options5) {
    options5.path = options5.socketPath;
    return net2.connect(options5);
  };
  var tlsConnect = function(options5) {
    options5.path = undefined;
    if (!options5.servername && options5.servername !== "") {
      options5.servername = net2.isIP(options5.host) ? "" : options5.host;
    }
    return tls.connect(options5);
  };
  var abortHandshake = function(websocket, stream2, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream2.setHeader) {
      stream2[kAborted] = true;
      stream2.abort();
      if (stream2.socket && !stream2.socket.destroyed) {
        stream2.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream2.destroy(err);
      stream2.once("error", websocket.emit.bind(websocket, "error"));
      stream2.once("close", websocket.emitClose.bind(websocket));
    }
  };
  var sendAfterClose = function(websocket, data, cb) {
    if (data) {
      const length2 = toBuffer2(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length2;
      else
        websocket._bufferedAmount += length2;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      cb(err);
    }
  };
  var receiverOnConclude = function(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  };
  var receiverOnDrain = function() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  };
  var receiverOnError = function(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  };
  var receiverOnFinish = function() {
    this[kWebSocket].emitClose();
  };
  var receiverOnMessage = function(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  };
  var receiverOnPing = function(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  };
  var receiverOnPong = function(data) {
    this[kWebSocket].emit("pong", data);
  };
  var resume = function(stream2) {
    stream2.resume();
  };
  var socketOnClose = function() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  };
  var socketOnData = function(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  };
  var socketOnEnd = function() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  };
  var socketOnError = function() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  };
  var EventEmitter3 = __require("events");
  var https2 = __require("https");
  var http3 = __require("http");
  var net2 = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash: createHash2 } = __require("crypto");
  var { Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants2();
  var {
    EventTarget: { addEventListener: addEventListener2, removeEventListener: removeEventListener2 }
  } = require_event_target();
  var { format: format2, parse: parse3 } = require_extension();
  var { toBuffer: toBuffer2 } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter3 {
    constructor(address, protocols, options5) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options5 = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options5);
      } else {
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options5) {
      const receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options5.maxPayload,
        skipUTF8Validation: options5.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options5.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options5, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options5 === "function") {
        cb = options5;
        options5 = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options5
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener2;
  WebSocket.prototype.removeEventListener = removeEventListener2;
  module.exports = WebSocket;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var parse3 = function(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i2 = 0;
    for (i2;i2 < header.length; i2++) {
      const code = header.charCodeAt(i2);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (i2 !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i2;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end === -1)
          end = i2;
        const protocol3 = header.slice(start, end);
        if (protocols.has(protocol3)) {
          throw new SyntaxError(`The "${protocol3}" subprotocol is duplicated`);
        }
        protocols.add(protocol3);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol2 = header.slice(start, i2);
    if (protocols.has(protocol2)) {
      throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
    }
    protocols.add(protocol2);
    return protocols;
  };
  var { tokenChars } = require_validation();
  module.exports = { parse: parse3 };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var addListeners = function(server, map2) {
    for (const event of Object.keys(map2))
      server.on(event, map2[event]);
    return function removeListeners() {
      for (const event of Object.keys(map2)) {
        server.removeListener(event, map2[event]);
      }
    };
  };
  var emitClose = function(server) {
    server._state = CLOSED;
    server.emit("close");
  };
  var socketOnError = function() {
    this.destroy();
  };
  var abortHandshake = function(socket, code, message, headers) {
    message = message || http3.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http3.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
  };
  var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  };
  var EventEmitter3 = __require("events");
  var http3 = __require("http");
  var https2 = __require("https");
  var net2 = __require("net");
  var tls = __require("tls");
  var { createHash: createHash2 } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants2();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter3 {
    constructor(options5, callback) {
      super();
      options5 = {
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options5
      };
      if (options5.port == null && !options5.server && !options5.noServer || options5.port != null && (options5.server || options5.noServer) || options5.server && options5.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
      }
      if (options5.port != null) {
        this._server = http3.createServer((req, res) => {
          const body = http3.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options5.port, options5.host, options5.backlog, callback);
      } else if (options5.server) {
        this._server = options5.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options5.perMessageDeflate === true)
        options5.perMessageDeflate = {};
      if (options5.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options5;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info2 = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info2, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info2))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash2("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null);
      if (protocols.size) {
        const protocol2 = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol2) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol2}`);
          ws._protocol = protocol2;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS((exports, module) => {
  var parseAcceptCharset = function(accept) {
    var accepts = accept.split(",");
    for (var i2 = 0, j = 0;i2 < accepts.length; i2++) {
      var charset = parseCharset(accepts[i2].trim(), i2);
      if (charset) {
        accepts[j++] = charset;
      }
    }
    accepts.length = j;
    return accepts;
  };
  var parseCharset = function(str, i2) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match)
      return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset,
      q,
      i: i2
    };
  };
  var getCharsetPriority = function(charset, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(charset, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  };
  var specify = function(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  };
  var preferredCharsets = function(accept, provided) {
    var accepts = parseAcceptCharset(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  };
  var compareSpecs = function(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  };
  var getFullCharset = function(spec) {
    return spec.charset;
  };
  var isQuality = function(spec) {
    return spec.q > 0;
  };
  module.exports = preferredCharsets;
  module.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  var parseAcceptEncoding = function(accept) {
    var accepts = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i2 = 0, j = 0;i2 < accepts.length; i2++) {
      var encoding = parseEncoding(accepts[i2].trim(), i2);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify("identity", encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j++] = {
        encoding: "identity",
        q: minQuality,
        i: i2
      };
    }
    accepts.length = j;
    return accepts;
  };
  var parseEncoding = function(str, i2) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match)
      return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding,
      q,
      i: i2
    };
  };
  var getEncodingPriority = function(encoding, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(encoding, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  };
  var specify = function(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  };
  var preferredEncodings = function(accept, provided) {
    var accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  };
  var compareSpecs = function(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  };
  var getFullEncoding = function(spec) {
    return spec.encoding;
  };
  var isQuality = function(spec) {
    return spec.q > 0;
  };
  module.exports = preferredEncodings;
  module.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS((exports, module) => {
  var parseAcceptLanguage = function(accept) {
    var accepts = accept.split(",");
    for (var i2 = 0, j = 0;i2 < accepts.length; i2++) {
      var language = parseLanguage(accepts[i2].trim(), i2);
      if (language) {
        accepts[j++] = language;
      }
    }
    accepts.length = j;
    return accepts;
  };
  var parseLanguage = function(str, i2) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match)
      return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q")
          q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i: i2,
      full
    };
  };
  var getLanguagePriority = function(language, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(language, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  };
  var specify = function(language, spec, index) {
    var p = parseLanguage(language);
    if (!p)
      return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  };
  var preferredLanguages = function(accept, provided) {
    var accepts = parseAcceptLanguage(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  };
  var compareSpecs = function(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  };
  var getFullLanguage = function(spec) {
    return spec.full;
  };
  var isQuality = function(spec) {
    return spec.q > 0;
  };
  module.exports = preferredLanguages;
  module.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS((exports, module) => {
  var parseAccept = function(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i2 = 0, j = 0;i2 < accepts.length; i2++) {
      var mediaType = parseMediaType(accepts[i2].trim(), i2);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }
    accepts.length = j;
    return accepts;
  };
  var parseMediaType = function(str, i2) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match)
      return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0;j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val2 = pair[1];
        var value = val2 && val2[0] === '"' && val2[val2.length - 1] === '"' ? val2.substr(1, val2.length - 2) : val2;
        if (key === "q") {
          q = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type,
      subtype,
      params,
      q,
      i: i2
    };
  };
  var getMediaTypePriority = function(type, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(type, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  };
  var specify = function(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  };
  var preferredMediaTypes = function(accept, provided) {
    var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  };
  var compareSpecs = function(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  };
  var getFullType = function(spec) {
    return spec.type + "/" + spec.subtype;
  };
  var isQuality = function(spec) {
    return spec.q > 0;
  };
  var quoteCount = function(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  };
  var splitKeyValuePair = function(str) {
    var index = str.indexOf("=");
    var key;
    var val2;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val2 = str.substr(index + 1);
    }
    return [key, val2];
  };
  var splitMediaTypes = function(accept) {
    var accepts = accept.split(",");
    for (var i2 = 1, j = 0;i2 < accepts.length; i2++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i2];
      } else {
        accepts[j] += "," + accepts[i2];
      }
    }
    accepts.length = j + 1;
    return accepts;
  };
  var splitParameters = function(str) {
    var parameters = str.split(";");
    for (var i2 = 1, j = 0;i2 < parameters.length; i2++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i2];
      } else {
        parameters[j] += ";" + parameters[i2];
      }
    }
    parameters.length = j + 1;
    for (var i2 = 0;i2 < parameters.length; i2++) {
      parameters[i2] = parameters[i2].trim();
    }
    return parameters;
  };
  module.exports = preferredMediaTypes;
  module.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS((exports, module) => {
  var Negotiator = function(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  };
  /*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var preferredCharsets = require_charset();
  var preferredEncodings = require_encoding();
  var preferredLanguages = require_language();
  var preferredMediaTypes = require_mediaType();
  module.exports = Negotiator;
  module.exports.Negotiator = Negotiator;
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers["accept-encoding"], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  var charset = function(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  };
  var contentType = function(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  };
  var extension = function(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  };
  var lookup2 = function(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  };
  var populateMaps = function(extensions, types7) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i2 = 0;i2 < exts.length; i2++) {
        var extension2 = exts[i2];
        if (types7[extension2]) {
          var from = preference.indexOf(db[types7[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types7[extension2] !== "application/octet-stream" && (from > to || from === to && types7[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types7[extension2] = type;
      }
    });
  };
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup2;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
});

// node_modules/accepts/index.js
var require_accepts = __commonJS((exports, module) => {
  var Accepts = function(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  };
  var extToMime = function(type) {
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  };
  var validMime = function(type) {
    return typeof type === "string";
  };
  /*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Negotiator = require_negotiator();
  var mime = require_mime_types();
  module.exports = Accepts;
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types7 = types_;
    if (types7 && !Array.isArray(types7)) {
      types7 = new Array(arguments.length);
      for (var i2 = 0;i2 < types7.length; i2++) {
        types7[i2] = arguments[i2];
      }
    }
    if (!types7 || types7.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types7[0];
    }
    var mimes = types7.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types7[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings = encodings_;
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i2 = 0;i2 < encodings.length; i2++) {
        encodings[i2] = arguments[i2];
      }
    }
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i2 = 0;i2 < charsets.length; i2++) {
        charsets[i2] = arguments[i2];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i2 = 0;i2 < languages.length; i2++) {
        languages[i2] = arguments[i2];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
});

// node_modules/base64id/lib/base64id.js
var require_base64id = __commonJS((exports, module) => {
  /*!
   * base64id v0.1.0
   */
  var crypto2 = __require("crypto");
  var Base64Id = function() {
  };
  Base64Id.prototype.getRandomBytes = function(bytes) {
    var BUFFER_SIZE = 4096;
    var self2 = this;
    bytes = bytes || 12;
    if (bytes > BUFFER_SIZE) {
      return crypto2.randomBytes(bytes);
    }
    var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
    var threshold = parseInt(bytesInBuffer * 0.85);
    if (!threshold) {
      return crypto2.randomBytes(bytes);
    }
    if (this.bytesBufferIndex == null) {
      this.bytesBufferIndex = -1;
    }
    if (this.bytesBufferIndex == bytesInBuffer) {
      this.bytesBuffer = null;
      this.bytesBufferIndex = -1;
    }
    if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
      if (!this.isGeneratingBytes) {
        this.isGeneratingBytes = true;
        crypto2.randomBytes(BUFFER_SIZE, function(err, bytes2) {
          self2.bytesBuffer = bytes2;
          self2.bytesBufferIndex = 0;
          self2.isGeneratingBytes = false;
        });
      }
      if (this.bytesBufferIndex == -1) {
        return crypto2.randomBytes(bytes);
      }
    }
    var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
    this.bytesBufferIndex++;
    return result;
  };
  Base64Id.prototype.generateId = function() {
    var rand = Buffer.alloc(15);
    if (!rand.writeInt32BE) {
      return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
    }
    this.sequenceNumber = this.sequenceNumber + 1 | 0;
    rand.writeInt32BE(this.sequenceNumber, 11);
    if (crypto2.randomBytes) {
      this.getRandomBytes(12).copy(rand);
    } else {
      [0, 4, 8].forEach(function(i2) {
        rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i2);
      });
    }
    return rand.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
  };
  exports = module.exports = new Base64Id;
});

// node_modules/engine.io-parser/build/cjs/commons.js
var require_commons = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = undefined;
  var PACKET_TYPES2 = Object.create(null);
  exports.PACKET_TYPES = PACKET_TYPES2;
  PACKET_TYPES2["open"] = "0";
  PACKET_TYPES2["close"] = "1";
  PACKET_TYPES2["ping"] = "2";
  PACKET_TYPES2["pong"] = "3";
  PACKET_TYPES2["message"] = "4";
  PACKET_TYPES2["upgrade"] = "5";
  PACKET_TYPES2["noop"] = "6";
  var PACKET_TYPES_REVERSE2 = Object.create(null);
  exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE2;
  Object.keys(PACKET_TYPES2).forEach((key) => {
    PACKET_TYPES_REVERSE2[PACKET_TYPES2[key]] = key;
  });
  var ERROR_PACKET2 = { type: "error", data: "parser error" };
  exports.ERROR_PACKET = ERROR_PACKET2;
});

// node_modules/engine.io-parser/build/cjs/encodePacket.js
var require_encodePacket = __commonJS((exports) => {
  var encodePacketToBinary2 = function(packet, callback) {
    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
      return callback(toBuffer2(packet.data, false));
    }
    (0, exports.encodePacket)(packet, true, (encoded) => {
      if (!TEXT_ENCODER2) {
        TEXT_ENCODER2 = new TextEncoder;
      }
      callback(TEXT_ENCODER2.encode(encoded));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodePacketToBinary = exports.encodePacket = undefined;
  var commons_js_1 = require_commons();
  var encodePacket3 = ({ type, data }, supportsBinary, callback) => {
    if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
      return callback(supportsBinary ? data : "b" + toBuffer2(data, true).toString("base64"));
    }
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
  };
  exports.encodePacket = encodePacket3;
  var toBuffer2 = (data, forceBufferConversion) => {
    if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return Buffer.from(data);
    } else {
      return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    }
  };
  var TEXT_ENCODER2;
  exports.encodePacketToBinary = encodePacketToBinary2;
});

// node_modules/engine.io-parser/build/cjs/decodePacket.js
var require_decodePacket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodePacket = undefined;
  var commons_js_1 = require_commons();
  var decodePacket3 = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary2(encodedPacket, binaryType)
      };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
      const buffer = Buffer.from(encodedPacket.substring(1), "base64");
      return {
        type: "message",
        data: mapBinary2(buffer, binaryType)
      };
    }
    if (!commons_js_1.PACKET_TYPES_REVERSE[type]) {
      return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: commons_js_1.PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: commons_js_1.PACKET_TYPES_REVERSE[type]
    };
  };
  exports.decodePacket = decodePacket3;
  var mapBinary2 = (data, binaryType) => {
    switch (binaryType) {
      case "arraybuffer":
        if (data instanceof ArrayBuffer) {
          return data;
        } else if (Buffer.isBuffer(data)) {
          return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
        } else {
          return data.buffer;
        }
      case "nodebuffer":
      default:
        if (Buffer.isBuffer(data)) {
          return data;
        } else {
          return Buffer.from(data);
        }
    }
  };
});

// node_modules/engine.io-parser/build/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var createPacketEncoderStream2 = function() {
    return new TransformStream({
      transform(packet, controller) {
        (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
          const payloadLength = encodedPacket.length;
          let header;
          if (payloadLength < 126) {
            header = new Uint8Array(1);
            new DataView(header.buffer).setUint8(0, payloadLength);
          } else if (payloadLength < 65536) {
            header = new Uint8Array(3);
            const view = new DataView(header.buffer);
            view.setUint8(0, 126);
            view.setUint16(1, payloadLength);
          } else {
            header = new Uint8Array(9);
            const view = new DataView(header.buffer);
            view.setUint8(0, 127);
            view.setBigUint64(1, BigInt(payloadLength));
          }
          if (packet.data && typeof packet.data !== "string") {
            header[0] |= 128;
          }
          controller.enqueue(header);
          controller.enqueue(encodedPacket);
        });
      }
    });
  };
  var totalLength2 = function(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
  };
  var concatChunks2 = function(chunks, size) {
    if (chunks[0].length === size) {
      return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i2 = 0;i2 < size; i2++) {
      buffer[i2] = chunks[0][j++];
      if (j === chunks[0].length) {
        chunks.shift();
        j = 0;
      }
    }
    if (chunks.length && j < chunks[0].length) {
      chunks[0] = chunks[0].slice(j);
    }
    return buffer;
  };
  var createPacketDecoderStream2 = function(maxPayload, binaryType) {
    if (!TEXT_DECODER2) {
      TEXT_DECODER2 = new TextDecoder;
    }
    const chunks = [];
    let state = 0;
    let expectedLength = -1;
    let isBinary2 = false;
    return new TransformStream({
      transform(chunk, controller) {
        chunks.push(chunk);
        while (true) {
          if (state === 0) {
            if (totalLength2(chunks) < 1) {
              break;
            }
            const header = concatChunks2(chunks, 1);
            isBinary2 = (header[0] & 128) === 128;
            expectedLength = header[0] & 127;
            if (expectedLength < 126) {
              state = 3;
            } else if (expectedLength === 126) {
              state = 1;
            } else {
              state = 2;
            }
          } else if (state === 1) {
            if (totalLength2(chunks) < 2) {
              break;
            }
            const headerArray = concatChunks2(chunks, 2);
            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
            state = 3;
          } else if (state === 2) {
            if (totalLength2(chunks) < 8) {
              break;
            }
            const headerArray = concatChunks2(chunks, 8);
            const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
            const n = view.getUint32(0);
            if (n > Math.pow(2, 53 - 32) - 1) {
              controller.enqueue(commons_js_1.ERROR_PACKET);
              break;
            }
            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
            state = 3;
          } else {
            if (totalLength2(chunks) < expectedLength) {
              break;
            }
            const data = concatChunks2(chunks, expectedLength);
            controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary2 ? data : TEXT_DECODER2.decode(data), binaryType));
            state = 0;
          }
          if (expectedLength === 0 || expectedLength > maxPayload) {
            controller.enqueue(commons_js_1.ERROR_PACKET);
            break;
          }
        }
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = exports.createPacketDecoderStream = exports.createPacketEncoderStream = undefined;
  var encodePacket_js_1 = require_encodePacket();
  Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function() {
    return encodePacket_js_1.encodePacket;
  } });
  var decodePacket_js_1 = require_decodePacket();
  Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function() {
    return decodePacket_js_1.decodePacket;
  } });
  var commons_js_1 = require_commons();
  var SEPARATOR2 = String.fromCharCode(30);
  var encodePayload2 = (packets, callback) => {
    const length2 = packets.length;
    const encodedPackets = new Array(length2);
    let count = 0;
    packets.forEach((packet, i2) => {
      (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
        encodedPackets[i2] = encodedPacket;
        if (++count === length2) {
          callback(encodedPackets.join(SEPARATOR2));
        }
      });
    });
  };
  exports.encodePayload = encodePayload2;
  var decodePayload2 = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR2);
    const packets = [];
    for (let i2 = 0;i2 < encodedPackets.length; i2++) {
      const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i2], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  exports.decodePayload = decodePayload2;
  exports.createPacketEncoderStream = createPacketEncoderStream2;
  var TEXT_DECODER2;
  exports.createPacketDecoderStream = createPacketDecoderStream2;
  exports.protocol = 4;
});

// node_modules/engine.io/build/parser-v3/utf8.js
var require_utf8 = __commonJS((exports, module) => {
  var ucs2decode = function(string) {
    var output = [];
    var counter = 0;
    var length2 = string.length;
    var value;
    var extra;
    while (counter < length2) {
      value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length2) {
        extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  };
  var ucs2encode = function(array) {
    var length2 = array.length;
    var index = -1;
    var value;
    var output = "";
    while (++index < length2) {
      value = array[index];
      if (value > 65535) {
        value -= 65536;
        output += stringFromCharCode(value >>> 10 & 1023 | 55296);
        value = 56320 | value & 1023;
      }
      output += stringFromCharCode(value);
    }
    return output;
  };
  var checkScalarValue = function(codePoint, strict) {
    if (codePoint >= 55296 && codePoint <= 57343) {
      if (strict) {
        throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
      }
      return false;
    }
    return true;
  };
  var createByte = function(codePoint, shift) {
    return stringFromCharCode(codePoint >> shift & 63 | 128);
  };
  var encodeCodePoint = function(codePoint, strict) {
    if ((codePoint & 4294967168) == 0) {
      return stringFromCharCode(codePoint);
    }
    var symbol = "";
    if ((codePoint & 4294965248) == 0) {
      symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
    } else if ((codePoint & 4294901760) == 0) {
      if (!checkScalarValue(codePoint, strict)) {
        codePoint = 65533;
      }
      symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
      symbol += createByte(codePoint, 6);
    } else if ((codePoint & 4292870144) == 0) {
      symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
      symbol += createByte(codePoint, 12);
      symbol += createByte(codePoint, 6);
    }
    symbol += stringFromCharCode(codePoint & 63 | 128);
    return symbol;
  };
  var utf8encode = function(string, opts) {
    opts = opts || {};
    var strict = opts.strict !== false;
    var codePoints = ucs2decode(string);
    var length2 = codePoints.length;
    var index = -1;
    var codePoint;
    var byteString = "";
    while (++index < length2) {
      codePoint = codePoints[index];
      byteString += encodeCodePoint(codePoint, strict);
    }
    return byteString;
  };
  var readContinuationByte = function() {
    if (byteIndex >= byteCount) {
      throw Error("Invalid byte index");
    }
    var continuationByte = byteArray[byteIndex] & 255;
    byteIndex++;
    if ((continuationByte & 192) == 128) {
      return continuationByte & 63;
    }
    throw Error("Invalid continuation byte");
  };
  var decodeSymbol = function(strict) {
    var byte1;
    var byte2;
    var byte3;
    var byte4;
    var codePoint;
    if (byteIndex > byteCount) {
      throw Error("Invalid byte index");
    }
    if (byteIndex == byteCount) {
      return false;
    }
    byte1 = byteArray[byteIndex] & 255;
    byteIndex++;
    if ((byte1 & 128) == 0) {
      return byte1;
    }
    if ((byte1 & 224) == 192) {
      byte2 = readContinuationByte();
      codePoint = (byte1 & 31) << 6 | byte2;
      if (codePoint >= 128) {
        return codePoint;
      } else {
        throw Error("Invalid continuation byte");
      }
    }
    if ((byte1 & 240) == 224) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
      if (codePoint >= 2048) {
        return checkScalarValue(codePoint, strict) ? codePoint : 65533;
      } else {
        throw Error("Invalid continuation byte");
      }
    }
    if ((byte1 & 248) == 240) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      byte4 = readContinuationByte();
      codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (codePoint >= 65536 && codePoint <= 1114111) {
        return codePoint;
      }
    }
    throw Error("Invalid UTF-8 detected");
  };
  var utf8decode = function(byteString, opts) {
    opts = opts || {};
    var strict = opts.strict !== false;
    byteArray = ucs2decode(byteString);
    byteCount = byteArray.length;
    byteIndex = 0;
    var codePoints = [];
    var tmp;
    while ((tmp = decodeSymbol(strict)) !== false) {
      codePoints.push(tmp);
    }
    return ucs2encode(codePoints);
  };
  /*! https://mths.be/utf8js v2.1.2 by @mathias */
  var stringFromCharCode = String.fromCharCode;
  var byteArray;
  var byteCount;
  var byteIndex;
  module.exports = {
    version: "2.1.2",
    encode: utf8encode,
    decode: utf8decode
  };
});

// node_modules/engine.io/build/parser-v3/index.js
var require_parser_v3 = __commonJS((exports) => {
  var encodePacket3 = function(packet, supportsBinary, utf8encode, callback) {
    if (typeof supportsBinary === "function") {
      callback = supportsBinary;
      supportsBinary = null;
    }
    if (typeof utf8encode === "function") {
      callback = utf8encode;
      utf8encode = null;
    }
    if (Buffer.isBuffer(packet.data)) {
      return encodeBuffer(packet, supportsBinary, callback);
    } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
      return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
    }
    var encoded = exports.packets[packet.type];
    if (packet.data !== undefined) {
      encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
    }
    return callback("" + encoded);
  };
  var encodeBuffer = function(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return encodeBase64Packet(packet, callback);
    }
    var data = packet.data;
    var typeBuffer = Buffer.allocUnsafe(1);
    typeBuffer[0] = exports.packets[packet.type];
    return callback(Buffer.concat([typeBuffer, data]));
  };
  var encodeBase64Packet = function(packet, callback) {
    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
    var message = "b" + exports.packets[packet.type];
    message += data.toString("base64");
    return callback(message);
  };
  var decodePacket3 = function(data, binaryType, utf8decode) {
    if (data === undefined) {
      return err;
    }
    var type;
    if (typeof data === "string") {
      type = data.charAt(0);
      if (type === "b") {
        return decodeBase64Packet(data.slice(1), binaryType);
      }
      if (utf8decode) {
        data = tryDecode(data);
        if (data === false) {
          return err;
        }
      }
      if (Number(type) != type || !packetslist[type]) {
        return err;
      }
      if (data.length > 1) {
        return { type: packetslist[type], data: data.slice(1) };
      } else {
        return { type: packetslist[type] };
      }
    }
    if (binaryType === "arraybuffer") {
      var intArray = new Uint8Array(data);
      type = intArray[0];
      return { type: packetslist[type], data: intArray.buffer.slice(1) };
    }
    if (data instanceof ArrayBuffer) {
      data = arrayBufferToBuffer(data);
    }
    type = data[0];
    return { type: packetslist[type], data: data.slice(1) };
  };
  var tryDecode = function(data) {
    try {
      data = utf8.decode(data, { strict: false });
    } catch (e) {
      return false;
    }
    return data;
  };
  var decodeBase64Packet = function(msg, binaryType) {
    var type = packetslist[msg.charAt(0)];
    var data = Buffer.from(msg.slice(1), "base64");
    if (binaryType === "arraybuffer") {
      var abv = new Uint8Array(data.length);
      for (var i2 = 0;i2 < abv.length; i2++) {
        abv[i2] = data[i2];
      }
      data = abv.buffer;
    }
    return { type, data };
  };
  var encodePayload2 = function(packets, supportsBinary, callback) {
    if (typeof supportsBinary === "function") {
      callback = supportsBinary;
      supportsBinary = null;
    }
    if (supportsBinary && hasBinary2(packets)) {
      return encodePayloadAsBinary(packets, callback);
    }
    if (!packets.length) {
      return callback("0:");
    }
    function encodeOne(packet, doneCallback) {
      encodePacket3(packet, supportsBinary, false, function(message) {
        doneCallback(null, setLengthHeader(message));
      });
    }
    map2(packets, encodeOne, function(err2, results) {
      return callback(results.join(""));
    });
  };
  var setLengthHeader = function(message) {
    return message.length + ":" + message;
  };
  var map2 = function(ary, each, done) {
    const results = new Array(ary.length);
    let count = 0;
    for (let i2 = 0;i2 < ary.length; i2++) {
      each(ary[i2], (error, msg) => {
        results[i2] = msg;
        if (++count === ary.length) {
          done(null, results);
        }
      });
    }
  };
  var decodePayload2 = function(data, binaryType, callback) {
    if (typeof data !== "string") {
      return decodePayloadAsBinary(data, binaryType, callback);
    }
    if (typeof binaryType === "function") {
      callback = binaryType;
      binaryType = null;
    }
    if (data === "") {
      return callback(err, 0, 1);
    }
    var length2 = "", n, msg, packet;
    for (var i2 = 0, l = data.length;i2 < l; i2++) {
      var chr = data.charAt(i2);
      if (chr !== ":") {
        length2 += chr;
        continue;
      }
      if (length2 === "" || length2 != (n = Number(length2))) {
        return callback(err, 0, 1);
      }
      msg = data.slice(i2 + 1, i2 + 1 + n);
      if (length2 != msg.length) {
        return callback(err, 0, 1);
      }
      if (msg.length) {
        packet = decodePacket3(msg, binaryType, false);
        if (err.type === packet.type && err.data === packet.data) {
          return callback(err, 0, 1);
        }
        var more = callback(packet, i2 + n, l);
        if (more === false)
          return;
      }
      i2 += n;
      length2 = "";
    }
    if (length2 !== "") {
      return callback(err, 0, 1);
    }
  };
  var bufferToString = function(buffer) {
    var str = "";
    for (var i2 = 0, l = buffer.length;i2 < l; i2++) {
      str += String.fromCharCode(buffer[i2]);
    }
    return str;
  };
  var stringToBuffer = function(string) {
    var buf = Buffer.allocUnsafe(string.length);
    for (var i2 = 0, l = string.length;i2 < l; i2++) {
      buf.writeUInt8(string.charCodeAt(i2), i2);
    }
    return buf;
  };
  var arrayBufferToBuffer = function(data) {
    var length2 = data.byteLength || data.length;
    var offset = data.byteOffset || 0;
    return Buffer.from(data.buffer || data, offset, length2);
  };
  var encodePayloadAsBinary = function(packets, callback) {
    if (!packets.length) {
      return callback(EMPTY_BUFFER);
    }
    map2(packets, encodeOneBinaryPacket, function(err2, results) {
      return callback(Buffer.concat(results));
    });
  };
  var encodeOneBinaryPacket = function(p, doneCallback) {
    function onBinaryPacketEncode(packet) {
      var encodingLength = "" + packet.length;
      var sizeBuffer;
      if (typeof packet === "string") {
        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
        sizeBuffer[0] = 0;
        for (var i2 = 0;i2 < encodingLength.length; i2++) {
          sizeBuffer[i2 + 1] = parseInt(encodingLength[i2], 10);
        }
        sizeBuffer[sizeBuffer.length - 1] = 255;
        return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
      }
      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
      sizeBuffer[0] = 1;
      for (var i2 = 0;i2 < encodingLength.length; i2++) {
        sizeBuffer[i2 + 1] = parseInt(encodingLength[i2], 10);
      }
      sizeBuffer[sizeBuffer.length - 1] = 255;
      doneCallback(null, Buffer.concat([sizeBuffer, packet]));
    }
    encodePacket3(p, true, true, onBinaryPacketEncode);
  };
  var decodePayloadAsBinary = function(data, binaryType, callback) {
    if (typeof binaryType === "function") {
      callback = binaryType;
      binaryType = null;
    }
    var bufferTail = data;
    var buffers = [];
    var i2;
    while (bufferTail.length > 0) {
      var strLen = "";
      var isString = bufferTail[0] === 0;
      for (i2 = 1;; i2++) {
        if (bufferTail[i2] === 255)
          break;
        if (strLen.length > 310) {
          return callback(err, 0, 1);
        }
        strLen += "" + bufferTail[i2];
      }
      bufferTail = bufferTail.slice(strLen.length + 1);
      var msgLength = parseInt(strLen, 10);
      var msg = bufferTail.slice(1, msgLength + 1);
      if (isString)
        msg = bufferToString(msg);
      buffers.push(msg);
      bufferTail = bufferTail.slice(msgLength + 1);
    }
    var total = buffers.length;
    for (i2 = 0;i2 < total; i2++) {
      var buffer = buffers[i2];
      callback(decodePacket3(buffer, binaryType, true), i2, total);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = undefined;
  var utf8 = require_utf8();
  exports.protocol = 3;
  var hasBinary2 = (packets) => {
    for (const packet of packets) {
      if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return true;
      }
    }
    return false;
  };
  exports.packets = {
    open: 0,
    close: 1,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = Object.keys(exports.packets);
  var err = { type: "error", data: "parser error" };
  var EMPTY_BUFFER = Buffer.concat([]);
  exports.encodePacket = encodePacket3;
  exports.encodeBase64Packet = encodeBase64Packet;
  exports.decodePacket = decodePacket3;
  exports.decodeBase64Packet = decodeBase64Packet;
  exports.encodePayload = encodePayload2;
  exports.decodePayload = decodePayload2;
  exports.encodePayloadAsBinary = encodePayloadAsBinary;
  exports.decodePayloadAsBinary = decodePayloadAsBinary;
});

// node_modules/engine.io/build/transport.js
var require_transport = __commonJS((exports) => {
  var noop3 = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transport = undefined;
  var events_1 = __require("events");
  var parser_v4 = require_cjs2();
  var parser_v3 = require_parser_v3();
  var debug_1 = require_src();
  var debug15 = (0, debug_1.default)("engine:transport");

  class Transport2 extends events_1.EventEmitter {
    constructor(req) {
      super();
      this.readyState = "open";
      this.discarded = false;
      this.protocol = req._query.EIO === "4" ? 4 : 3;
      this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
    }
    get readyState() {
      return this._readyState;
    }
    set readyState(state) {
      debug15("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
      this._readyState = state;
    }
    discard() {
      this.discarded = true;
    }
    onRequest(req) {
      debug15("setting request");
      this.req = req;
    }
    close(fn) {
      if (this.readyState === "closed" || this.readyState === "closing")
        return;
      this.readyState = "closing";
      this.doClose(fn || noop3);
    }
    onError(msg, desc) {
      if (this.listeners("error").length) {
        const err = new Error(msg);
        err.type = "TransportError";
        err.description = desc;
        this.emit("error", err);
      } else {
        debug15("ignored transport error %s (%s)", msg, desc);
      }
    }
    onPacket(packet) {
      this.emit("packet", packet);
    }
    onData(data) {
      this.onPacket(this.parser.decodePacket(data));
    }
    onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  }
  exports.Transport = Transport2;
});

// node_modules/engine.io/build/transports/polling.js
var require_polling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var transport_1 = require_transport();
  var zlib_1 = __require("zlib");
  var accepts = require_accepts();
  var debug_1 = require_src();
  var debug15 = (0, debug_1.default)("engine:polling");
  var compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate
  };

  class Polling2 extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.closeTimeout = 30 * 1000;
    }
    get name() {
      return "polling";
    }
    get supportsFraming() {
      return false;
    }
    onRequest(req) {
      const res = req.res;
      if (req.method === "GET") {
        this.onPollRequest(req, res);
      } else if (req.method === "POST") {
        this.onDataRequest(req, res);
      } else {
        res.writeHead(500);
        res.end();
      }
    }
    onPollRequest(req, res) {
      if (this.req) {
        debug15("request overlap");
        this.onError("overlap from client");
        res.writeHead(400);
        res.end();
        return;
      }
      debug15("setting request");
      this.req = req;
      this.res = res;
      const onClose = () => {
        this.onError("poll connection closed prematurely");
      };
      const cleanup = () => {
        req.removeListener("close", onClose);
        this.req = this.res = null;
      };
      req.cleanup = cleanup;
      req.on("close", onClose);
      this.writable = true;
      this.emit("drain");
      if (this.writable && this.shouldClose) {
        debug15("triggering empty send to append close packet");
        this.send([{ type: "noop" }]);
      }
    }
    onDataRequest(req, res) {
      if (this.dataReq) {
        this.onError("data request overlap from client");
        res.writeHead(400);
        res.end();
        return;
      }
      const isBinary2 = req.headers["content-type"] === "application/octet-stream";
      if (isBinary2 && this.protocol === 4) {
        return this.onError("invalid content");
      }
      this.dataReq = req;
      this.dataRes = res;
      let chunks = isBinary2 ? Buffer.concat([]) : "";
      const cleanup = () => {
        req.removeListener("data", onData);
        req.removeListener("end", onEnd);
        req.removeListener("close", onClose);
        this.dataReq = this.dataRes = chunks = null;
      };
      const onClose = () => {
        cleanup();
        this.onError("data request connection closed prematurely");
      };
      const onData = (data) => {
        let contentLength;
        if (isBinary2) {
          chunks = Buffer.concat([chunks, data]);
          contentLength = chunks.length;
        } else {
          chunks += data;
          contentLength = Buffer.byteLength(chunks);
        }
        if (contentLength > this.maxHttpBufferSize) {
          res.writeHead(413).end();
          cleanup();
        }
      };
      const onEnd = () => {
        this.onData(chunks);
        const headers = {
          "Content-Type": "text/html",
          "Content-Length": 2
        };
        res.writeHead(200, this.headers(req, headers));
        res.end("ok");
        cleanup();
      };
      req.on("close", onClose);
      if (!isBinary2)
        req.setEncoding("utf8");
      req.on("data", onData);
      req.on("end", onEnd);
    }
    onData(data) {
      debug15('received "%s"', data);
      const callback = (packet) => {
        if (packet.type === "close") {
          debug15("got xhr close packet");
          this.onClose();
          return false;
        }
        this.onPacket(packet);
      };
      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    onClose() {
      if (this.writable) {
        this.send([{ type: "noop" }]);
      }
      super.onClose();
    }
    send(packets) {
      this.writable = false;
      if (this.shouldClose) {
        debug15("appending close packet to payload");
        packets.push({ type: "close" });
        this.shouldClose();
        this.shouldClose = null;
      }
      const doWrite = (data) => {
        const compress = packets.some((packet) => {
          return packet.options && packet.options.compress;
        });
        this.write(data, { compress });
      };
      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    write(data, options5) {
      debug15('writing "%s"', data);
      this.doWrite(data, options5, () => {
        this.req.cleanup();
      });
    }
    doWrite(data, options5, callback) {
      const isString = typeof data === "string";
      const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      const headers = {
        "Content-Type": contentType
      };
      const respond = (data2) => {
        headers["Content-Length"] = typeof data2 === "string" ? Buffer.byteLength(data2) : data2.length;
        this.res.writeHead(200, this.headers(this.req, headers));
        this.res.end(data2);
        callback();
      };
      if (!this.httpCompression || !options5.compress) {
        respond(data);
        return;
      }
      const len = isString ? Buffer.byteLength(data) : data.length;
      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }
      const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
      if (!encoding) {
        respond(data);
        return;
      }
      this.compress(data, encoding, (err, data2) => {
        if (err) {
          this.res.writeHead(500);
          this.res.end();
          callback(err);
          return;
        }
        headers["Content-Encoding"] = encoding;
        respond(data2);
      });
    }
    compress(data, encoding, callback) {
      debug15("compressing");
      const buffers = [];
      let nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function() {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    doClose(fn) {
      debug15("closing");
      let closeTimeoutTimer;
      if (this.dataReq) {
        debug15("aborting ongoing data request");
        this.dataReq.destroy();
      }
      const onClose = () => {
        clearTimeout(closeTimeoutTimer);
        fn();
        this.onClose();
      };
      if (this.writable) {
        debug15("transport writable - closing right away");
        this.send([{ type: "close" }]);
        onClose();
      } else if (this.discarded) {
        debug15("transport discarded - closing right away");
        onClose();
      } else {
        debug15("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    headers(req, headers) {
      headers = headers || {};
      const ua = req.headers["user-agent"];
      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        headers["X-XSS-Protection"] = "0";
      }
      headers["cache-control"] = "no-store";
      this.emit("headers", headers, req);
      return headers;
    }
  }
  exports.Polling = Polling2;
});

// node_modules/engine.io/build/transports/polling-jsonp.js
var require_polling_jsonp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JSONP = undefined;
  var polling_1 = require_polling();
  var qs = __require("querystring");
  var rDoubleSlashes = /\\\\n/g;
  var rSlashes = /(\\)?\\n/g;

  class JSONP extends polling_1.Polling {
    constructor(req) {
      super(req);
      this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
      this.foot = ");";
    }
    onData(data) {
      data = qs.parse(data).d;
      if (typeof data === "string") {
        data = data.replace(rSlashes, function(match, slashes) {
          return slashes ? match : "\n";
        });
        super.onData(data.replace(rDoubleSlashes, "\\n"));
      }
    }
    doWrite(data, options5, callback) {
      const js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      data = this.head + js + this.foot;
      super.doWrite(data, options5, callback);
    }
  }
  exports.JSONP = JSONP;
});

// node_modules/engine.io/build/transports/websocket.js
var require_websocket2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebSocket = undefined;
  var transport_1 = require_transport();
  var debug_1 = require_src();
  var debug15 = (0, debug_1.default)("engine:ws");

  class WebSocket3 extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.socket = req.websocket;
      this.socket.on("message", (data, isBinary2) => {
        const message = isBinary2 ? data : data.toString();
        debug15('received "%s"', message);
        super.onData(message);
      });
      this.socket.once("close", this.onClose.bind(this));
      this.socket.on("error", this.onError.bind(this));
      this.writable = true;
      this.perMessageDeflate = null;
    }
    get name() {
      return "websocket";
    }
    get handlesUpgrades() {
      return true;
    }
    get supportsFraming() {
      return true;
    }
    send(packets) {
      this.writable = false;
      for (let i2 = 0;i2 < packets.length; i2++) {
        const packet = packets[i2];
        const isLast = i2 + 1 === packets.length;
        const opts = {};
        if (packet.options) {
          opts.compress = packet.options.compress;
        }
        const onSent = (err) => {
          if (err) {
            return this.onError("write error", err.stack);
          } else if (isLast) {
            this.writable = true;
            this.emit("drain");
          }
        };
        const send = (data) => {
          if (this.perMessageDeflate) {
            const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
            if (len < this.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
          debug15('writing "%s"', data);
          this.socket.send(data, opts, onSent);
        };
        if (packet.options && typeof packet.options.wsPreEncoded === "string") {
          send(packet.options.wsPreEncoded);
        } else if (this._canSendPreEncodedFrame(packet)) {
          this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, onSent);
        } else {
          this.parser.encodePacket(packet, this.supportsBinary, send);
        }
      }
    }
    _canSendPreEncodedFrame(packet) {
      var _a, _b, _c;
      return !this.perMessageDeflate && typeof ((_b = (_a = this.socket) === null || _a === undefined ? undefined : _a._sender) === null || _b === undefined ? undefined : _b.sendFrame) === "function" && ((_c = packet.options) === null || _c === undefined ? undefined : _c.wsPreEncodedFrame) !== undefined;
    }
    doClose(fn) {
      debug15("closing");
      this.socket.close();
      fn && fn();
    }
  }
  exports.WebSocket = WebSocket3;
});

// node_modules/engine.io/build/transports/webtransport.js
var require_webtransport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebTransport = undefined;
  var transport_1 = require_transport();
  var debug_1 = require_src();
  var engine_io_parser_1 = require_cjs2();
  var debug15 = (0, debug_1.default)("engine:webtransport");

  class WebTransport2 extends transport_1.Transport {
    constructor(session, stream3, reader) {
      super({ _query: { EIO: "4" } });
      this.session = session;
      const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();
      transformStream.readable.pipeTo(stream3.writable).catch(() => {
        debug15("the stream was closed");
      });
      this.writer = transformStream.writable.getWriter();
      (async () => {
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              debug15("session is closed");
              break;
            }
            debug15("received chunk: %o", value);
            this.onPacket(value);
          }
        } catch (e) {
          debug15("error while reading: %s", e.message);
        }
      })();
      session.closed.then(() => this.onClose());
      this.writable = true;
    }
    get name() {
      return "webtransport";
    }
    get supportsFraming() {
      return true;
    }
    async send(packets) {
      this.writable = false;
      try {
        for (let i2 = 0;i2 < packets.length; i2++) {
          const packet = packets[i2];
          await this.writer.write(packet);
        }
      } catch (e) {
        debug15("error while writing: %s", e.message);
      }
      this.writable = true;
      this.emit("drain");
    }
    doClose(fn) {
      debug15("closing WebTransport session");
      this.session.close();
      fn && fn();
    }
  }
  exports.WebTransport = WebTransport2;
});

// node_modules/engine.io/build/transports/index.js
var require_transports = __commonJS((exports) => {
  var polling2 = function(req) {
    if (typeof req._query.j === "string") {
      return new polling_jsonp_1.JSONP(req);
    } else {
      return new polling_1.Polling(req);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var polling_1 = require_polling();
  var polling_jsonp_1 = require_polling_jsonp();
  var websocket_1 = require_websocket2();
  var webtransport_1 = require_webtransport();
  exports.default = {
    polling: polling2,
    websocket: websocket_1.WebSocket,
    webtransport: webtransport_1.WebTransport
  };
  polling2.upgradesTo = ["websocket", "webtransport"];
});

// node_modules/engine.io/build/socket.js
var require_socket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Socket = undefined;
  var events_1 = __require("events");
  var debug_1 = require_src();
  var timers_1 = __require("timers");
  var debug15 = (0, debug_1.default)("engine:socket");

  class Socket3 extends events_1.EventEmitter {
    constructor(id, server, transport4, req, protocol4) {
      super();
      this.id = id;
      this.server = server;
      this.upgrading = false;
      this.upgraded = false;
      this.readyState = "opening";
      this.writeBuffer = [];
      this.packetsFn = [];
      this.sentCallbackFn = [];
      this.cleanupFn = [];
      this.request = req;
      this.protocol = protocol4;
      if (req) {
        if (req.websocket && req.websocket._socket) {
          this.remoteAddress = req.websocket._socket.remoteAddress;
        } else {
          this.remoteAddress = req.connection.remoteAddress;
        }
      } else {
      }
      this.checkIntervalTimer = null;
      this.upgradeTimeoutTimer = null;
      this.pingTimeoutTimer = null;
      this.pingIntervalTimer = null;
      this.setTransport(transport4);
      this.onOpen();
    }
    get readyState() {
      return this._readyState;
    }
    set readyState(state) {
      debug15("readyState updated from %s to %s", this._readyState, state);
      this._readyState = state;
    }
    onOpen() {
      this.readyState = "open";
      this.transport.sid = this.id;
      this.sendPacket("open", JSON.stringify({
        sid: this.id,
        upgrades: this.getAvailableUpgrades(),
        pingInterval: this.server.opts.pingInterval,
        pingTimeout: this.server.opts.pingTimeout,
        maxPayload: this.server.opts.maxHttpBufferSize
      }));
      if (this.server.opts.initialPacket) {
        this.sendPacket("message", this.server.opts.initialPacket);
      }
      this.emit("open");
      if (this.protocol === 3) {
        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
      } else {
        this.schedulePing();
      }
    }
    onPacket(packet) {
      if (this.readyState !== "open") {
        return debug15("packet received with closed socket");
      }
      debug15(`received packet ${packet.type}`);
      this.emit("packet", packet);
      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
      switch (packet.type) {
        case "ping":
          if (this.transport.protocol !== 3) {
            this.onError("invalid heartbeat direction");
            return;
          }
          debug15("got ping");
          this.sendPacket("pong");
          this.emit("heartbeat");
          break;
        case "pong":
          if (this.transport.protocol === 3) {
            this.onError("invalid heartbeat direction");
            return;
          }
          debug15("got pong");
          this.pingIntervalTimer.refresh();
          this.emit("heartbeat");
          break;
        case "error":
          this.onClose("parse error");
          break;
        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    }
    onError(err) {
      debug15("transport error");
      this.onClose("transport error", err);
    }
    schedulePing() {
      this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
        debug15("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
        this.sendPacket("ping");
        this.resetPingTimeout(this.server.opts.pingTimeout);
      }, this.server.opts.pingInterval);
    }
    resetPingTimeout(timeout) {
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {
        if (this.readyState === "closed")
          return;
        this.onClose("ping timeout");
      }, timeout);
    }
    setTransport(transport4) {
      const onError = this.onError.bind(this);
      const onPacket = this.onPacket.bind(this);
      const flush = this.flush.bind(this);
      const onClose = this.onClose.bind(this, "transport close");
      this.transport = transport4;
      this.transport.once("error", onError);
      this.transport.on("packet", onPacket);
      this.transport.on("drain", flush);
      this.transport.once("close", onClose);
      this.setupSendCallback();
      this.cleanupFn.push(function() {
        transport4.removeListener("error", onError);
        transport4.removeListener("packet", onPacket);
        transport4.removeListener("drain", flush);
        transport4.removeListener("close", onClose);
      });
    }
    maybeUpgrade(transport4) {
      debug15('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport4.name);
      this.upgrading = true;
      this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
        debug15("client did not complete upgrade - closing transport");
        cleanup();
        if (transport4.readyState === "open") {
          transport4.close();
        }
      }, this.server.opts.upgradeTimeout);
      const onPacket = (packet) => {
        if (packet.type === "ping" && packet.data === "probe") {
          debug15("got probe ping packet, sending pong");
          transport4.send([{ type: "pong", data: "probe" }]);
          this.emit("upgrading", transport4);
          clearInterval(this.checkIntervalTimer);
          this.checkIntervalTimer = setInterval(check, 100);
        } else if (packet.type === "upgrade" && this.readyState !== "closed") {
          debug15("got upgrade packet - upgrading");
          cleanup();
          this.transport.discard();
          this.upgraded = true;
          this.clearTransport();
          this.setTransport(transport4);
          this.emit("upgrade", transport4);
          this.flush();
          if (this.readyState === "closing") {
            transport4.close(() => {
              this.onClose("forced close");
            });
          }
        } else {
          cleanup();
          transport4.close();
        }
      };
      const check = () => {
        if (this.transport.name === "polling" && this.transport.writable) {
          debug15("writing a noop packet to polling for fast upgrade");
          this.transport.send([{ type: "noop" }]);
        }
      };
      const cleanup = () => {
        this.upgrading = false;
        clearInterval(this.checkIntervalTimer);
        this.checkIntervalTimer = null;
        (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);
        this.upgradeTimeoutTimer = null;
        transport4.removeListener("packet", onPacket);
        transport4.removeListener("close", onTransportClose);
        transport4.removeListener("error", onError);
        this.removeListener("close", onClose);
      };
      const onError = (err) => {
        debug15("client did not complete upgrade - %s", err);
        cleanup();
        transport4.close();
        transport4 = null;
      };
      const onTransportClose = () => {
        onError("transport closed");
      };
      const onClose = () => {
        onError("socket closed");
      };
      transport4.on("packet", onPacket);
      transport4.once("close", onTransportClose);
      transport4.once("error", onError);
      this.once("close", onClose);
    }
    clearTransport() {
      let cleanup;
      const toCleanUp = this.cleanupFn.length;
      for (let i2 = 0;i2 < toCleanUp; i2++) {
        cleanup = this.cleanupFn.shift();
        cleanup();
      }
      this.transport.on("error", function() {
        debug15("error triggered by discarded transport");
      });
      this.transport.close();
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    onClose(reason, description) {
      if (this.readyState !== "closed") {
        this.readyState = "closed";
        (0, timers_1.clearTimeout)(this.pingIntervalTimer);
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        clearInterval(this.checkIntervalTimer);
        this.checkIntervalTimer = null;
        (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);
        process.nextTick(() => {
          this.writeBuffer = [];
        });
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.clearTransport();
        this.emit("close", reason, description);
      }
    }
    setupSendCallback() {
      const onDrain = () => {
        if (this.sentCallbackFn.length > 0) {
          const seqFn = this.sentCallbackFn.splice(0, 1)[0];
          if (typeof seqFn === "function") {
            debug15("executing send callback");
            seqFn(this.transport);
          } else if (Array.isArray(seqFn)) {
            debug15("executing batch send callback");
            const l = seqFn.length;
            let i2 = 0;
            for (;i2 < l; i2++) {
              if (typeof seqFn[i2] === "function") {
                seqFn[i2](this.transport);
              }
            }
          }
        }
      };
      this.transport.on("drain", onDrain);
      this.cleanupFn.push(() => {
        this.transport.removeListener("drain", onDrain);
      });
    }
    send(data, options5, callback) {
      this.sendPacket("message", data, options5, callback);
      return this;
    }
    write(data, options5, callback) {
      this.sendPacket("message", data, options5, callback);
      return this;
    }
    sendPacket(type, data, options5 = {}, callback) {
      if (typeof options5 === "function") {
        callback = options5;
        options5 = {};
      }
      if (this.readyState !== "closing" && this.readyState !== "closed") {
        debug15('sending packet "%s" (%s)', type, data);
        options5.compress = options5.compress !== false;
        const packet = {
          type,
          options: options5
        };
        if (data)
          packet.data = data;
        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (callback)
          this.packetsFn.push(callback);
        this.flush();
      }
    }
    flush() {
      if (this.readyState !== "closed" && this.transport.writable && this.writeBuffer.length) {
        debug15("flushing buffer to transport");
        this.emit("flush", this.writeBuffer);
        this.server.emit("flush", this, this.writeBuffer);
        const wbuf = this.writeBuffer;
        this.writeBuffer = [];
        if (!this.transport.supportsFraming) {
          this.sentCallbackFn.push(this.packetsFn);
        } else {
          this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
        }
        this.packetsFn = [];
        this.transport.send(wbuf);
        this.emit("drain");
        this.server.emit("drain", this);
      }
    }
    getAvailableUpgrades() {
      const availableUpgrades = [];
      const allUpgrades = this.server.upgrades(this.transport.name);
      let i2 = 0;
      const l = allUpgrades.length;
      for (;i2 < l; ++i2) {
        const upg = allUpgrades[i2];
        if (this.server.opts.transports.indexOf(upg) !== -1) {
          availableUpgrades.push(upg);
        }
      }
      return availableUpgrades;
    }
    close(discard) {
      if (this.readyState !== "open")
        return;
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        debug15("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
        this.once("drain", () => {
          debug15("all packets have been sent, closing the transport");
          this.closeTransport(discard);
        });
        return;
      }
      debug15("the buffer is empty, closing the transport right away", discard);
      this.closeTransport(discard);
    }
    closeTransport(discard) {
      debug15("closing the transport (discard? %s)", discard);
      if (discard)
        this.transport.discard();
      this.transport.close(this.onClose.bind(this, "forced close"));
    }
  }
  exports.Socket = Socket3;
});

// node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  var parse4 = function(str, options5) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options5 || {};
    var pairs = str.split(";");
    var dec = opt.decode || decode2;
    for (var i2 = 0;i2 < pairs.length; i2++) {
      var pair = pairs[i2];
      var index = pair.indexOf("=");
      if (index < 0) {
        continue;
      }
      var key = pair.substring(0, index).trim();
      if (obj[key] == undefined) {
        var val2 = pair.substring(index + 1, pair.length).trim();
        if (val2[0] === '"') {
          val2 = val2.slice(1, -1);
        }
        obj[key] = tryDecode(val2, dec);
      }
    }
    return obj;
  };
  var serialize = function(name, val2, options5) {
    var opt = options5 || {};
    var enc = opt.encode || encode3;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val2);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      if (typeof opt.expires.toUTCString !== "function") {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + opt.expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  };
  var tryDecode = function(str, decode3) {
    try {
      return decode3(str);
    } catch (e) {
      return str;
    }
  };
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse4;
  exports.serialize = serialize;
  var decode2 = decodeURIComponent;
  var encode3 = encodeURIComponent;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket3 = require_websocket();
  WebSocket3.createWebSocketStream = require_stream();
  WebSocket3.Server = require_websocket_server();
  WebSocket3.Receiver = require_receiver();
  WebSocket3.Sender = require_sender();
  WebSocket3.WebSocket = WebSocket3;
  WebSocket3.WebSocketServer = WebSocket3.Server;
  module.exports = WebSocket3;
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports, module) => {
  var toObject = function(val2) {
    if (val2 === null || val2 === undefined) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val2);
  };
  var shouldUseNative = function() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0;i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  };
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1;s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i2 = 0;i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from, symbols[i2])) {
            to[symbols[i2]] = from[symbols[i2]];
          }
        }
      }
    }
    return to;
  };
});

// node_modules/vary/index.js
var require_vary = __commonJS((exports, module) => {
  var append = function(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse4(String(field)) : field;
    for (var j = 0;j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val2 = header;
    var vals = parse4(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i2 = 0;i2 < fields.length; i2++) {
      var fld = fields[i2].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val2 = val2 ? val2 + ", " + fields[i2] : fields[i2];
      }
    }
    return val2;
  };
  var parse4 = function(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i2 = 0, len = header.length;i2 < len; i2++) {
      switch (header.charCodeAt(i2)) {
        case 32:
          if (start === end) {
            start = end = i2 + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i2 + 1;
          break;
        default:
          end = i2 + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  };
  var vary = function(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val2 = res.getHeader("Vary") || "";
    var header = Array.isArray(val2) ? val2.join(", ") : String(val2);
    if (val2 = append(header, field)) {
      res.setHeader("Vary", val2);
    }
  };
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = vary;
  module.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
});

// node_modules/cors/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  (function() {
    var assign = require_object_assign();
    var vary = require_vary();
    var defaults2 = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString(s) {
      return typeof s === "string" || s instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i2 = 0;i2 < allowedOrigin.length; ++i2) {
          if (isOriginAllowed(origin, allowedOrigin[i2])) {
            return true;
          }
        }
        return false;
      } else if (isString(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options5, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options5.origin || options5.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString(options5.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options5.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options5.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options5) {
      var methods = options5.methods;
      if (methods.join) {
        methods = options5.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods
      };
    }
    function configureCredentials(options5) {
      if (options5.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options5, req) {
      var allowedHeaders = options5.allowedHeaders || options5.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options5) {
      var headers = options5.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options5) {
      var maxAge = (typeof options5.maxAge === "number" || options5.maxAge) && options5.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i2 = 0, n = headers.length;i2 < n; i2++) {
        var header = headers[i2];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors(options5, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options5, req));
        headers.push(configureCredentials(options5, req));
        headers.push(configureMethods(options5, req));
        headers.push(configureAllowedHeaders(options5, req));
        headers.push(configureMaxAge(options5, req));
        headers.push(configureExposedHeaders(options5, req));
        applyHeaders(headers, res);
        if (options5.preflightContinue) {
          next();
        } else {
          res.statusCode = options5.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options5, req));
        headers.push(configureCredentials(options5, req));
        headers.push(configureExposedHeaders(options5, req));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options5) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults2, options5);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  corsOptions.origin = origin;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    module.exports = middlewareWrapper;
  })();
});

// node_modules/engine.io/build/server.js
var require_server = __commonJS((exports) => {
  var parseSessionId = function(data) {
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed.sid === "string") {
        return parsed.sid;
      }
    } catch (e) {
    }
  };
  var abortRequest = function(res, errorCode, errorContext) {
    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
    const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
    res.writeHead(statusCode, { "Content-Type": "application/json" });
    res.end(JSON.stringify({
      code: errorCode,
      message
    }));
  };
  var abortUpgrade = function(socket4, errorCode, errorContext = {}) {
    socket4.on("error", () => {
      debug15("ignoring error from closed connection");
    });
    if (socket4.writable) {
      const message = errorContext.message || Server.errorMessages[errorCode];
      const length2 = Buffer.byteLength(message);
      socket4.write("HTTP/1.1 400 Bad Request\r\nConnection: close\r\nContent-type: text/html\r\nContent-Length: " + length2 + "\r\n\r\n" + message);
    }
    socket4.destroy();
  };
  var checkInvalidHeaderChar = function(val2) {
    val2 += "";
    if (val2.length < 1)
      return false;
    if (!validHdrChars[val2.charCodeAt(0)]) {
      debug15('invalid header, index 0, char "%s"', val2.charCodeAt(0));
      return true;
    }
    if (val2.length < 2)
      return false;
    if (!validHdrChars[val2.charCodeAt(1)]) {
      debug15('invalid header, index 1, char "%s"', val2.charCodeAt(1));
      return true;
    }
    if (val2.length < 3)
      return false;
    if (!validHdrChars[val2.charCodeAt(2)]) {
      debug15('invalid header, index 2, char "%s"', val2.charCodeAt(2));
      return true;
    }
    if (val2.length < 4)
      return false;
    if (!validHdrChars[val2.charCodeAt(3)]) {
      debug15('invalid header, index 3, char "%s"', val2.charCodeAt(3));
      return true;
    }
    for (let i2 = 4;i2 < val2.length; ++i2) {
      if (!validHdrChars[val2.charCodeAt(i2)]) {
        debug15('invalid header, index "%i", char "%s"', i2, val2.charCodeAt(i2));
        return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = exports.BaseServer = undefined;
  var qs = __require("querystring");
  var url_1 = __require("url");
  var base64id = require_base64id();
  var transports_1 = require_transports();
  var events_1 = __require("events");
  var socket_1 = require_socket();
  var debug_1 = require_src();
  var cookie_1 = require_cookie();
  var ws_1 = require_ws();
  var webtransport_1 = require_webtransport();
  var engine_io_parser_1 = require_cjs2();
  var debug15 = (0, debug_1.default)("engine");
  var kResponseHeaders = Symbol("responseHeaders");

  class BaseServer extends events_1.EventEmitter {
    constructor(opts = {}) {
      super();
      this.middlewares = [];
      this.clients = {};
      this.clientsCount = 0;
      this.opts = Object.assign({
        wsEngine: ws_1.Server,
        pingTimeout: 20000,
        pingInterval: 25000,
        upgradeTimeout: 1e4,
        maxHttpBufferSize: 1e6,
        transports: ["polling", "websocket"],
        allowUpgrades: true,
        httpCompression: {
          threshold: 1024
        },
        cors: false,
        allowEIO3: false
      }, opts);
      if (opts.cookie) {
        this.opts.cookie = Object.assign({
          name: "io",
          path: "/",
          httpOnly: opts.cookie.path !== false,
          sameSite: "lax"
        }, opts.cookie);
      }
      if (this.opts.cors) {
        this.use(require_lib6()(this.opts.cors));
      }
      if (opts.perMessageDeflate) {
        this.opts.perMessageDeflate = Object.assign({
          threshold: 1024
        }, opts.perMessageDeflate);
      }
      this.init();
    }
    _computePath(options5) {
      let path = (options5.path || "/engine.io").replace(/\/$/, "");
      if (options5.addTrailingSlash !== false) {
        path += "/";
      }
      return path;
    }
    upgrades(transport4) {
      if (!this.opts.allowUpgrades)
        return [];
      return transports_1.default[transport4].upgradesTo || [];
    }
    verify(req, upgrade, fn) {
      const transport4 = req._query.transport;
      if (!~this.opts.transports.indexOf(transport4) || transport4 === "webtransport") {
        debug15('unknown transport "%s"', transport4);
        return fn(Server.errors.UNKNOWN_TRANSPORT, { transport: transport4 });
      }
      const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
      if (isOriginInvalid) {
        const origin = req.headers.origin;
        req.headers.origin = null;
        debug15("origin header invalid");
        return fn(Server.errors.BAD_REQUEST, {
          name: "INVALID_ORIGIN",
          origin
        });
      }
      const sid = req._query.sid;
      if (sid) {
        if (!this.clients.hasOwnProperty(sid)) {
          debug15('unknown sid "%s"', sid);
          return fn(Server.errors.UNKNOWN_SID, {
            sid
          });
        }
        const previousTransport = this.clients[sid].transport.name;
        if (!upgrade && previousTransport !== transport4) {
          debug15("bad request: unexpected transport without upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_MISMATCH",
            transport: transport4,
            previousTransport
          });
        }
      } else {
        if (req.method !== "GET") {
          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
            method: req.method
          });
        }
        if (transport4 === "websocket" && !upgrade) {
          debug15("invalid transport upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_HANDSHAKE_ERROR"
          });
        }
        if (!this.opts.allowRequest)
          return fn();
        return this.opts.allowRequest(req, (message, success) => {
          if (!success) {
            return fn(Server.errors.FORBIDDEN, {
              message
            });
          }
          fn();
        });
      }
      fn();
    }
    use(fn) {
      this.middlewares.push(fn);
    }
    _applyMiddlewares(req, res, callback) {
      if (this.middlewares.length === 0) {
        debug15("no middleware to apply, skipping");
        return callback();
      }
      const apply = (i2) => {
        debug15("applying middleware n\xB0%d", i2 + 1);
        this.middlewares[i2](req, res, (err) => {
          if (err) {
            return callback(err);
          }
          if (i2 + 1 < this.middlewares.length) {
            apply(i2 + 1);
          } else {
            callback();
          }
        });
      };
      apply(0);
    }
    close() {
      debug15("closing all open clients");
      for (let i2 in this.clients) {
        if (this.clients.hasOwnProperty(i2)) {
          this.clients[i2].close(true);
        }
      }
      this.cleanup();
      return this;
    }
    generateId(req) {
      return base64id.generateId();
    }
    async handshake(transportName, req, closeConnection) {
      const protocol4 = req._query.EIO === "4" ? 4 : 3;
      if (protocol4 === 3 && !this.opts.allowEIO3) {
        debug15("unsupported protocol version");
        this.emit("connection_error", {
          req,
          code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
          message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
          context: {
            protocol: protocol4
          }
        });
        closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
        return;
      }
      let id;
      try {
        id = await this.generateId(req);
      } catch (e) {
        debug15("error while generating an id");
        this.emit("connection_error", {
          req,
          code: Server.errors.BAD_REQUEST,
          message: Server.errorMessages[Server.errors.BAD_REQUEST],
          context: {
            name: "ID_GENERATION_ERROR",
            error: e
          }
        });
        closeConnection(Server.errors.BAD_REQUEST);
        return;
      }
      debug15('handshaking client "%s"', id);
      try {
        var transport4 = this.createTransport(transportName, req);
        if (transportName === "polling") {
          transport4.maxHttpBufferSize = this.opts.maxHttpBufferSize;
          transport4.httpCompression = this.opts.httpCompression;
        } else if (transportName === "websocket") {
          transport4.perMessageDeflate = this.opts.perMessageDeflate;
        }
        if (req._query && req._query.b64) {
          transport4.supportsBinary = false;
        } else {
          transport4.supportsBinary = true;
        }
      } catch (e) {
        debug15('error handshaking to transport "%s"', transportName);
        this.emit("connection_error", {
          req,
          code: Server.errors.BAD_REQUEST,
          message: Server.errorMessages[Server.errors.BAD_REQUEST],
          context: {
            name: "TRANSPORT_HANDSHAKE_ERROR",
            error: e
          }
        });
        closeConnection(Server.errors.BAD_REQUEST);
        return;
      }
      const socket4 = new socket_1.Socket(id, this, transport4, req, protocol4);
      transport4.on("headers", (headers, req2) => {
        const isInitialRequest = !req2._query.sid;
        if (isInitialRequest) {
          if (this.opts.cookie) {
            headers["Set-Cookie"] = [
              (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)
            ];
          }
          this.emit("initial_headers", headers, req2);
        }
        this.emit("headers", headers, req2);
      });
      transport4.onRequest(req);
      this.clients[id] = socket4;
      this.clientsCount++;
      socket4.once("close", () => {
        delete this.clients[id];
        this.clientsCount--;
      });
      this.emit("connection", socket4);
      return transport4;
    }
    async onWebTransportSession(session) {
      const timeout = setTimeout(() => {
        debug15("the client failed to establish a bidirectional stream in the given period");
        session.close();
      }, this.opts.upgradeTimeout);
      const streamReader = session.incomingBidirectionalStreams.getReader();
      const result = await streamReader.read();
      if (result.done) {
        debug15("session is closed");
        return;
      }
      const stream3 = result.value;
      const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
      const reader = stream3.readable.pipeThrough(transformStream).getReader();
      const { value, done } = await reader.read();
      if (done) {
        debug15("stream is closed");
        return;
      }
      clearTimeout(timeout);
      if (value.type !== "open") {
        debug15("invalid WebTransport handshake");
        return session.close();
      }
      if (value.data === undefined) {
        const transport4 = new webtransport_1.WebTransport(session, stream3, reader);
        const id = base64id.generateId();
        debug15('handshaking client "%s" (WebTransport)', id);
        const socket4 = new socket_1.Socket(id, this, transport4, null, 4);
        this.clients[id] = socket4;
        this.clientsCount++;
        socket4.once("close", () => {
          delete this.clients[id];
          this.clientsCount--;
        });
        this.emit("connection", socket4);
        return;
      }
      const sid = parseSessionId(value.data);
      if (!sid) {
        debug15("invalid WebTransport handshake");
        return session.close();
      }
      const client2 = this.clients[sid];
      if (!client2) {
        debug15("upgrade attempt for closed client");
        session.close();
      } else if (client2.upgrading) {
        debug15("transport has already been trying to upgrade");
        session.close();
      } else if (client2.upgraded) {
        debug15("transport had already been upgraded");
        session.close();
      } else {
        debug15("upgrading existing transport");
        const transport4 = new webtransport_1.WebTransport(session, stream3, reader);
        client2.maybeUpgrade(transport4);
      }
    }
  }
  exports.BaseServer = BaseServer;
  BaseServer.errors = {
    UNKNOWN_TRANSPORT: 0,
    UNKNOWN_SID: 1,
    BAD_HANDSHAKE_METHOD: 2,
    BAD_REQUEST: 3,
    FORBIDDEN: 4,
    UNSUPPORTED_PROTOCOL_VERSION: 5
  };
  BaseServer.errorMessages = {
    0: "Transport unknown",
    1: "Session ID unknown",
    2: "Bad handshake method",
    3: "Bad request",
    4: "Forbidden",
    5: "Unsupported protocol version"
  };

  class WebSocketResponse {
    constructor(req, socket4) {
      this.req = req;
      this.socket = socket4;
      req[kResponseHeaders] = {};
    }
    setHeader(name, value) {
      this.req[kResponseHeaders][name] = value;
    }
    getHeader(name) {
      return this.req[kResponseHeaders][name];
    }
    removeHeader(name) {
      delete this.req[kResponseHeaders][name];
    }
    write() {
    }
    writeHead() {
    }
    end() {
      this.socket.destroy();
    }
  }

  class Server extends BaseServer {
    init() {
      if (!~this.opts.transports.indexOf("websocket"))
        return;
      if (this.ws)
        this.ws.close();
      this.ws = new this.opts.wsEngine({
        noServer: true,
        clientTracking: false,
        perMessageDeflate: this.opts.perMessageDeflate,
        maxPayload: this.opts.maxHttpBufferSize
      });
      if (typeof this.ws.on === "function") {
        this.ws.on("headers", (headersArray, req) => {
          const additionalHeaders = req[kResponseHeaders] || {};
          delete req[kResponseHeaders];
          const isInitialRequest = !req._query.sid;
          if (isInitialRequest) {
            this.emit("initial_headers", additionalHeaders, req);
          }
          this.emit("headers", additionalHeaders, req);
          debug15("writing headers: %j", additionalHeaders);
          Object.keys(additionalHeaders).forEach((key) => {
            headersArray.push(`${key}: ${additionalHeaders[key]}`);
          });
        });
      }
    }
    cleanup() {
      if (this.ws) {
        debug15("closing webSocketServer");
        this.ws.close();
      }
    }
    prepare(req) {
      if (!req._query) {
        req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
      }
    }
    createTransport(transportName, req) {
      return new transports_1.default[transportName](req);
    }
    handleRequest(req, res) {
      debug15('handling "%s" http request "%s"', req.method, req.url);
      this.prepare(req);
      req.res = res;
      const callback = (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });
          abortRequest(res, errorCode, errorContext);
          return;
        }
        if (req._query.sid) {
          debug15("setting new request for existing client");
          this.clients[req._query.sid].transport.onRequest(req);
        } else {
          const closeConnection = (errorCode2, errorContext2) => abortRequest(res, errorCode2, errorContext2);
          this.handshake(req._query.transport, req, closeConnection);
        }
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, false, callback);
        }
      });
    }
    handleUpgrade(req, socket4, upgradeHead) {
      this.prepare(req);
      const res = new WebSocketResponse(req, socket4);
      const callback = (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });
          abortUpgrade(socket4, errorCode, errorContext);
          return;
        }
        const head = Buffer.from(upgradeHead);
        upgradeHead = null;
        res.writeHead();
        this.ws.handleUpgrade(req, socket4, head, (websocket3) => {
          this.onWebSocket(req, socket4, websocket3);
        });
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, true, callback);
        }
      });
    }
    onWebSocket(req, socket4, websocket3) {
      websocket3.on("error", onUpgradeError);
      if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
        debug15("transport doesnt handle upgraded requests");
        websocket3.close();
        return;
      }
      const id = req._query.sid;
      req.websocket = websocket3;
      if (id) {
        const client2 = this.clients[id];
        if (!client2) {
          debug15("upgrade attempt for closed client");
          websocket3.close();
        } else if (client2.upgrading) {
          debug15("transport has already been trying to upgrade");
          websocket3.close();
        } else if (client2.upgraded) {
          debug15("transport had already been upgraded");
          websocket3.close();
        } else {
          debug15("upgrading existing transport");
          websocket3.removeListener("error", onUpgradeError);
          const transport4 = this.createTransport(req._query.transport, req);
          if (req._query && req._query.b64) {
            transport4.supportsBinary = false;
          } else {
            transport4.supportsBinary = true;
          }
          transport4.perMessageDeflate = this.opts.perMessageDeflate;
          client2.maybeUpgrade(transport4);
        }
      } else {
        const closeConnection = (errorCode, errorContext) => abortUpgrade(socket4, errorCode, errorContext);
        this.handshake(req._query.transport, req, closeConnection);
      }
      function onUpgradeError() {
        debug15("websocket error before upgrade");
      }
    }
    attach(server, options5 = {}) {
      const path = this._computePath(options5);
      const destroyUpgradeTimeout = options5.destroyUpgradeTimeout || 1000;
      function check(req) {
        return path === req.url.slice(0, path.length);
      }
      const listeners = server.listeners("request").slice(0);
      server.removeAllListeners("request");
      server.on("close", this.close.bind(this));
      server.on("listening", this.init.bind(this));
      server.on("request", (req, res) => {
        if (check(req)) {
          debug15('intercepting request for path "%s"', path);
          this.handleRequest(req, res);
        } else {
          let i2 = 0;
          const l = listeners.length;
          for (;i2 < l; i2++) {
            listeners[i2].call(server, req, res);
          }
        }
      });
      if (~this.opts.transports.indexOf("websocket")) {
        server.on("upgrade", (req, socket4, head) => {
          if (check(req)) {
            this.handleUpgrade(req, socket4, head);
          } else if (options5.destroyUpgrade !== false) {
            setTimeout(function() {
              if (socket4.writable && socket4.bytesWritten <= 0) {
                socket4.on("error", (e) => {
                  debug15("error while destroying upgrade: %s", e.message);
                });
                return socket4.end();
              }
            }, destroyUpgradeTimeout);
          }
        });
      }
    }
  }
  exports.Server = Server;
  var validHdrChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
});

// node_modules/engine.io/build/transports-uws/polling.js
var require_polling2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var transport_1 = require_transport();
  var zlib_1 = __require("zlib");
  var accepts = require_accepts();
  var debug_1 = require_src();
  var debug15 = (0, debug_1.default)("engine:polling");
  var compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate
  };

  class Polling2 extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.closeTimeout = 30 * 1000;
    }
    get name() {
      return "polling";
    }
    get supportsFraming() {
      return false;
    }
    onRequest(req) {
      const res = req.res;
      if (req.getMethod() === "get") {
        this.onPollRequest(req, res);
      } else if (req.getMethod() === "post") {
        this.onDataRequest(req, res);
      } else {
        res.writeStatus("500 Internal Server Error");
        res.end();
      }
    }
    onPollRequest(req, res) {
      if (this.req) {
        debug15("request overlap");
        this.onError("overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }
      debug15("setting request");
      this.req = req;
      this.res = res;
      const onClose = () => {
        this.writable = false;
        this.onError("poll connection closed prematurely");
      };
      const cleanup = () => {
        this.req = this.res = null;
      };
      req.cleanup = cleanup;
      res.onAborted(onClose);
      this.writable = true;
      this.emit("drain");
      if (this.writable && this.shouldClose) {
        debug15("triggering empty send to append close packet");
        this.send([{ type: "noop" }]);
      }
    }
    onDataRequest(req, res) {
      if (this.dataReq) {
        this.onError("data request overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }
      const expectedContentLength = Number(req.headers["content-length"]);
      if (!expectedContentLength) {
        this.onError("content-length header required");
        res.writeStatus("411 Length Required").end();
        return;
      }
      if (expectedContentLength > this.maxHttpBufferSize) {
        this.onError("payload too large");
        res.writeStatus("413 Payload Too Large").end();
        return;
      }
      const isBinary2 = req.headers["content-type"] === "application/octet-stream";
      if (isBinary2 && this.protocol === 4) {
        return this.onError("invalid content");
      }
      this.dataReq = req;
      this.dataRes = res;
      let buffer;
      let offset = 0;
      const headers = {
        "Content-Type": "text/html"
      };
      this.headers(req, headers);
      for (let key in headers) {
        res.writeHeader(key, String(headers[key]));
      }
      const onEnd = (buffer2) => {
        this.onData(buffer2.toString());
        this.onDataRequestCleanup();
        res.cork(() => {
          res.end("ok");
        });
      };
      res.onAborted(() => {
        this.onDataRequestCleanup();
        this.onError("data request connection closed prematurely");
      });
      res.onData((arrayBuffer, isLast) => {
        const totalLength2 = offset + arrayBuffer.byteLength;
        if (totalLength2 > expectedContentLength) {
          this.onError("content-length mismatch");
          res.close();
          return;
        }
        if (!buffer) {
          if (isLast) {
            onEnd(Buffer.from(arrayBuffer));
            return;
          }
          buffer = Buffer.allocUnsafe(expectedContentLength);
        }
        Buffer.from(arrayBuffer).copy(buffer, offset);
        if (isLast) {
          if (totalLength2 != expectedContentLength) {
            this.onError("content-length mismatch");
            res.writeStatus("400 Content-Length Mismatch").end();
            this.onDataRequestCleanup();
            return;
          }
          onEnd(buffer);
          return;
        }
        offset = totalLength2;
      });
    }
    onDataRequestCleanup() {
      this.dataReq = this.dataRes = null;
    }
    onData(data) {
      debug15('received "%s"', data);
      const callback = (packet) => {
        if (packet.type === "close") {
          debug15("got xhr close packet");
          this.onClose();
          return false;
        }
        this.onPacket(packet);
      };
      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    onClose() {
      if (this.writable) {
        this.send([{ type: "noop" }]);
      }
      super.onClose();
    }
    send(packets) {
      this.writable = false;
      if (this.shouldClose) {
        debug15("appending close packet to payload");
        packets.push({ type: "close" });
        this.shouldClose();
        this.shouldClose = null;
      }
      const doWrite = (data) => {
        const compress = packets.some((packet) => {
          return packet.options && packet.options.compress;
        });
        this.write(data, { compress });
      };
      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    write(data, options5) {
      debug15('writing "%s"', data);
      this.doWrite(data, options5, () => {
        this.req.cleanup();
      });
    }
    doWrite(data, options5, callback) {
      const isString = typeof data === "string";
      const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      const headers = {
        "Content-Type": contentType
      };
      const respond = (data2) => {
        this.headers(this.req, headers);
        this.res.cork(() => {
          Object.keys(headers).forEach((key) => {
            this.res.writeHeader(key, String(headers[key]));
          });
          this.res.end(data2);
        });
        callback();
      };
      if (!this.httpCompression || !options5.compress) {
        respond(data);
        return;
      }
      const len = isString ? Buffer.byteLength(data) : data.length;
      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }
      const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
      if (!encoding) {
        respond(data);
        return;
      }
      this.compress(data, encoding, (err, data2) => {
        if (err) {
          this.res.writeStatus("500 Internal Server Error");
          this.res.end();
          callback(err);
          return;
        }
        headers["Content-Encoding"] = encoding;
        respond(data2);
      });
    }
    compress(data, encoding, callback) {
      debug15("compressing");
      const buffers = [];
      let nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function() {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    doClose(fn) {
      debug15("closing");
      let closeTimeoutTimer;
      const onClose = () => {
        clearTimeout(closeTimeoutTimer);
        fn();
        this.onClose();
      };
      if (this.writable) {
        debug15("transport writable - closing right away");
        this.send([{ type: "close" }]);
        onClose();
      } else if (this.discarded) {
        debug15("transport discarded - closing right away");
        onClose();
      } else {
        debug15("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    headers(req, headers) {
      headers = headers || {};
      const ua = req.headers["user-agent"];
      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        headers["X-XSS-Protection"] = "0";
      }
      headers["cache-control"] = "no-store";
      this.emit("headers", headers, req);
      return headers;
    }
  }
  exports.Polling = Polling2;
});

// node_modules/engine.io/build/transports-uws/websocket.js
var require_websocket3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebSocket = undefined;
  var transport_1 = require_transport();
  var debug_1 = require_src();
  var debug15 = (0, debug_1.default)("engine:ws");

  class WebSocket3 extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.writable = false;
      this.perMessageDeflate = null;
    }
    get name() {
      return "websocket";
    }
    get handlesUpgrades() {
      return true;
    }
    get supportsFraming() {
      return true;
    }
    send(packets) {
      this.writable = false;
      for (let i2 = 0;i2 < packets.length; i2++) {
        const packet = packets[i2];
        const isLast = i2 + 1 === packets.length;
        const send = (data) => {
          const isBinary2 = typeof data !== "string";
          const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
          debug15('writing "%s"', data);
          this.socket.send(data, isBinary2, compress);
          if (isLast) {
            this.writable = true;
            this.emit("drain");
          }
        };
        if (packet.options && typeof packet.options.wsPreEncoded === "string") {
          send(packet.options.wsPreEncoded);
        } else {
          this.parser.encodePacket(packet, this.supportsBinary, send);
        }
      }
    }
    doClose(fn) {
      debug15("closing");
      fn && fn();
      this.socket.end();
    }
  }
  exports.WebSocket = WebSocket3;
});

// node_modules/engine.io/build/transports-uws/index.js
var require_transports_uws = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var polling_1 = require_polling2();
  var websocket_1 = require_websocket3();
  exports.default = {
    polling: polling_1.Polling,
    websocket: websocket_1.WebSocket
  };
});

// node_modules/engine.io/build/userver.js
var require_userver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uServer = undefined;
  var debug_1 = require_src();
  var server_1 = require_server();
  var transports_uws_1 = require_transports_uws();
  var debug15 = (0, debug_1.default)("engine:uws");

  class uServer extends server_1.BaseServer {
    init() {
    }
    cleanup() {
    }
    prepare(req, res) {
      req.method = req.getMethod().toUpperCase();
      req.url = req.getUrl();
      const params = new URLSearchParams(req.getQuery());
      req._query = Object.fromEntries(params.entries());
      req.headers = {};
      req.forEach((key, value) => {
        req.headers[key] = value;
      });
      req.connection = {
        remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
      };
      res.onAborted(() => {
        debug15("response has been aborted");
      });
    }
    createTransport(transportName, req) {
      return new transports_uws_1.default[transportName](req);
    }
    attach(app, options5 = {}) {
      const path = this._computePath(options5);
      app.any(path, this.handleRequest.bind(this)).ws(path, {
        compression: options5.compression,
        idleTimeout: options5.idleTimeout,
        maxBackpressure: options5.maxBackpressure,
        maxPayloadLength: this.opts.maxHttpBufferSize,
        upgrade: this.handleUpgrade.bind(this),
        open: (ws) => {
          const transport4 = ws.getUserData().transport;
          transport4.socket = ws;
          transport4.writable = true;
          transport4.emit("drain");
        },
        message: (ws, message, isBinary2) => {
          ws.getUserData().transport.onData(isBinary2 ? message : Buffer.from(message).toString());
        },
        close: (ws, code, message) => {
          ws.getUserData().transport.onClose(code, message);
        }
      });
    }
    _applyMiddlewares(req, res, callback) {
      if (this.middlewares.length === 0) {
        return callback();
      }
      req.res = new ResponseWrapper(res);
      super._applyMiddlewares(req, req.res, (err) => {
        req.res.writeHead();
        callback(err);
      });
    }
    handleRequest(res, req) {
      debug15('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
      this.prepare(req, res);
      req.res = res;
      const callback = (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });
          this.abortRequest(req.res, errorCode, errorContext);
          return;
        }
        if (req._query.sid) {
          debug15("setting new request for existing client");
          this.clients[req._query.sid].transport.onRequest(req);
        } else {
          const closeConnection = (errorCode2, errorContext2) => this.abortRequest(res, errorCode2, errorContext2);
          this.handshake(req._query.transport, req, closeConnection);
        }
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, false, callback);
        }
      });
    }
    handleUpgrade(res, req, context) {
      debug15("on upgrade");
      this.prepare(req, res);
      req.res = res;
      const callback = async (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });
          this.abortRequest(res, errorCode, errorContext);
          return;
        }
        const id = req._query.sid;
        let transport4;
        if (id) {
          const client2 = this.clients[id];
          if (!client2) {
            debug15("upgrade attempt for closed client");
            res.close();
          } else if (client2.upgrading) {
            debug15("transport has already been trying to upgrade");
            res.close();
          } else if (client2.upgraded) {
            debug15("transport had already been upgraded");
            res.close();
          } else {
            debug15("upgrading existing transport");
            transport4 = this.createTransport(req._query.transport, req);
            client2.maybeUpgrade(transport4);
          }
        } else {
          transport4 = await this.handshake(req._query.transport, req, (errorCode2, errorContext2) => this.abortRequest(res, errorCode2, errorContext2));
          if (!transport4) {
            return;
          }
        }
        req.res.writeStatus("101 Switching Protocols");
        res.upgrade({
          transport: transport4
        }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, true, callback);
        }
      });
    }
    abortRequest(res, errorCode, errorContext) {
      const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
      const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
      res.writeStatus(statusCode);
      res.writeHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: errorCode,
        message
      }));
    }
  }
  exports.uServer = uServer;

  class ResponseWrapper {
    constructor(res) {
      this.res = res;
      this.statusWritten = false;
      this.headers = [];
      this.isAborted = false;
    }
    set statusCode(status) {
      if (!status) {
        return;
      }
      this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
    writeHead(status) {
      this.statusCode = status;
    }
    setHeader(key, value) {
      if (Array.isArray(value)) {
        value.forEach((val2) => {
          this.writeHeader(key, val2);
        });
      } else {
        this.writeHeader(key, value);
      }
    }
    removeHeader() {
    }
    getHeader() {
    }
    writeStatus(status) {
      if (this.isAborted)
        return;
      this.res.writeStatus(status);
      this.statusWritten = true;
      this.writeBufferedHeaders();
      return this;
    }
    writeHeader(key, value) {
      if (this.isAborted)
        return;
      if (key === "Content-Length") {
        return;
      }
      if (this.statusWritten) {
        this.res.writeHeader(key, value);
      } else {
        this.headers.push([key, value]);
      }
    }
    writeBufferedHeaders() {
      this.headers.forEach(([key, value]) => {
        this.res.writeHeader(key, value);
      });
    }
    end(data) {
      if (this.isAborted)
        return;
      this.res.cork(() => {
        if (!this.statusWritten) {
          this.writeBufferedHeaders();
        }
        this.res.end(data);
      });
    }
    onData(fn) {
      if (this.isAborted)
        return;
      this.res.onData(fn);
    }
    onAborted(fn) {
      if (this.isAborted)
        return;
      this.res.onAborted(() => {
        this.isAborted = true;
        fn();
      });
    }
    cork(fn) {
      if (this.isAborted)
        return;
      this.res.cork(fn);
    }
  }
});

// node_modules/engine.io/build/engine.io.js
var require_engine_io = __commonJS((exports) => {
  var listen = function(port, options5, fn) {
    if (typeof options5 === "function") {
      fn = options5;
      options5 = {};
    }
    const server = (0, http_1.createServer)(function(req, res) {
      res.writeHead(501);
      res.end("Not Implemented");
    });
    const engine = attach(server, options5);
    engine.httpServer = server;
    server.listen(port, fn);
    return engine;
  };
  var attach = function(server, options5) {
    const engine = new server_1.Server(options5);
    engine.attach(server, options5);
    return engine;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.attach = exports.listen = exports.transports = exports.Server = undefined;
  var http_1 = __require("http");
  var server_1 = require_server();
  Object.defineProperty(exports, "Server", { enumerable: true, get: function() {
    return server_1.Server;
  } });
  var index_1 = require_transports();
  exports.transports = index_1.default;
  var parser = require_cjs2();
  exports.parser = parser;
  var userver_1 = require_userver();
  Object.defineProperty(exports, "uServer", { enumerable: true, get: function() {
    return userver_1.uServer;
  } });
  var socket_1 = require_socket();
  Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
    return socket_1.Socket;
  } });
  var transport_1 = require_transport();
  Object.defineProperty(exports, "Transport", { enumerable: true, get: function() {
    return transport_1.Transport;
  } });
  exports.protocol = parser.protocol;
  exports.listen = listen;
  exports.attach = attach;
});

// node_modules/socket.io-parser/build/cjs/is-binary.js
var require_is_binary = __commonJS((exports) => {
  var isBinary2 = function(obj) {
    return withNativeArrayBuffer2 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile2 && obj instanceof File;
  };
  var hasBinary2 = function(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i2 = 0, l = obj.length;i2 < l; i2++) {
        if (hasBinary2(obj[i2])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary2(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary2(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary2(obj[key])) {
        return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasBinary = exports.isBinary = undefined;
  var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
  var isView2 = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  var toString3 = Object.prototype.toString;
  var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString3.call(Blob) === "[object BlobConstructor]";
  var withNativeFile2 = typeof File === "function" || typeof File !== "undefined" && toString3.call(File) === "[object FileConstructor]";
  exports.isBinary = isBinary2;
  exports.hasBinary = hasBinary2;
});

// node_modules/socket.io-parser/build/cjs/binary.js
var require_binary2 = __commonJS((exports) => {
  var deconstructPacket2 = function(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket2(packetData, buffers);
    pack.attachments = buffers.length;
    return { packet: pack, buffers };
  };
  var _deconstructPacket2 = function(data, buffers) {
    if (!data)
      return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
      const placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i2 = 0;i2 < data.length; i2++) {
        newData[i2] = _deconstructPacket2(data[i2], buffers);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          newData[key] = _deconstructPacket2(data[key], buffers);
        }
      }
      return newData;
    }
    return data;
  };
  var reconstructPacket2 = function(packet, buffers) {
    packet.data = _reconstructPacket2(packet.data, buffers);
    delete packet.attachments;
    return packet;
  };
  var _reconstructPacket2 = function(data, buffers) {
    if (!data)
      return data;
    if (data && data._placeholder === true) {
      const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
      if (isIndexValid) {
        return buffers[data.num];
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (let i2 = 0;i2 < data.length; i2++) {
        data[i2] = _reconstructPacket2(data[i2], buffers);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket2(data[key], buffers);
        }
      }
    }
    return data;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconstructPacket = exports.deconstructPacket = undefined;
  var is_binary_js_1 = require_is_binary();
  exports.deconstructPacket = deconstructPacket2;
  exports.reconstructPacket = reconstructPacket2;
});

// node_modules/socket.io-parser/build/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  var isObject2 = function(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = undefined;
  var component_emitter_1 = require_component_emitter();
  var binary_js_1 = require_binary2();
  var is_binary_js_1 = require_is_binary();
  var debug_1 = require_src();
  var debug15 = (0, debug_1.default)("socket.io-parser");
  var RESERVED_EVENTS3 = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
  ];
  exports.protocol = 5;
  var PacketType2;
  (function(PacketType3) {
    PacketType3[PacketType3["CONNECT"] = 0] = "CONNECT";
    PacketType3[PacketType3["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType3[PacketType3["EVENT"] = 2] = "EVENT";
    PacketType3[PacketType3["ACK"] = 3] = "ACK";
    PacketType3[PacketType3["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType3[PacketType3["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType3[PacketType3["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType2 = exports.PacketType || (exports.PacketType = {}));

  class Encoder2 {
    constructor(replacer) {
      this.replacer = replacer;
    }
    encode(obj) {
      debug15("encoding packet %j", obj);
      if (obj.type === PacketType2.EVENT || obj.type === PacketType2.ACK) {
        if ((0, is_binary_js_1.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType2.EVENT ? PacketType2.BINARY_EVENT : PacketType2.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    encodeAsString(obj) {
      let str = "" + obj.type;
      if (obj.type === PacketType2.BINARY_EVENT || obj.type === PacketType2.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      if (obj.nsp && obj.nsp !== "/") {
        str += obj.nsp + ",";
      }
      if (obj.id != null) {
        str += obj.id;
      }
      if (obj.data != null) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      debug15("encoded %j as %s", obj, str);
      return str;
    }
    encodeAsBinary(obj) {
      const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers = deconstruction.buffers;
      buffers.unshift(pack);
      return buffers;
    }
  }
  exports.Encoder = Encoder2;

  class Decoder2 extends component_emitter_1.Emitter {
    constructor(reviver) {
      super();
      this.reviver = reviver;
    }
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        const isBinaryEvent = packet.type === PacketType2.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType2.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType2.EVENT : PacketType2.ACK;
          this.reconstructor = new BinaryReconstructor2(packet);
          if (packet.attachments === 0) {
            super.emitReserved("decoded", packet);
          }
        } else {
          super.emitReserved("decoded", packet);
        }
      } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emitReserved("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    decodeString(str) {
      let i2 = 0;
      const p = {
        type: Number(str.charAt(0))
      };
      if (PacketType2[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      }
      if (p.type === PacketType2.BINARY_EVENT || p.type === PacketType2.BINARY_ACK) {
        const start = i2 + 1;
        while (str.charAt(++i2) !== "-" && i2 != str.length) {
        }
        const buf = str.substring(start, i2);
        if (buf != Number(buf) || str.charAt(i2) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      if (str.charAt(i2 + 1) === "/") {
        const start = i2 + 1;
        while (++i2) {
          const c = str.charAt(i2);
          if (c === ",")
            break;
          if (i2 === str.length)
            break;
        }
        p.nsp = str.substring(start, i2);
      } else {
        p.nsp = "/";
      }
      const next = str.charAt(i2 + 1);
      if (next !== "" && Number(next) == next) {
        const start = i2 + 1;
        while (++i2) {
          const c = str.charAt(i2);
          if (c == null || Number(c) != c) {
            --i2;
            break;
          }
          if (i2 === str.length)
            break;
        }
        p.id = Number(str.substring(start, i2 + 1));
      }
      if (str.charAt(++i2)) {
        const payload2 = this.tryParse(str.substr(i2));
        if (Decoder2.isPayloadValid(p.type, payload2)) {
          p.data = payload2;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug15("decoded %s as %j", str, p);
      return p;
    }
    tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    }
    static isPayloadValid(type, payload2) {
      switch (type) {
        case PacketType2.CONNECT:
          return isObject2(payload2);
        case PacketType2.DISCONNECT:
          return payload2 === undefined;
        case PacketType2.CONNECT_ERROR:
          return typeof payload2 === "string" || isObject2(payload2);
        case PacketType2.EVENT:
        case PacketType2.BINARY_EVENT:
          return Array.isArray(payload2) && (typeof payload2[0] === "number" || typeof payload2[0] === "string" && RESERVED_EVENTS3.indexOf(payload2[0]) === -1);
        case PacketType2.ACK:
        case PacketType2.BINARY_ACK:
          return Array.isArray(payload2);
      }
    }
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }
  exports.Decoder = Decoder2;

  class BinaryReconstructor2 {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }
});

// node_modules/socket.io/dist/client.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Client = undefined;
  var socket_io_parser_1 = require_cjs3();
  var debugModule11 = require_src();
  var url3 = __require("url");
  var debug15 = debugModule11("socket.io:client");

  class Client {
    constructor(server, conn) {
      this.sockets = new Map;
      this.nsps = new Map;
      this.server = server;
      this.conn = conn;
      this.encoder = server.encoder;
      this.decoder = new server._parser.Decoder;
      this.id = conn.id;
      this.setup();
    }
    get request() {
      return this.conn.request;
    }
    setup() {
      this.onclose = this.onclose.bind(this);
      this.ondata = this.ondata.bind(this);
      this.onerror = this.onerror.bind(this);
      this.ondecoded = this.ondecoded.bind(this);
      this.decoder.on("decoded", this.ondecoded);
      this.conn.on("data", this.ondata);
      this.conn.on("error", this.onerror);
      this.conn.on("close", this.onclose);
      this.connectTimeout = setTimeout(() => {
        if (this.nsps.size === 0) {
          debug15("no namespace joined yet, close the client");
          this.close();
        } else {
          debug15("the client has already joined a namespace, nothing to do");
        }
      }, this.server._connectTimeout);
    }
    connect(name, auth = {}) {
      if (this.server._nsps.has(name)) {
        debug15("connecting to namespace %s", name);
        return this.doConnect(name, auth);
      }
      this.server._checkNamespace(name, auth, (dynamicNspName) => {
        if (dynamicNspName) {
          this.doConnect(name, auth);
        } else {
          debug15("creation of namespace %s was denied", name);
          this._packet({
            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
            nsp: name,
            data: {
              message: "Invalid namespace"
            }
          });
        }
      });
    }
    doConnect(name, auth) {
      const nsp = this.server.of(name);
      nsp._add(this, auth, (socket4) => {
        this.sockets.set(socket4.id, socket4);
        this.nsps.set(nsp.name, socket4);
        if (this.connectTimeout) {
          clearTimeout(this.connectTimeout);
          this.connectTimeout = undefined;
        }
      });
    }
    _disconnect() {
      for (const socket4 of this.sockets.values()) {
        socket4.disconnect();
      }
      this.sockets.clear();
      this.close();
    }
    _remove(socket4) {
      if (this.sockets.has(socket4.id)) {
        const nsp = this.sockets.get(socket4.id).nsp.name;
        this.sockets.delete(socket4.id);
        this.nsps.delete(nsp);
      } else {
        debug15("ignoring remove for %s", socket4.id);
      }
    }
    close() {
      if (this.conn.readyState === "open") {
        debug15("forcing transport close");
        this.conn.close();
        this.onclose("forced server close");
      }
    }
    _packet(packet, opts = {}) {
      if (this.conn.readyState !== "open") {
        debug15("ignoring packet write %j", packet);
        return;
      }
      const encodedPackets = opts.preEncoded ? packet : this.encoder.encode(packet);
      this.writeToEngine(encodedPackets, opts);
    }
    writeToEngine(encodedPackets, opts) {
      if (opts.volatile && !this.conn.transport.writable) {
        debug15("volatile packet is discarded since the transport is not currently writable");
        return;
      }
      const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];
      for (const encodedPacket of packets) {
        this.conn.write(encodedPacket, opts);
      }
    }
    ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e) {
        debug15("invalid packet format");
        this.onerror(e);
      }
    }
    ondecoded(packet) {
      let namespace;
      let authPayload;
      if (this.conn.protocol === 3) {
        const parsed = url3.parse(packet.nsp, true);
        namespace = parsed.pathname;
        authPayload = parsed.query;
      } else {
        namespace = packet.nsp;
        authPayload = packet.data;
      }
      const socket4 = this.nsps.get(namespace);
      if (!socket4 && packet.type === socket_io_parser_1.PacketType.CONNECT) {
        this.connect(namespace, authPayload);
      } else if (socket4 && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {
        process.nextTick(function() {
          socket4._onpacket(packet);
        });
      } else {
        debug15("invalid state (packet type: %s)", packet.type);
        this.close();
      }
    }
    onerror(err) {
      for (const socket4 of this.sockets.values()) {
        socket4._onerror(err);
      }
      this.conn.close();
    }
    onclose(reason, description) {
      debug15("client close with reason %s", reason);
      this.destroy();
      for (const socket4 of this.sockets.values()) {
        socket4._onclose(reason, description);
      }
      this.sockets.clear();
      this.decoder.destroy();
    }
    destroy() {
      this.conn.removeListener("data", this.ondata);
      this.conn.removeListener("error", this.onerror);
      this.conn.removeListener("close", this.onclose);
      this.decoder.removeListener("decoded", this.ondecoded);
      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = undefined;
      }
    }
  }
  exports.Client = Client;
});

// node_modules/socket.io/dist/typed-events.js
var require_typed_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StrictEventEmitter = undefined;
  var events_1 = __require("events");

  class StrictEventEmitter extends events_1.EventEmitter {
    on(ev, listener) {
      return super.on(ev, listener);
    }
    once(ev, listener) {
      return super.once(ev, listener);
    }
    emit(ev, ...args) {
      return super.emit(ev, ...args);
    }
    emitReserved(ev, ...args) {
      return super.emit(ev, ...args);
    }
    emitUntyped(ev, ...args) {
      return super.emit(ev, ...args);
    }
    listeners(event) {
      return super.listeners(event);
    }
  }
  exports.StrictEventEmitter = StrictEventEmitter;
});

// node_modules/socket.io/dist/broadcast-operator.js
var require_broadcast_operator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoteSocket = exports.BroadcastOperator = undefined;
  var socket_1 = require_socket2();
  var socket_io_parser_1 = require_cjs3();

  class BroadcastOperator {
    constructor(adapter, rooms = new Set, exceptRooms = new Set, flags = {}) {
      this.adapter = adapter;
      this.rooms = rooms;
      this.exceptRooms = exceptRooms;
      this.flags = flags;
    }
    to(room) {
      const rooms = new Set(this.rooms);
      if (Array.isArray(room)) {
        room.forEach((r) => rooms.add(r));
      } else {
        rooms.add(room);
      }
      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    in(room) {
      return this.to(room);
    }
    except(room) {
      const exceptRooms = new Set(this.exceptRooms);
      if (Array.isArray(room)) {
        room.forEach((r) => exceptRooms.add(r));
      } else {
        exceptRooms.add(room);
      }
      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    compress(compress) {
      const flags = Object.assign({}, this.flags, { compress });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    get volatile() {
      const flags = Object.assign({}, this.flags, { volatile: true });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    get local() {
      const flags = Object.assign({}, this.flags, { local: true });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    timeout(timeout) {
      const flags = Object.assign({}, this.flags, { timeout });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    emit(ev, ...args) {
      if (socket_1.RESERVED_EVENTS.has(ev)) {
        throw new Error(`"${String(ev)}" is a reserved event name`);
      }
      const data = [ev, ...args];
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data
      };
      const withAck = typeof data[data.length - 1] === "function";
      if (!withAck) {
        this.adapter.broadcast(packet, {
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        });
        return true;
      }
      const ack = data.pop();
      let timedOut2 = false;
      let responses = [];
      const timer2 = setTimeout(() => {
        timedOut2 = true;
        ack.apply(this, [
          new Error("operation has timed out"),
          this.flags.expectSingleResponse ? null : responses
        ]);
      }, this.flags.timeout);
      let expectedServerCount = -1;
      let actualServerCount = 0;
      let expectedClientCount = 0;
      const checkCompleteness = () => {
        if (!timedOut2 && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
          clearTimeout(timer2);
          ack.apply(this, [
            null,
            this.flags.expectSingleResponse ? null : responses
          ]);
        }
      };
      this.adapter.broadcastWithAck(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, (clientCount) => {
        expectedClientCount += clientCount;
        actualServerCount++;
        checkCompleteness();
      }, (clientResponse) => {
        responses.push(clientResponse);
        checkCompleteness();
      });
      this.adapter.serverCount().then((serverCount) => {
        expectedServerCount = serverCount;
        checkCompleteness();
      });
      return true;
    }
    emitWithAck(ev, ...args) {
      return new Promise((resolve, reject) => {
        args.push((err, responses) => {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve(responses);
          }
        });
        this.emit(ev, ...args);
      });
    }
    allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }
      return this.adapter.sockets(this.rooms);
    }
    fetchSockets() {
      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }).then((sockets) => {
        return sockets.map((socket4) => {
          if (socket4 instanceof socket_1.Socket) {
            return socket4;
          } else {
            return new RemoteSocket(this.adapter, socket4);
          }
        });
      });
    }
    socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    disconnectSockets(close = false) {
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, close);
    }
  }
  exports.BroadcastOperator = BroadcastOperator;

  class RemoteSocket {
    constructor(adapter, details) {
      this.id = details.id;
      this.handshake = details.handshake;
      this.rooms = new Set(details.rooms);
      this.data = details.data;
      this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set, {
        expectSingleResponse: true
      });
    }
    timeout(timeout) {
      return this.operator.timeout(timeout);
    }
    emit(ev, ...args) {
      return this.operator.emit(ev, ...args);
    }
    join(room) {
      return this.operator.socketsJoin(room);
    }
    leave(room) {
      return this.operator.socketsLeave(room);
    }
    disconnect(close = false) {
      this.operator.disconnectSockets(close);
      return this;
    }
  }
  exports.RemoteSocket = RemoteSocket;
});

// node_modules/socket.io/dist/socket.js
var require_socket2 = __commonJS((exports) => {
  var noop3 = function() {
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Socket = exports.RESERVED_EVENTS = undefined;
  var socket_io_parser_1 = require_cjs3();
  var debug_1 = __importDefault(require_src());
  var typed_events_1 = require_typed_events();
  var base64id_1 = __importDefault(require_base64id());
  var broadcast_operator_1 = require_broadcast_operator();
  var debug15 = (0, debug_1.default)("socket.io:socket");
  var RECOVERABLE_DISCONNECT_REASONS = new Set([
    "transport error",
    "transport close",
    "forced close",
    "ping timeout",
    "server shutting down",
    "forced server close"
  ]);
  exports.RESERVED_EVENTS = new Set([
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
  ]);

  class Socket3 extends typed_events_1.StrictEventEmitter {
    constructor(nsp, client2, auth, previousSession) {
      super();
      this.nsp = nsp;
      this.client = client2;
      this.recovered = false;
      this.data = {};
      this.connected = false;
      this.acks = new Map;
      this.fns = [];
      this.flags = {};
      this.server = nsp.server;
      this.adapter = this.nsp.adapter;
      if (previousSession) {
        this.id = previousSession.sid;
        this.pid = previousSession.pid;
        previousSession.rooms.forEach((room) => this.join(room));
        this.data = previousSession.data;
        previousSession.missedPackets.forEach((packet) => {
          this.packet({
            type: socket_io_parser_1.PacketType.EVENT,
            data: packet
          });
        });
        this.recovered = true;
      } else {
        if (client2.conn.protocol === 3) {
          this.id = nsp.name !== "/" ? nsp.name + "#" + client2.id : client2.id;
        } else {
          this.id = base64id_1.default.generateId();
        }
        if (this.server._opts.connectionStateRecovery) {
          this.pid = base64id_1.default.generateId();
        }
      }
      this.handshake = this.buildHandshake(auth);
      this.on("error", noop3);
    }
    buildHandshake(auth) {
      var _a, _b, _c, _d;
      return {
        headers: ((_a = this.request) === null || _a === undefined ? undefined : _a.headers) || {},
        time: new Date + "",
        address: this.conn.remoteAddress,
        xdomain: !!((_b = this.request) === null || _b === undefined ? undefined : _b.headers.origin),
        secure: !this.request || !!this.request.connection.encrypted,
        issued: +new Date,
        url: (_c = this.request) === null || _c === undefined ? undefined : _c.url,
        query: ((_d = this.request) === null || _d === undefined ? undefined : _d._query) || {},
        auth
      };
    }
    emit(ev, ...args) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error(`"${String(ev)}" is a reserved event name`);
      }
      const data = [ev, ...args];
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data
      };
      if (typeof data[data.length - 1] === "function") {
        const id = this.nsp._ids++;
        debug15("emitting packet with ack id %d", id);
        this.registerAckCallback(id, data.pop());
        packet.id = id;
      }
      const flags = Object.assign({}, this.flags);
      this.flags = {};
      if (this.nsp.server.opts.connectionStateRecovery) {
        this.adapter.broadcast(packet, {
          rooms: new Set([this.id]),
          except: new Set,
          flags
        });
      } else {
        this.notifyOutgoingListeners(packet);
        this.packet(packet, flags);
      }
      return true;
    }
    emitWithAck(ev, ...args) {
      const withErr = this.flags.timeout !== undefined;
      return new Promise((resolve, reject) => {
        args.push((arg1, arg2) => {
          if (withErr) {
            return arg1 ? reject(arg1) : resolve(arg2);
          } else {
            return resolve(arg1);
          }
        });
        this.emit(ev, ...args);
      });
    }
    registerAckCallback(id, ack) {
      const timeout = this.flags.timeout;
      if (timeout === undefined) {
        this.acks.set(id, ack);
        return;
      }
      const timer2 = setTimeout(() => {
        debug15("event with ack id %d has timed out after %d ms", id, timeout);
        this.acks.delete(id);
        ack.call(this, new Error("operation has timed out"));
      }, timeout);
      this.acks.set(id, (...args) => {
        clearTimeout(timer2);
        ack.apply(this, [null, ...args]);
      });
    }
    to(room) {
      return this.newBroadcastOperator().to(room);
    }
    in(room) {
      return this.newBroadcastOperator().in(room);
    }
    except(room) {
      return this.newBroadcastOperator().except(room);
    }
    send(...args) {
      this.emit("message", ...args);
      return this;
    }
    write(...args) {
      this.emit("message", ...args);
      return this;
    }
    packet(packet, opts = {}) {
      packet.nsp = this.nsp.name;
      opts.compress = opts.compress !== false;
      this.client._packet(packet, opts);
    }
    join(rooms) {
      debug15("join room %s", rooms);
      return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
    }
    leave(room) {
      debug15("leave room %s", room);
      return this.adapter.del(this.id, room);
    }
    leaveAll() {
      this.adapter.delAll(this.id);
    }
    _onconnect() {
      debug15("socket connected - writing packet");
      this.connected = true;
      this.join(this.id);
      if (this.conn.protocol === 3) {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: { sid: this.id, pid: this.pid }
        });
      }
    }
    _onpacket(packet) {
      debug15("got packet %j", packet);
      switch (packet.type) {
        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
      }
    }
    onevent(packet) {
      const args = packet.data || [];
      debug15("emitting event %j", args);
      if (packet.id != null) {
        debug15("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      this.dispatch(args);
    }
    ack(id) {
      const self2 = this;
      let sent = false;
      return function() {
        if (sent)
          return;
        const args = Array.prototype.slice.call(arguments);
        debug15("sending ack %j", args);
        self2.packet({
          id,
          type: socket_io_parser_1.PacketType.ACK,
          data: args
        });
        sent = true;
      };
    }
    onack(packet) {
      const ack = this.acks.get(packet.id);
      if (typeof ack == "function") {
        debug15("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        this.acks.delete(packet.id);
      } else {
        debug15("bad ack %s", packet.id);
      }
    }
    ondisconnect() {
      debug15("got disconnect packet");
      this._onclose("client namespace disconnect");
    }
    _onerror(err) {
      this.emitReserved("error", err);
    }
    _onclose(reason, description) {
      if (!this.connected)
        return this;
      debug15("closing socket - reason %s", reason);
      this.emitReserved("disconnecting", reason, description);
      if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
        debug15("connection state recovery is enabled for sid %s", this.id);
        this.adapter.persistSession({
          sid: this.id,
          pid: this.pid,
          rooms: [...this.rooms],
          data: this.data
        });
      }
      this._cleanup();
      this.client._remove(this);
      this.connected = false;
      this.emitReserved("disconnect", reason, description);
      return;
    }
    _cleanup() {
      this.leaveAll();
      this.nsp._remove(this);
      this.join = noop3;
    }
    _error(err) {
      this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });
    }
    disconnect(close = false) {
      if (!this.connected)
        return this;
      if (close) {
        this.client._disconnect();
      } else {
        this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        this._onclose("server namespace disconnect");
      }
      return this;
    }
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    get broadcast() {
      return this.newBroadcastOperator();
    }
    get local() {
      return this.newBroadcastOperator().local;
    }
    timeout(timeout) {
      this.flags.timeout = timeout;
      return this;
    }
    dispatch(event) {
      debug15("dispatching an event %j", event);
      this.run(event, (err) => {
        process.nextTick(() => {
          if (err) {
            return this._onerror(err);
          }
          if (this.connected) {
            super.emitUntyped.apply(this, event);
          } else {
            debug15("ignore packet received after disconnection");
          }
        });
      });
    }
    use(fn) {
      this.fns.push(fn);
      return this;
    }
    run(event, fn) {
      const fns = this.fns.slice(0);
      if (!fns.length)
        return fn(null);
      function run(i2) {
        fns[i2](event, function(err) {
          if (err)
            return fn(err);
          if (!fns[i2 + 1])
            return fn(null);
          run(i2 + 1);
        });
      }
      run(0);
    }
    get disconnected() {
      return !this.connected;
    }
    get request() {
      return this.client.request;
    }
    get conn() {
      return this.client.conn;
    }
    get rooms() {
      return this.adapter.socketRooms(this.id) || new Set;
    }
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i2 = 0;i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    listenersAny() {
      return this._anyListeners || [];
    }
    onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyOutgoingListeners;
        for (let i2 = 0;i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const listeners = this._anyOutgoingListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, packet.data);
        }
      }
    }
    newBroadcastOperator() {
      const flags = Object.assign({}, this.flags);
      this.flags = {};
      return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set, new Set([this.id]), flags);
    }
  }
  exports.Socket = Socket3;
});

// node_modules/socket.io/dist/namespace.js
var require_namespace = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Namespace = exports.RESERVED_EVENTS = undefined;
  var socket_1 = require_socket2();
  var typed_events_1 = require_typed_events();
  var debug_1 = __importDefault(require_src());
  var broadcast_operator_1 = require_broadcast_operator();
  var debug15 = (0, debug_1.default)("socket.io:namespace");
  exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);

  class Namespace extends typed_events_1.StrictEventEmitter {
    constructor(server, name) {
      super();
      this.sockets = new Map;
      this._fns = [];
      this._ids = 0;
      this.server = server;
      this.name = name;
      this._initAdapter();
    }
    _initAdapter() {
      this.adapter = new (this.server.adapter())(this);
    }
    use(fn) {
      this._fns.push(fn);
      return this;
    }
    run(socket4, fn) {
      const fns = this._fns.slice(0);
      if (!fns.length)
        return fn(null);
      function run(i2) {
        fns[i2](socket4, function(err) {
          if (err)
            return fn(err);
          if (!fns[i2 + 1])
            return fn(null);
          run(i2 + 1);
        });
      }
      run(0);
    }
    to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
    }
    except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    async _add(client2, auth, fn) {
      var _a;
      debug15("adding socket to nsp %s", this.name);
      const socket4 = await this._createSocket(client2, auth);
      if (((_a = this.server.opts.connectionStateRecovery) === null || _a === undefined ? undefined : _a.skipMiddlewares) && socket4.recovered && client2.conn.readyState === "open") {
        return this._doConnect(socket4, fn);
      }
      this.run(socket4, (err) => {
        process.nextTick(() => {
          if (client2.conn.readyState !== "open") {
            debug15("next called after client was closed - ignoring socket");
            socket4._cleanup();
            return;
          }
          if (err) {
            debug15("middleware error, sending CONNECT_ERROR packet to the client");
            socket4._cleanup();
            if (client2.conn.protocol === 3) {
              return socket4._error(err.data || err.message);
            } else {
              return socket4._error({
                message: err.message,
                data: err.data
              });
            }
          }
          this._doConnect(socket4, fn);
        });
      });
    }
    async _createSocket(client2, auth) {
      const sessionId = auth.pid;
      const offset = auth.offset;
      if (this.server.opts.connectionStateRecovery && typeof sessionId === "string" && typeof offset === "string") {
        let session;
        try {
          session = await this.adapter.restoreSession(sessionId, offset);
        } catch (e) {
          debug15("error while restoring session: %s", e);
        }
        if (session) {
          debug15("connection state recovered for sid %s", session.sid);
          return new socket_1.Socket(this, client2, auth, session);
        }
      }
      return new socket_1.Socket(this, client2, auth);
    }
    _doConnect(socket4, fn) {
      this.sockets.set(socket4.id, socket4);
      socket4._onconnect();
      if (fn)
        fn(socket4);
      this.emitReserved("connect", socket4);
      this.emitReserved("connection", socket4);
    }
    _remove(socket4) {
      if (this.sockets.has(socket4.id)) {
        this.sockets.delete(socket4.id);
      } else {
        debug15("ignoring remove for %s", socket4.id);
      }
    }
    emit(ev, ...args) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
    }
    emitWithAck(ev, ...args) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).emitWithAck(ev, ...args);
    }
    send(...args) {
      this.emit("message", ...args);
      return this;
    }
    write(...args) {
      this.emit("message", ...args);
      return this;
    }
    serverSideEmit(ev, ...args) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error(`"${String(ev)}" is a reserved event name`);
      }
      args.unshift(ev);
      this.adapter.serverSideEmit(args);
      return true;
    }
    serverSideEmitWithAck(ev, ...args) {
      return new Promise((resolve, reject) => {
        args.push((err, responses) => {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve(responses);
          }
        });
        this.serverSideEmit(ev, ...args);
      });
    }
    _onServerSideEmit(args) {
      super.emitUntyped.apply(this, args);
    }
    allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    compress(compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
    }
    get volatile() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
    }
    get local() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    timeout(timeout) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
    }
    fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    disconnectSockets(close = false) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }
  exports.Namespace = Namespace;
});

// node_modules/socket.io/dist/parent-namespace.js
var require_parent_namespace = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentNamespace = undefined;
  var namespace_1 = require_namespace();
  var debug_1 = __importDefault(require_src());
  var debug15 = (0, debug_1.default)("socket.io:parent-namespace");

  class ParentNamespace extends namespace_1.Namespace {
    constructor(server) {
      super(server, "/_" + ParentNamespace.count++);
      this.children = new Set;
    }
    _initAdapter() {
      const broadcast = (packet, opts) => {
        this.children.forEach((nsp) => {
          nsp.adapter.broadcast(packet, opts);
        });
      };
      this.adapter = { broadcast };
    }
    emit(ev, ...args) {
      this.children.forEach((nsp) => {
        nsp.emit(ev, ...args);
      });
      return true;
    }
    createChild(name) {
      debug15("creating child namespace %s", name);
      const namespace = new namespace_1.Namespace(this.server, name);
      namespace._fns = this._fns.slice(0);
      this.listeners("connect").forEach((listener) => namespace.on("connect", listener));
      this.listeners("connection").forEach((listener) => namespace.on("connection", listener));
      this.children.add(namespace);
      if (this.server._opts.cleanupEmptyChildNamespaces) {
        const remove = namespace._remove;
        namespace._remove = (socket4) => {
          remove.call(namespace, socket4);
          if (namespace.sockets.size === 0) {
            debug15("closing child namespace %s", name);
            namespace.adapter.close();
            this.server._nsps.delete(namespace.name);
            this.children.delete(namespace);
          }
        };
      }
      this.server._nsps.set(name, namespace);
      this.server.sockets.emitReserved("new_namespace", namespace);
      return namespace;
    }
    fetchSockets() {
      throw new Error("fetchSockets() is not supported on parent namespaces");
    }
  }
  exports.ParentNamespace = ParentNamespace;
  ParentNamespace.count = 0;
});

// node_modules/socket.io-adapter/dist/contrib/yeast.js
var require_yeast = __commonJS((exports) => {
  var encode3 = function(num) {
    let encoded = "";
    do {
      encoded = alphabet3[num % length2] + encoded;
      num = Math.floor(num / length2);
    } while (num > 0);
    return encoded;
  };
  var decode2 = function(str) {
    let decoded = 0;
    for (i2 = 0;i2 < str.length; i2++) {
      decoded = decoded * length2 + map2[str.charAt(i2)];
    }
    return decoded;
  };
  var yeast4 = function() {
    const now = encode3(+new Date);
    if (now !== prev2)
      return seed2 = 0, prev2 = now;
    return now + "." + encode3(seed2++);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.yeast = exports.decode = exports.encode = undefined;
  var alphabet3 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
  var length2 = 64;
  var map2 = {};
  var seed2 = 0;
  var i2 = 0;
  var prev2;
  exports.encode = encode3;
  exports.decode = decode2;
  exports.yeast = yeast4;
  for (;i2 < length2; i2++)
    map2[alphabet3[i2]] = i2;
});

// node_modules/socket.io-adapter/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var shouldIncludePacket = function(sessionRooms, opts) {
    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));
    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));
    return included && notExcluded;
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SessionAwareAdapter = exports.Adapter = undefined;
  var events_1 = __require("events");
  var yeast_1 = require_yeast();
  var WebSocket3 = require_ws();
  var canPreComputeFrame = typeof ((_a = WebSocket3 === null || WebSocket3 === undefined ? undefined : WebSocket3.Sender) === null || _a === undefined ? undefined : _a.frame) === "function";

  class Adapter extends events_1.EventEmitter {
    constructor(nsp) {
      super();
      this.nsp = nsp;
      this.rooms = new Map;
      this.sids = new Map;
      this.encoder = nsp.server.encoder;
    }
    init() {
    }
    close() {
    }
    serverCount() {
      return Promise.resolve(1);
    }
    addAll(id, rooms) {
      if (!this.sids.has(id)) {
        this.sids.set(id, new Set);
      }
      for (const room of rooms) {
        this.sids.get(id).add(room);
        if (!this.rooms.has(room)) {
          this.rooms.set(room, new Set);
          this.emit("create-room", room);
        }
        if (!this.rooms.get(room).has(id)) {
          this.rooms.get(room).add(id);
          this.emit("join-room", room, id);
        }
      }
    }
    del(id, room) {
      if (this.sids.has(id)) {
        this.sids.get(id).delete(room);
      }
      this._del(room, id);
    }
    _del(room, id) {
      const _room = this.rooms.get(room);
      if (_room != null) {
        const deleted = _room.delete(id);
        if (deleted) {
          this.emit("leave-room", room, id);
        }
        if (_room.size === 0 && this.rooms.delete(room)) {
          this.emit("delete-room", room);
        }
      }
    }
    delAll(id) {
      if (!this.sids.has(id)) {
        return;
      }
      for (const room of this.sids.get(id)) {
        this._del(room, id);
      }
      this.sids.delete(id);
    }
    broadcast(packet, opts) {
      const flags = opts.flags || {};
      const packetOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      const encodedPackets = this._encode(packet, packetOpts);
      this.apply(opts, (socket4) => {
        if (typeof socket4.notifyOutgoingListeners === "function") {
          socket4.notifyOutgoingListeners(packet);
        }
        socket4.client.writeToEngine(encodedPackets, packetOpts);
      });
    }
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
      const flags = opts.flags || {};
      const packetOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      packet.id = this.nsp._ids++;
      const encodedPackets = this._encode(packet, packetOpts);
      let clientCount = 0;
      this.apply(opts, (socket4) => {
        clientCount++;
        socket4.acks.set(packet.id, ack);
        if (typeof socket4.notifyOutgoingListeners === "function") {
          socket4.notifyOutgoingListeners(packet);
        }
        socket4.client.writeToEngine(encodedPackets, packetOpts);
      });
      clientCountCallback(clientCount);
    }
    _encode(packet, packetOpts) {
      const encodedPackets = this.encoder.encode(packet);
      if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === "string") {
        const data = Buffer.from("4" + encodedPackets[0]);
        packetOpts.wsPreEncodedFrame = WebSocket3.Sender.frame(data, {
          readOnly: false,
          mask: false,
          rsv1: false,
          opcode: 1,
          fin: true
        });
      }
      return encodedPackets;
    }
    sockets(rooms) {
      const sids = new Set;
      this.apply({ rooms }, (socket4) => {
        sids.add(socket4.id);
      });
      return Promise.resolve(sids);
    }
    socketRooms(id) {
      return this.sids.get(id);
    }
    fetchSockets(opts) {
      const sockets = [];
      this.apply(opts, (socket4) => {
        sockets.push(socket4);
      });
      return Promise.resolve(sockets);
    }
    addSockets(opts, rooms) {
      this.apply(opts, (socket4) => {
        socket4.join(rooms);
      });
    }
    delSockets(opts, rooms) {
      this.apply(opts, (socket4) => {
        rooms.forEach((room) => socket4.leave(room));
      });
    }
    disconnectSockets(opts, close) {
      this.apply(opts, (socket4) => {
        socket4.disconnect(close);
      });
    }
    apply(opts, callback) {
      const rooms = opts.rooms;
      const except = this.computeExceptSids(opts.except);
      if (rooms.size) {
        const ids = new Set;
        for (const room of rooms) {
          if (!this.rooms.has(room))
            continue;
          for (const id of this.rooms.get(room)) {
            if (ids.has(id) || except.has(id))
              continue;
            const socket4 = this.nsp.sockets.get(id);
            if (socket4) {
              callback(socket4);
              ids.add(id);
            }
          }
        }
      } else {
        for (const [id] of this.sids) {
          if (except.has(id))
            continue;
          const socket4 = this.nsp.sockets.get(id);
          if (socket4)
            callback(socket4);
        }
      }
    }
    computeExceptSids(exceptRooms) {
      const exceptSids = new Set;
      if (exceptRooms && exceptRooms.size > 0) {
        for (const room of exceptRooms) {
          if (this.rooms.has(room)) {
            this.rooms.get(room).forEach((sid) => exceptSids.add(sid));
          }
        }
      }
      return exceptSids;
    }
    serverSideEmit(packet) {
      console.warn("this adapter does not support the serverSideEmit() functionality");
    }
    persistSession(session) {
    }
    restoreSession(pid, offset) {
      return null;
    }
  }
  exports.Adapter = Adapter;

  class SessionAwareAdapter extends Adapter {
    constructor(nsp) {
      super(nsp);
      this.nsp = nsp;
      this.sessions = new Map;
      this.packets = [];
      this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
      const timer2 = setInterval(() => {
        const threshold = Date.now() - this.maxDisconnectionDuration;
        this.sessions.forEach((session, sessionId) => {
          const hasExpired = session.disconnectedAt < threshold;
          if (hasExpired) {
            this.sessions.delete(sessionId);
          }
        });
        for (let i2 = this.packets.length - 1;i2 >= 0; i2--) {
          const hasExpired = this.packets[i2].emittedAt < threshold;
          if (hasExpired) {
            this.packets.splice(0, i2 + 1);
            break;
          }
        }
      }, 60 * 1000);
      timer2.unref();
    }
    persistSession(session) {
      session.disconnectedAt = Date.now();
      this.sessions.set(session.pid, session);
    }
    restoreSession(pid, offset) {
      const session = this.sessions.get(pid);
      if (!session) {
        return null;
      }
      const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
      if (hasExpired) {
        this.sessions.delete(pid);
        return null;
      }
      const index = this.packets.findIndex((packet) => packet.id === offset);
      if (index === -1) {
        return null;
      }
      const missedPackets = [];
      for (let i2 = index + 1;i2 < this.packets.length; i2++) {
        const packet = this.packets[i2];
        if (shouldIncludePacket(session.rooms, packet.opts)) {
          missedPackets.push(packet.data);
        }
      }
      return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
    }
    broadcast(packet, opts) {
      var _a2;
      const isEventPacket = packet.type === 2;
      const withoutAcknowledgement = packet.id === undefined;
      const notVolatile = ((_a2 = opts.flags) === null || _a2 === undefined ? undefined : _a2.volatile) === undefined;
      if (isEventPacket && withoutAcknowledgement && notVolatile) {
        const id = (0, yeast_1.yeast)();
        packet.data.push(id);
        this.packets.push({
          id,
          opts,
          data: packet.data,
          emittedAt: Date.now()
        });
      }
      super.broadcast(packet, opts);
    }
  }
  exports.SessionAwareAdapter = SessionAwareAdapter;
});

// node_modules/socket.io/dist/uws.js
var require_uws = __commonJS((exports) => {
  var patchAdapter = function(app) {
    socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {
      const isNew = !this.sids.has(id);
      addAll.call(this, id, rooms);
      const socket4 = this.nsp.sockets.get(id);
      if (!socket4) {
        return;
      }
      if (socket4.conn.transport.name === "websocket") {
        subscribe(this.nsp.name, socket4, isNew, rooms);
        return;
      }
      if (isNew) {
        socket4.conn.on("upgrade", () => {
          const rooms2 = this.sids.get(id);
          if (rooms2) {
            subscribe(this.nsp.name, socket4, isNew, rooms2);
          }
        });
      }
    };
    socket_io_adapter_1.Adapter.prototype.del = function(id, room) {
      del.call(this, id, room);
      const socket4 = this.nsp.sockets.get(id);
      if (socket4 && socket4.conn.transport.name === "websocket") {
        const sessionId = socket4.conn.id;
        const websocket3 = socket4.conn.transport.socket;
        const topic = `${this.nsp.name}${SEPARATOR2}${room}`;
        debug15("unsubscribe connection %s from topic %s", sessionId, topic);
        websocket3.unsubscribe(topic);
      }
    };
    socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {
      const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
      if (!useFastPublish) {
        broadcast.call(this, packet, opts);
        return;
      }
      const flags = opts.flags || {};
      const basePacketOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      const encodedPackets = this.encoder.encode(packet);
      const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR2}${opts.rooms.keys().next().value}`;
      debug15("fast publish to %s", topic);
      encodedPackets.forEach((encodedPacket) => {
        const isBinary2 = typeof encodedPacket !== "string";
        app.publish(topic, isBinary2 ? encodedPacket : "4" + encodedPacket, isBinary2);
      });
      this.apply(opts, (socket4) => {
        if (socket4.conn.transport.name !== "websocket") {
          socket4.client.writeToEngine(encodedPackets, basePacketOpts);
        }
      });
    };
  };
  var subscribe = function(namespaceName, socket4, isNew, rooms) {
    const sessionId = socket4.conn.id;
    const websocket3 = socket4.conn.transport.socket;
    if (isNew) {
      debug15("subscribe connection %s to topic %s", sessionId, namespaceName);
      websocket3.subscribe(namespaceName);
    }
    rooms.forEach((room) => {
      const topic = `${namespaceName}${SEPARATOR2}${room}`;
      debug15("subscribe connection %s to topic %s", sessionId, topic);
      websocket3.subscribe(topic);
    });
  };
  var restoreAdapter = function() {
    socket_io_adapter_1.Adapter.prototype.addAll = addAll;
    socket_io_adapter_1.Adapter.prototype.del = del;
    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
  };
  var serveFile = function(res, filepath) {
    const { size } = (0, fs_1.statSync)(filepath);
    const readStream2 = (0, fs_1.createReadStream)(filepath);
    const destroyReadStream = () => !readStream2.destroyed && readStream2.destroy();
    const onError = (error) => {
      destroyReadStream();
      throw error;
    };
    const onDataChunk = (chunk) => {
      const arrayBufferChunk = toArrayBuffer(chunk);
      const lastOffset = res.getWriteOffset();
      const [ok, done] = res.tryEnd(arrayBufferChunk, size);
      if (!done && !ok) {
        readStream2.pause();
        res.onWritable((offset) => {
          const [ok2, done2] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
          if (!done2 && ok2) {
            readStream2.resume();
          }
          return ok2;
        });
      }
    };
    res.onAborted(destroyReadStream);
    readStream2.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serveFile = exports.restoreAdapter = exports.patchAdapter = undefined;
  var socket_io_adapter_1 = require_dist3();
  var fs_1 = __require("fs");
  var debug_1 = __importDefault(require_src());
  var debug15 = (0, debug_1.default)("socket.io:adapter-uws");
  var SEPARATOR2 = "\x1F";
  var { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
  exports.patchAdapter = patchAdapter;
  exports.restoreAdapter = restoreAdapter;
  var toArrayBuffer = (buffer) => {
    const { buffer: arrayBuffer, byteOffset, byteLength: byteLength2 } = buffer;
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength2);
  };
  exports.serveFile = serveFile;
});

// node_modules/socket.io/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "socket.io",
    version: "4.7.2",
    description: "node.js realtime framework server",
    keywords: [
      "realtime",
      "framework",
      "websocket",
      "tcp",
      "events",
      "socket",
      "io"
    ],
    files: [
      "dist/",
      "client-dist/",
      "wrapper.mjs",
      "!**/*.tsbuildinfo"
    ],
    directories: {
      doc: "docs/",
      example: "example/",
      lib: "lib/",
      test: "test/"
    },
    type: "commonjs",
    main: "./dist/index.js",
    exports: {
      types: "./dist/index.d.ts",
      import: "./wrapper.mjs",
      require: "./dist/index.js"
    },
    types: "./dist/index.d.ts",
    license: "MIT",
    repository: {
      type: "git",
      url: "git://github.com/socketio/socket.io"
    },
    scripts: {
      compile: "rimraf ./dist && tsc",
      test: "npm run format:check && npm run compile && npm run test:types && npm run test:unit",
      "test:types": "tsd",
      "test:unit": "nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts",
      "format:check": "prettier --check \"lib/**/*.ts\" \"test/**/*.ts\"",
      "format:fix": "prettier --write \"lib/**/*.ts\" \"test/**/*.ts\"",
      prepack: "npm run compile"
    },
    dependencies: {
      accepts: "~1.3.4",
      base64id: "~2.0.0",
      cors: "~2.8.5",
      debug: "~4.3.2",
      "engine.io": "~6.5.2",
      "socket.io-adapter": "~2.5.2",
      "socket.io-parser": "~4.2.4"
    },
    devDependencies: {
      "@types/mocha": "^9.0.0",
      "expect.js": "0.3.1",
      mocha: "^10.0.0",
      nyc: "^15.1.0",
      prettier: "^2.3.2",
      rimraf: "^3.0.2",
      "socket.io-client": "4.7.2",
      "socket.io-client-v2": "npm:socket.io-client@^2.4.0",
      superagent: "^8.0.0",
      supertest: "^6.1.6",
      "ts-node": "^10.2.1",
      tsd: "^0.21.0",
      typescript: "^4.4.2",
      "uWebSockets.js": "github:uNetworking/uWebSockets.js#v20.30.0"
    },
    contributors: [
      {
        name: "Guillermo Rauch",
        email: "rauchg@gmail.com"
      },
      {
        name: "Arnout Kazemier",
        email: "info@3rd-eden.com"
      },
      {
        name: "Vladimir Dronnikov",
        email: "dronnikov@gmail.com"
      },
      {
        name: "Einar Otto Stangvik",
        email: "einaros@gmail.com"
      }
    ],
    engines: {
      node: ">=10.2.0"
    },
    tsd: {
      directory: "test"
    }
  };
});

// node_modules/socket.io/dist/index.js
var require_dist4 = __commonJS((exports, module) => {
  var __dirname = "/work/charite/src/upload/node_modules/socket.io/dist";
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Namespace = exports.Socket = exports.Server = undefined;
  var http3 = __require("http");
  var fs_1 = __require("fs");
  var zlib_1 = __require("zlib");
  var accepts = require_accepts();
  var stream_1 = __require("stream");
  var path = __require("path");
  var engine_io_1 = require_engine_io();
  var client_1 = require_client();
  var events_1 = __require("events");
  var namespace_1 = require_namespace();
  Object.defineProperty(exports, "Namespace", { enumerable: true, get: function() {
    return namespace_1.Namespace;
  } });
  var parent_namespace_1 = require_parent_namespace();
  var socket_io_adapter_1 = require_dist3();
  var parser = __importStar(require_cjs3());
  var debug_1 = __importDefault(require_src());
  var socket_1 = require_socket2();
  Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
    return socket_1.Socket;
  } });
  var typed_events_1 = require_typed_events();
  var uws_1 = require_uws();
  var cors_1 = __importDefault(require_lib6());
  var debug15 = (0, debug_1.default)("socket.io:server");
  var clientVersion = require_package2().version;
  var dotMapRegex = /\.map/;

  class Server extends typed_events_1.StrictEventEmitter {
    constructor(srv, opts = {}) {
      super();
      this._nsps = new Map;
      this.parentNsps = new Map;
      this.parentNamespacesFromRegExp = new Map;
      if (typeof srv === "object" && srv instanceof Object && !srv.listen) {
        opts = srv;
        srv = undefined;
      }
      this.path(opts.path || "/socket.io");
      this.connectTimeout(opts.connectTimeout || 45000);
      this.serveClient(opts.serveClient !== false);
      this._parser = opts.parser || parser;
      this.encoder = new this._parser.Encoder;
      this.opts = opts;
      if (opts.connectionStateRecovery) {
        opts.connectionStateRecovery = Object.assign({
          maxDisconnectionDuration: 2 * 60 * 1000,
          skipMiddlewares: true
        }, opts.connectionStateRecovery);
        this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
      } else {
        this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
      }
      opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
      this.sockets = this.of("/");
      if (srv || typeof srv == "number")
        this.attach(srv);
      if (this.opts.cors) {
        this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
      }
    }
    get _opts() {
      return this.opts;
    }
    serveClient(v) {
      if (!arguments.length)
        return this._serveClient;
      this._serveClient = v;
      return this;
    }
    _checkNamespace(name, auth, fn) {
      if (this.parentNsps.size === 0)
        return fn(false);
      const keysIterator = this.parentNsps.keys();
      const run = () => {
        const nextFn = keysIterator.next();
        if (nextFn.done) {
          return fn(false);
        }
        nextFn.value(name, auth, (err, allow) => {
          if (err || !allow) {
            return run();
          }
          if (this._nsps.has(name)) {
            debug15("dynamic namespace %s already exists", name);
            return fn(this._nsps.get(name));
          }
          const namespace = this.parentNsps.get(nextFn.value).createChild(name);
          debug15("dynamic namespace %s was created", name);
          fn(namespace);
        });
      };
      run();
    }
    path(v) {
      if (!arguments.length)
        return this._path;
      this._path = v.replace(/\/$/, "");
      const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
      return this;
    }
    connectTimeout(v) {
      if (v === undefined)
        return this._connectTimeout;
      this._connectTimeout = v;
      return this;
    }
    adapter(v) {
      if (!arguments.length)
        return this._adapter;
      this._adapter = v;
      for (const nsp of this._nsps.values()) {
        nsp._initAdapter();
      }
      return this;
    }
    listen(srv, opts = {}) {
      return this.attach(srv, opts);
    }
    attach(srv, opts = {}) {
      if (typeof srv == "function") {
        const msg = "You are trying to attach socket.io to an express request handler function. Please pass a http.Server instance.";
        throw new Error(msg);
      }
      if (Number(srv) == srv) {
        srv = Number(srv);
      }
      if (typeof srv == "number") {
        debug15("creating http server and binding to %d", srv);
        const port = srv;
        srv = http3.createServer((req, res) => {
          res.writeHead(404);
          res.end();
        });
        srv.listen(port);
      }
      Object.assign(opts, this.opts);
      opts.path = opts.path || this._path;
      this.initEngine(srv, opts);
      return this;
    }
    attachApp(app, opts = {}) {
      Object.assign(opts, this.opts);
      opts.path = opts.path || this._path;
      debug15("creating uWebSockets.js-based engine with opts %j", opts);
      const engine = new engine_io_1.uServer(opts);
      engine.attach(app, opts);
      this.bind(engine);
      if (this._serveClient) {
        app.get(`${this._path}/*`, (res, req) => {
          if (!this.clientPathRegex.test(req.getUrl())) {
            req.setYield(true);
            return;
          }
          const filename = req.getUrl().replace(this._path, "").replace(/\?.*$/, "").replace(/^\//, "");
          const isMap = dotMapRegex.test(filename);
          const type = isMap ? "map" : "source";
          const expectedEtag = '"' + clientVersion + '"';
          const weakEtag = "W/" + expectedEtag;
          const etag = req.getHeader("if-none-match");
          if (etag) {
            if (expectedEtag === etag || weakEtag === etag) {
              debug15("serve client %s 304", type);
              res.writeStatus("304 Not Modified");
              res.end();
              return;
            }
          }
          debug15("serve client %s", type);
          res.writeHeader("cache-control", "public, max-age=0");
          res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
          res.writeHeader("etag", expectedEtag);
          const filepath = path.join(__dirname, "../client-dist/", filename);
          (0, uws_1.serveFile)(res, filepath);
        });
      }
      (0, uws_1.patchAdapter)(app);
    }
    initEngine(srv, opts) {
      debug15("creating engine.io instance with opts %j", opts);
      this.eio = (0, engine_io_1.attach)(srv, opts);
      if (this._serveClient)
        this.attachServe(srv);
      this.httpServer = srv;
      this.bind(this.eio);
    }
    attachServe(srv) {
      debug15("attaching client serving req handler");
      const evs = srv.listeners("request").slice(0);
      srv.removeAllListeners("request");
      srv.on("request", (req, res) => {
        if (this.clientPathRegex.test(req.url)) {
          if (this._corsMiddleware) {
            this._corsMiddleware(req, res, () => {
              this.serve(req, res);
            });
          } else {
            this.serve(req, res);
          }
        } else {
          for (let i2 = 0;i2 < evs.length; i2++) {
            evs[i2].call(srv, req, res);
          }
        }
      });
    }
    serve(req, res) {
      const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
      const isMap = dotMapRegex.test(filename);
      const type = isMap ? "map" : "source";
      const expectedEtag = '"' + clientVersion + '"';
      const weakEtag = "W/" + expectedEtag;
      const etag = req.headers["if-none-match"];
      if (etag) {
        if (expectedEtag === etag || weakEtag === etag) {
          debug15("serve client %s 304", type);
          res.writeHead(304);
          res.end();
          return;
        }
      }
      debug15("serve client %s", type);
      res.setHeader("Cache-Control", "public, max-age=0");
      res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
      res.setHeader("ETag", expectedEtag);
      Server.sendFile(filename, req, res);
    }
    static sendFile(filename, req, res) {
      const readStream2 = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
      const encoding = accepts(req).encodings(["br", "gzip", "deflate"]);
      const onError = (err) => {
        if (err) {
          res.end();
        }
      };
      switch (encoding) {
        case "br":
          res.writeHead(200, { "content-encoding": "br" });
          readStream2.pipe((0, zlib_1.createBrotliCompress)()).pipe(res);
          (0, stream_1.pipeline)(readStream2, (0, zlib_1.createBrotliCompress)(), res, onError);
          break;
        case "gzip":
          res.writeHead(200, { "content-encoding": "gzip" });
          (0, stream_1.pipeline)(readStream2, (0, zlib_1.createGzip)(), res, onError);
          break;
        case "deflate":
          res.writeHead(200, { "content-encoding": "deflate" });
          (0, stream_1.pipeline)(readStream2, (0, zlib_1.createDeflate)(), res, onError);
          break;
        default:
          res.writeHead(200);
          (0, stream_1.pipeline)(readStream2, res, onError);
      }
    }
    bind(engine) {
      this.engine = engine;
      this.engine.on("connection", this.onconnection.bind(this));
      return this;
    }
    onconnection(conn) {
      debug15("incoming connection with id %s", conn.id);
      const client2 = new client_1.Client(this, conn);
      if (conn.protocol === 3) {
        client2.connect("/");
      }
      return this;
    }
    of(name, fn) {
      if (typeof name === "function" || name instanceof RegExp) {
        const parentNsp = new parent_namespace_1.ParentNamespace(this);
        debug15("initializing parent namespace %s", parentNsp.name);
        if (typeof name === "function") {
          this.parentNsps.set(name, parentNsp);
        } else {
          this.parentNsps.set((nsp2, conn, next) => next(null, name.test(nsp2)), parentNsp);
          this.parentNamespacesFromRegExp.set(name, parentNsp);
        }
        if (fn) {
          parentNsp.on("connect", fn);
        }
        return parentNsp;
      }
      if (String(name)[0] !== "/")
        name = "/" + name;
      let nsp = this._nsps.get(name);
      if (!nsp) {
        for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {
          if (regex.test(name)) {
            debug15("attaching namespace %s to parent namespace %s", name, regex);
            return parentNamespace.createChild(name);
          }
        }
        debug15("initializing namespace %s", name);
        nsp = new namespace_1.Namespace(this, name);
        this._nsps.set(name, nsp);
        if (name !== "/") {
          this.sockets.emitReserved("new_namespace", nsp);
        }
      }
      if (fn)
        nsp.on("connect", fn);
      return nsp;
    }
    close(fn) {
      for (const socket4 of this.sockets.sockets.values()) {
        socket4._onclose("server shutting down");
      }
      this.engine.close();
      (0, uws_1.restoreAdapter)();
      if (this.httpServer) {
        this.httpServer.close(fn);
      } else {
        fn && fn();
      }
    }
    use(fn) {
      this.sockets.use(fn);
      return this;
    }
    to(room) {
      return this.sockets.to(room);
    }
    in(room) {
      return this.sockets.in(room);
    }
    except(room) {
      return this.sockets.except(room);
    }
    emitWithAck(ev, ...args) {
      return this.sockets.emitWithAck(ev, ...args);
    }
    send(...args) {
      this.sockets.emit("message", ...args);
      return this;
    }
    write(...args) {
      this.sockets.emit("message", ...args);
      return this;
    }
    serverSideEmit(ev, ...args) {
      return this.sockets.serverSideEmit(ev, ...args);
    }
    serverSideEmitWithAck(ev, ...args) {
      return this.sockets.serverSideEmitWithAck(ev, ...args);
    }
    allSockets() {
      return this.sockets.allSockets();
    }
    compress(compress) {
      return this.sockets.compress(compress);
    }
    get volatile() {
      return this.sockets.volatile;
    }
    get local() {
      return this.sockets.local;
    }
    timeout(timeout) {
      return this.sockets.timeout(timeout);
    }
    fetchSockets() {
      return this.sockets.fetchSockets();
    }
    socketsJoin(room) {
      return this.sockets.socketsJoin(room);
    }
    socketsLeave(room) {
      return this.sockets.socketsLeave(room);
    }
    disconnectSockets(close = false) {
      return this.sockets.disconnectSockets(close);
    }
  }
  exports.Server = Server;
  var emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {
    return typeof events_1.EventEmitter.prototype[key] === "function";
  });
  emitterMethods.forEach(function(fn) {
    Server.prototype[fn] = function() {
      return this.sockets[fn].apply(this.sockets, arguments);
    };
  });
  module.exports = (srv, opts) => new Server(srv, opts);
  module.exports.Server = Server;
  module.exports.Namespace = namespace_1.Namespace;
  module.exports.Socket = socket_1.Socket;
  var socket_2 = require_socket2();
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i2 = 1, n = arguments.length;i2 < n; i2++) {
        s = arguments[i2];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
          if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
            t[p[i2]] = s[p[i2]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d = decorators[i2])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0;i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = undefined;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k = 0, i2 = 0;i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l = from.length, ar;i2 < l; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n) {
        if (g[n])
          i2[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i2, p;
      return i2 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n, f) {
        i2[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i2;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet2 = function(receiver2, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
    };
    __classPrivateFieldSet2 = function(receiver2, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
    };
    __classPrivateFieldIn = function(state, receiver2) {
      if (receiver2 === null || typeof receiver2 !== "object" && typeof receiver2 !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver2 === state : state.has(receiver2);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// node_modules/@smithy/protocol-http/dist-cjs/extensions/httpExtensionConfiguration.js
var require_httpExtensionConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpHandlerRuntimeConfig = exports.getHttpHandlerExtensionConfiguration = undefined;
  var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
      setHttpHandler(handler) {
        httpHandler = handler;
      },
      httpHandler() {
        return httpHandler;
      },
      updateHttpClientConfig(key, value) {
        httpHandler.updateHttpClientConfig(key, value);
      },
      httpHandlerConfigs() {
        return httpHandler.httpHandlerConfigs();
      }
    };
  };
  exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration;
  var resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
      httpHandler: httpHandlerExtensionConfiguration.httpHandler()
    };
  };
  exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig;
});

// node_modules/@smithy/protocol-http/dist-cjs/extensions/index.js
var require_extensions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_httpExtensionConfiguration(), exports);
});

// node_modules/@smithy/types/dist-cjs/abort.js
var require_abort = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/auth.js
var require_auth = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpAuthLocation = undefined;
  var HttpAuthLocation;
  (function(HttpAuthLocation2) {
    HttpAuthLocation2["HEADER"] = "header";
    HttpAuthLocation2["QUERY"] = "query";
  })(HttpAuthLocation = exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));
});

// node_modules/@smithy/types/dist-cjs/blob/blob-payload-input-types.js
var require_blob_payload_input_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/checksum.js
var require_checksum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/client.js
var require_client2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/command.js
var require_command2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/connection/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/connection/manager.js
var require_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/connection/pool.js
var require_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/connection/index.js
var require_connection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_config(), exports);
  tslib_1.__exportStar(require_manager(), exports);
  tslib_1.__exportStar(require_pool(), exports);
});

// node_modules/@smithy/types/dist-cjs/crypto.js
var require_crypto = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/encode.js
var require_encode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/endpoint.js
var require_endpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointURLScheme = undefined;
  var EndpointURLScheme;
  (function(EndpointURLScheme2) {
    EndpointURLScheme2["HTTP"] = "http";
    EndpointURLScheme2["HTTPS"] = "https";
  })(EndpointURLScheme = exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));
});

// node_modules/@smithy/types/dist-cjs/endpoints/EndpointRuleObject.js
var require_EndpointRuleObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/endpoints/ErrorRuleObject.js
var require_ErrorRuleObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/endpoints/RuleSetObject.js
var require_RuleSetObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/endpoints/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/endpoints/TreeRuleObject.js
var require_TreeRuleObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/endpoints/index.js
var require_endpoints = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EndpointRuleObject(), exports);
  tslib_1.__exportStar(require_ErrorRuleObject(), exports);
  tslib_1.__exportStar(require_RuleSetObject(), exports);
  tslib_1.__exportStar(require_shared(), exports);
  tslib_1.__exportStar(require_TreeRuleObject(), exports);
});

// node_modules/@smithy/types/dist-cjs/eventStream.js
var require_eventStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/extensions/checksum.js
var require_checksum2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveChecksumRuntimeConfig = exports.getChecksumConfiguration = exports.AlgorithmId = undefined;
  var AlgorithmId;
  (function(AlgorithmId2) {
    AlgorithmId2["MD5"] = "md5";
    AlgorithmId2["CRC32"] = "crc32";
    AlgorithmId2["CRC32C"] = "crc32c";
    AlgorithmId2["SHA1"] = "sha1";
    AlgorithmId2["SHA256"] = "sha256";
  })(AlgorithmId = exports.AlgorithmId || (exports.AlgorithmId = {}));
  var getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
      checksumAlgorithms.push({
        algorithmId: () => AlgorithmId.SHA256,
        checksumConstructor: () => runtimeConfig.sha256
      });
    }
    if (runtimeConfig.md5 != null) {
      checksumAlgorithms.push({
        algorithmId: () => AlgorithmId.MD5,
        checksumConstructor: () => runtimeConfig.md5
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  };
  exports.getChecksumConfiguration = getChecksumConfiguration;
  var resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  };
  exports.resolveChecksumRuntimeConfig = resolveChecksumRuntimeConfig;
});

// node_modules/@smithy/types/dist-cjs/extensions/defaultClientConfiguration.js
var require_defaultClientConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveDefaultRuntimeConfig = exports.getDefaultClientConfiguration = undefined;
  var checksum_1 = require_checksum2();
  var getDefaultClientConfiguration = (runtimeConfig) => {
    return {
      ...(0, checksum_1.getChecksumConfiguration)(runtimeConfig)
    };
  };
  exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
  var resolveDefaultRuntimeConfig = (config) => {
    return {
      ...(0, checksum_1.resolveChecksumRuntimeConfig)(config)
    };
  };
  exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
});

// node_modules/@smithy/types/dist-cjs/extensions/defaultExtensionConfiguration.js
var require_defaultExtensionConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/extensions/index.js
var require_extensions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlgorithmId = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_defaultClientConfiguration(), exports);
  tslib_1.__exportStar(require_defaultExtensionConfiguration(), exports);
  var checksum_1 = require_checksum2();
  Object.defineProperty(exports, "AlgorithmId", { enumerable: true, get: function() {
    return checksum_1.AlgorithmId;
  } });
});

// node_modules/@smithy/types/dist-cjs/http.js
var require_http = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FieldPosition = undefined;
  var FieldPosition;
  (function(FieldPosition2) {
    FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
    FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
  })(FieldPosition = exports.FieldPosition || (exports.FieldPosition = {}));
});

// node_modules/@smithy/types/dist-cjs/identity/awsCredentialIdentity.js
var require_awsCredentialIdentity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/identity/identity.js
var require_identity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/identity/index.js
var require_identity2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_awsCredentialIdentity(), exports);
  tslib_1.__exportStar(require_identity(), exports);
});

// node_modules/@smithy/types/dist-cjs/logger.js
var require_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/middleware.js
var require_middleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SMITHY_CONTEXT_KEY = undefined;
  exports.SMITHY_CONTEXT_KEY = "__smithy_context";
});

// node_modules/@smithy/types/dist-cjs/pagination.js
var require_pagination = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/profile.js
var require_profile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IniSectionType = undefined;
  var IniSectionType;
  (function(IniSectionType2) {
    IniSectionType2["PROFILE"] = "profile";
    IniSectionType2["SSO_SESSION"] = "sso-session";
    IniSectionType2["SERVICES"] = "services";
  })(IniSectionType = exports.IniSectionType || (exports.IniSectionType = {}));
});

// node_modules/@smithy/types/dist-cjs/response.js
var require_response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/retry.js
var require_retry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/serde.js
var require_serde = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/shapes.js
var require_shapes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/signature.js
var require_signature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/stream.js
var require_stream2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/streaming-payload/streaming-blob-common-types.js
var require_streaming_blob_common_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/streaming-payload/streaming-blob-payload-input-types.js
var require_streaming_blob_payload_input_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/streaming-payload/streaming-blob-payload-output-types.js
var require_streaming_blob_payload_output_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/transfer.js
var require_transfer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequestHandlerProtocol = undefined;
  var RequestHandlerProtocol;
  (function(RequestHandlerProtocol2) {
    RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
  })(RequestHandlerProtocol = exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));
});

// node_modules/@smithy/types/dist-cjs/transform/client-payload-blob-type-narrow.js
var require_client_payload_blob_type_narrow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/transform/type-transform.js
var require_type_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/uri.js
var require_uri2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/waiter.js
var require_waiter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_abort(), exports);
  tslib_1.__exportStar(require_auth(), exports);
  tslib_1.__exportStar(require_blob_payload_input_types(), exports);
  tslib_1.__exportStar(require_checksum(), exports);
  tslib_1.__exportStar(require_client2(), exports);
  tslib_1.__exportStar(require_command2(), exports);
  tslib_1.__exportStar(require_connection(), exports);
  tslib_1.__exportStar(require_crypto(), exports);
  tslib_1.__exportStar(require_encode(), exports);
  tslib_1.__exportStar(require_endpoint(), exports);
  tslib_1.__exportStar(require_endpoints(), exports);
  tslib_1.__exportStar(require_eventStream(), exports);
  tslib_1.__exportStar(require_extensions2(), exports);
  tslib_1.__exportStar(require_http(), exports);
  tslib_1.__exportStar(require_identity2(), exports);
  tslib_1.__exportStar(require_logger(), exports);
  tslib_1.__exportStar(require_middleware(), exports);
  tslib_1.__exportStar(require_pagination(), exports);
  tslib_1.__exportStar(require_profile(), exports);
  tslib_1.__exportStar(require_response(), exports);
  tslib_1.__exportStar(require_retry(), exports);
  tslib_1.__exportStar(require_serde(), exports);
  tslib_1.__exportStar(require_shapes(), exports);
  tslib_1.__exportStar(require_signature(), exports);
  tslib_1.__exportStar(require_stream2(), exports);
  tslib_1.__exportStar(require_streaming_blob_common_types(), exports);
  tslib_1.__exportStar(require_streaming_blob_payload_input_types(), exports);
  tslib_1.__exportStar(require_streaming_blob_payload_output_types(), exports);
  tslib_1.__exportStar(require_transfer(), exports);
  tslib_1.__exportStar(require_client_payload_blob_type_narrow(), exports);
  tslib_1.__exportStar(require_type_transform(), exports);
  tslib_1.__exportStar(require_uri2(), exports);
  tslib_1.__exportStar(require_util(), exports);
  tslib_1.__exportStar(require_waiter(), exports);
});

// node_modules/@smithy/protocol-http/dist-cjs/Field.js
var require_Field = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Field = undefined;
  var types_1 = require_dist_cjs();

  class Field {
    constructor({ name, kind = types_1.FieldPosition.HEADER, values = [] }) {
      this.name = name;
      this.kind = kind;
      this.values = values;
    }
    add(value) {
      this.values.push(value);
    }
    set(values) {
      this.values = values;
    }
    remove(value) {
      this.values = this.values.filter((v) => v !== value);
    }
    toString() {
      return this.values.map((v) => v.includes(",") || v.includes(" ") ? `"${v}"` : v).join(", ");
    }
    get() {
      return this.values;
    }
  }
  exports.Field = Field;
});

// node_modules/@smithy/protocol-http/dist-cjs/Fields.js
var require_Fields = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Fields = undefined;

  class Fields {
    constructor({ fields = [], encoding = "utf-8" }) {
      this.entries = {};
      fields.forEach(this.setField.bind(this));
      this.encoding = encoding;
    }
    setField(field) {
      this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
      return this.entries[name.toLowerCase()];
    }
    removeField(name) {
      delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
      return Object.values(this.entries).filter((field) => field.kind === kind);
    }
  }
  exports.Fields = Fields;
});

// node_modules/@smithy/protocol-http/dist-cjs/httpHandler.js
var require_httpHandler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/protocol-http/dist-cjs/httpRequest.js
var require_httpRequest = __commonJS((exports) => {
  var cloneQuery = function(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpRequest = undefined;

  class HttpRequest {
    constructor(options5) {
      this.method = options5.method || "GET";
      this.hostname = options5.hostname || "localhost";
      this.port = options5.port;
      this.query = options5.query || {};
      this.headers = options5.headers || {};
      this.body = options5.body;
      this.protocol = options5.protocol ? options5.protocol.slice(-1) !== ":" ? `${options5.protocol}:` : options5.protocol : "https:";
      this.path = options5.path ? options5.path.charAt(0) !== "/" ? `/${options5.path}` : options5.path : "/";
      this.username = options5.username;
      this.password = options5.password;
      this.fragment = options5.fragment;
    }
    static isInstance(request) {
      if (!request)
        return false;
      const req = request;
      return ("method" in req) && ("protocol" in req) && ("hostname" in req) && ("path" in req) && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      const cloned = new HttpRequest({
        ...this,
        headers: { ...this.headers }
      });
      if (cloned.query)
        cloned.query = cloneQuery(cloned.query);
      return cloned;
    }
  }
  exports.HttpRequest = HttpRequest;
});

// node_modules/@smithy/protocol-http/dist-cjs/httpResponse.js
var require_httpResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpResponse = undefined;

  class HttpResponse {
    constructor(options5) {
      this.statusCode = options5.statusCode;
      this.reason = options5.reason;
      this.headers = options5.headers || {};
      this.body = options5.body;
    }
    static isInstance(response4) {
      if (!response4)
        return false;
      const resp = response4;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  }
  exports.HttpResponse = HttpResponse;
});

// node_modules/@smithy/protocol-http/dist-cjs/isValidHostname.js
var require_isValidHostname = __commonJS((exports) => {
  var isValidHostname = function(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidHostname = undefined;
  exports.isValidHostname = isValidHostname;
});

// node_modules/@smithy/protocol-http/dist-cjs/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_extensions(), exports);
  tslib_1.__exportStar(require_Field(), exports);
  tslib_1.__exportStar(require_Fields(), exports);
  tslib_1.__exportStar(require_httpHandler(), exports);
  tslib_1.__exportStar(require_httpRequest(), exports);
  tslib_1.__exportStar(require_httpResponse(), exports);
  tslib_1.__exportStar(require_isValidHostname(), exports);
  tslib_1.__exportStar(require_types2(), exports);
});

// node_modules/@aws-sdk/middleware-expect-continue/dist-cjs/index.js
var require_dist_cjs3 = __commonJS((exports) => {
  var addExpectContinueMiddleware = function(options5) {
    return (next) => async (args) => {
      const { request } = args;
      if (protocol_http_1.HttpRequest.isInstance(request) && request.body && options5.runtime === "node") {
        request.headers = {
          ...request.headers,
          Expect: "100-continue"
        };
      }
      return next({
        ...args,
        request
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAddExpectContinuePlugin = exports.addExpectContinueMiddlewareOptions = exports.addExpectContinueMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  exports.addExpectContinueMiddleware = addExpectContinueMiddleware;
  exports.addExpectContinueMiddlewareOptions = {
    step: "build",
    tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
    name: "addExpectContinueMiddleware",
    override: true
  };
  var getAddExpectContinuePlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.add(addExpectContinueMiddleware(options5), exports.addExpectContinueMiddlewareOptions);
    }
  });
  exports.getAddExpectContinuePlugin = getAddExpectContinuePlugin;
});

// node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs4 = __commonJS((exports) => {
  var resolveHostHeaderConfig = function(input) {
    return input;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHostHeaderPlugin = exports.hostHeaderMiddlewareOptions = exports.hostHeaderMiddleware = exports.resolveHostHeaderConfig = undefined;
  var protocol_http_1 = require_dist_cjs2();
  exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
  var hostHeaderMiddleware = (options5) => (next) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
      return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options5.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
      delete request.headers["host"];
      request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    } else if (!request.headers["host"]) {
      let host = request.hostname;
      if (request.port != null)
        host += `:${request.port}`;
      request.headers["host"] = host;
    }
    return next(args);
  };
  exports.hostHeaderMiddleware = hostHeaderMiddleware;
  exports.hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
  var getHostHeaderPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.add((0, exports.hostHeaderMiddleware)(options5), exports.hostHeaderMiddlewareOptions);
    }
  });
  exports.getHostHeaderPlugin = getHostHeaderPlugin;
});

// node_modules/@aws-sdk/middleware-logger/dist-cjs/loggerMiddleware.js
var require_loggerMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getLoggerPlugin = exports.loggerMiddlewareOptions = exports.loggerMiddleware = undefined;
  var loggerMiddleware = () => (next, context) => async (args) => {
    var _a, _b;
    try {
      const response4 = await next(args);
      const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== undefined ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
      const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog !== null && overrideOutputFilterSensitiveLog !== undefined ? overrideOutputFilterSensitiveLog : context.outputFilterSensitiveLog;
      const { $metadata, ...outputWithoutMetadata } = response4.output;
      (_a = logger === null || logger === undefined ? undefined : logger.info) === null || _a === undefined || _a.call(logger, {
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        output: outputFilterSensitiveLog(outputWithoutMetadata),
        metadata: $metadata
      });
      return response4;
    } catch (error) {
      const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== undefined ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
      (_b = logger === null || logger === undefined ? undefined : logger.error) === null || _b === undefined || _b.call(logger, {
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        error,
        metadata: error.$metadata
      });
      throw error;
    }
  };
  exports.loggerMiddleware = loggerMiddleware;
  exports.loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
  var getLoggerPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.add((0, exports.loggerMiddleware)(), exports.loggerMiddlewareOptions);
    }
  });
  exports.getLoggerPlugin = getLoggerPlugin;
});

// node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_loggerMiddleware(), exports);
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRecursionDetectionPlugin = exports.addRecursionDetectionMiddlewareOptions = exports.recursionDetectionMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
  var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
  var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
  var recursionDetectionMiddleware = (options5) => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request) || options5.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
      return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
      request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
      ...args,
      request
    });
  };
  exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
  exports.addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
  var getRecursionDetectionPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.add((0, exports.recursionDetectionMiddleware)(options5), exports.addRecursionDetectionMiddlewareOptions);
    }
  });
  exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;
});

// node_modules/@smithy/smithy-client/dist-cjs/NoOpLogger.js
var require_NoOpLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoOpLogger = undefined;

  class NoOpLogger {
    trace() {
    }
    debug() {
    }
    info() {
    }
    warn() {
    }
    error() {
    }
  }
  exports.NoOpLogger = NoOpLogger;
});

// node_modules/@smithy/middleware-stack/dist-cjs/MiddlewareStack.js
var require_MiddlewareStack = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.constructStack = undefined;
  var getAllAliases = (name, aliases2) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases2) {
      for (const alias of aliases2) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  };
  var getMiddlewareNameWithAliases = (name, aliases2) => {
    return `${name || "anonymous"}${aliases2 && aliases2.length > 0 ? ` (a.k.a. ${aliases2.join(",")})` : ""}`;
  };
  var constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set;
    const sort = (entries2) => entries2.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const aliases2 = getAllAliases(entry.name, entry.aliases);
        if (aliases2.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases2) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const removeByReference = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const cloneTo = (toStack) => {
      var _a;
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      (_a = toStack.identifyOnResolve) === null || _a === undefined || _a.call(toStack, stack.identifyOnResolve());
      return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug15 = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === undefined) {
            if (debug15) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ` + `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` + `middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    };
    const stack = {
      add: (middleware, options5 = {}) => {
        const { name, override, aliases: _aliases } = options5;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware,
          ...options5
        };
        const aliases2 = getAllAliases(name, _aliases);
        if (aliases2.length > 0) {
          if (aliases2.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases2) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => {
                var _a;
                return entry2.name === alias || ((_a = entry2.aliases) === null || _a === undefined ? undefined : _a.some((a) => a === alias));
              });
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` + `${toOverride.priority} priority in ${toOverride.step} step cannot ` + `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` + `${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases2) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware, options5) => {
        const { name, override, aliases: _aliases } = options5;
        const entry = {
          middleware,
          ...options5
        };
        const aliases2 = getAllAliases(name, _aliases);
        if (aliases2.length > 0) {
          if (aliases2.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases2) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => {
                var _a;
                return entry2.name === alias || ((_a = entry2.aliases) === null || _a === undefined ? undefined : _a.some((a) => a === alias));
              });
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` + `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` + `"${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases2) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo((0, exports.constructStack)()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases2 = getAllAliases(name, _aliases);
            for (const alias of aliases2) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        var _a, _b;
        const cloned = cloneTo((0, exports.constructStack)());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || ((_b = (_a = from.identifyOnResolve) === null || _a === undefined ? undefined : _a.call(from)) !== null && _b !== undefined ? _b : false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          var _a;
          const step = (_a = mw.step) !== null && _a !== undefined ? _a : mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context) => {
        for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware(handler, context);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  };
  exports.constructStack = constructStack;
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
});

// node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_MiddlewareStack(), exports);
});

// node_modules/@smithy/smithy-client/dist-cjs/client.js
var require_client3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Client = undefined;
  var middleware_stack_1 = require_dist_cjs7();

  class Client {
    constructor(config) {
      this.middlewareStack = (0, middleware_stack_1.constructStack)();
      this.config = config;
    }
    send(command, optionsOrCb, cb) {
      const options5 = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
      const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
      const handler = command.resolveMiddleware(this.middlewareStack, this.config, options5);
      if (callback) {
        handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
        });
      } else {
        return handler(command).then((result) => result.output);
      }
    }
    destroy() {
      if (this.config.requestHandler.destroy)
        this.config.requestHandler.destroy();
    }
  }
  exports.Client = Client;
});

// node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArrayBuffer = undefined;
  var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  exports.isArrayBuffer = isArrayBuffer;
});

// node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromString = exports.fromArrayBuffer = undefined;
  var is_array_buffer_1 = require_dist_cjs8();
  var buffer_1 = __require("buffer");
  var fromArrayBuffer = (input, offset = 0, length2 = input.byteLength - offset) => {
    if (!(0, is_array_buffer_1.isArrayBuffer)(input)) {
      throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer_1.Buffer.from(input, offset, length2);
  };
  exports.fromArrayBuffer = fromArrayBuffer;
  var fromString = (input, encoding) => {
    if (typeof input !== "string") {
      throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer_1.Buffer.from(input, encoding) : buffer_1.Buffer.from(input);
  };
  exports.fromString = fromString;
});

// node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
  var fromBase64 = (input) => {
    if (input.length * 3 % 4 !== 0) {
      throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
      throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  };
  exports.fromBase64 = fromBase64;
});

// node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var toBase64 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
  exports.toBase64 = toBase64;
});

// node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromBase64(), exports);
  tslib_1.__exportStar(require_toBase64(), exports);
});

// node_modules/@smithy/util-utf8/dist-cjs/fromUtf8.js
var require_fromUtf8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromUtf8 = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var fromUtf8 = (input) => {
    const buf = (0, util_buffer_from_1.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  };
  exports.fromUtf8 = fromUtf8;
});

// node_modules/@smithy/util-utf8/dist-cjs/toUint8Array.js
var require_toUint8Array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUint8Array = undefined;
  var fromUtf8_1 = require_fromUtf8();
  var toUint8Array = (data) => {
    if (typeof data === "string") {
      return (0, fromUtf8_1.fromUtf8)(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  };
  exports.toUint8Array = toUint8Array;
});

// node_modules/@smithy/util-utf8/dist-cjs/toUtf8.js
var require_toUtf8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUtf8 = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var toUtf8 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  exports.toUtf8 = toUtf8;
});

// node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromUtf8(), exports);
  tslib_1.__exportStar(require_toUint8Array(), exports);
  tslib_1.__exportStar(require_toUtf8(), exports);
});

// node_modules/@smithy/util-stream/dist-cjs/blob/transforms.js
var require_transforms = __commonJS((exports) => {
  var transformToString = function(payload2, encoding = "utf-8") {
    if (encoding === "base64") {
      return (0, util_base64_1.toBase64)(payload2);
    }
    return (0, util_utf8_1.toUtf8)(payload2);
  };
  var transformFromString = function(str, encoding) {
    if (encoding === "base64") {
      return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_base64_1.fromBase64)(str));
    }
    return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_utf8_1.fromUtf8)(str));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformFromString = exports.transformToString = undefined;
  var util_base64_1 = require_dist_cjs10();
  var util_utf8_1 = require_dist_cjs11();
  var Uint8ArrayBlobAdapter_1 = require_Uint8ArrayBlobAdapter();
  exports.transformToString = transformToString;
  exports.transformFromString = transformFromString;
});

// node_modules/@smithy/util-stream/dist-cjs/blob/Uint8ArrayBlobAdapter.js
var require_Uint8ArrayBlobAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uint8ArrayBlobAdapter = undefined;
  var transforms_1 = require_transforms();

  class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
      switch (typeof source) {
        case "string":
          return (0, transforms_1.transformFromString)(source, encoding);
        default:
          throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
    }
    static mutate(source) {
      Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      return (0, transforms_1.transformToString)(this, encoding);
    }
  }
  exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;
});

// node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAwsChunkedEncodingStream = undefined;
  var stream_1 = __require("stream");
  var getAwsChunkedEncodingStream = (readableStream, options5) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options5;
    const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({ read: () => {
    } });
    readableStream.on("data", (data) => {
      const length2 = bodyLengthChecker(data) || 0;
      awsChunkedEncodingStream.push(`${length2.toString(16)}\r\n`);
      awsChunkedEncodingStream.push(data);
      awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
      awsChunkedEncodingStream.push(`0\r\n`);
      if (checksumRequired) {
        const checksum = base64Encoder(await digest);
        awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
        awsChunkedEncodingStream.push(`\r\n`);
      }
      awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
  };
  exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
});

// node_modules/@smithy/util-uri-escape/dist-cjs/escape-uri.js
var require_escape_uri = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUri = undefined;
  var escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
  exports.escapeUri = escapeUri;
  var hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
});

// node_modules/@smithy/util-uri-escape/dist-cjs/escape-uri-path.js
var require_escape_uri_path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUriPath = undefined;
  var escape_uri_1 = require_escape_uri();
  var escapeUriPath = (uri) => uri.split("/").map(escape_uri_1.escapeUri).join("/");
  exports.escapeUriPath = escapeUriPath;
});

// node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_escape_uri(), exports);
  tslib_1.__exportStar(require_escape_uri_path(), exports);
});

// node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs13 = __commonJS((exports) => {
  var buildQueryString = function(query) {
    const parts2 = [];
    for (let key of Object.keys(query).sort()) {
      const value = query[key];
      key = (0, util_uri_escape_1.escapeUri)(key);
      if (Array.isArray(value)) {
        for (let i2 = 0, iLen = value.length;i2 < iLen; i2++) {
          parts2.push(`${key}=${(0, util_uri_escape_1.escapeUri)(value[i2])}`);
        }
      } else {
        let qsEntry = key;
        if (value || typeof value === "string") {
          qsEntry += `=${(0, util_uri_escape_1.escapeUri)(value)}`;
        }
        parts2.push(qsEntry);
      }
    }
    return parts2.join("&");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildQueryString = undefined;
  var util_uri_escape_1 = require_dist_cjs12();
  exports.buildQueryString = buildQueryString;
});

// node_modules/@smithy/node-http-handler/dist-cjs/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODEJS_TIMEOUT_ERROR_CODES = undefined;
  exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
});

// node_modules/@smithy/node-http-handler/dist-cjs/get-transformed-headers.js
var require_get_transformed_headers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTransformedHeaders = undefined;
  var getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
      const headerValues = headers[name];
      transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
  };
  exports.getTransformedHeaders = getTransformedHeaders;
});

// node_modules/@smithy/node-http-handler/dist-cjs/set-connection-timeout.js
var require_set_connection_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setConnectionTimeout = undefined;
  var setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
      return;
    }
    const timeoutId = setTimeout(() => {
      request.destroy();
      reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
        name: "TimeoutError"
      }));
    }, timeoutInMs);
    request.on("socket", (socket4) => {
      if (socket4.connecting) {
        socket4.on("connect", () => {
          clearTimeout(timeoutId);
        });
      } else {
        clearTimeout(timeoutId);
      }
    });
  };
  exports.setConnectionTimeout = setConnectionTimeout;
});

// node_modules/@smithy/node-http-handler/dist-cjs/set-socket-keep-alive.js
var require_set_socket_keep_alive = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setSocketKeepAlive = undefined;
  var setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
      return;
    }
    request.on("socket", (socket4) => {
      socket4.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
  };
  exports.setSocketKeepAlive = setSocketKeepAlive;
});

// node_modules/@smithy/node-http-handler/dist-cjs/set-socket-timeout.js
var require_set_socket_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setSocketTimeout = undefined;
  var setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
      request.destroy();
      reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
  };
  exports.setSocketTimeout = setSocketTimeout;
});

// node_modules/@smithy/node-http-handler/dist-cjs/write-request-body.js
var require_write_request_body = __commonJS((exports) => {
  async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    var _a;
    const headers = (_a = request.headers) !== null && _a !== undefined ? _a : {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
      await Promise.race([
        new Promise((resolve) => {
          timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
        }),
        new Promise((resolve) => {
          httpRequest.on("continue", () => {
            clearTimeout(timeoutId);
            resolve();
          });
          httpRequest.on("error", () => {
            hasError = true;
            clearTimeout(timeoutId);
            resolve();
          });
        })
      ]);
    }
    if (!hasError) {
      writeBody(httpRequest, request.body);
    }
  }
  var writeBody = function(httpRequest, body) {
    if (body instanceof stream_1.Readable) {
      body.pipe(httpRequest);
    } else if (body) {
      httpRequest.end(Buffer.from(body));
    } else {
      httpRequest.end();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeRequestBody = undefined;
  var stream_1 = __require("stream");
  var MIN_WAIT_TIME = 1000;
  exports.writeRequestBody = writeRequestBody;
});

// node_modules/@smithy/node-http-handler/dist-cjs/node-http-handler.js
var require_node_http_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeHttpHandler = exports.DEFAULT_REQUEST_TIMEOUT = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var querystring_builder_1 = require_dist_cjs13();
  var http_1 = __require("http");
  var https_1 = __require("https");
  var constants_1 = require_constants3();
  var get_transformed_headers_1 = require_get_transformed_headers();
  var set_connection_timeout_1 = require_set_connection_timeout();
  var set_socket_keep_alive_1 = require_set_socket_keep_alive();
  var set_socket_timeout_1 = require_set_socket_timeout();
  var write_request_body_1 = require_write_request_body();
  exports.DEFAULT_REQUEST_TIMEOUT = 0;

  class NodeHttpHandler {
    constructor(options5) {
      this.metadata = { handlerProtocol: "http/1.1" };
      this.configProvider = new Promise((resolve, reject) => {
        if (typeof options5 === "function") {
          options5().then((_options) => {
            resolve(this.resolveDefaultConfig(_options));
          }).catch(reject);
        } else {
          resolve(this.resolveDefaultConfig(options5));
        }
      });
    }
    resolveDefaultConfig(options5) {
      const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options5 || {};
      const keepAlive = true;
      const maxSockets = 50;
      return {
        connectionTimeout,
        requestTimeout: requestTimeout !== null && requestTimeout !== undefined ? requestTimeout : socketTimeout,
        httpAgent: httpAgent || new http_1.Agent({ keepAlive, maxSockets }),
        httpsAgent: httpsAgent || new https_1.Agent({ keepAlive, maxSockets })
      };
    }
    destroy() {
      var _a, _b, _c, _d;
      (_b = (_a = this.config) === null || _a === undefined ? undefined : _a.httpAgent) === null || _b === undefined || _b.destroy();
      (_d = (_c = this.config) === null || _c === undefined ? undefined : _c.httpsAgent) === null || _d === undefined || _d.destroy();
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      return new Promise((_resolve, _reject) => {
        var _a, _b;
        let writeRequestBodyPromise = undefined;
        const resolve = async (arg) => {
          await writeRequestBodyPromise;
          _resolve(arg);
        };
        const reject = async (arg) => {
          await writeRequestBodyPromise;
          _reject(arg);
        };
        if (!this.config) {
          throw new Error("Node HTTP request handler config is not resolved");
        }
        if (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const isSSL = request.protocol === "https:";
        const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
        let auth = undefined;
        if (request.username != null || request.password != null) {
          const username = (_a = request.username) !== null && _a !== undefined ? _a : "";
          const password = (_b = request.password) !== null && _b !== undefined ? _b : "";
          auth = `${username}:${password}`;
        }
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        const nodeHttpsOptions = {
          headers: request.headers,
          host: request.hostname,
          method: request.method,
          path,
          port: request.port,
          agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
          auth
        };
        const requestFunc = isSSL ? https_1.request : http_1.request;
        const req = requestFunc(nodeHttpsOptions, (res) => {
          const httpResponse = new protocol_http_1.HttpResponse({
            statusCode: res.statusCode || -1,
            reason: res.statusMessage,
            headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
            body: res
          });
          resolve({ response: httpResponse });
        });
        req.on("error", (err) => {
          if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
            reject(Object.assign(err, { name: "TimeoutError" }));
          } else {
            reject(err);
          }
        });
        (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.config.connectionTimeout);
        (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.config.requestTimeout);
        if (abortSignal) {
          abortSignal.onabort = () => {
            req.abort();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          };
        }
        const httpAgent = nodeHttpsOptions.agent;
        if (typeof httpAgent === "object" && ("keepAlive" in httpAgent)) {
          (0, set_socket_keep_alive_1.setSocketKeepAlive)(req, {
            keepAlive: httpAgent.keepAlive,
            keepAliveMsecs: httpAgent.keepAliveMsecs
          });
        }
        writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, this.config.requestTimeout).catch(_reject);
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        return {
          ...config,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      var _a;
      return (_a = this.config) !== null && _a !== undefined ? _a : {};
    }
  }
  exports.NodeHttpHandler = NodeHttpHandler;
});

// node_modules/@smithy/node-http-handler/dist-cjs/node-http2-connection-pool.js
var require_node_http2_connection_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeHttp2ConnectionPool = undefined;

  class NodeHttp2ConnectionPool {
    constructor(sessions) {
      this.sessions = [];
      this.sessions = sessions !== null && sessions !== undefined ? sessions : [];
    }
    poll() {
      if (this.sessions.length > 0) {
        return this.sessions.shift();
      }
    }
    offerLast(session) {
      this.sessions.push(session);
    }
    contains(session) {
      return this.sessions.includes(session);
    }
    remove(session) {
      this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
      for (const session of this.sessions) {
        if (session === connection) {
          if (!session.destroyed) {
            session.destroy();
          }
        }
      }
    }
  }
  exports.NodeHttp2ConnectionPool = NodeHttp2ConnectionPool;
});

// node_modules/@smithy/node-http-handler/dist-cjs/node-http2-connection-manager.js
var require_node_http2_connection_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeHttp2ConnectionManager = undefined;
  var tslib_1 = require_tslib();
  var http2_1 = tslib_1.__importDefault(__require("http2"));
  var node_http2_connection_pool_1 = require_node_http2_connection_pool();

  class NodeHttp2ConnectionManager {
    constructor(config) {
      this.sessionCache = new Map;
      this.config = config;
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrency must be greater than zero.");
      }
    }
    lease(requestContext, connectionConfiguration) {
      const url3 = this.getUrlString(requestContext);
      const existingPool = this.sessionCache.get(url3);
      if (existingPool) {
        const existingSession = existingPool.poll();
        if (existingSession && !this.config.disableConcurrency) {
          return existingSession;
        }
      }
      const session = http2_1.default.connect(url3);
      if (this.config.maxConcurrency) {
        session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
          if (err) {
            throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
          }
        });
      }
      session.unref();
      const destroySessionCb = () => {
        session.destroy();
        this.deleteSession(url3, session);
      };
      session.on("goaway", destroySessionCb);
      session.on("error", destroySessionCb);
      session.on("frameError", destroySessionCb);
      session.on("close", () => this.deleteSession(url3, session));
      if (connectionConfiguration.requestTimeout) {
        session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
      }
      const connectionPool = this.sessionCache.get(url3) || new node_http2_connection_pool_1.NodeHttp2ConnectionPool;
      connectionPool.offerLast(session);
      this.sessionCache.set(url3, connectionPool);
      return session;
    }
    deleteSession(authority, session) {
      const existingConnectionPool = this.sessionCache.get(authority);
      if (!existingConnectionPool) {
        return;
      }
      if (!existingConnectionPool.contains(session)) {
        return;
      }
      existingConnectionPool.remove(session);
      this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
      var _a;
      const cacheKey = this.getUrlString(requestContext);
      (_a = this.sessionCache.get(cacheKey)) === null || _a === undefined || _a.offerLast(session);
    }
    destroy() {
      for (const [key, connectionPool] of this.sessionCache) {
        for (const session of connectionPool) {
          if (!session.destroyed) {
            session.destroy();
          }
          connectionPool.remove(session);
        }
        this.sessionCache.delete(key);
      }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrentStreams must be greater than zero.");
      }
      this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
      this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
      return request.destination.toString();
    }
  }
  exports.NodeHttp2ConnectionManager = NodeHttp2ConnectionManager;
});

// node_modules/@smithy/node-http-handler/dist-cjs/node-http2-handler.js
var require_node_http2_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeHttp2Handler = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var querystring_builder_1 = require_dist_cjs13();
  var http2_1 = __require("http2");
  var get_transformed_headers_1 = require_get_transformed_headers();
  var node_http2_connection_manager_1 = require_node_http2_connection_manager();
  var write_request_body_1 = require_write_request_body();

  class NodeHttp2Handler {
    constructor(options5) {
      this.metadata = { handlerProtocol: "h2" };
      this.connectionManager = new node_http2_connection_manager_1.NodeHttp2ConnectionManager({});
      this.configProvider = new Promise((resolve, reject) => {
        if (typeof options5 === "function") {
          options5().then((opts) => {
            resolve(opts || {});
          }).catch(reject);
        } else {
          resolve(options5 || {});
        }
      });
    }
    destroy() {
      this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
        if (this.config.maxConcurrentStreams) {
          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
        }
      }
      const { requestTimeout, disableConcurrentStreams } = this.config;
      return new Promise((_resolve, _reject) => {
        var _a, _b, _c;
        let fulfilled = false;
        let writeRequestBodyPromise = undefined;
        const resolve = async (arg) => {
          await writeRequestBodyPromise;
          _resolve(arg);
        };
        const reject = async (arg) => {
          await writeRequestBodyPromise;
          _reject(arg);
        };
        if (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted) {
          fulfilled = true;
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const { hostname, method, port, protocol: protocol4, query } = request;
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = (_a = request.username) !== null && _a !== undefined ? _a : "";
          const password = (_b = request.password) !== null && _b !== undefined ? _b : "";
          auth = `${username}:${password}@`;
        }
        const authority = `${protocol4}//${auth}${hostname}${port ? `:${port}` : ""}`;
        const requestContext = { destination: new URL(authority) };
        const session = this.connectionManager.lease(requestContext, {
          requestTimeout: (_c = this.config) === null || _c === undefined ? undefined : _c.sessionTimeout,
          disableConcurrentStreams: disableConcurrentStreams || false
        });
        const rejectWithDestroy = (err) => {
          if (disableConcurrentStreams) {
            this.destroySession(session);
          }
          fulfilled = true;
          reject(err);
        };
        const queryString = (0, querystring_builder_1.buildQueryString)(query || {});
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        const req = session.request({
          ...request.headers,
          [http2_1.constants.HTTP2_HEADER_PATH]: path,
          [http2_1.constants.HTTP2_HEADER_METHOD]: method
        });
        session.ref();
        req.on("response", (headers) => {
          const httpResponse = new protocol_http_1.HttpResponse({
            statusCode: headers[":status"] || -1,
            headers: (0, get_transformed_headers_1.getTransformedHeaders)(headers),
            body: req
          });
          fulfilled = true;
          resolve({ response: httpResponse });
          if (disableConcurrentStreams) {
            session.close();
            this.connectionManager.deleteSession(authority, session);
          }
        });
        if (requestTimeout) {
          req.setTimeout(requestTimeout, () => {
            req.close();
            const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
            timeoutError.name = "TimeoutError";
            rejectWithDestroy(timeoutError);
          });
        }
        if (abortSignal) {
          abortSignal.onabort = () => {
            req.close();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            rejectWithDestroy(abortError);
          };
        }
        req.on("frameError", (type, code, id) => {
          rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
        });
        req.on("error", rejectWithDestroy);
        req.on("aborted", () => {
          rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
        });
        req.on("close", () => {
          session.unref();
          if (disableConcurrentStreams) {
            session.destroy();
          }
          if (!fulfilled) {
            rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
          }
        });
        writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, requestTimeout);
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        return {
          ...config,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      var _a;
      return (_a = this.config) !== null && _a !== undefined ? _a : {};
    }
    destroySession(session) {
      if (!session.destroyed) {
        session.destroy();
      }
    }
  }
  exports.NodeHttp2Handler = NodeHttp2Handler;
});

// node_modules/@smithy/node-http-handler/dist-cjs/stream-collector/collector.js
var require_collector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Collector = undefined;
  var stream_1 = __require("stream");

  class Collector extends stream_1.Writable {
    constructor() {
      super(...arguments);
      this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  }
  exports.Collector = Collector;
});

// node_modules/@smithy/node-http-handler/dist-cjs/stream-collector/index.js
var require_stream_collector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.streamCollector = undefined;
  var collector_1 = require_collector();
  var streamCollector = (stream3) => new Promise((resolve, reject) => {
    const collector = new collector_1.Collector;
    stream3.pipe(collector);
    stream3.on("error", (err) => {
      collector.end();
      reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function() {
      const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
      resolve(bytes);
    });
  });
  exports.streamCollector = streamCollector;
});

// node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_node_http_handler(), exports);
  tslib_1.__exportStar(require_node_http2_handler(), exports);
  tslib_1.__exportStar(require_stream_collector(), exports);
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var node_http_handler_1 = require_dist_cjs14();
  var util_buffer_from_1 = require_dist_cjs9();
  var stream_1 = __require("stream");
  var util_1 = __require("util");
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin = (stream3) => {
    var _a, _b;
    if (!(stream3 instanceof stream_1.Readable)) {
      const name = ((_b = (_a = stream3 === null || stream3 === undefined ? undefined : stream3.__proto__) === null || _a === undefined ? undefined : _a.constructor) === null || _b === undefined ? undefined : _b.name) || stream3;
      throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, node_http_handler_1.streamCollector)(stream3);
    };
    return Object.assign(stream3, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === undefined || Buffer.isEncoding(encoding)) {
          return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
        } else {
          const decoder = new util_1.TextDecoder(encoding);
          return decoder.decode(buf);
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        if (stream3.readableFlowing !== null) {
          throw new Error("The stream has been consumed by other callbacks.");
        }
        if (typeof stream_1.Readable.toWeb !== "function") {
          throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
        }
        transformed = true;
        return stream_1.Readable.toWeb(stream3);
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin;
});

// node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_Uint8ArrayBlobAdapter(), exports);
  tslib_1.__exportStar(require_getAwsChunkedEncodingStream(), exports);
  tslib_1.__exportStar(require_sdk_stream_mixin(), exports);
});

// node_modules/@smithy/smithy-client/dist-cjs/collect-stream-body.js
var require_collect_stream_body = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.collectBody = undefined;
  var util_stream_1 = require_dist_cjs15();
  var collectBody = async (streamBody = new Uint8Array, context) => {
    if (streamBody instanceof Uint8Array) {
      return util_stream_1.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return util_stream_1.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
    }
    const fromContext = context.streamCollector(streamBody);
    return util_stream_1.Uint8ArrayBlobAdapter.mutate(await fromContext);
  };
  exports.collectBody = collectBody;
});

// node_modules/@smithy/smithy-client/dist-cjs/command.js
var require_command3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Command = undefined;
  var middleware_stack_1 = require_dist_cjs7();

  class Command2 {
    constructor() {
      this.middlewareStack = (0, middleware_stack_1.constructStack)();
    }
  }
  exports.Command = Command2;
});

// node_modules/@smithy/smithy-client/dist-cjs/constants.js
var require_constants4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SENSITIVE_STRING = undefined;
  exports.SENSITIVE_STRING = "***SensitiveInformation***";
});

// node_modules/@smithy/smithy-client/dist-cjs/create-aggregated-client.js
var require_create_aggregated_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createAggregatedClient = undefined;
  var createAggregatedClient = (commands, Client) => {
    for (const command of Object.keys(commands)) {
      const CommandCtor = commands[command];
      const methodImpl = async function(args, optionsOrCb, cb) {
        const command2 = new CommandCtor(args);
        if (typeof optionsOrCb === "function") {
          this.send(command2, optionsOrCb);
        } else if (typeof cb === "function") {
          if (typeof optionsOrCb !== "object")
            throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
          this.send(command2, optionsOrCb || {}, cb);
        } else {
          return this.send(command2, optionsOrCb);
        }
      };
      const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
      Client.prototype[methodName] = methodImpl;
    }
  };
  exports.createAggregatedClient = createAggregatedClient;
});

// node_modules/@smithy/smithy-client/dist-cjs/parse-utils.js
var require_parse_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = undefined;
  var parseBoolean = (value) => {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value}"`);
    }
  };
  exports.parseBoolean = parseBoolean;
  var expectBoolean = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "number") {
      if (value === 0 || value === 1) {
        exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (value === 0) {
        return false;
      }
      if (value === 1) {
        return true;
      }
    }
    if (typeof value === "string") {
      const lower = value.toLowerCase();
      if (lower === "false" || lower === "true") {
        exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (lower === "false") {
        return false;
      }
      if (lower === "true") {
        return true;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
  };
  exports.expectBoolean = expectBoolean;
  var expectNumber = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value)) {
          exports.logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
        }
        return parsed;
      }
    }
    if (typeof value === "number") {
      return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
  };
  exports.expectNumber = expectNumber;
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = (value) => {
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== (-Infinity)) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value}`);
      }
    }
    return expected;
  };
  exports.expectFloat32 = expectFloat32;
  var expectLong = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
      return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
  };
  exports.expectLong = expectLong;
  exports.expectInt = exports.expectLong;
  var expectInt32 = (value) => expectSizedInt(value, 32);
  exports.expectInt32 = expectInt32;
  var expectShort = (value) => expectSizedInt(value, 16);
  exports.expectShort = expectShort;
  var expectByte = (value) => expectSizedInt(value, 8);
  exports.expectByte = expectByte;
  var expectSizedInt = (value, size) => {
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
      throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
  };
  var castInt = (value, size) => {
    switch (size) {
      case 32:
        return Int32Array.of(value)[0];
      case 16:
        return Int16Array.of(value)[0];
      case 8:
        return Int8Array.of(value)[0];
    }
  };
  var expectNonNull = (value, location2) => {
    if (value === null || value === undefined) {
      if (location2) {
        throw new TypeError(`Expected a non-null value for ${location2}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value;
  };
  exports.expectNonNull = expectNonNull;
  var expectObject = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
      return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
  };
  exports.expectObject = expectObject;
  var expectString = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
      exports.logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
      return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
  };
  exports.expectString = expectString;
  var expectUnion = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    const asObject = (0, exports.expectObject)(value);
    const setKeys = Object.entries(asObject).filter(([, v]) => v != null).map(([k]) => k);
    if (setKeys.length === 0) {
      throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
      throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
  };
  exports.expectUnion = expectUnion;
  var strictParseDouble = (value) => {
    if (typeof value == "string") {
      return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
  };
  exports.strictParseDouble = strictParseDouble;
  exports.strictParseFloat = exports.strictParseDouble;
  var strictParseFloat32 = (value) => {
    if (typeof value == "string") {
      return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
  };
  exports.strictParseFloat32 = strictParseFloat32;
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
  };
  var limitedParseDouble = (value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
  };
  exports.limitedParseDouble = limitedParseDouble;
  exports.handleFloat = exports.limitedParseDouble;
  exports.limitedParseFloat = exports.limitedParseDouble;
  var limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
  };
  exports.limitedParseFloat32 = limitedParseFloat32;
  var parseFloatString = (value) => {
    switch (value) {
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return (-Infinity);
      default:
        throw new Error(`Unable to parse float value: ${value}`);
    }
  };
  var strictParseLong = (value) => {
    if (typeof value === "string") {
      return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
  };
  exports.strictParseLong = strictParseLong;
  exports.strictParseInt = exports.strictParseLong;
  var strictParseInt32 = (value) => {
    if (typeof value === "string") {
      return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
  };
  exports.strictParseInt32 = strictParseInt32;
  var strictParseShort = (value) => {
    if (typeof value === "string") {
      return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
  };
  exports.strictParseShort = strictParseShort;
  var strictParseByte = (value) => {
    if (typeof value === "string") {
      return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
  };
  exports.strictParseByte = strictParseByte;
  var stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s) => !s.includes("stackTraceWarning")).join("\n");
  };
  exports.logger = {
    warn: console.warn
  };
});

// node_modules/@smithy/smithy-client/dist-cjs/date-utils.js
var require_date_utils = __commonJS((exports) => {
  var dateToUtcString = function(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTimeWithOffset = exports.parseRfc3339DateTime = exports.dateToUtcString = undefined;
  var parse_utils_1 = require_parse_utils();
  var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  exports.dateToUtcString = dateToUtcString;
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  };
  exports.parseRfc3339DateTime = parseRfc3339DateTime;
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
  };
  exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
  var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
      const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
      const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
      }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
      const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
      return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
  };
  exports.parseRfc7231DateTime = parseRfc7231DateTime;
  var parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    let valueAsDouble;
    if (typeof value === "number") {
      valueAsDouble = value;
    } else if (typeof value === "string") {
      valueAsDouble = (0, parse_utils_1.strictParseDouble)(value);
    } else {
      throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === (-Infinity)) {
      throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
  };
  exports.parseEpochTimestamp = parseEpochTimestamp;
  var buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
  };
  var parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
      return valueInThisCentury + 100;
    }
    return valueInThisCentury;
  };
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  var adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
      return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
  };
  var parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
      throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
  };
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
      maxDays = 29;
    }
    if (day > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
  };
  var isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var parseDateValue = (value, type, lower, upper) => {
    const dateVal = (0, parse_utils_1.strictParseByte)(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
      throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
  };
  var parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
      return 0;
    }
    return (0, parse_utils_1.strictParseFloat32)("0." + value) * 1000;
  };
  var parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
  };
  var stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value;
    }
    return value.slice(idx);
  };
});

// node_modules/@smithy/smithy-client/dist-cjs/exceptions.js
var require_exceptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorateServiceException = exports.ServiceException = undefined;

  class ServiceException extends Error {
    constructor(options5) {
      super(options5.message);
      Object.setPrototypeOf(this, ServiceException.prototype);
      this.name = options5.name;
      this.$fault = options5.$fault;
      this.$metadata = options5.$metadata;
    }
  }
  exports.ServiceException = ServiceException;
  var decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions).filter(([, v]) => v !== undefined).forEach(([k, v]) => {
      if (exception[k] == undefined || exception[k] === "") {
        exception[k] = v;
      }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
  };
  exports.decorateServiceException = decorateServiceException;
});

// node_modules/@smithy/smithy-client/dist-cjs/default-error-handler.js
var require_default_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withBaseException = exports.throwDefaultError = undefined;
  var exceptions_1 = require_exceptions();
  var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response4 = new exceptionCtor({
      name: (parsedBody === null || parsedBody === undefined ? undefined : parsedBody.code) || (parsedBody === null || parsedBody === undefined ? undefined : parsedBody.Code) || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw (0, exceptions_1.decorateServiceException)(response4, parsedBody);
  };
  exports.throwDefaultError = throwDefaultError;
  var withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      (0, exports.throwDefaultError)({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  };
  exports.withBaseException = withBaseException;
  var deserializeMetadata = (output) => {
    var _a, _b;
    return {
      httpStatusCode: output.statusCode,
      requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== undefined ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== undefined ? _b : output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    };
  };
});

// node_modules/@smithy/smithy-client/dist-cjs/defaults-mode.js
var require_defaults_mode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadConfigsForDefaultMode = undefined;
  var loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
      case "standard":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "in-region":
        return {
          retryMode: "standard",
          connectionTimeout: 1100
        };
      case "cross-region":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "mobile":
        return {
          retryMode: "standard",
          connectionTimeout: 30000
        };
      default:
        return {};
    }
  };
  exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;
});

// node_modules/@smithy/smithy-client/dist-cjs/emitWarningIfUnsupportedVersion.js
var require_emitWarningIfUnsupportedVersion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.emitWarningIfUnsupportedVersion = undefined;
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
      warningEmitted = true;
    }
  };
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
});

// node_modules/@smithy/smithy-client/dist-cjs/extensions/checksum.js
var require_checksum3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveChecksumRuntimeConfig = exports.getChecksumConfiguration = exports.AlgorithmId = undefined;
  var types_1 = require_dist_cjs();
  Object.defineProperty(exports, "AlgorithmId", { enumerable: true, get: function() {
    return types_1.AlgorithmId;
  } });
  var getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types_1.AlgorithmId) {
      const algorithmId = types_1.AlgorithmId[id];
      if (runtimeConfig[algorithmId] === undefined) {
        continue;
      }
      checksumAlgorithms.push({
        algorithmId: () => algorithmId,
        checksumConstructor: () => runtimeConfig[algorithmId]
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  };
  exports.getChecksumConfiguration = getChecksumConfiguration;
  var resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  };
  exports.resolveChecksumRuntimeConfig = resolveChecksumRuntimeConfig;
});

// node_modules/@smithy/smithy-client/dist-cjs/extensions/retry.js
var require_retry2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRetryRuntimeConfig = exports.getRetryConfiguration = undefined;
  var getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
      setRetryStrategy(retryStrategy) {
        _retryStrategy = retryStrategy;
      },
      retryStrategy() {
        return _retryStrategy;
      }
    };
  };
  exports.getRetryConfiguration = getRetryConfiguration;
  var resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
  };
  exports.resolveRetryRuntimeConfig = resolveRetryRuntimeConfig;
});

// node_modules/@smithy/smithy-client/dist-cjs/extensions/defaultExtensionConfiguration.js
var require_defaultExtensionConfiguration2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveDefaultRuntimeConfig = exports.getDefaultClientConfiguration = exports.getDefaultExtensionConfiguration = undefined;
  var checksum_1 = require_checksum3();
  var retry_1 = require_retry2();
  var getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
      ...(0, checksum_1.getChecksumConfiguration)(runtimeConfig),
      ...(0, retry_1.getRetryConfiguration)(runtimeConfig)
    };
  };
  exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
  exports.getDefaultClientConfiguration = exports.getDefaultExtensionConfiguration;
  var resolveDefaultRuntimeConfig = (config) => {
    return {
      ...(0, checksum_1.resolveChecksumRuntimeConfig)(config),
      ...(0, retry_1.resolveRetryRuntimeConfig)(config)
    };
  };
  exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
});

// node_modules/@smithy/smithy-client/dist-cjs/extensions/index.js
var require_extensions3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_defaultExtensionConfiguration2(), exports);
});

// node_modules/@smithy/smithy-client/dist-cjs/extended-encode-uri-component.js
var require_extended_encode_uri_component = __commonJS((exports) => {
  var extendedEncodeURIComponent = function(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendedEncodeURIComponent = undefined;
  exports.extendedEncodeURIComponent = extendedEncodeURIComponent;
});

// node_modules/@smithy/smithy-client/dist-cjs/get-array-if-single-item.js
var require_get_array_if_single_item = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getArrayIfSingleItem = undefined;
  var getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
  exports.getArrayIfSingleItem = getArrayIfSingleItem;
});

// node_modules/@smithy/smithy-client/dist-cjs/get-value-from-text-node.js
var require_get_value_from_text_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getValueFromTextNode = undefined;
  var getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = (0, exports.getValueFromTextNode)(obj[key]);
      }
    }
    return obj;
  };
  exports.getValueFromTextNode = getValueFromTextNode;
});

// node_modules/@smithy/smithy-client/dist-cjs/lazy-json.js
var require_lazy_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LazyJsonString = exports.StringWrapper = undefined;
  var StringWrapper = function() {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor;
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
  };
  exports.StringWrapper = StringWrapper;
  exports.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
      value: exports.StringWrapper,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Object.setPrototypeOf(exports.StringWrapper, String);

  class LazyJsonString extends exports.StringWrapper {
    deserializeJSON() {
      return JSON.parse(super.toString());
    }
    toJSON() {
      return super.toString();
    }
    static fromObject(object) {
      if (object instanceof LazyJsonString) {
        return object;
      } else if (object instanceof String || typeof object === "string") {
        return new LazyJsonString(object);
      }
      return new LazyJsonString(JSON.stringify(object));
    }
  }
  exports.LazyJsonString = LazyJsonString;
});

// node_modules/@smithy/smithy-client/dist-cjs/object-mapping.js
var require_object_mapping = __commonJS((exports) => {
  var map2 = function(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.take = exports.convertMap = exports.map = undefined;
  exports.map = map2;
  var convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
      output[k] = [, v];
    }
    return output;
  };
  exports.convertMap = convertMap;
  var take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
      applyInstruction(out, source, instructions, key);
    }
    return out;
  };
  exports.take = take;
  var mapWithFilter = (target, filter, instructions) => {
    return map2(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
      if (Array.isArray(value)) {
        _instructions[key] = value;
      } else {
        if (typeof value === "function") {
          _instructions[key] = [filter, value()];
        } else {
          _instructions[key] = [filter, value];
        }
      }
      return _instructions;
    }, {}));
  };
  var applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter === undefined && (_value = value()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value();
      }
    } else {
      const defaultFilterPassed = filter === undefined && value != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value;
      }
    }
  };
  var nonNullish = (_) => _ != null;
  var pass = (_) => _;
});

// node_modules/@smithy/smithy-client/dist-cjs/resolve-path.js
var require_resolve_path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolvedPath = undefined;
  var extended_encode_uri_component_1 = require_extended_encode_uri_component();
  var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
      const labelValue = labelValueProvider();
      if (labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(segment)).join("/") : (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath2;
  };
  exports.resolvedPath = resolvedPath;
});

// node_modules/@smithy/smithy-client/dist-cjs/ser-utils.js
var require_ser_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializeFloat = undefined;
  var serializeFloat = (value) => {
    if (value !== value) {
      return "NaN";
    }
    switch (value) {
      case Infinity:
        return "Infinity";
      case (-Infinity):
        return "-Infinity";
      default:
        return value;
    }
  };
  exports.serializeFloat = serializeFloat;
});

// node_modules/@smithy/smithy-client/dist-cjs/serde-json.js
var require_serde_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._json = undefined;
  var _json = (obj) => {
    if (obj == null) {
      return {};
    }
    if (Array.isArray(obj)) {
      return obj.filter((_) => _ != null);
    }
    if (typeof obj === "object") {
      const target = {};
      for (const key of Object.keys(obj)) {
        if (obj[key] == null) {
          continue;
        }
        target[key] = (0, exports._json)(obj[key]);
      }
      return target;
    }
    return obj;
  };
  exports._json = _json;
});

// node_modules/@smithy/smithy-client/dist-cjs/split-every.js
var require_split_every = __commonJS((exports) => {
  var splitEvery = function(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
      throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
      return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i2 = 0;i2 < segments.length; i2++) {
      if (currentSegment === "") {
        currentSegment = segments[i2];
      } else {
        currentSegment += delimiter + segments[i2];
      }
      if ((i2 + 1) % numDelimiters === 0) {
        compoundSegments.push(currentSegment);
        currentSegment = "";
      }
    }
    if (currentSegment !== "") {
      compoundSegments.push(currentSegment);
    }
    return compoundSegments;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitEvery = undefined;
  exports.splitEvery = splitEvery;
});

// node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_NoOpLogger(), exports);
  tslib_1.__exportStar(require_client3(), exports);
  tslib_1.__exportStar(require_collect_stream_body(), exports);
  tslib_1.__exportStar(require_command3(), exports);
  tslib_1.__exportStar(require_constants4(), exports);
  tslib_1.__exportStar(require_create_aggregated_client(), exports);
  tslib_1.__exportStar(require_date_utils(), exports);
  tslib_1.__exportStar(require_default_error_handler(), exports);
  tslib_1.__exportStar(require_defaults_mode(), exports);
  tslib_1.__exportStar(require_emitWarningIfUnsupportedVersion(), exports);
  tslib_1.__exportStar(require_extensions3(), exports);
  tslib_1.__exportStar(require_exceptions(), exports);
  tslib_1.__exportStar(require_extended_encode_uri_component(), exports);
  tslib_1.__exportStar(require_get_array_if_single_item(), exports);
  tslib_1.__exportStar(require_get_value_from_text_node(), exports);
  tslib_1.__exportStar(require_lazy_json(), exports);
  tslib_1.__exportStar(require_object_mapping(), exports);
  tslib_1.__exportStar(require_parse_utils(), exports);
  tslib_1.__exportStar(require_resolve_path(), exports);
  tslib_1.__exportStar(require_ser_utils(), exports);
  tslib_1.__exportStar(require_serde_json(), exports);
  tslib_1.__exportStar(require_split_every(), exports);
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/check-content-length-header.js
var require_check_content_length_header = __commonJS((exports) => {
  var checkContentLengthHeader = function() {
    return (next, context) => async (args) => {
      var _a;
      const { request } = args;
      if (protocol_http_1.HttpRequest.isInstance(request)) {
        if (!request.headers[CONTENT_LENGTH_HEADER]) {
          const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
          if (typeof ((_a = context === null || context === undefined ? undefined : context.logger) === null || _a === undefined ? undefined : _a.warn) === "function" && !(context.logger instanceof smithy_client_1.NoOpLogger)) {
            context.logger.warn(message);
          } else {
            console.warn(message);
          }
        }
      }
      return next({ ...args });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCheckContentLengthHeaderPlugin = exports.checkContentLengthHeaderMiddlewareOptions = exports.checkContentLengthHeader = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var CONTENT_LENGTH_HEADER = "content-length";
  exports.checkContentLengthHeader = checkContentLengthHeader;
  exports.checkContentLengthHeaderMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["CHECK_CONTENT_LENGTH_HEADER"],
    name: "getCheckContentLengthHeaderPlugin",
    override: true
  };
  var getCheckContentLengthHeaderPlugin = (unused) => ({
    applyToStack: (clientStack) => {
      clientStack.add(checkContentLengthHeader(), exports.checkContentLengthHeaderMiddlewareOptions);
    }
  });
  exports.getCheckContentLengthHeaderPlugin = getCheckContentLengthHeaderPlugin;
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/region-redirect-endpoint-middleware.js
var require_region_redirect_endpoint_middleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regionRedirectEndpointMiddlewareOptions = exports.regionRedirectEndpointMiddleware = undefined;
  var regionRedirectEndpointMiddleware = (config) => {
    return (next, context) => async (args) => {
      const originalRegion = await config.region();
      const regionProviderRef = config.region;
      if (context.__s3RegionRedirect) {
        config.region = async () => {
          config.region = regionProviderRef;
          return context.__s3RegionRedirect;
        };
      }
      const result = await next(args);
      if (context.__s3RegionRedirect) {
        const region = await config.region();
        if (originalRegion !== region) {
          throw new Error("Region was not restored following S3 region redirect.");
        }
      }
      return result;
    };
  };
  exports.regionRedirectEndpointMiddleware = regionRedirectEndpointMiddleware;
  exports.regionRedirectEndpointMiddlewareOptions = {
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectEndpointMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/region-redirect-middleware.js
var require_region_redirect_middleware = __commonJS((exports) => {
  var regionRedirectMiddleware = function(clientConfig) {
    return (next, context) => async (args) => {
      var _a;
      try {
        return await next(args);
      } catch (err) {
        if (clientConfig.followRegionRedirects && err.$metadata.httpStatusCode === 301) {
          try {
            const actualRegion = err.$response.headers["x-amz-bucket-region"];
            (_a = context.logger) === null || _a === undefined || _a.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
            context.__s3RegionRedirect = actualRegion;
          } catch (e) {
            throw new Error("Region redirect failed: " + e);
          }
          return next(args);
        } else {
          throw err;
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRegionRedirectMiddlewarePlugin = exports.regionRedirectMiddlewareOptions = exports.regionRedirectMiddleware = undefined;
  var region_redirect_endpoint_middleware_1 = require_region_redirect_endpoint_middleware();
  exports.regionRedirectMiddleware = regionRedirectMiddleware;
  exports.regionRedirectMiddlewareOptions = {
    step: "initialize",
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectMiddleware",
    override: true
  };
  var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add(regionRedirectMiddleware(clientConfig), exports.regionRedirectMiddlewareOptions);
      clientStack.addRelativeTo((0, region_redirect_endpoint_middleware_1.regionRedirectEndpointMiddleware)(clientConfig), region_redirect_endpoint_middleware_1.regionRedirectEndpointMiddlewareOptions);
    }
  });
  exports.getRegionRedirectMiddlewarePlugin = getRegionRedirectMiddlewarePlugin;
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/s3Configuration.js
var require_s3Configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveS3Config = undefined;
  var resolveS3Config = (input) => {
    var _a, _b, _c, _d;
    return {
      ...input,
      forcePathStyle: (_a = input.forcePathStyle) !== null && _a !== undefined ? _a : false,
      useAccelerateEndpoint: (_b = input.useAccelerateEndpoint) !== null && _b !== undefined ? _b : false,
      disableMultiregionAccessPoints: (_c = input.disableMultiregionAccessPoints) !== null && _c !== undefined ? _c : false,
      followRegionRedirects: (_d = input.followRegionRedirects) !== null && _d !== undefined ? _d : false
    };
  };
  exports.resolveS3Config = resolveS3Config;
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/throw-200-exceptions.js
var require_throw_200_exceptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getThrow200ExceptionsPlugin = exports.throw200ExceptionsMiddlewareOptions = exports.throw200ExceptionsMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var throw200ExceptionsMiddleware = (config) => (next) => async (args) => {
    const result = await next(args);
    const { response: response4 } = result;
    if (!protocol_http_1.HttpResponse.isInstance(response4))
      return result;
    const { statusCode, body } = response4;
    if (statusCode < 200 || statusCode >= 300)
      return result;
    const bodyBytes = await collectBody(body, config);
    const bodyString = await collectBodyString(bodyBytes, config);
    if (bodyBytes.length === 0) {
      const err = new Error("S3 aborted request");
      err.name = "InternalError";
      throw err;
    }
    if (bodyString && bodyString.match("<Error>")) {
      response4.statusCode = 400;
    }
    response4.body = bodyBytes;
    return result;
  };
  exports.throw200ExceptionsMiddleware = throw200ExceptionsMiddleware;
  var collectBody = (streamBody = new Uint8Array, context) => {
    if (streamBody instanceof Uint8Array) {
      return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array);
  };
  var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
  exports.throw200ExceptionsMiddlewareOptions = {
    relation: "after",
    toMiddleware: "deserializerMiddleware",
    tags: ["THROW_200_EXCEPTIONS", "S3"],
    name: "throw200ExceptionsMiddleware",
    override: true
  };
  var getThrow200ExceptionsPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo((0, exports.throw200ExceptionsMiddleware)(config), exports.throw200ExceptionsMiddlewareOptions);
    }
  });
  exports.getThrow200ExceptionsPlugin = getThrow200ExceptionsPlugin;
});

// node_modules/@aws-sdk/util-arn-parser/dist-cjs/index.js
var require_dist_cjs17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = exports.parse = exports.validate = undefined;
  var validate3 = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
  exports.validate = validate3;
  var parse4 = (arn) => {
    const segments = arn.split(":");
    if (segments.length < 6 || segments[0] !== "arn")
      throw new Error("Malformed ARN");
    const [, partition, service, region, accountId, ...resource] = segments;
    return {
      partition,
      service,
      region,
      accountId,
      resource: resource.join(":")
    };
  };
  exports.parse = parse4;
  var build = (arnObject) => {
    const { partition = "aws", service, region, accountId, resource } = arnObject;
    if ([service, region, accountId, resource].some((segment) => typeof segment !== "string")) {
      throw new Error("Input ARN object is invalid");
    }
    return `arn:${partition}:${service}:${region}:${accountId}:${resource}`;
  };
  exports.build = build;
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/validate-bucket-name.js
var require_validate_bucket_name = __commonJS((exports) => {
  var validateBucketNameMiddleware = function() {
    return (next) => async (args) => {
      const { input: { Bucket } } = args;
      if (typeof Bucket === "string" && !(0, util_arn_parser_1.validate)(Bucket) && Bucket.indexOf("/") >= 0) {
        const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
        err.name = "InvalidBucketName";
        throw err;
      }
      return next({ ...args });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getValidateBucketNamePlugin = exports.validateBucketNameMiddlewareOptions = exports.validateBucketNameMiddleware = undefined;
  var util_arn_parser_1 = require_dist_cjs17();
  exports.validateBucketNameMiddleware = validateBucketNameMiddleware;
  exports.validateBucketNameMiddlewareOptions = {
    step: "initialize",
    tags: ["VALIDATE_BUCKET_NAME"],
    name: "validateBucketNameMiddleware",
    override: true
  };
  var getValidateBucketNamePlugin = (unused) => ({
    applyToStack: (clientStack) => {
      clientStack.add(validateBucketNameMiddleware(), exports.validateBucketNameMiddlewareOptions);
    }
  });
  exports.getValidateBucketNamePlugin = getValidateBucketNamePlugin;
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/index.js
var require_dist_cjs18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_check_content_length_header(), exports);
  tslib_1.__exportStar(require_region_redirect_endpoint_middleware(), exports);
  tslib_1.__exportStar(require_region_redirect_middleware(), exports);
  tslib_1.__exportStar(require_s3Configuration(), exports);
  tslib_1.__exportStar(require_throw_200_exceptions(), exports);
  tslib_1.__exportStar(require_validate_bucket_name(), exports);
});

// node_modules/@smithy/property-provider/dist-cjs/ProviderError.js
var require_ProviderError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProviderError = undefined;

  class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
      super(message);
      this.tryNextLink = tryNextLink;
      this.name = "ProviderError";
      Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
      return Object.assign(new this(error.message, tryNextLink), error);
    }
  }
  exports.ProviderError = ProviderError;
});

// node_modules/@smithy/property-provider/dist-cjs/CredentialsProviderError.js
var require_CredentialsProviderError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CredentialsProviderError = undefined;
  var ProviderError_1 = require_ProviderError();

  class CredentialsProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
      super(message, tryNextLink);
      this.tryNextLink = tryNextLink;
      this.name = "CredentialsProviderError";
      Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
  }
  exports.CredentialsProviderError = CredentialsProviderError;
});

// node_modules/@smithy/property-provider/dist-cjs/TokenProviderError.js
var require_TokenProviderError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenProviderError = undefined;
  var ProviderError_1 = require_ProviderError();

  class TokenProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
      super(message, tryNextLink);
      this.tryNextLink = tryNextLink;
      this.name = "TokenProviderError";
      Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
  }
  exports.TokenProviderError = TokenProviderError;
});

// node_modules/@smithy/property-provider/dist-cjs/chain.js
var require_chain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chain = undefined;
  var ProviderError_1 = require_ProviderError();
  var chain = (...providers) => async () => {
    if (providers.length === 0) {
      throw new ProviderError_1.ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
      try {
        const credentials = await provider();
        return credentials;
      } catch (err) {
        lastProviderError = err;
        if (err === null || err === undefined ? undefined : err.tryNextLink) {
          continue;
        }
        throw err;
      }
    }
    throw lastProviderError;
  };
  exports.chain = chain;
});

// node_modules/@smithy/property-provider/dist-cjs/fromStatic.js
var require_fromStatic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromStatic = undefined;
  var fromStatic = (staticValue) => () => Promise.resolve(staticValue);
  exports.fromStatic = fromStatic;
});

// node_modules/@smithy/property-provider/dist-cjs/memoize.js
var require_memoize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.memoize = undefined;
  var memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
      if (!pending) {
        pending = provider();
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    };
    if (isExpired === undefined) {
      return async (options5) => {
        if (!hasResult || (options5 === null || options5 === undefined ? undefined : options5.forceRefresh)) {
          resolved = await coalesceProvider();
        }
        return resolved;
      };
    }
    return async (options5) => {
      if (!hasResult || (options5 === null || options5 === undefined ? undefined : options5.forceRefresh)) {
        resolved = await coalesceProvider();
      }
      if (isConstant) {
        return resolved;
      }
      if (requiresRefresh && !requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider();
        return resolved;
      }
      return resolved;
    };
  };
  exports.memoize = memoize;
});

// node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_CredentialsProviderError(), exports);
  tslib_1.__exportStar(require_ProviderError(), exports);
  tslib_1.__exportStar(require_TokenProviderError(), exports);
  tslib_1.__exportStar(require_chain(), exports);
  tslib_1.__exportStar(require_fromStatic(), exports);
  tslib_1.__exportStar(require_memoize(), exports);
});

// node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS((exports, module) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __createBinding;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i2 = 1, n = arguments.length;i2 < n; i2++) {
        s = arguments[i2];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
          if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
            t[p[i2]] = s[p[i2]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d = decorators[i2])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __createBinding = function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __exportStar = function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = undefined;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k = 0, i2 = 0;i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n) {
        if (g[n])
          i2[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i2, p;
      return i2 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n, f) {
        i2[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i2;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet2 = function(receiver2, privateMap) {
      if (!privateMap.has(receiver2)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver2);
    };
    __classPrivateFieldSet2 = function(receiver2, privateMap, value) {
      if (!privateMap.has(receiver2)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver2, value);
      return value;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
  });
});

// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
var require_pureJs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUtf8 = exports.fromUtf8 = undefined;
  var fromUtf8 = (input) => {
    const bytes = [];
    for (let i2 = 0, len = input.length;i2 < len; i2++) {
      const value = input.charCodeAt(i2);
      if (value < 128) {
        bytes.push(value);
      } else if (value < 2048) {
        bytes.push(value >> 6 | 192, value & 63 | 128);
      } else if (i2 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i2 + 1) & 64512) === 56320) {
        const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i2) & 1023);
        bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
      } else {
        bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
      }
    }
    return Uint8Array.from(bytes);
  };
  exports.fromUtf8 = fromUtf8;
  var toUtf8 = (input) => {
    let decoded = "";
    for (let i2 = 0, len = input.length;i2 < len; i2++) {
      const byte = input[i2];
      if (byte < 128) {
        decoded += String.fromCharCode(byte);
      } else if (192 <= byte && byte < 224) {
        const nextByte = input[++i2];
        decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
      } else if (240 <= byte && byte < 365) {
        const surrogatePair = [byte, input[++i2], input[++i2], input[++i2]];
        const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
        decoded += decodeURIComponent(encoded);
      } else {
        decoded += String.fromCharCode((byte & 15) << 12 | (input[++i2] & 63) << 6 | input[++i2] & 63);
      }
    }
    return decoded;
  };
  exports.toUtf8 = toUtf8;
});

// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
var require_whatwgEncodingApi = __commonJS((exports) => {
  var fromUtf8 = function(input) {
    return new TextEncoder().encode(input);
  };
  var toUtf8 = function(input) {
    return new TextDecoder("utf-8").decode(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUtf8 = exports.fromUtf8 = undefined;
  exports.fromUtf8 = fromUtf8;
  exports.toUtf8 = toUtf8;
});

// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
var require_dist_cjs20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUtf8 = exports.fromUtf8 = undefined;
  var pureJs_1 = require_pureJs();
  var whatwgEncodingApi_1 = require_whatwgEncodingApi();
  var fromUtf8 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
  exports.fromUtf8 = fromUtf8;
  var toUtf8 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
  exports.toUtf8 = toUtf8;
});

// node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS((exports) => {
  var convertToBuffer = function(data) {
    if (data instanceof Uint8Array)
      return data;
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertToBuffer = undefined;
  var util_utf8_browser_1 = require_dist_cjs20();
  var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
    return Buffer.from(input, "utf8");
  } : util_utf8_browser_1.fromUtf8;
  exports.convertToBuffer = convertToBuffer;
});

// node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData = __commonJS((exports) => {
  var isEmptyData = function(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmptyData = undefined;
  exports.isEmptyData = isEmptyData;
});

// node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS((exports) => {
  var numToUint8 = function(num) {
    return new Uint8Array([
      (num & 4278190080) >> 24,
      (num & 16711680) >> 16,
      (num & 65280) >> 8,
      num & 255
    ]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.numToUint8 = undefined;
  exports.numToUint8 = numToUint8;
});

// node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS((exports) => {
  var uint32ArrayFrom = function(a_lookUpTable) {
    if (!Uint32Array.from) {
      var return_array = new Uint32Array(a_lookUpTable.length);
      var a_index = 0;
      while (a_index < a_lookUpTable.length) {
        return_array[a_index] = a_lookUpTable[a_index];
        a_index += 1;
      }
      return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint32ArrayFrom = undefined;
  exports.uint32ArrayFrom = uint32ArrayFrom;
});

// node_modules/@aws-crypto/util/build/index.js
var require_build = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = undefined;
  var convertToBuffer_1 = require_convertToBuffer();
  Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
    return convertToBuffer_1.convertToBuffer;
  } });
  var isEmptyData_1 = require_isEmptyData();
  Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
    return isEmptyData_1.isEmptyData;
  } });
  var numToUint8_1 = require_numToUint8();
  Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
    return numToUint8_1.numToUint8;
  } });
  var uint32ArrayFrom_1 = require_uint32ArrayFrom();
  Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
    return uint32ArrayFrom_1.uint32ArrayFrom;
  } });
});

// node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32 = undefined;
  var tslib_1 = require_tslib2();
  var util_1 = require_build();
  var index_1 = require_build2();
  var AwsCrc32 = function() {
    function AwsCrc322() {
      this.crc32 = new index_1.Crc32;
    }
    AwsCrc322.prototype.update = function(toHash) {
      if ((0, util_1.isEmptyData)(toHash))
        return;
      this.crc32.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc322.prototype.digest = function() {
      return tslib_1.__awaiter(this, undefined, undefined, function() {
        return tslib_1.__generator(this, function(_a) {
          return [2, (0, util_1.numToUint8)(this.crc32.digest())];
        });
      });
    };
    AwsCrc322.prototype.reset = function() {
      this.crc32 = new index_1.Crc32;
    };
    return AwsCrc322;
  }();
  exports.AwsCrc32 = AwsCrc32;
});

// node_modules/@aws-crypto/crc32/build/index.js
var require_build2 = __commonJS((exports) => {
  var crc32 = function(data) {
    return new Crc32().update(data).digest();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32 = exports.Crc32 = exports.crc32 = undefined;
  var tslib_1 = require_tslib2();
  var util_1 = require_build();
  exports.crc32 = crc32;
  var Crc32 = function() {
    function Crc322() {
      this.checksum = 4294967295;
    }
    Crc322.prototype.update = function(data) {
      var e_1, _a;
      try {
        for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
          var byte = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a = data_1.return))
            _a.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc322.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc322;
  }();
  exports.Crc32 = Crc32;
  var a_lookUpTable = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
  var aws_crc32_1 = require_aws_crc32();
  Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
    return aws_crc32_1.AwsCrc32;
  } });
});

// node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs21 = __commonJS((exports) => {
  var fromHex = function(encoded) {
    if (encoded.length % 2 !== 0) {
      throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i2 = 0;i2 < encoded.length; i2 += 2) {
      const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
      if (encodedByte in HEX_TO_SHORT) {
        out[i2 / 2] = HEX_TO_SHORT[encodedByte];
      } else {
        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
      }
    }
    return out;
  };
  var toHex = function(bytes) {
    let out = "";
    for (let i2 = 0;i2 < bytes.byteLength; i2++) {
      out += SHORT_TO_HEX[bytes[i2]];
    }
    return out;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toHex = exports.fromHex = undefined;
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i2 = 0;i2 < 256; i2++) {
    let encodedByte = i2.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i2] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i2;
  }
  exports.fromHex = fromHex;
  exports.toHex = toHex;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/Int64.js
var require_Int64 = __commonJS((exports) => {
  var negate = function(bytes) {
    for (let i2 = 0;i2 < 8; i2++) {
      bytes[i2] ^= 255;
    }
    for (let i2 = 7;i2 > -1; i2--) {
      bytes[i2]++;
      if (bytes[i2] !== 0)
        break;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Int64 = undefined;
  var util_hex_encoding_1 = require_dist_cjs21();

  class Int64 {
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number) {
      if (number > 9223372036854776000 || number < -9223372036854776000) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i2 = 7, remaining = Math.abs(Math.round(number));i2 > -1 && remaining > 0; i2--, remaining /= 256) {
        bytes[i2] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int64(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt((0, util_hex_encoding_1.toHex)(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  }
  exports.Int64 = Int64;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/HeaderMarshaller.js
var require_HeaderMarshaller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HeaderMarshaller = undefined;
  var util_hex_encoding_1 = require_dist_cjs21();
  var Int64_1 = require_Int64();

  class HeaderMarshaller {
    constructor(toUtf8, fromUtf8) {
      this.toUtf8 = toUtf8;
      this.fromUtf8 = fromUtf8;
    }
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = this.fromUtf8(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = this.fromUtf8(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int64_1.Int64.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set((0, util_hex_encoding_1.fromHex)(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
    parse(headers) {
      const out = {};
      let position = 0;
      while (position < headers.byteLength) {
        const nameLength = headers.getUint8(position++);
        const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
        position += nameLength;
        switch (headers.getUint8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.getInt8(position++)
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.getInt16(position, false)
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.getInt32(position, false)
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
            };
            position += 8;
            break;
          case 6:
            const binaryLength = headers.getUint16(position, false);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
            };
            position += binaryLength;
            break;
          case 7:
            const stringLength = headers.getUint16(position, false);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
            };
            position += 8;
            break;
          case 9:
            const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: `${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(0, 4))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(4, 6))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(6, 8))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(8, 10))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(10))}`
            };
            break;
          default:
            throw new Error(`Unrecognized header type tag`);
        }
      }
      return out;
    }
  }
  exports.HeaderMarshaller = HeaderMarshaller;
  var HEADER_VALUE_TYPE;
  (function(HEADER_VALUE_TYPE2) {
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
  })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
  var BOOLEAN_TAG = "boolean";
  var BYTE_TAG = "byte";
  var SHORT_TAG = "short";
  var INT_TAG = "integer";
  var LONG_TAG = "long";
  var BINARY_TAG = "binary";
  var STRING_TAG = "string";
  var TIMESTAMP_TAG = "timestamp";
  var UUID_TAG = "uuid";
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/splitMessage.js
var require_splitMessage = __commonJS((exports) => {
  var splitMessage = function({ byteLength: byteLength2, byteOffset, buffer }) {
    if (byteLength2 < MINIMUM_MESSAGE_LENGTH) {
      throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength2);
    const messageLength = view.getUint32(0, false);
    if (byteLength2 !== messageLength) {
      throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength2 - CHECKSUM_LENGTH, false);
    const checksummer = new crc32_1.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
      throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength2 - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
      throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
      headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
      body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitMessage = undefined;
  var crc32_1 = require_build2();
  var PRELUDE_MEMBER_LENGTH = 4;
  var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
  var CHECKSUM_LENGTH = 4;
  var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  exports.splitMessage = splitMessage;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/EventStreamCodec.js
var require_EventStreamCodec = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventStreamCodec = undefined;
  var crc32_1 = require_build2();
  var HeaderMarshaller_1 = require_HeaderMarshaller();
  var splitMessage_1 = require_splitMessage();

  class EventStreamCodec {
    constructor(toUtf8, fromUtf8) {
      this.headerMarshaller = new HeaderMarshaller_1.HeaderMarshaller(toUtf8, fromUtf8);
      this.messageBuffer = [];
      this.isEndOfStream = false;
    }
    feed(message) {
      this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
      this.isEndOfStream = true;
    }
    getMessage() {
      const message = this.messageBuffer.pop();
      const isEndOfStream = this.isEndOfStream;
      return {
        getMessage() {
          return message;
        },
        isEndOfStream() {
          return isEndOfStream;
        }
      };
    }
    getAvailableMessages() {
      const messages = this.messageBuffer;
      this.messageBuffer = [];
      const isEndOfStream = this.isEndOfStream;
      return {
        getMessages() {
          return messages;
        },
        isEndOfStream() {
          return isEndOfStream;
        }
      };
    }
    encode({ headers: rawHeaders, body }) {
      const headers = this.headerMarshaller.format(rawHeaders);
      const length2 = headers.byteLength + body.byteLength + 16;
      const out = new Uint8Array(length2);
      const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      const checksum = new crc32_1.Crc32;
      view.setUint32(0, length2, false);
      view.setUint32(4, headers.byteLength, false);
      view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
      out.set(headers, 12);
      out.set(body, headers.byteLength + 12);
      view.setUint32(length2 - 4, checksum.update(out.subarray(8, length2 - 4)).digest(), false);
      return out;
    }
    decode(message) {
      const { headers, body } = (0, splitMessage_1.splitMessage)(message);
      return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
      return this.headerMarshaller.format(rawHeaders);
    }
  }
  exports.EventStreamCodec = EventStreamCodec;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/Message.js
var require_Message = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/eventstream-codec/dist-cjs/MessageDecoderStream.js
var require_MessageDecoderStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageDecoderStream = undefined;

  class MessageDecoderStream {
    constructor(options5) {
      this.options = options5;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const bytes of this.options.inputStream) {
        const decoded = this.options.decoder.decode(bytes);
        yield decoded;
      }
    }
  }
  exports.MessageDecoderStream = MessageDecoderStream;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/MessageEncoderStream.js
var require_MessageEncoderStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageEncoderStream = undefined;

  class MessageEncoderStream {
    constructor(options5) {
      this.options = options5;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const msg of this.options.messageStream) {
        const encoded = this.options.encoder.encode(msg);
        yield encoded;
      }
      if (this.options.includeEndFrame) {
        yield new Uint8Array(0);
      }
    }
  }
  exports.MessageEncoderStream = MessageEncoderStream;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/SmithyMessageDecoderStream.js
var require_SmithyMessageDecoderStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SmithyMessageDecoderStream = undefined;

  class SmithyMessageDecoderStream {
    constructor(options5) {
      this.options = options5;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const message of this.options.messageStream) {
        const deserialized = await this.options.deserializer(message);
        if (deserialized === undefined)
          continue;
        yield deserialized;
      }
    }
  }
  exports.SmithyMessageDecoderStream = SmithyMessageDecoderStream;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/SmithyMessageEncoderStream.js
var require_SmithyMessageEncoderStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SmithyMessageEncoderStream = undefined;

  class SmithyMessageEncoderStream {
    constructor(options5) {
      this.options = options5;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const chunk of this.options.inputStream) {
        const payloadBuf = this.options.serializer(chunk);
        yield payloadBuf;
      }
    }
  }
  exports.SmithyMessageEncoderStream = SmithyMessageEncoderStream;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/index.js
var require_dist_cjs22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EventStreamCodec(), exports);
  tslib_1.__exportStar(require_HeaderMarshaller(), exports);
  tslib_1.__exportStar(require_Int64(), exports);
  tslib_1.__exportStar(require_Message(), exports);
  tslib_1.__exportStar(require_MessageDecoderStream(), exports);
  tslib_1.__exportStar(require_MessageEncoderStream(), exports);
  tslib_1.__exportStar(require_SmithyMessageDecoderStream(), exports);
  tslib_1.__exportStar(require_SmithyMessageEncoderStream(), exports);
});

// node_modules/@smithy/util-middleware/dist-cjs/getSmithyContext.js
var require_getSmithyContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSmithyContext = undefined;
  var types_1 = require_dist_cjs();
  var getSmithyContext = (context) => context[types_1.SMITHY_CONTEXT_KEY] || (context[types_1.SMITHY_CONTEXT_KEY] = {});
  exports.getSmithyContext = getSmithyContext;
});

// node_modules/@smithy/util-middleware/dist-cjs/normalizeProvider.js
var require_normalizeProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizeProvider = undefined;
  var normalizeProvider = (input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  };
  exports.normalizeProvider = normalizeProvider;
});

// node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs23 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_getSmithyContext(), exports);
  tslib_1.__exportStar(require_normalizeProvider(), exports);
});

// node_modules/@smithy/signature-v4/dist-cjs/constants.js
var require_constants5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MAX_PRESIGNED_TTL = exports.KEY_TYPE_IDENTIFIER = exports.MAX_CACHE_SIZE = exports.UNSIGNED_PAYLOAD = exports.EVENT_ALGORITHM_IDENTIFIER = exports.ALGORITHM_IDENTIFIER_V4A = exports.ALGORITHM_IDENTIFIER = exports.UNSIGNABLE_PATTERNS = exports.SEC_HEADER_PATTERN = exports.PROXY_HEADER_PATTERN = exports.ALWAYS_UNSIGNABLE_HEADERS = exports.HOST_HEADER = exports.TOKEN_HEADER = exports.SHA256_HEADER = exports.SIGNATURE_HEADER = exports.GENERATED_HEADERS = exports.DATE_HEADER = exports.AMZ_DATE_HEADER = exports.AUTH_HEADER = exports.REGION_SET_PARAM = exports.TOKEN_QUERY_PARAM = exports.SIGNATURE_QUERY_PARAM = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = undefined;
  exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  exports.SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  exports.TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  exports.REGION_SET_PARAM = "X-Amz-Region-Set";
  exports.AUTH_HEADER = "authorization";
  exports.AMZ_DATE_HEADER = exports.AMZ_DATE_QUERY_PARAM.toLowerCase();
  exports.DATE_HEADER = "date";
  exports.GENERATED_HEADERS = [exports.AUTH_HEADER, exports.AMZ_DATE_HEADER, exports.DATE_HEADER];
  exports.SIGNATURE_HEADER = exports.SIGNATURE_QUERY_PARAM.toLowerCase();
  exports.SHA256_HEADER = "x-amz-content-sha256";
  exports.TOKEN_HEADER = exports.TOKEN_QUERY_PARAM.toLowerCase();
  exports.HOST_HEADER = "host";
  exports.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
  };
  exports.PROXY_HEADER_PATTERN = /^proxy-/;
  exports.SEC_HEADER_PATTERN = /^sec-/;
  exports.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
  exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
  exports.ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
  exports.EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
  exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  exports.MAX_CACHE_SIZE = 50;
  exports.KEY_TYPE_IDENTIFIER = "aws4_request";
  exports.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
});

// node_modules/@smithy/signature-v4/dist-cjs/credentialDerivation.js
var require_credentialDerivation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.clearCredentialCache = exports.getSigningKey = exports.createScope = undefined;
  var util_hex_encoding_1 = require_dist_cjs21();
  var util_utf8_1 = require_dist_cjs11();
  var constants_1 = require_constants5();
  var signingKeyCache = {};
  var cacheQueue = [];
  var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
  exports.createScope = createScope;
  var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
      return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
      delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {
      key = await hmac(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
  };
  exports.getSigningKey = getSigningKey;
  var clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
      delete signingKeyCache[cacheKey];
    });
  };
  exports.clearCredentialCache = clearCredentialCache;
  var hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update((0, util_utf8_1.toUint8Array)(data));
    return hash.digest();
  };
});

// node_modules/@smithy/signature-v4/dist-cjs/getCanonicalHeaders.js
var require_getCanonicalHeaders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCanonicalHeaders = undefined;
  var constants_1 = require_constants5();
  var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
      if (headers[headerName] == undefined) {
        continue;
      }
      const canonicalHeaderName = headerName.toLowerCase();
      if ((canonicalHeaderName in constants_1.ALWAYS_UNSIGNABLE_HEADERS) || (unsignableHeaders === null || unsignableHeaders === undefined ? undefined : unsignableHeaders.has(canonicalHeaderName)) || constants_1.PROXY_HEADER_PATTERN.test(canonicalHeaderName) || constants_1.SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
  };
  exports.getCanonicalHeaders = getCanonicalHeaders;
});

// node_modules/@smithy/signature-v4/dist-cjs/getCanonicalQuery.js
var require_getCanonicalQuery = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCanonicalQuery = undefined;
  var util_uri_escape_1 = require_dist_cjs12();
  var constants_1 = require_constants5();
  var getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query).sort()) {
      if (key.toLowerCase() === constants_1.SIGNATURE_HEADER) {
        continue;
      }
      keys.push(key);
      const value = query[key];
      if (typeof value === "string") {
        serialized[key] = `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`;
      } else if (Array.isArray(value)) {
        serialized[key] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value2)}`]), []).sort().join("&");
      }
    }
    return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
  };
  exports.getCanonicalQuery = getCanonicalQuery;
});

// node_modules/@smithy/signature-v4/dist-cjs/getPayloadHash.js
var require_getPayloadHash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPayloadHash = undefined;
  var is_array_buffer_1 = require_dist_cjs8();
  var util_hex_encoding_1 = require_dist_cjs21();
  var util_utf8_1 = require_dist_cjs11();
  var constants_1 = require_constants5();
  var getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase() === constants_1.SHA256_HEADER) {
        return headers[headerName];
      }
    }
    if (body == undefined) {
      return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, is_array_buffer_1.isArrayBuffer)(body)) {
      const hashCtor = new hashConstructor;
      hashCtor.update((0, util_utf8_1.toUint8Array)(body));
      return (0, util_hex_encoding_1.toHex)(await hashCtor.digest());
    }
    return constants_1.UNSIGNED_PAYLOAD;
  };
  exports.getPayloadHash = getPayloadHash;
});

// node_modules/@smithy/signature-v4/dist-cjs/headerUtil.js
var require_headerUtil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteHeader = exports.getHeaderValue = exports.hasHeader = undefined;
  var hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  };
  exports.hasHeader = hasHeader;
  var getHeaderValue = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return headers[headerName];
      }
    }
    return;
  };
  exports.getHeaderValue = getHeaderValue;
  var deleteHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        delete headers[headerName];
      }
    }
  };
  exports.deleteHeader = deleteHeader;
});

// node_modules/@smithy/signature-v4/dist-cjs/cloneRequest.js
var require_cloneRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneQuery = exports.cloneRequest = undefined;
  var cloneRequest = ({ headers, query, ...rest }) => ({
    ...rest,
    headers: { ...headers },
    query: query ? (0, exports.cloneQuery)(query) : undefined
  });
  exports.cloneRequest = cloneRequest;
  var cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
  exports.cloneQuery = cloneQuery;
});

// node_modules/@smithy/signature-v4/dist-cjs/moveHeadersToQuery.js
var require_moveHeadersToQuery = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.moveHeadersToQuery = undefined;
  var cloneRequest_1 = require_cloneRequest();
  var moveHeadersToQuery = (request, options5 = {}) => {
    var _a;
    const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const name of Object.keys(headers)) {
      const lname = name.toLowerCase();
      if (lname.slice(0, 6) === "x-amz-" && !((_a = options5.unhoistableHeaders) === null || _a === undefined ? undefined : _a.has(lname))) {
        query[name] = headers[name];
        delete headers[name];
      }
    }
    return {
      ...request,
      headers,
      query
    };
  };
  exports.moveHeadersToQuery = moveHeadersToQuery;
});

// node_modules/@smithy/signature-v4/dist-cjs/prepareRequest.js
var require_prepareRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareRequest = undefined;
  var cloneRequest_1 = require_cloneRequest();
  var constants_1 = require_constants5();
  var prepareRequest = (request) => {
    request = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const headerName of Object.keys(request.headers)) {
      if (constants_1.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
    return request;
  };
  exports.prepareRequest = prepareRequest;
});

// node_modules/@smithy/signature-v4/dist-cjs/utilDate.js
var require_utilDate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toDate = exports.iso8601 = undefined;
  var iso8601 = (time) => (0, exports.toDate)(time).toISOString().replace(/\.\d{3}Z$/, "Z");
  exports.iso8601 = iso8601;
  var toDate = (time) => {
    if (typeof time === "number") {
      return new Date(time * 1000);
    }
    if (typeof time === "string") {
      if (Number(time)) {
        return new Date(Number(time) * 1000);
      }
      return new Date(time);
    }
    return time;
  };
  exports.toDate = toDate;
});

// node_modules/@smithy/signature-v4/dist-cjs/SignatureV4.js
var require_SignatureV4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SignatureV4 = undefined;
  var eventstream_codec_1 = require_dist_cjs22();
  var util_hex_encoding_1 = require_dist_cjs21();
  var util_middleware_1 = require_dist_cjs23();
  var util_utf8_1 = require_dist_cjs11();
  var constants_1 = require_constants5();
  var credentialDerivation_1 = require_credentialDerivation();
  var getCanonicalHeaders_1 = require_getCanonicalHeaders();
  var getCanonicalQuery_1 = require_getCanonicalQuery();
  var getPayloadHash_1 = require_getPayloadHash();
  var headerUtil_1 = require_headerUtil();
  var moveHeadersToQuery_1 = require_moveHeadersToQuery();
  var prepareRequest_1 = require_prepareRequest();
  var utilDate_1 = require_utilDate();

  class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
      this.headerMarshaller = new eventstream_codec_1.HeaderMarshaller(util_utf8_1.toUtf8, util_utf8_1.fromUtf8);
      this.service = service;
      this.sha256 = sha256;
      this.uriEscapePath = uriEscapePath;
      this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
      this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);
      this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);
    }
    async presign(originalRequest, options5 = {}) {
      const { signingDate = new Date, expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options5;
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion !== null && signingRegion !== undefined ? signingRegion : await this.regionProvider();
      const { longDate, shortDate } = formatDate(signingDate);
      if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {
        return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
      }
      const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== undefined ? signingService : this.service);
      const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), { unhoistableHeaders });
      if (credentials.sessionToken) {
        request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
      }
      request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
      request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
      request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
      request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
      const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
      request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
      request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));
      return request;
    }
    async sign(toSign, options5) {
      if (typeof toSign === "string") {
        return this.signString(toSign, options5);
      } else if (toSign.headers && toSign.payload) {
        return this.signEvent(toSign, options5);
      } else if (toSign.message) {
        return this.signMessage(toSign, options5);
      } else {
        return this.signRequest(toSign, options5);
      }
    }
    async signEvent({ headers, payload: payload2 }, { signingDate = new Date, priorSignature, signingRegion, signingService }) {
      const region = signingRegion !== null && signingRegion !== undefined ? signingRegion : await this.regionProvider();
      const { shortDate, longDate } = formatDate(signingDate);
      const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== undefined ? signingService : this.service);
      const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({ headers: {}, body: payload2 }, this.sha256);
      const hash = new this.sha256;
      hash.update(headers);
      const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());
      const stringToSign = [
        constants_1.EVENT_ALGORITHM_IDENTIFIER,
        longDate,
        scope,
        priorSignature,
        hashedHeaders,
        hashedPayload
      ].join("\n");
      return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date, signingRegion, signingService }) {
      const promise = this.signEvent({
        headers: this.headerMarshaller.format(signableMessage.message.headers),
        payload: signableMessage.message.body
      }, {
        signingDate,
        signingRegion,
        signingService,
        priorSignature: signableMessage.priorSignature
      });
      return promise.then((signature) => {
        return { message: signableMessage.message, signature };
      });
    }
    async signString(stringToSign, { signingDate = new Date, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion !== null && signingRegion !== undefined ? signingRegion : await this.regionProvider();
      const { shortDate } = formatDate(signingDate);
      const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
      hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
      return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date, signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion !== null && signingRegion !== undefined ? signingRegion : await this.regionProvider();
      const request = (0, prepareRequest_1.prepareRequest)(requestToSign);
      const { longDate, shortDate } = formatDate(signingDate);
      const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== undefined ? signingService : this.service);
      request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
      if (credentials.sessionToken) {
        request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
      }
      const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);
      if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
        request.headers[constants_1.SHA256_HEADER] = payloadHash;
      }
      const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
      const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
      request.headers[constants_1.AUTH_HEADER] = `${constants_1.ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;
      return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
      const sortedHeaders = Object.keys(canonicalHeaders).sort();
      return `${request.method}
${this.getCanonicalPath(request)}
${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
      const hash = new this.sha256;
      hash.update((0, util_utf8_1.toUint8Array)(canonicalRequest));
      const hashedRequest = await hash.digest();
      return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
      if (this.uriEscapePath) {
        const normalizedPathSegments = [];
        for (const pathSegment of path.split("/")) {
          if ((pathSegment === null || pathSegment === undefined ? undefined : pathSegment.length) === 0)
            continue;
          if (pathSegment === ".")
            continue;
          if (pathSegment === "..") {
            normalizedPathSegments.pop();
          } else {
            normalizedPathSegments.push(pathSegment);
          }
        }
        const normalizedPath = `${(path === null || path === undefined ? undefined : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path === null || path === undefined ? undefined : path.endsWith("/")) ? "/" : ""}`;
        const doubleEncoded = encodeURIComponent(normalizedPath);
        return doubleEncoded.replace(/%2F/g, "/");
      }
      return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
      const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
      const hash = new this.sha256(await keyPromise);
      hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
      return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
      return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
      if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
        throw new Error("Resolved credential object is not valid");
      }
    }
  }
  exports.SignatureV4 = SignatureV4;
  var formatDate = (now) => {
    const longDate = (0, utilDate_1.iso8601)(now).replace(/[\-:]/g, "");
    return {
      longDate,
      shortDate: longDate.slice(0, 8)
    };
  };
  var getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");
});

// node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs24 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareRequest = exports.moveHeadersToQuery = exports.getPayloadHash = exports.getCanonicalQuery = exports.getCanonicalHeaders = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_SignatureV4(), exports);
  var getCanonicalHeaders_1 = require_getCanonicalHeaders();
  Object.defineProperty(exports, "getCanonicalHeaders", { enumerable: true, get: function() {
    return getCanonicalHeaders_1.getCanonicalHeaders;
  } });
  var getCanonicalQuery_1 = require_getCanonicalQuery();
  Object.defineProperty(exports, "getCanonicalQuery", { enumerable: true, get: function() {
    return getCanonicalQuery_1.getCanonicalQuery;
  } });
  var getPayloadHash_1 = require_getPayloadHash();
  Object.defineProperty(exports, "getPayloadHash", { enumerable: true, get: function() {
    return getPayloadHash_1.getPayloadHash;
  } });
  var moveHeadersToQuery_1 = require_moveHeadersToQuery();
  Object.defineProperty(exports, "moveHeadersToQuery", { enumerable: true, get: function() {
    return moveHeadersToQuery_1.moveHeadersToQuery;
  } });
  var prepareRequest_1 = require_prepareRequest();
  Object.defineProperty(exports, "prepareRequest", { enumerable: true, get: function() {
    return prepareRequest_1.prepareRequest;
  } });
  tslib_1.__exportStar(require_credentialDerivation(), exports);
});

// node_modules/@aws-sdk/middleware-signing/dist-cjs/awsAuthConfiguration.js
var require_awsAuthConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = undefined;
  var property_provider_1 = require_dist_cjs19();
  var signature_v4_1 = require_dist_cjs24();
  var util_middleware_1 = require_dist_cjs23();
  var CREDENTIAL_EXPIRE_WINDOW = 300000;
  var resolveAwsAuthConfig = (input) => {
    const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
      signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    } else if (input.regionInfoProvider) {
      signer = () => (0, util_middleware_1.normalizeProvider)(input.region)().then(async (region) => [
        await input.regionInfoProvider(region, {
          useFipsEndpoint: await input.useFipsEndpoint(),
          useDualstackEndpoint: await input.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        input.signingRegion = input.signingRegion || signingRegion || region;
        input.signingName = input.signingName || signingService || input.serviceId;
        const params = {
          ...input,
          credentials: normalizedCreds,
          region: input.signingRegion,
          service: input.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
        return new SignerCtor(params);
      });
    } else {
      signer = async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: input.signingName || input.defaultSigningName,
          signingRegion: await (0, util_middleware_1.normalizeProvider)(input.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        input.signingRegion = input.signingRegion || signingRegion;
        input.signingName = input.signingName || signingService || input.serviceId;
        const params = {
          ...input,
          credentials: normalizedCreds,
          region: input.signingRegion,
          service: input.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
        return new SignerCtor(params);
      };
    }
    return {
      ...input,
      systemClockOffset,
      signingEscapePath,
      credentials: normalizedCreds,
      signer
    };
  };
  exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
  var resolveSigV4AuthConfig = (input) => {
    const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
      signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    } else {
      signer = (0, util_middleware_1.normalizeProvider)(new signature_v4_1.SignatureV4({
        credentials: normalizedCreds,
        region: input.region,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      }));
    }
    return {
      ...input,
      systemClockOffset,
      signingEscapePath,
      credentials: normalizedCreds,
      signer
    };
  };
  exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
  var normalizeCredentialProvider = (credentials) => {
    if (typeof credentials === "function") {
      return (0, property_provider_1.memoize)(credentials, (credentials2) => credentials2.expiration !== undefined && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials2) => credentials2.expiration !== undefined);
    }
    return (0, util_middleware_1.normalizeProvider)(credentials);
  };
});

// node_modules/@aws-sdk/middleware-signing/dist-cjs/utils/getSkewCorrectedDate.js
var require_getSkewCorrectedDate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSkewCorrectedDate = undefined;
  var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  exports.getSkewCorrectedDate = getSkewCorrectedDate;
});

// node_modules/@aws-sdk/middleware-signing/dist-cjs/utils/isClockSkewed.js
var require_isClockSkewed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isClockSkewed = undefined;
  var getSkewCorrectedDate_1 = require_getSkewCorrectedDate();
  var isClockSkewed = (clockTime, systemClockOffset) => Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
  exports.isClockSkewed = isClockSkewed;
});

// node_modules/@aws-sdk/middleware-signing/dist-cjs/utils/getUpdatedSystemClockOffset.js
var require_getUpdatedSystemClockOffset = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUpdatedSystemClockOffset = undefined;
  var isClockSkewed_1 = require_isClockSkewed();
  var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  };
  exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;
});

// node_modules/@aws-sdk/middleware-signing/dist-cjs/awsAuthMiddleware.js
var require_awsAuthMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var getSkewCorrectedDate_1 = require_getSkewCorrectedDate();
  var getUpdatedSystemClockOffset_1 = require_getUpdatedSystemClockOffset();
  var awsAuthMiddleware = (options5) => (next, context) => async function(args) {
    var _a, _b, _c, _d;
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
      return next(args);
    const authScheme = (_c = (_b = (_a = context.endpointV2) === null || _a === undefined ? undefined : _a.properties) === null || _b === undefined ? undefined : _b.authSchemes) === null || _c === undefined ? undefined : _c[0];
    const multiRegionOverride = (authScheme === null || authScheme === undefined ? undefined : authScheme.name) === "sigv4a" ? (_d = authScheme === null || authScheme === undefined ? undefined : authScheme.signingRegionSet) === null || _d === undefined ? undefined : _d.join(",") : undefined;
    const signer = await options5.signer(authScheme);
    const output = await next({
      ...args,
      request: await signer.sign(args.request, {
        signingDate: (0, getSkewCorrectedDate_1.getSkewCorrectedDate)(options5.systemClockOffset),
        signingRegion: multiRegionOverride || context["signing_region"],
        signingService: context["signing_service"]
      })
    }).catch((error) => {
      var _a2;
      const serverTime = (_a2 = error.ServerTime) !== null && _a2 !== undefined ? _a2 : getDateHeader(error.$response);
      if (serverTime) {
        options5.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(serverTime, options5.systemClockOffset);
      }
      throw error;
    });
    const dateHeader = getDateHeader(output.response);
    if (dateHeader) {
      options5.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(dateHeader, options5.systemClockOffset);
    }
    return output;
  };
  exports.awsAuthMiddleware = awsAuthMiddleware;
  var getDateHeader = (response4) => {
    var _a, _b, _c;
    return protocol_http_1.HttpResponse.isInstance(response4) ? (_b = (_a = response4.headers) === null || _a === undefined ? undefined : _a.date) !== null && _b !== undefined ? _b : (_c = response4.headers) === null || _c === undefined ? undefined : _c.Date : undefined;
  };
  exports.awsAuthMiddlewareOptions = {
    name: "awsAuthMiddleware",
    tags: ["SIGNATURE", "AWSAUTH"],
    relation: "after",
    toMiddleware: "retryMiddleware",
    override: true
  };
  var getAwsAuthPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo((0, exports.awsAuthMiddleware)(options5), exports.awsAuthMiddlewareOptions);
    }
  });
  exports.getAwsAuthPlugin = getAwsAuthPlugin;
  exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin;
});

// node_modules/@aws-sdk/middleware-signing/dist-cjs/index.js
var require_dist_cjs25 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_awsAuthConfiguration(), exports);
  tslib_1.__exportStar(require_awsAuthMiddleware(), exports);
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/configurations.js
var require_configurations = __commonJS((exports) => {
  var resolveUserAgentConfig = function(input) {
    return {
      ...input,
      customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveUserAgentConfig = undefined;
  exports.resolveUserAgentConfig = resolveUserAgentConfig;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/isIpAddress.js
var require_isIpAddress = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIpAddress = undefined;
  var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}\$`);
  var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
  exports.isIpAddress = isIpAddress;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/isValidHostLabel.js
var require_isValidHostLabel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidHostLabel = undefined;
  var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-\$)(?!-)[a-zA-Z0-9-]{1,63}\$`);
  var isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
      return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
      if (!(0, exports.isValidHostLabel)(label)) {
        return false;
      }
    }
    return true;
  };
  exports.isValidHostLabel = isValidHostLabel;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/customEndpointFunctions.js
var require_customEndpointFunctions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.customEndpointFunctions = undefined;
  exports.customEndpointFunctions = {};
});

// node_modules/@smithy/util-endpoints/dist-cjs/debug/debugId.js
var require_debugId = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debugId = undefined;
  exports.debugId = "endpoints";
});

// node_modules/@smithy/util-endpoints/dist-cjs/debug/toDebugString.js
var require_toDebugString = __commonJS((exports) => {
  var toDebugString = function(input) {
    if (typeof input !== "object" || input == null) {
      return input;
    }
    if ("ref" in input) {
      return `\$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
      return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toDebugString = undefined;
  exports.toDebugString = toDebugString;
});

// node_modules/@smithy/util-endpoints/dist-cjs/debug/index.js
var require_debug2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_debugId(), exports);
  tslib_1.__exportStar(require_toDebugString(), exports);
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/EndpointError.js
var require_EndpointError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointError = undefined;

  class EndpointError extends Error {
    constructor(message) {
      super(message);
      this.name = "EndpointError";
    }
  }
  exports.EndpointError = EndpointError;
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/EndpointFunctions.js
var require_EndpointFunctions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/EndpointRuleObject.js
var require_EndpointRuleObject2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/ErrorRuleObject.js
var require_ErrorRuleObject2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/RuleSetObject.js
var require_RuleSetObject2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/TreeRuleObject.js
var require_TreeRuleObject2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/shared.js
var require_shared2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-endpoints/dist-cjs/types/index.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EndpointError(), exports);
  tslib_1.__exportStar(require_EndpointFunctions(), exports);
  tslib_1.__exportStar(require_EndpointRuleObject2(), exports);
  tslib_1.__exportStar(require_ErrorRuleObject2(), exports);
  tslib_1.__exportStar(require_RuleSetObject2(), exports);
  tslib_1.__exportStar(require_TreeRuleObject2(), exports);
  tslib_1.__exportStar(require_shared2(), exports);
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/booleanEquals.js
var require_booleanEquals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.booleanEquals = undefined;
  var booleanEquals = (value1, value2) => value1 === value2;
  exports.booleanEquals = booleanEquals;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/getAttrPathList.js
var require_getAttrPathList = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAttrPathList = undefined;
  var types_1 = require_types3();
  var getAttrPathList = (path) => {
    const parts2 = path.split(".");
    const pathList = [];
    for (const part3 of parts2) {
      const squareBracketIndex = part3.indexOf("[");
      if (squareBracketIndex !== -1) {
        if (part3.indexOf("]") !== part3.length - 1) {
          throw new types_1.EndpointError(`Path: '${path}' does not end with ']'`);
        }
        const arrayIndex = part3.slice(squareBracketIndex + 1, -1);
        if (Number.isNaN(parseInt(arrayIndex))) {
          throw new types_1.EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
        }
        if (squareBracketIndex !== 0) {
          pathList.push(part3.slice(0, squareBracketIndex));
        }
        pathList.push(arrayIndex);
      } else {
        pathList.push(part3);
      }
    }
    return pathList;
  };
  exports.getAttrPathList = getAttrPathList;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/getAttr.js
var require_getAttr = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAttr = undefined;
  var types_1 = require_types3();
  var getAttrPathList_1 = require_getAttrPathList();
  var getAttr = (value, path) => (0, getAttrPathList_1.getAttrPathList)(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
      throw new types_1.EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    } else if (Array.isArray(acc)) {
      return acc[parseInt(index)];
    }
    return acc[index];
  }, value);
  exports.getAttr = getAttr;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/isSet.js
var require_isSet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSet = undefined;
  var isSet = (value) => value != null;
  exports.isSet = isSet;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.not = undefined;
  var not = (value) => !value;
  exports.not = not;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/parseURL.js
var require_parseURL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseURL = undefined;
  var types_1 = require_dist_cjs();
  var isIpAddress_1 = require_isIpAddress();
  var DEFAULT_PORTS = {
    [types_1.EndpointURLScheme.HTTP]: 80,
    [types_1.EndpointURLScheme.HTTPS]: 443
  };
  var parseURL = (value) => {
    const whatwgURL = (() => {
      try {
        if (value instanceof URL) {
          return value;
        }
        if (typeof value === "object" && ("hostname" in value)) {
          const { hostname: hostname2, port, protocol: protocol5 = "", path = "", query = {} } = value;
          const url3 = new URL(`${protocol5}//${hostname2}${port ? `:${port}` : ""}${path}`);
          url3.search = Object.entries(query).map(([k, v]) => `${k}=${v}`).join("&");
          return url3;
        }
        return new URL(value);
      } catch (error) {
        return null;
      }
    })();
    if (!whatwgURL) {
      console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
      return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol: protocol4, search } = whatwgURL;
    if (search) {
      return null;
    }
    const scheme = protocol4.slice(0, -1);
    if (!Object.values(types_1.EndpointURLScheme).includes(scheme)) {
      return null;
    }
    const isIp = (0, isIpAddress_1.isIpAddress)(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
      scheme,
      authority,
      path: pathname,
      normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
      isIp
    };
  };
  exports.parseURL = parseURL;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/stringEquals.js
var require_stringEquals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringEquals = undefined;
  var stringEquals = (value1, value2) => value1 === value2;
  exports.stringEquals = stringEquals;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/substring.js
var require_substring = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.substring = undefined;
  var substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
      return null;
    }
    if (!reverse) {
      return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
  };
  exports.substring = substring;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/uriEncode.js
var require_uriEncode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uriEncode = undefined;
  var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  exports.uriEncode = uriEncode;
});

// node_modules/@smithy/util-endpoints/dist-cjs/lib/index.js
var require_lib7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_booleanEquals(), exports);
  tslib_1.__exportStar(require_getAttr(), exports);
  tslib_1.__exportStar(require_isSet(), exports);
  tslib_1.__exportStar(require_isValidHostLabel(), exports);
  tslib_1.__exportStar(require_not(), exports);
  tslib_1.__exportStar(require_parseURL(), exports);
  tslib_1.__exportStar(require_stringEquals(), exports);
  tslib_1.__exportStar(require_substring(), exports);
  tslib_1.__exportStar(require_uriEncode(), exports);
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/endpointFunctions.js
var require_endpointFunctions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endpointFunctions = undefined;
  var lib_1 = require_lib7();
  exports.endpointFunctions = {
    booleanEquals: lib_1.booleanEquals,
    getAttr: lib_1.getAttr,
    isSet: lib_1.isSet,
    isValidHostLabel: lib_1.isValidHostLabel,
    not: lib_1.not,
    parseURL: lib_1.parseURL,
    stringEquals: lib_1.stringEquals,
    substring: lib_1.substring,
    uriEncode: lib_1.uriEncode
  };
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateTemplate.js
var require_evaluateTemplate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateTemplate = undefined;
  var lib_1 = require_lib7();
  var evaluateTemplate = (template, options5) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
      ...options5.endpointParams,
      ...options5.referenceRecord
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
      const openingBraceIndex = template.indexOf("{", currentIndex);
      if (openingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(currentIndex));
        break;
      }
      evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
      const closingBraceIndex = template.indexOf("}", openingBraceIndex);
      if (closingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex));
        break;
      }
      if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
        currentIndex = closingBraceIndex + 2;
      }
      const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
      if (parameterName.includes("#")) {
        const [refName, attrName] = parameterName.split("#");
        evaluatedTemplateArr.push((0, lib_1.getAttr)(templateContext[refName], attrName));
      } else {
        evaluatedTemplateArr.push(templateContext[parameterName]);
      }
      currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
  };
  exports.evaluateTemplate = evaluateTemplate;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/getReferenceValue.js
var require_getReferenceValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getReferenceValue = undefined;
  var getReferenceValue = ({ ref }, options5) => {
    const referenceRecord = {
      ...options5.endpointParams,
      ...options5.referenceRecord
    };
    return referenceRecord[ref];
  };
  exports.getReferenceValue = getReferenceValue;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateExpression.js
var require_evaluateExpression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateExpression = undefined;
  var types_1 = require_types3();
  var callFunction_1 = require_callFunction();
  var evaluateTemplate_1 = require_evaluateTemplate();
  var getReferenceValue_1 = require_getReferenceValue();
  var evaluateExpression = (obj, keyName, options5) => {
    if (typeof obj === "string") {
      return (0, evaluateTemplate_1.evaluateTemplate)(obj, options5);
    } else if (obj["fn"]) {
      return (0, callFunction_1.callFunction)(obj, options5);
    } else if (obj["ref"]) {
      return (0, getReferenceValue_1.getReferenceValue)(obj, options5);
    }
    throw new types_1.EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
  };
  exports.evaluateExpression = evaluateExpression;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/callFunction.js
var require_callFunction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callFunction = undefined;
  var customEndpointFunctions_1 = require_customEndpointFunctions();
  var endpointFunctions_1 = require_endpointFunctions();
  var evaluateExpression_1 = require_evaluateExpression();
  var callFunction = ({ fn, argv }, options5) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : (0, evaluateExpression_1.evaluateExpression)(arg, "arg", options5));
    const fnSegments = fn.split(".");
    if ((fnSegments[0] in customEndpointFunctions_1.customEndpointFunctions) && fnSegments[1] != null) {
      return customEndpointFunctions_1.customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions_1.endpointFunctions[fn](...evaluatedArgs);
  };
  exports.callFunction = callFunction;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateCondition.js
var require_evaluateCondition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateCondition = undefined;
  var debug_1 = require_debug2();
  var types_1 = require_types3();
  var callFunction_1 = require_callFunction();
  var evaluateCondition = ({ assign, ...fnArgs }, options5) => {
    var _a, _b;
    if (assign && (assign in options5.referenceRecord)) {
      throw new types_1.EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = (0, callFunction_1.callFunction)(fnArgs, options5);
    (_b = (_a = options5.logger) === null || _a === undefined ? undefined : _a.debug) === null || _b === undefined || _b.call(_a, debug_1.debugId, `evaluateCondition: ${(0, debug_1.toDebugString)(fnArgs)} = ${(0, debug_1.toDebugString)(value)}`);
    return {
      result: value === "" ? true : !!value,
      ...assign != null && { toAssign: { name: assign, value } }
    };
  };
  exports.evaluateCondition = evaluateCondition;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateConditions.js
var require_evaluateConditions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateConditions = undefined;
  var debug_1 = require_debug2();
  var evaluateCondition_1 = require_evaluateCondition();
  var evaluateConditions = (conditions = [], options5) => {
    var _a, _b;
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
      const { result, toAssign } = (0, evaluateCondition_1.evaluateCondition)(condition, {
        ...options5,
        referenceRecord: {
          ...options5.referenceRecord,
          ...conditionsReferenceRecord
        }
      });
      if (!result) {
        return { result };
      }
      if (toAssign) {
        conditionsReferenceRecord[toAssign.name] = toAssign.value;
        (_b = (_a = options5.logger) === null || _a === undefined ? undefined : _a.debug) === null || _b === undefined || _b.call(_a, debug_1.debugId, `assign: ${toAssign.name} := ${(0, debug_1.toDebugString)(toAssign.value)}`);
      }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
  };
  exports.evaluateConditions = evaluateConditions;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/getEndpointHeaders.js
var require_getEndpointHeaders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointHeaders = undefined;
  var types_1 = require_types3();
  var evaluateExpression_1 = require_evaluateExpression();
  var getEndpointHeaders = (headers, options5) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
      const processedExpr = (0, evaluateExpression_1.evaluateExpression)(headerValEntry, "Header value entry", options5);
      if (typeof processedExpr !== "string") {
        throw new types_1.EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
      }
      return processedExpr;
    })
  }), {});
  exports.getEndpointHeaders = getEndpointHeaders;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/getEndpointProperty.js
var require_getEndpointProperty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointProperty = undefined;
  var types_1 = require_types3();
  var evaluateTemplate_1 = require_evaluateTemplate();
  var getEndpointProperties_1 = require_getEndpointProperties();
  var getEndpointProperty = (property, options5) => {
    if (Array.isArray(property)) {
      return property.map((propertyEntry) => (0, exports.getEndpointProperty)(propertyEntry, options5));
    }
    switch (typeof property) {
      case "string":
        return (0, evaluateTemplate_1.evaluateTemplate)(property, options5);
      case "object":
        if (property === null) {
          throw new types_1.EndpointError(`Unexpected endpoint property: ${property}`);
        }
        return (0, getEndpointProperties_1.getEndpointProperties)(property, options5);
      case "boolean":
        return property;
      default:
        throw new types_1.EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
  };
  exports.getEndpointProperty = getEndpointProperty;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/getEndpointProperties.js
var require_getEndpointProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointProperties = undefined;
  var getEndpointProperty_1 = require_getEndpointProperty();
  var getEndpointProperties = (properties, options5) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: (0, getEndpointProperty_1.getEndpointProperty)(propertyVal, options5)
  }), {});
  exports.getEndpointProperties = getEndpointProperties;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/getEndpointUrl.js
var require_getEndpointUrl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointUrl = undefined;
  var types_1 = require_types3();
  var evaluateExpression_1 = require_evaluateExpression();
  var getEndpointUrl = (endpointUrl, options5) => {
    const expression = (0, evaluateExpression_1.evaluateExpression)(endpointUrl, "Endpoint URL", options5);
    if (typeof expression === "string") {
      try {
        return new URL(expression);
      } catch (error) {
        console.error(`Failed to construct URL with ${expression}`, error);
        throw error;
      }
    }
    throw new types_1.EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
  };
  exports.getEndpointUrl = getEndpointUrl;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateEndpointRule.js
var require_evaluateEndpointRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateEndpointRule = undefined;
  var debug_1 = require_debug2();
  var evaluateConditions_1 = require_evaluateConditions();
  var getEndpointHeaders_1 = require_getEndpointHeaders();
  var getEndpointProperties_1 = require_getEndpointProperties();
  var getEndpointUrl_1 = require_getEndpointUrl();
  var evaluateEndpointRule = (endpointRule, options5) => {
    var _a, _b;
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options5);
    if (!result) {
      return;
    }
    const endpointRuleOptions = {
      ...options5,
      referenceRecord: { ...options5.referenceRecord, ...referenceRecord }
    };
    const { url: url3, properties, headers } = endpoint;
    (_b = (_a = options5.logger) === null || _a === undefined ? undefined : _a.debug) === null || _b === undefined || _b.call(_a, debug_1.debugId, `Resolving endpoint from template: ${(0, debug_1.toDebugString)(endpoint)}`);
    return {
      ...headers != null && {
        headers: (0, getEndpointHeaders_1.getEndpointHeaders)(headers, endpointRuleOptions)
      },
      ...properties != null && {
        properties: (0, getEndpointProperties_1.getEndpointProperties)(properties, endpointRuleOptions)
      },
      url: (0, getEndpointUrl_1.getEndpointUrl)(url3, endpointRuleOptions)
    };
  };
  exports.evaluateEndpointRule = evaluateEndpointRule;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateErrorRule.js
var require_evaluateErrorRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateErrorRule = undefined;
  var types_1 = require_types3();
  var evaluateConditions_1 = require_evaluateConditions();
  var evaluateExpression_1 = require_evaluateExpression();
  var evaluateErrorRule = (errorRule, options5) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options5);
    if (!result) {
      return;
    }
    throw new types_1.EndpointError((0, evaluateExpression_1.evaluateExpression)(error, "Error", {
      ...options5,
      referenceRecord: { ...options5.referenceRecord, ...referenceRecord }
    }));
  };
  exports.evaluateErrorRule = evaluateErrorRule;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateTreeRule.js
var require_evaluateTreeRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateTreeRule = undefined;
  var evaluateConditions_1 = require_evaluateConditions();
  var evaluateRules_1 = require_evaluateRules();
  var evaluateTreeRule = (treeRule, options5) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options5);
    if (!result) {
      return;
    }
    return (0, evaluateRules_1.evaluateRules)(rules, {
      ...options5,
      referenceRecord: { ...options5.referenceRecord, ...referenceRecord }
    });
  };
  exports.evaluateTreeRule = evaluateTreeRule;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/evaluateRules.js
var require_evaluateRules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateRules = undefined;
  var types_1 = require_types3();
  var evaluateEndpointRule_1 = require_evaluateEndpointRule();
  var evaluateErrorRule_1 = require_evaluateErrorRule();
  var evaluateTreeRule_1 = require_evaluateTreeRule();
  var evaluateRules = (rules, options5) => {
    for (const rule of rules) {
      if (rule.type === "endpoint") {
        const endpointOrUndefined = (0, evaluateEndpointRule_1.evaluateEndpointRule)(rule, options5);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else if (rule.type === "error") {
        (0, evaluateErrorRule_1.evaluateErrorRule)(rule, options5);
      } else if (rule.type === "tree") {
        const endpointOrUndefined = (0, evaluateTreeRule_1.evaluateTreeRule)(rule, options5);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else {
        throw new types_1.EndpointError(`Unknown endpoint rule: ${rule}`);
      }
    }
    throw new types_1.EndpointError(`Rules evaluation failed`);
  };
  exports.evaluateRules = evaluateRules;
});

// node_modules/@smithy/util-endpoints/dist-cjs/utils/index.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_customEndpointFunctions(), exports);
  tslib_1.__exportStar(require_evaluateRules(), exports);
});

// node_modules/@smithy/util-endpoints/dist-cjs/resolveEndpoint.js
var require_resolveEndpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveEndpoint = undefined;
  var debug_1 = require_debug2();
  var types_1 = require_types3();
  var utils_1 = require_utils2();
  var resolveEndpoint = (ruleSetObject, options5) => {
    var _a, _b, _c, _d, _e, _f;
    const { endpointParams, logger } = options5;
    const { parameters, rules } = ruleSetObject;
    (_b = (_a = options5.logger) === null || _a === undefined ? undefined : _a.debug) === null || _b === undefined || _b.call(_a, `${debug_1.debugId} Initial EndpointParams: ${(0, debug_1.toDebugString)(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters).filter(([, v]) => v.default != null).map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
      for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
        endpointParams[paramKey] = (_c = endpointParams[paramKey]) !== null && _c !== undefined ? _c : paramDefaultValue;
      }
    }
    const requiredParams = Object.entries(parameters).filter(([, v]) => v.required).map(([k]) => k);
    for (const requiredParam of requiredParams) {
      if (endpointParams[requiredParam] == null) {
        throw new types_1.EndpointError(`Missing required parameter: '${requiredParam}'`);
      }
    }
    const endpoint = (0, utils_1.evaluateRules)(rules, { endpointParams, logger, referenceRecord: {} });
    if ((_d = options5.endpointParams) === null || _d === undefined ? undefined : _d.Endpoint) {
      try {
        const givenEndpoint = new URL(options5.endpointParams.Endpoint);
        const { protocol: protocol4, port } = givenEndpoint;
        endpoint.url.protocol = protocol4;
        endpoint.url.port = port;
      } catch (e) {
      }
    }
    (_f = (_e = options5.logger) === null || _e === undefined ? undefined : _e.debug) === null || _f === undefined || _f.call(_e, `${debug_1.debugId} Resolved endpoint: ${(0, debug_1.toDebugString)(endpoint)}`);
    return endpoint;
  };
  exports.resolveEndpoint = resolveEndpoint;
});

// node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs26 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_isIpAddress(), exports);
  tslib_1.__exportStar(require_isValidHostLabel(), exports);
  tslib_1.__exportStar(require_customEndpointFunctions(), exports);
  tslib_1.__exportStar(require_resolveEndpoint(), exports);
  tslib_1.__exportStar(require_types3(), exports);
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/lib/isIpAddress.js
var require_isIpAddress2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIpAddress = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  Object.defineProperty(exports, "isIpAddress", { enumerable: true, get: function() {
    return util_endpoints_1.isIpAddress;
  } });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/lib/aws/isVirtualHostableS3Bucket.js
var require_isVirtualHostableS3Bucket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isVirtualHostableS3Bucket = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  var isIpAddress_1 = require_isIpAddress2();
  var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
      for (const label of value.split(".")) {
        if (!(0, exports.isVirtualHostableS3Bucket)(label)) {
          return false;
        }
      }
      return true;
    }
    if (!(0, util_endpoints_1.isValidHostLabel)(value)) {
      return false;
    }
    if (value.length < 3 || value.length > 63) {
      return false;
    }
    if (value !== value.toLowerCase()) {
      return false;
    }
    if ((0, isIpAddress_1.isIpAddress)(value)) {
      return false;
    }
    return true;
  };
  exports.isVirtualHostableS3Bucket = isVirtualHostableS3Bucket;
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/lib/aws/parseArn.js
var require_parseArn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseArn = undefined;
  var parseArn = (value) => {
    const segments = value.split(":");
    if (segments.length < 6)
      return null;
    const [arn, partition, service, region, accountId, ...resourceId] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "")
      return null;
    return {
      partition,
      service,
      region,
      accountId,
      resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
    };
  };
  exports.parseArn = parseArn;
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/lib/aws/partitions.json
var require_partitions = __commonJS((exports, module) => {
  module.exports = {
    partitions: [{
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "aws-global": {
          description: "AWS Standard global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    }, {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "AWS China global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    }, {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "AWS GovCloud (US) global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }, {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "c2s.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "AWS ISO (US) global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    }, {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "sc2s.sgov.gov",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "AWS ISOB (US) global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        }
      }
    }, {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "cloud.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {}
    }, {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "csp.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {}
    }],
    version: "1.1"
  };
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/lib/aws/partition.js
var require_partition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentPrefix = exports.useDefaultPartitionInfo = exports.setPartitionInfo = exports.partition = undefined;
  var tslib_1 = require_tslib();
  var partitions_json_1 = tslib_1.__importDefault(require_partitions());
  var selectedPartitionsInfo = partitions_json_1.default;
  var selectedUserAgentPrefix = "";
  var partition = (value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition2 of partitions) {
      const { regions, outputs } = partition2;
      for (const [region, regionData] of Object.entries(regions)) {
        if (region === value) {
          return {
            ...outputs,
            ...regionData
          };
        }
      }
    }
    for (const partition2 of partitions) {
      const { regionRegex, outputs } = partition2;
      if (new RegExp(regionRegex).test(value)) {
        return {
          ...outputs
        };
      }
    }
    const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
    if (!DEFAULT_PARTITION) {
      throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
    }
    return {
      ...DEFAULT_PARTITION.outputs
    };
  };
  exports.partition = partition;
  var setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo;
    selectedUserAgentPrefix = userAgentPrefix;
  };
  exports.setPartitionInfo = setPartitionInfo;
  var useDefaultPartitionInfo = () => {
    (0, exports.setPartitionInfo)(partitions_json_1.default, "");
  };
  exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
  var getUserAgentPrefix = () => selectedUserAgentPrefix;
  exports.getUserAgentPrefix = getUserAgentPrefix;
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/aws.js
var require_aws = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_endpoints_1 = require_dist_cjs26();
  var isVirtualHostableS3Bucket_1 = require_isVirtualHostableS3Bucket();
  var parseArn_1 = require_parseArn();
  var partition_1 = require_partition();
  var awsEndpointFunctions = {
    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket_1.isVirtualHostableS3Bucket,
    parseArn: parseArn_1.parseArn,
    partition: partition_1.partition
  };
  util_endpoints_1.customEndpointFunctions.aws = awsEndpointFunctions;
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/resolveEndpoint.js
var require_resolveEndpoint2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveEndpoint = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  Object.defineProperty(exports, "resolveEndpoint", { enumerable: true, get: function() {
    return util_endpoints_1.resolveEndpoint;
  } });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/EndpointError.js
var require_EndpointError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointError = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  Object.defineProperty(exports, "EndpointError", { enumerable: true, get: function() {
    return util_endpoints_1.EndpointError;
  } });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/EndpointRuleObject.js
var require_EndpointRuleObject3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/ErrorRuleObject.js
var require_ErrorRuleObject3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/RuleSetObject.js
var require_RuleSetObject3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/TreeRuleObject.js
var require_TreeRuleObject3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/shared.js
var require_shared3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/types/index.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EndpointError2(), exports);
  tslib_1.__exportStar(require_EndpointRuleObject3(), exports);
  tslib_1.__exportStar(require_ErrorRuleObject3(), exports);
  tslib_1.__exportStar(require_RuleSetObject3(), exports);
  tslib_1.__exportStar(require_TreeRuleObject3(), exports);
  tslib_1.__exportStar(require_shared3(), exports);
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs27 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_aws(), exports);
  tslib_1.__exportStar(require_partition(), exports);
  tslib_1.__exportStar(require_isIpAddress2(), exports);
  tslib_1.__exportStar(require_resolveEndpoint2(), exports);
  tslib_1.__exportStar(require_types4(), exports);
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/constants.js
var require_constants6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UA_ESCAPE_CHAR = exports.UA_VALUE_ESCAPE_REGEX = exports.UA_NAME_ESCAPE_REGEX = exports.UA_NAME_SEPARATOR = exports.SPACE = exports.X_AMZ_USER_AGENT = exports.USER_AGENT = undefined;
  exports.USER_AGENT = "user-agent";
  exports.X_AMZ_USER_AGENT = "x-amz-user-agent";
  exports.SPACE = " ";
  exports.UA_NAME_SEPARATOR = "/";
  exports.UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  exports.UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
  exports.UA_ESCAPE_CHAR = "-";
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/user-agent-middleware.js
var require_user_agent_middleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentPlugin = exports.getUserAgentMiddlewareOptions = exports.userAgentMiddleware = undefined;
  var util_endpoints_1 = require_dist_cjs27();
  var protocol_http_1 = require_dist_cjs2();
  var constants_1 = require_constants6();
  var userAgentMiddleware = (options5) => (next, context) => async (args) => {
    var _a, _b;
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request))
      return next(args);
    const { headers } = request;
    const userAgent = ((_a = context === null || context === undefined ? undefined : context.userAgent) === null || _a === undefined ? undefined : _a.map(escapeUserAgent)) || [];
    const defaultUserAgent = (await options5.defaultUserAgentProvider()).map(escapeUserAgent);
    const customUserAgent = ((_b = options5 === null || options5 === undefined ? undefined : options5.customUserAgent) === null || _b === undefined ? undefined : _b.map(escapeUserAgent)) || [];
    const prefix = (0, util_endpoints_1.getUserAgentPrefix)();
    const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(constants_1.SPACE);
    const normalUAValue = [
      ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
      ...customUserAgent
    ].join(constants_1.SPACE);
    if (options5.runtime !== "browser") {
      if (normalUAValue) {
        headers[constants_1.X_AMZ_USER_AGENT] = headers[constants_1.X_AMZ_USER_AGENT] ? `${headers[constants_1.USER_AGENT]} ${normalUAValue}` : normalUAValue;
      }
      headers[constants_1.USER_AGENT] = sdkUserAgentValue;
    } else {
      headers[constants_1.X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
      ...args,
      request
    });
  };
  exports.userAgentMiddleware = userAgentMiddleware;
  var escapeUserAgent = (userAgentPair) => {
    var _a;
    const name = userAgentPair[0].split(constants_1.UA_NAME_SEPARATOR).map((part3) => part3.replace(constants_1.UA_NAME_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR)).join(constants_1.UA_NAME_SEPARATOR);
    const version = (_a = userAgentPair[1]) === null || _a === undefined ? undefined : _a.replace(constants_1.UA_VALUE_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(constants_1.UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
      uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
      switch (index) {
        case 0:
          return item;
        case 1:
          return `${acc}/${item}`;
        default:
          return `${acc}#${item}`;
      }
    }, "");
  };
  exports.getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
  var getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add((0, exports.userAgentMiddleware)(config), exports.getUserAgentMiddlewareOptions);
    }
  });
  exports.getUserAgentPlugin = getUserAgentPlugin;
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs28 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_configurations(), exports);
  tslib_1.__exportStar(require_user_agent_middleware(), exports);
});

// node_modules/@smithy/util-config-provider/dist-cjs/booleanSelector.js
var require_booleanSelector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.booleanSelector = exports.SelectorType = undefined;
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2["ENV"] = "env";
    SelectorType2["CONFIG"] = "shared config entry";
  })(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
  var booleanSelector = (obj, key, type) => {
    if (!(key in obj))
      return;
    if (obj[key] === "true")
      return true;
    if (obj[key] === "false")
      return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
  };
  exports.booleanSelector = booleanSelector;
});

// node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs29 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_booleanSelector(), exports);
});

// node_modules/@smithy/config-resolver/dist-cjs/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var require_NodeUseDualstackEndpointConfigOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_DUALSTACK_ENDPOINT = exports.CONFIG_USE_DUALSTACK_ENDPOINT = exports.ENV_USE_DUALSTACK_ENDPOINT = undefined;
  var util_config_provider_1 = require_dist_cjs29();
  exports.ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
  exports.CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
  exports.DEFAULT_USE_DUALSTACK_ENDPOINT = false;
  exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false
  };
});

// node_modules/@smithy/config-resolver/dist-cjs/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var require_NodeUseFipsEndpointConfigOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_FIPS_ENDPOINT = exports.CONFIG_USE_FIPS_ENDPOINT = exports.ENV_USE_FIPS_ENDPOINT = undefined;
  var util_config_provider_1 = require_dist_cjs29();
  exports.ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
  exports.CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
  exports.DEFAULT_USE_FIPS_ENDPOINT = false;
  exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false
  };
});

// node_modules/@smithy/config-resolver/dist-cjs/endpointsConfig/resolveCustomEndpointsConfig.js
var require_resolveCustomEndpointsConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveCustomEndpointsConfig = undefined;
  var util_middleware_1 = require_dist_cjs23();
  var resolveCustomEndpointsConfig = (input) => {
    var _a, _b;
    const { endpoint, urlParser } = input;
    return {
      ...input,
      tls: (_a = input.tls) !== null && _a !== undefined ? _a : true,
      endpoint: (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
      isCustomEndpoint: true,
      useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== undefined ? _b : false)
    };
  };
  exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;
});

// node_modules/@smithy/config-resolver/dist-cjs/endpointsConfig/utils/getEndpointFromRegion.js
var require_getEndpointFromRegion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointFromRegion = undefined;
  var getEndpointFromRegion = async (input) => {
    var _a;
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
      throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = (_a = await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint })) !== null && _a !== undefined ? _a : {};
    if (!hostname) {
      throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
  };
  exports.getEndpointFromRegion = getEndpointFromRegion;
});

// node_modules/@smithy/config-resolver/dist-cjs/endpointsConfig/resolveEndpointsConfig.js
var require_resolveEndpointsConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveEndpointsConfig = undefined;
  var util_middleware_1 = require_dist_cjs23();
  var getEndpointFromRegion_1 = require_getEndpointFromRegion();
  var resolveEndpointsConfig = (input) => {
    var _a, _b;
    const useDualstackEndpoint = (0, util_middleware_1.normalizeProvider)((_a = input.useDualstackEndpoint) !== null && _a !== undefined ? _a : false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
      ...input,
      tls: (_b = input.tls) !== null && _b !== undefined ? _b : true,
      endpoint: endpoint ? (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : () => (0, getEndpointFromRegion_1.getEndpointFromRegion)({ ...input, useDualstackEndpoint, useFipsEndpoint }),
      isCustomEndpoint: !!endpoint,
      useDualstackEndpoint
    };
  };
  exports.resolveEndpointsConfig = resolveEndpointsConfig;
});

// node_modules/@smithy/config-resolver/dist-cjs/endpointsConfig/index.js
var require_endpointsConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_NodeUseDualstackEndpointConfigOptions(), exports);
  tslib_1.__exportStar(require_NodeUseFipsEndpointConfigOptions(), exports);
  tslib_1.__exportStar(require_resolveCustomEndpointsConfig(), exports);
  tslib_1.__exportStar(require_resolveEndpointsConfig(), exports);
});

// node_modules/@smithy/config-resolver/dist-cjs/regionConfig/config.js
var require_config2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = undefined;
  exports.REGION_ENV_NAME = "AWS_REGION";
  exports.REGION_INI_NAME = "region";
  exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
    configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
  };
});

// node_modules/@smithy/config-resolver/dist-cjs/regionConfig/isFipsRegion.js
var require_isFipsRegion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFipsRegion = undefined;
  var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  exports.isFipsRegion = isFipsRegion;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionConfig/getRealRegion.js
var require_getRealRegion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRealRegion = undefined;
  var isFipsRegion_1 = require_isFipsRegion();
  var getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  exports.getRealRegion = getRealRegion;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionConfig/resolveRegionConfig.js
var require_resolveRegionConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRegionConfig = undefined;
  var getRealRegion_1 = require_getRealRegion();
  var isFipsRegion_1 = require_isFipsRegion();
  var resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return {
      ...input,
      region: async () => {
        if (typeof region === "string") {
          return (0, getRealRegion_1.getRealRegion)(region);
        }
        const providedRegion = await region();
        return (0, getRealRegion_1.getRealRegion)(providedRegion);
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    };
  };
  exports.resolveRegionConfig = resolveRegionConfig;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionConfig/index.js
var require_regionConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_config2(), exports);
  tslib_1.__exportStar(require_resolveRegionConfig(), exports);
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/PartitionHash.js
var require_PartitionHash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/RegionHash.js
var require_RegionHash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/getHostnameFromVariants.js
var require_getHostnameFromVariants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHostnameFromVariants = undefined;
  var getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => {
    var _a;
    return (_a = variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))) === null || _a === undefined ? undefined : _a.hostname;
  };
  exports.getHostnameFromVariants = getHostnameFromVariants;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/getResolvedHostname.js
var require_getResolvedHostname = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getResolvedHostname = undefined;
  var getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : undefined;
  exports.getResolvedHostname = getResolvedHostname;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/getResolvedPartition.js
var require_getResolvedPartition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getResolvedPartition = undefined;
  var getResolvedPartition = (region, { partitionHash }) => {
    var _a;
    return (_a = Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region))) !== null && _a !== undefined ? _a : "aws";
  };
  exports.getResolvedPartition = getResolvedPartition;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/getResolvedSigningRegion.js
var require_getResolvedSigningRegion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getResolvedSigningRegion = undefined;
  var getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
      return signingRegion;
    } else if (useFipsEndpoint) {
      const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
      const regionRegexmatchArray = hostname.match(regionRegexJs);
      if (regionRegexmatchArray) {
        return regionRegexmatchArray[0].slice(1, -1);
      }
    }
  };
  exports.getResolvedSigningRegion = getResolvedSigningRegion;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/getRegionInfo.js
var require_getRegionInfo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRegionInfo = undefined;
  var getHostnameFromVariants_1 = require_getHostnameFromVariants();
  var getResolvedHostname_1 = require_getResolvedHostname();
  var getResolvedPartition_1 = require_getResolvedPartition();
  var getResolvedSigningRegion_1 = require_getResolvedSigningRegion();
  var getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash }) => {
    var _a, _b, _c, _d, _e, _f;
    const partition = (0, getResolvedPartition_1.getResolvedPartition)(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : (_b = (_a = partitionHash[partition]) === null || _a === undefined ? undefined : _a.endpoint) !== null && _b !== undefined ? _b : region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_c = regionHash[resolvedRegion]) === null || _c === undefined ? undefined : _c.variants, hostnameOptions);
    const partitionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_d = partitionHash[partition]) === null || _d === undefined ? undefined : _d.variants, hostnameOptions);
    const hostname = (0, getResolvedHostname_1.getResolvedHostname)(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
      throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = (0, getResolvedSigningRegion_1.getResolvedSigningRegion)(hostname, {
      signingRegion: (_e = regionHash[resolvedRegion]) === null || _e === undefined ? undefined : _e.signingRegion,
      regionRegex: partitionHash[partition].regionRegex,
      useFipsEndpoint
    });
    return {
      partition,
      signingService,
      hostname,
      ...signingRegion && { signingRegion },
      ...((_f = regionHash[resolvedRegion]) === null || _f === undefined ? undefined : _f.signingService) && {
        signingService: regionHash[resolvedRegion].signingService
      }
    };
  };
  exports.getRegionInfo = getRegionInfo;
});

// node_modules/@smithy/config-resolver/dist-cjs/regionInfo/index.js
var require_regionInfo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_PartitionHash(), exports);
  tslib_1.__exportStar(require_RegionHash(), exports);
  tslib_1.__exportStar(require_getRegionInfo(), exports);
});

// node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs30 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_endpointsConfig(), exports);
  tslib_1.__exportStar(require_regionConfig(), exports);
  tslib_1.__exportStar(require_regionInfo(), exports);
});

// node_modules/@smithy/eventstream-serde-config-resolver/dist-cjs/EventStreamSerdeConfig.js
var require_EventStreamSerdeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveEventStreamSerdeConfig = undefined;
  var resolveEventStreamSerdeConfig = (input) => ({
    ...input,
    eventStreamMarshaller: input.eventStreamSerdeProvider(input)
  });
  exports.resolveEventStreamSerdeConfig = resolveEventStreamSerdeConfig;
});

// node_modules/@smithy/eventstream-serde-config-resolver/dist-cjs/index.js
var require_dist_cjs31 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EventStreamSerdeConfig(), exports);
});

// node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs32 = __commonJS((exports) => {
  var contentLengthMiddleware = function(bodyLengthChecker) {
    return (next) => async (args) => {
      const request = args.request;
      if (protocol_http_1.HttpRequest.isInstance(request)) {
        const { body, headers } = request;
        if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
          try {
            const length2 = bodyLengthChecker(body);
            request.headers = {
              ...request.headers,
              [CONTENT_LENGTH_HEADER]: String(length2)
            };
          } catch (error) {
          }
        }
      }
      return next({
        ...args,
        request
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getContentLengthPlugin = exports.contentLengthMiddlewareOptions = exports.contentLengthMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var CONTENT_LENGTH_HEADER = "content-length";
  exports.contentLengthMiddleware = contentLengthMiddleware;
  exports.contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
  var getContentLengthPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.add(contentLengthMiddleware(options5.bodyLengthChecker), exports.contentLengthMiddlewareOptions);
    }
  });
  exports.getContentLengthPlugin = getContentLengthPlugin;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/service-customizations/s3.js
var require_s3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArnBucketName = exports.isDnsCompatibleBucketName = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = exports.resolveParamsForS3 = undefined;
  var resolveParamsForS3 = async (endpointParams) => {
    const bucket = (endpointParams === null || endpointParams === undefined ? undefined : endpointParams.Bucket) || "";
    if (typeof endpointParams.Bucket === "string") {
      endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if ((0, exports.isArnBucketName)(bucket)) {
      if (endpointParams.ForcePathStyle === true) {
        throw new Error("Path-style addressing cannot be used with ARN buckets");
      }
    } else if (!(0, exports.isDnsCompatibleBucketName)(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
      endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
      endpointParams.disableMultiRegionAccessPoints = true;
      endpointParams.DisableMRAP = true;
    }
    return endpointParams;
  };
  exports.resolveParamsForS3 = resolveParamsForS3;
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  exports.DOT_PATTERN = /\./;
  exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
  var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
  exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
  var isArnBucketName = (bucketName) => {
    const [arn, partition, service, region, account, typeOrId] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = [arn, partition, service, account, typeOrId].filter(Boolean).length === 5;
    if (isArn && !isValidArn) {
      throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return arn === "arn" && !!partition && !!service && !!account && !!typeOrId;
  };
  exports.isArnBucketName = isArnBucketName;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/service-customizations/index.js
var require_service_customizations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_s3(), exports);
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/createConfigValueProvider.js
var require_createConfigValueProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConfigValueProvider = undefined;
  var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
      var _a;
      const configValue = (_a = config[configKey]) !== null && _a !== undefined ? _a : config[canonicalEndpointParamKey];
      if (typeof configValue === "function") {
        return configValue();
      }
      return configValue;
    };
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
      return async () => {
        const endpoint = await configProvider();
        if (endpoint && typeof endpoint === "object") {
          if ("url" in endpoint) {
            return endpoint.url.href;
          }
          if ("hostname" in endpoint) {
            const { protocol: protocol4, hostname, port, path } = endpoint;
            return `${protocol4}//${hostname}${port ? ":" + port : ""}${path}`;
          }
        }
        return endpoint;
      };
    }
    return configProvider;
  };
  exports.createConfigValueProvider = createConfigValueProvider;
});

// node_modules/@smithy/node-config-provider/dist-cjs/fromEnv.js
var require_fromEnv = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEnv = undefined;
  var property_provider_1 = require_dist_cjs19();
  var fromEnv = (envVarSelector) => async () => {
    try {
      const config = envVarSelector(process.env);
      if (config === undefined) {
        throw new Error;
      }
      return config;
    } catch (e) {
      throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
  };
  exports.fromEnv = fromEnv;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHomeDir = undefined;
  var os_1 = __require("os");
  var path_1 = __require("path");
  var homeDirCache = {};
  var getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
      return `${process.geteuid()}`;
    }
    return "DEFAULT";
  };
  var getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
      return HOME;
    if (USERPROFILE)
      return USERPROFILE;
    if (HOMEPATH)
      return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
      homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache[homeDirCacheKey];
  };
  exports.getHomeDir = getHomeDir;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getProfileName.js
var require_getProfileName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getProfileName = exports.DEFAULT_PROFILE = exports.ENV_PROFILE = undefined;
  exports.ENV_PROFILE = "AWS_PROFILE";
  exports.DEFAULT_PROFILE = "default";
  var getProfileName = (init2) => init2.profile || process.env[exports.ENV_PROFILE] || exports.DEFAULT_PROFILE;
  exports.getProfileName = getProfileName;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFilepath = undefined;
  var crypto_1 = __require("crypto");
  var path_1 = __require("path");
  var getHomeDir_1 = require_getHomeDir();
  var getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
  };
  exports.getSSOTokenFilepath = getSSOTokenFilepath;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFromFile = undefined;
  var fs_1 = __require("fs");
  var getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
  var { readFile } = fs_1.promises;
  var getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
  };
  exports.getSSOTokenFromFile = getSSOTokenFromFile;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getConfigData.js
var require_getConfigData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getConfigData = undefined;
  var types_1 = require_dist_cjs();
  var loadSharedConfigFiles_1 = require_loadSharedConfigFiles();
  var getConfigData = (data) => Object.entries(data).filter(([key]) => {
    const sections = key.split(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR);
    if (sections.length === 2 && Object.values(types_1.IniSectionType).includes(sections[0])) {
      return true;
    }
    return false;
  }).reduce((acc, [key, value]) => {
    const updatedKey = key.startsWith(types_1.IniSectionType.PROFILE) ? key.split(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR)[1] : key;
    acc[updatedKey] = value;
    return acc;
  }, {
    ...data.default && { default: data.default }
  });
  exports.getConfigData = getConfigData;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getConfigFilepath.js
var require_getConfigFilepath = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getConfigFilepath = exports.ENV_CONFIG_PATH = undefined;
  var path_1 = __require("path");
  var getHomeDir_1 = require_getHomeDir();
  exports.ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
  var getConfigFilepath = () => process.env[exports.ENV_CONFIG_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "config");
  exports.getConfigFilepath = getConfigFilepath;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getCredentialsFilepath.js
var require_getCredentialsFilepath = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCredentialsFilepath = exports.ENV_CREDENTIALS_PATH = undefined;
  var path_1 = __require("path");
  var getHomeDir_1 = require_getHomeDir();
  exports.ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
  var getCredentialsFilepath = () => process.env[exports.ENV_CREDENTIALS_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "credentials");
  exports.getCredentialsFilepath = getCredentialsFilepath;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/parseIni.js
var require_parseIni = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseIni = undefined;
  var types_1 = require_dist_cjs();
  var loadSharedConfigFiles_1 = require_loadSharedConfigFiles();
  var prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+]+)\2$/;
  var profileNameBlockList = ["__proto__", "profile __proto__"];
  var parseIni = (iniData) => {
    const map2 = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
      const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
      const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
      if (isSection) {
        currentSection = undefined;
        currentSubSection = undefined;
        const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
        const matches = prefixKeyRegex.exec(sectionName);
        if (matches) {
          const [, prefix, , name] = matches;
          if (Object.values(types_1.IniSectionType).includes(prefix)) {
            currentSection = [prefix, name].join(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR);
          }
        } else {
          currentSection = sectionName;
        }
        if (profileNameBlockList.includes(sectionName)) {
          throw new Error(`Found invalid profile name "${sectionName}"`);
        }
      } else if (currentSection) {
        const indexOfEqualsSign = trimmedLine.indexOf("=");
        if (![0, -1].includes(indexOfEqualsSign)) {
          const [name, value] = [
            trimmedLine.substring(0, indexOfEqualsSign).trim(),
            trimmedLine.substring(indexOfEqualsSign + 1).trim()
          ];
          if (value === "") {
            currentSubSection = name;
          } else {
            if (currentSubSection && iniLine.trimStart() === iniLine) {
              currentSubSection = undefined;
            }
            map2[currentSection] = map2[currentSection] || {};
            const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR) : name;
            map2[currentSection][key] = value;
          }
        }
      }
    }
    return map2;
  };
  exports.parseIni = parseIni;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/slurpFile.js
var require_slurpFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.slurpFile = undefined;
  var fs_1 = __require("fs");
  var { readFile } = fs_1.promises;
  var filePromisesHash = {};
  var slurpFile = (path, options5) => {
    if (!filePromisesHash[path] || (options5 === null || options5 === undefined ? undefined : options5.ignoreCache)) {
      filePromisesHash[path] = readFile(path, "utf8");
    }
    return filePromisesHash[path];
  };
  exports.slurpFile = slurpFile;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/loadSharedConfigFiles.js
var require_loadSharedConfigFiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadSharedConfigFiles = exports.CONFIG_PREFIX_SEPARATOR = undefined;
  var getConfigData_1 = require_getConfigData();
  var getConfigFilepath_1 = require_getConfigFilepath();
  var getCredentialsFilepath_1 = require_getCredentialsFilepath();
  var parseIni_1 = require_parseIni();
  var slurpFile_1 = require_slurpFile();
  var swallowError = () => ({});
  exports.CONFIG_PREFIX_SEPARATOR = ".";
  var loadSharedConfigFiles = async (init2 = {}) => {
    const { filepath = (0, getCredentialsFilepath_1.getCredentialsFilepath)(), configFilepath = (0, getConfigFilepath_1.getConfigFilepath)() } = init2;
    const parsedFiles = await Promise.all([
      (0, slurpFile_1.slurpFile)(configFilepath, {
        ignoreCache: init2.ignoreCache
      }).then(parseIni_1.parseIni).then(getConfigData_1.getConfigData).catch(swallowError),
      (0, slurpFile_1.slurpFile)(filepath, {
        ignoreCache: init2.ignoreCache
      }).then(parseIni_1.parseIni).catch(swallowError)
    ]);
    return {
      configFile: parsedFiles[0],
      credentialsFile: parsedFiles[1]
    };
  };
  exports.loadSharedConfigFiles = loadSharedConfigFiles;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSsoSessionData.js
var require_getSsoSessionData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSsoSessionData = undefined;
  var types_1 = require_dist_cjs();
  var loadSharedConfigFiles_1 = require_loadSharedConfigFiles();
  var getSsoSessionData = (data) => Object.entries(data).filter(([key]) => key.startsWith(types_1.IniSectionType.SSO_SESSION + loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({ ...acc, [key.split(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR)[1]]: value }), {});
  exports.getSsoSessionData = getSsoSessionData;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/loadSsoSessionData.js
var require_loadSsoSessionData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadSsoSessionData = undefined;
  var getConfigFilepath_1 = require_getConfigFilepath();
  var getSsoSessionData_1 = require_getSsoSessionData();
  var parseIni_1 = require_parseIni();
  var slurpFile_1 = require_slurpFile();
  var swallowError = () => ({});
  var loadSsoSessionData = async (init2 = {}) => {
    var _a;
    return (0, slurpFile_1.slurpFile)((_a = init2.configFilepath) !== null && _a !== undefined ? _a : (0, getConfigFilepath_1.getConfigFilepath)()).then(parseIni_1.parseIni).then(getSsoSessionData_1.getSsoSessionData).catch(swallowError);
  };
  exports.loadSsoSessionData = loadSsoSessionData;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/mergeConfigFiles.js
var require_mergeConfigFiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeConfigFiles = undefined;
  var mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
      for (const [key, values] of Object.entries(file)) {
        if (merged[key] !== undefined) {
          Object.assign(merged[key], values);
        } else {
          merged[key] = values;
        }
      }
    }
    return merged;
  };
  exports.mergeConfigFiles = mergeConfigFiles;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/parseKnownFiles.js
var require_parseKnownFiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseKnownFiles = undefined;
  var loadSharedConfigFiles_1 = require_loadSharedConfigFiles();
  var mergeConfigFiles_1 = require_mergeConfigFiles();
  var parseKnownFiles = async (init2) => {
    const parsedFiles = await (0, loadSharedConfigFiles_1.loadSharedConfigFiles)(init2);
    return (0, mergeConfigFiles_1.mergeConfigFiles)(parsedFiles.configFile, parsedFiles.credentialsFile);
  };
  exports.parseKnownFiles = parseKnownFiles;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/types.js
var require_types5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs33 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_getHomeDir(), exports);
  tslib_1.__exportStar(require_getProfileName(), exports);
  tslib_1.__exportStar(require_getSSOTokenFilepath(), exports);
  tslib_1.__exportStar(require_getSSOTokenFromFile(), exports);
  tslib_1.__exportStar(require_loadSharedConfigFiles(), exports);
  tslib_1.__exportStar(require_loadSsoSessionData(), exports);
  tslib_1.__exportStar(require_parseKnownFiles(), exports);
  tslib_1.__exportStar(require_types5(), exports);
});

// node_modules/@smithy/node-config-provider/dist-cjs/fromSharedConfigFiles.js
var require_fromSharedConfigFiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSharedConfigFiles = undefined;
  var property_provider_1 = require_dist_cjs19();
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init2 } = {}) => async () => {
    const profile = (0, shared_ini_file_loader_1.getProfileName)(init2);
    const { configFile, credentialsFile } = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init2);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
    try {
      const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
      const configValue = configSelector(mergedProfile, cfgFile);
      if (configValue === undefined) {
        throw new Error;
      }
      return configValue;
    } catch (e) {
      throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
  };
  exports.fromSharedConfigFiles = fromSharedConfigFiles;
});

// node_modules/@smithy/node-config-provider/dist-cjs/fromStatic.js
var require_fromStatic2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromStatic = undefined;
  var property_provider_1 = require_dist_cjs19();
  var isFunction5 = (func) => typeof func === "function";
  var fromStatic = (defaultValue) => isFunction5(defaultValue) ? async () => await defaultValue() : (0, property_provider_1.fromStatic)(defaultValue);
  exports.fromStatic = fromStatic;
});

// node_modules/@smithy/node-config-provider/dist-cjs/configLoader.js
var require_configLoader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadConfig = undefined;
  var property_provider_1 = require_dist_cjs19();
  var fromEnv_1 = require_fromEnv();
  var fromSharedConfigFiles_1 = require_fromSharedConfigFiles();
  var fromStatic_1 = require_fromStatic2();
  var loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromEnv_1.fromEnv)(environmentVariableSelector), (0, fromSharedConfigFiles_1.fromSharedConfigFiles)(configFileSelector, configuration), (0, fromStatic_1.fromStatic)(defaultValue)));
  exports.loadConfig = loadConfig;
});

// node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs34 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_configLoader(), exports);
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointUrlConfig = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
  var CONFIG_ENDPOINT_URL = "endpoint_url";
  var getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
      const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
      const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
      if (serviceEndpointUrl)
        return serviceEndpointUrl;
      const endpointUrl = env[ENV_ENDPOINT_URL];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    configFileSelector: (profile, config) => {
      if (config && profile.services) {
        const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
        if (servicesSection) {
          const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
          const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
          if (endpointUrl2)
            return endpointUrl2;
        }
      }
      const endpointUrl = profile[CONFIG_ENDPOINT_URL];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    default: undefined
  });
  exports.getEndpointUrlConfig = getEndpointUrlConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointFromConfig = undefined;
  var node_config_provider_1 = require_dist_cjs34();
  var getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
  var getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId))();
  exports.getEndpointFromConfig = getEndpointFromConfig;
});

// node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs35 = __commonJS((exports) => {
  var parseQueryString = function(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
      for (const pair of querystring.split("&")) {
        let [key, value = null] = pair.split("=");
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    }
    return query;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseQueryString = undefined;
  exports.parseQueryString = parseQueryString;
});

// node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs36 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseUrl = undefined;
  var querystring_parser_1 = require_dist_cjs35();
  var parseUrl = (url3) => {
    if (typeof url3 === "string") {
      return (0, exports.parseUrl)(new URL(url3));
    }
    const { hostname, pathname, port, protocol: protocol4, search } = url3;
    let query;
    if (search) {
      query = (0, querystring_parser_1.parseQueryString)(search);
    }
    return {
      hostname,
      port: port ? parseInt(port) : undefined,
      protocol: protocol4,
      path: pathname,
      query
    };
  };
  exports.parseUrl = parseUrl;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/toEndpointV1.js
var require_toEndpointV1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toEndpointV1 = undefined;
  var url_parser_1 = require_dist_cjs36();
  var toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
      if ("url" in endpoint) {
        return (0, url_parser_1.parseUrl)(endpoint.url);
      }
      return endpoint;
    }
    return (0, url_parser_1.parseUrl)(endpoint);
  };
  exports.toEndpointV1 = toEndpointV1;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromInstructions.js
var require_getEndpointFromInstructions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveParams = exports.getEndpointFromInstructions = undefined;
  var service_customizations_1 = require_service_customizations();
  var createConfigValueProvider_1 = require_createConfigValueProvider();
  var getEndpointFromConfig_1 = require_getEndpointFromConfig();
  var toEndpointV1_1 = require_toEndpointV1();
  var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
      const endpointFromConfig = await (0, getEndpointFromConfig_1.getEndpointFromConfig)(clientConfig.serviceId || "");
      if (endpointFromConfig) {
        clientConfig.endpoint = () => Promise.resolve((0, toEndpointV1_1.toEndpointV1)(endpointFromConfig));
      }
    }
    const endpointParams = await (0, exports.resolveParams)(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
      throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
  };
  exports.getEndpointFromInstructions = getEndpointFromInstructions;
  var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    var _a;
    const endpointParams = {};
    const instructions = ((_a = instructionsSupplier === null || instructionsSupplier === undefined ? undefined : instructionsSupplier.getEndpointParameterInstructions) === null || _a === undefined ? undefined : _a.call(instructionsSupplier)) || {};
    for (const [name, instruction] of Object.entries(instructions)) {
      switch (instruction.type) {
        case "staticContextParams":
          endpointParams[name] = instruction.value;
          break;
        case "contextParams":
          endpointParams[name] = commandInput[instruction.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          endpointParams[name] = await (0, createConfigValueProvider_1.createConfigValueProvider)(instruction.name, name, clientConfig)();
          break;
        default:
          throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
      }
    }
    if (Object.keys(instructions).length === 0) {
      Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
      await (0, service_customizations_1.resolveParamsForS3)(endpointParams);
    }
    return endpointParams;
  };
  exports.resolveParams = resolveParams;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/index.js
var require_adaptors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_getEndpointFromInstructions(), exports);
  tslib_1.__exportStar(require_toEndpointV1(), exports);
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/endpointMiddleware.js
var require_endpointMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endpointMiddleware = undefined;
  var getEndpointFromInstructions_1 = require_getEndpointFromInstructions();
  var endpointMiddleware = ({ config, instructions }) => {
    return (next, context) => async (args) => {
      var _a, _b;
      const endpoint = await (0, getEndpointFromInstructions_1.getEndpointFromInstructions)(args.input, {
        getEndpointParameterInstructions() {
          return instructions;
        }
      }, { ...config }, context);
      context.endpointV2 = endpoint;
      context.authSchemes = (_a = endpoint.properties) === null || _a === undefined ? undefined : _a.authSchemes;
      const authScheme = (_b = context.authSchemes) === null || _b === undefined ? undefined : _b[0];
      if (authScheme) {
        context["signing_region"] = authScheme.signingRegion;
        context["signing_service"] = authScheme.signingName;
      }
      return next({
        ...args
      });
    };
  };
  exports.endpointMiddleware = endpointMiddleware;
});

// node_modules/@smithy/middleware-serde/dist-cjs/deserializerMiddleware.js
var require_deserializerMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializerMiddleware = undefined;
  var deserializerMiddleware = (options5, deserializer) => (next, context) => async (args) => {
    const { response: response4 } = await next(args);
    try {
      const parsed = await deserializer(response4, options5);
      return {
        response: response4,
        output: parsed
      };
    } catch (error) {
      Object.defineProperty(error, "$response", {
        value: response4
      });
      if (!("$metadata" in error)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.\$response on this object.`;
        error.message += "\n  " + hint;
      }
      throw error;
    }
  };
  exports.deserializerMiddleware = deserializerMiddleware;
});

// node_modules/@smithy/middleware-serde/dist-cjs/serializerMiddleware.js
var require_serializerMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializerMiddleware = undefined;
  var serializerMiddleware = (options5, serializer) => (next, context) => async (args) => {
    var _a;
    const endpoint = ((_a = context.endpointV2) === null || _a === undefined ? undefined : _a.url) && options5.urlParser ? async () => options5.urlParser(context.endpointV2.url) : options5.endpoint;
    if (!endpoint) {
      throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options5, endpoint });
    return next({
      ...args,
      request
    });
  };
  exports.serializerMiddleware = serializerMiddleware;
});

// node_modules/@smithy/middleware-serde/dist-cjs/serdePlugin.js
var require_serdePlugin = __commonJS((exports) => {
  var getSerdePlugin = function(config, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add((0, deserializerMiddleware_1.deserializerMiddleware)(config, deserializer), exports.deserializerMiddlewareOption);
        commandStack.add((0, serializerMiddleware_1.serializerMiddleware)(config, serializer), exports.serializerMiddlewareOption);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSerdePlugin = exports.serializerMiddlewareOption = exports.deserializerMiddlewareOption = undefined;
  var deserializerMiddleware_1 = require_deserializerMiddleware();
  var serializerMiddleware_1 = require_serializerMiddleware();
  exports.deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  exports.serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  exports.getSerdePlugin = getSerdePlugin;
});

// node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs37 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_deserializerMiddleware(), exports);
  tslib_1.__exportStar(require_serdePlugin(), exports);
  tslib_1.__exportStar(require_serializerMiddleware(), exports);
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/getEndpointPlugin.js
var require_getEndpointPlugin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointPlugin = exports.endpointMiddlewareOptions = undefined;
  var middleware_serde_1 = require_dist_cjs37();
  var endpointMiddleware_1 = require_endpointMiddleware();
  exports.endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_1.serializerMiddlewareOption.name
  };
  var getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo((0, endpointMiddleware_1.endpointMiddleware)({
        config,
        instructions
      }), exports.endpointMiddlewareOptions);
    }
  });
  exports.getEndpointPlugin = getEndpointPlugin;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/resolveEndpointConfig.js
var require_resolveEndpointConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveEndpointConfig = undefined;
  var util_middleware_1 = require_dist_cjs23();
  var toEndpointV1_1 = require_toEndpointV1();
  var resolveEndpointConfig = (input) => {
    var _a, _b, _c;
    const tls = (_a = input.tls) !== null && _a !== undefined ? _a : true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => (0, toEndpointV1_1.toEndpointV1)(await (0, util_middleware_1.normalizeProvider)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
      ...input,
      endpoint: customEndpointProvider,
      tls,
      isCustomEndpoint,
      useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== undefined ? _b : false),
      useFipsEndpoint: (0, util_middleware_1.normalizeProvider)((_c = input.useFipsEndpoint) !== null && _c !== undefined ? _c : false)
    };
  };
  exports.resolveEndpointConfig = resolveEndpointConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/types.js
var require_types6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs38 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_adaptors(), exports);
  tslib_1.__exportStar(require_endpointMiddleware(), exports);
  tslib_1.__exportStar(require_getEndpointPlugin(), exports);
  tslib_1.__exportStar(require_resolveEndpointConfig(), exports);
  tslib_1.__exportStar(require_types6(), exports);
});

// node_modules/@smithy/util-retry/dist-cjs/config.js
var require_config3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_MODE = exports.DEFAULT_MAX_ATTEMPTS = exports.RETRY_MODES = undefined;
  var RETRY_MODES;
  (function(RETRY_MODES2) {
    RETRY_MODES2["STANDARD"] = "standard";
    RETRY_MODES2["ADAPTIVE"] = "adaptive";
  })(RETRY_MODES = exports.RETRY_MODES || (exports.RETRY_MODES = {}));
  exports.DEFAULT_MAX_ATTEMPTS = 3;
  exports.DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
});

// node_modules/@smithy/service-error-classification/dist-cjs/constants.js
var require_constants7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODEJS_TIMEOUT_ERROR_CODES = exports.TRANSIENT_ERROR_STATUS_CODES = exports.TRANSIENT_ERROR_CODES = exports.THROTTLING_ERROR_CODES = exports.CLOCK_SKEW_ERROR_CODES = undefined;
  exports.CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch"
  ];
  exports.THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  exports.TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  exports.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
  exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
});

// node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs39 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isServerError = exports.isTransientError = exports.isThrottlingError = exports.isClockSkewError = exports.isRetryableByTrait = undefined;
  var constants_1 = require_constants7();
  var isRetryableByTrait = (error) => error.$retryable !== undefined;
  exports.isRetryableByTrait = isRetryableByTrait;
  var isClockSkewError = (error) => constants_1.CLOCK_SKEW_ERROR_CODES.includes(error.name);
  exports.isClockSkewError = isClockSkewError;
  var isThrottlingError = (error) => {
    var _a, _b;
    return ((_a = error.$metadata) === null || _a === undefined ? undefined : _a.httpStatusCode) === 429 || constants_1.THROTTLING_ERROR_CODES.includes(error.name) || ((_b = error.$retryable) === null || _b === undefined ? undefined : _b.throttling) == true;
  };
  exports.isThrottlingError = isThrottlingError;
  var isTransientError = (error) => {
    var _a;
    return constants_1.TRANSIENT_ERROR_CODES.includes(error.name) || constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes((error === null || error === undefined ? undefined : error.code) || "") || constants_1.TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) === null || _a === undefined ? undefined : _a.httpStatusCode) || 0);
  };
  exports.isTransientError = isTransientError;
  var isServerError = (error) => {
    var _a;
    if (((_a = error.$metadata) === null || _a === undefined ? undefined : _a.httpStatusCode) !== undefined) {
      const statusCode = error.$metadata.httpStatusCode;
      if (500 <= statusCode && statusCode <= 599 && !(0, exports.isTransientError)(error)) {
        return true;
      }
      return false;
    }
    return false;
  };
  exports.isServerError = isServerError;
});

// node_modules/@smithy/util-retry/dist-cjs/DefaultRateLimiter.js
var require_DefaultRateLimiter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultRateLimiter = undefined;
  var service_error_classification_1 = require_dist_cjs39();

  class DefaultRateLimiter {
    constructor(options5) {
      var _a, _b, _c, _d, _e;
      this.currentCapacity = 0;
      this.enabled = false;
      this.lastMaxRate = 0;
      this.measuredTxRate = 0;
      this.requestCount = 0;
      this.lastTimestamp = 0;
      this.timeWindow = 0;
      this.beta = (_a = options5 === null || options5 === undefined ? undefined : options5.beta) !== null && _a !== undefined ? _a : 0.7;
      this.minCapacity = (_b = options5 === null || options5 === undefined ? undefined : options5.minCapacity) !== null && _b !== undefined ? _b : 1;
      this.minFillRate = (_c = options5 === null || options5 === undefined ? undefined : options5.minFillRate) !== null && _c !== undefined ? _c : 0.5;
      this.scaleConstant = (_d = options5 === null || options5 === undefined ? undefined : options5.scaleConstant) !== null && _d !== undefined ? _d : 0.4;
      this.smooth = (_e = options5 === null || options5 === undefined ? undefined : options5.smooth) !== null && _e !== undefined ? _e : 0.8;
      const currentTimeInSeconds = this.getCurrentTimeInSeconds();
      this.lastThrottleTime = currentTimeInSeconds;
      this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
      this.fillRate = this.minFillRate;
      this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
      return Date.now() / 1000;
    }
    async getSendToken() {
      return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
      if (!this.enabled) {
        return;
      }
      this.refillTokenBucket();
      if (amount > this.currentCapacity) {
        const delay2 = (amount - this.currentCapacity) / this.fillRate * 1000;
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
      this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
      const timestamp = this.getCurrentTimeInSeconds();
      if (!this.lastTimestamp) {
        this.lastTimestamp = timestamp;
        return;
      }
      const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
      this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
      this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response4) {
      let calculatedRate;
      this.updateMeasuredRate();
      if ((0, service_error_classification_1.isThrottlingError)(response4)) {
        const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
        this.lastMaxRate = rateToUse;
        this.calculateTimeWindow();
        this.lastThrottleTime = this.getCurrentTimeInSeconds();
        calculatedRate = this.cubicThrottle(rateToUse);
        this.enableTokenBucket();
      } else {
        this.calculateTimeWindow();
        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
      }
      const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
      this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
      this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
      return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
      return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
      this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
      this.refillTokenBucket();
      this.fillRate = Math.max(newRate, this.minFillRate);
      this.maxCapacity = Math.max(newRate, this.minCapacity);
      this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
      const t = this.getCurrentTimeInSeconds();
      const timeBucket = Math.floor(t * 2) / 2;
      this.requestCount++;
      if (timeBucket > this.lastTxRateBucket) {
        const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
        this.requestCount = 0;
        this.lastTxRateBucket = timeBucket;
      }
    }
    getPrecise(num) {
      return parseFloat(num.toFixed(8));
    }
  }
  exports.DefaultRateLimiter = DefaultRateLimiter;
});

// node_modules/@smithy/util-retry/dist-cjs/constants.js
var require_constants8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REQUEST_HEADER = exports.INVOCATION_ID_HEADER = exports.NO_RETRY_INCREMENT = exports.TIMEOUT_RETRY_COST = exports.RETRY_COST = exports.INITIAL_RETRY_TOKENS = exports.THROTTLING_RETRY_DELAY_BASE = exports.MAXIMUM_RETRY_DELAY = exports.DEFAULT_RETRY_DELAY_BASE = undefined;
  exports.DEFAULT_RETRY_DELAY_BASE = 100;
  exports.MAXIMUM_RETRY_DELAY = 20 * 1000;
  exports.THROTTLING_RETRY_DELAY_BASE = 500;
  exports.INITIAL_RETRY_TOKENS = 500;
  exports.RETRY_COST = 5;
  exports.TIMEOUT_RETRY_COST = 10;
  exports.NO_RETRY_INCREMENT = 1;
  exports.INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
  exports.REQUEST_HEADER = "amz-sdk-request";
});

// node_modules/@smithy/util-retry/dist-cjs/defaultRetryBackoffStrategy.js
var require_defaultRetryBackoffStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDefaultRetryBackoffStrategy = undefined;
  var constants_1 = require_constants8();
  var getDefaultRetryBackoffStrategy = () => {
    let delayBase = constants_1.DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
      return Math.floor(Math.min(constants_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay2) => {
      delayBase = delay2;
    };
    return {
      computeNextBackoffDelay,
      setDelayBase
    };
  };
  exports.getDefaultRetryBackoffStrategy = getDefaultRetryBackoffStrategy;
});

// node_modules/@smithy/util-retry/dist-cjs/defaultRetryToken.js
var require_defaultRetryToken = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultRetryToken = undefined;
  var constants_1 = require_constants8();
  var createDefaultRetryToken = ({ retryDelay, retryCount: retryCount2, retryCost }) => {
    const getRetryCount = () => retryCount2;
    const getRetryDelay = () => Math.min(constants_1.MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
      getRetryCount,
      getRetryDelay,
      getRetryCost
    };
  };
  exports.createDefaultRetryToken = createDefaultRetryToken;
});

// node_modules/@smithy/util-retry/dist-cjs/StandardRetryStrategy.js
var require_StandardRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StandardRetryStrategy = undefined;
  var config_1 = require_config3();
  var constants_1 = require_constants8();
  var defaultRetryBackoffStrategy_1 = require_defaultRetryBackoffStrategy();
  var defaultRetryToken_1 = require_defaultRetryToken();

  class StandardRetryStrategy {
    constructor(maxAttempts) {
      this.maxAttempts = maxAttempts;
      this.mode = config_1.RETRY_MODES.STANDARD;
      this.capacity = constants_1.INITIAL_RETRY_TOKENS;
      this.retryBackoffStrategy = (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();
      this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
      return (0, defaultRetryToken_1.createDefaultRetryToken)({
        retryDelay: constants_1.DEFAULT_RETRY_DELAY_BASE,
        retryCount: 0
      });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
      const maxAttempts = await this.getMaxAttempts();
      if (this.shouldRetry(token, errorInfo, maxAttempts)) {
        const errorType = errorInfo.errorType;
        this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE);
        const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
        const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
        const capacityCost = this.getCapacityCost(errorType);
        this.capacity -= capacityCost;
        return (0, defaultRetryToken_1.createDefaultRetryToken)({
          retryDelay,
          retryCount: token.getRetryCount() + 1,
          retryCost: capacityCost
        });
      }
      throw new Error("No retry token available");
    }
    recordSuccess(token) {
      var _a;
      this.capacity = Math.max(constants_1.INITIAL_RETRY_TOKENS, this.capacity + ((_a = token.getRetryCost()) !== null && _a !== undefined ? _a : constants_1.NO_RETRY_INCREMENT));
    }
    getCapacity() {
      return this.capacity;
    }
    async getMaxAttempts() {
      try {
        return await this.maxAttemptsProvider();
      } catch (error) {
        console.warn(`Max attempts provider could not resolve. Using default of ${config_1.DEFAULT_MAX_ATTEMPTS}`);
        return config_1.DEFAULT_MAX_ATTEMPTS;
      }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
      const attempts = tokenToRenew.getRetryCount() + 1;
      return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
    }
    getCapacityCost(errorType) {
      return errorType === "TRANSIENT" ? constants_1.TIMEOUT_RETRY_COST : constants_1.RETRY_COST;
    }
    isRetryableError(errorType) {
      return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
  }
  exports.StandardRetryStrategy = StandardRetryStrategy;
});

// node_modules/@smithy/util-retry/dist-cjs/AdaptiveRetryStrategy.js
var require_AdaptiveRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdaptiveRetryStrategy = undefined;
  var config_1 = require_config3();
  var DefaultRateLimiter_1 = require_DefaultRateLimiter();
  var StandardRetryStrategy_1 = require_StandardRetryStrategy();

  class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options5) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.mode = config_1.RETRY_MODES.ADAPTIVE;
      const { rateLimiter } = options5 !== null && options5 !== undefined ? options5 : {};
      this.rateLimiter = rateLimiter !== null && rateLimiter !== undefined ? rateLimiter : new DefaultRateLimiter_1.DefaultRateLimiter;
      this.standardRetryStrategy = new StandardRetryStrategy_1.StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
      await this.rateLimiter.getSendToken();
      return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      this.rateLimiter.updateClientSendingRate(errorInfo);
      return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
      this.rateLimiter.updateClientSendingRate({});
      this.standardRetryStrategy.recordSuccess(token);
    }
  }
  exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
});

// node_modules/@smithy/util-retry/dist-cjs/ConfiguredRetryStrategy.js
var require_ConfiguredRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfiguredRetryStrategy = undefined;
  var constants_1 = require_constants8();
  var StandardRetryStrategy_1 = require_StandardRetryStrategy();

  class ConfiguredRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttempts, computeNextBackoffDelay = constants_1.DEFAULT_RETRY_DELAY_BASE) {
      super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
      if (typeof computeNextBackoffDelay === "number") {
        this.computeNextBackoffDelay = () => computeNextBackoffDelay;
      } else {
        this.computeNextBackoffDelay = computeNextBackoffDelay;
      }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
      return token;
    }
  }
  exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;
});

// node_modules/@smithy/util-retry/dist-cjs/types.js
var require_types7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs40 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_AdaptiveRetryStrategy(), exports);
  tslib_1.__exportStar(require_ConfiguredRetryStrategy(), exports);
  tslib_1.__exportStar(require_DefaultRateLimiter(), exports);
  tslib_1.__exportStar(require_StandardRetryStrategy(), exports);
  tslib_1.__exportStar(require_config3(), exports);
  tslib_1.__exportStar(require_constants8(), exports);
  tslib_1.__exportStar(require_types7(), exports);
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate3 = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate3;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringify = function(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i2 = 0;i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).substr(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options5, buf, offset) {
    let i2 = buf && offset || 0;
    const b = buf || new Array(16);
    options5 = options5 || {};
    let node = options5.node || _nodeId;
    let clockseq = options5.clockseq !== undefined ? options5.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options5.random || (options5.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options5.msecs !== undefined ? options5.msecs : Date.now();
    let nsecs = options5.nsecs !== undefined ? options5.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options5.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options5.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i2++] = tl >>> 24 & 255;
    b[i2++] = tl >>> 16 & 255;
    b[i2++] = tl >>> 8 & 255;
    b[i2++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i2++] = tmh >>> 8 & 255;
    b[i2++] = tmh & 255;
    b[i2++] = tmh >>> 24 & 15 | 16;
    b[i2++] = tmh >>> 16 & 255;
    b[i2++] = clockseq >>> 8 | 128;
    b[i2++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i2 + n] = node[n];
    }
    return buf || (0, _stringify.default)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse4 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse4;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i2 = 0;i2 < str.length; ++i2) {
      bytes.push(str.charCodeAt(i2));
    }
    return bytes;
  };
  var _default = function(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i2 = 0;i2 < 16; ++i2) {
          buf[offset + i2] = bytes[i2];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  exports.URL = exports.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify2());
  var _parse = _interopRequireDefault(require_parse2());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options5, buf, offset) {
    options5 = options5 || {};
    const rnds = options5.random || (options5.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0;i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _parse = _interopRequireDefault(require_parse2());
});

// node_modules/@smithy/middleware-retry/dist-cjs/defaultRetryQuota.js
var require_defaultRetryQuota = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDefaultRetryQuota = undefined;
  var util_retry_1 = require_dist_cjs40();
  var getDefaultRetryQuota = (initialRetryTokens, options5) => {
    var _a, _b, _c;
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = (_a = options5 === null || options5 === undefined ? undefined : options5.noRetryIncrement) !== null && _a !== undefined ? _a : util_retry_1.NO_RETRY_INCREMENT;
    const retryCost = (_b = options5 === null || options5 === undefined ? undefined : options5.retryCost) !== null && _b !== undefined ? _b : util_retry_1.RETRY_COST;
    const timeoutRetryCost = (_c = options5 === null || options5 === undefined ? undefined : options5.timeoutRetryCost) !== null && _c !== undefined ? _c : util_retry_1.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => error.name === "TimeoutError" ? timeoutRetryCost : retryCost;
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
      if (!hasRetryTokens(error)) {
        throw new Error("No retry token available");
      }
      const capacityAmount = getCapacityAmount(error);
      availableCapacity -= capacityAmount;
      return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
      availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== undefined ? capacityReleaseAmount : noRetryIncrement;
      availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
      hasRetryTokens,
      retrieveRetryTokens,
      releaseRetryTokens
    });
  };
  exports.getDefaultRetryQuota = getDefaultRetryQuota;
});

// node_modules/@smithy/middleware-retry/dist-cjs/delayDecider.js
var require_delayDecider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultDelayDecider = undefined;
  var util_retry_1 = require_dist_cjs40();
  var defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(util_retry_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  exports.defaultDelayDecider = defaultDelayDecider;
});

// node_modules/@smithy/middleware-retry/dist-cjs/retryDecider.js
var require_retryDecider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryDecider = undefined;
  var service_error_classification_1 = require_dist_cjs39();
  var defaultRetryDecider = (error) => {
    if (!error) {
      return false;
    }
    return (0, service_error_classification_1.isRetryableByTrait)(error) || (0, service_error_classification_1.isClockSkewError)(error) || (0, service_error_classification_1.isThrottlingError)(error) || (0, service_error_classification_1.isTransientError)(error);
  };
  exports.defaultRetryDecider = defaultRetryDecider;
});

// node_modules/@smithy/middleware-retry/dist-cjs/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asSdkError = undefined;
  var asSdkError = (error) => {
    if (error instanceof Error)
      return error;
    if (error instanceof Object)
      return Object.assign(new Error, error);
    if (typeof error === "string")
      return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
  };
  exports.asSdkError = asSdkError;
});

// node_modules/@smithy/middleware-retry/dist-cjs/StandardRetryStrategy.js
var require_StandardRetryStrategy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StandardRetryStrategy = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var service_error_classification_1 = require_dist_cjs39();
  var util_retry_1 = require_dist_cjs40();
  var uuid_1 = require_dist5();
  var defaultRetryQuota_1 = require_defaultRetryQuota();
  var delayDecider_1 = require_delayDecider();
  var retryDecider_1 = require_retryDecider();
  var util_1 = require_util2();

  class StandardRetryStrategy {
    constructor(maxAttemptsProvider, options5) {
      var _a, _b, _c;
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.mode = util_retry_1.RETRY_MODES.STANDARD;
      this.retryDecider = (_a = options5 === null || options5 === undefined ? undefined : options5.retryDecider) !== null && _a !== undefined ? _a : retryDecider_1.defaultRetryDecider;
      this.delayDecider = (_b = options5 === null || options5 === undefined ? undefined : options5.delayDecider) !== null && _b !== undefined ? _b : delayDecider_1.defaultDelayDecider;
      this.retryQuota = (_c = options5 === null || options5 === undefined ? undefined : options5.retryQuota) !== null && _c !== undefined ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
      return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
      let maxAttempts;
      try {
        maxAttempts = await this.maxAttemptsProvider();
      } catch (error) {
        maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;
      }
      return maxAttempts;
    }
    async retry(next, args, options5) {
      let retryTokenAmount;
      let attempts = 0;
      let totalDelay = 0;
      const maxAttempts = await this.getMaxAttempts();
      const { request } = args;
      if (protocol_http_1.HttpRequest.isInstance(request)) {
        request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
      }
      while (true) {
        try {
          if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          if (options5 === null || options5 === undefined ? undefined : options5.beforeRequest) {
            await options5.beforeRequest();
          }
          const { response: response4, output } = await next(args);
          if (options5 === null || options5 === undefined ? undefined : options5.afterRequest) {
            options5.afterRequest(response4);
          }
          this.retryQuota.releaseRetryTokens(retryTokenAmount);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalDelay;
          return { response: response4, output };
        } catch (e) {
          const err = (0, util_1.asSdkError)(e);
          attempts++;
          if (this.shouldRetry(err, attempts, maxAttempts)) {
            retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
            const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);
            const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
            const delay2 = Math.max(delayFromResponse || 0, delayFromDecider);
            totalDelay += delay2;
            await new Promise((resolve) => setTimeout(resolve, delay2));
            continue;
          }
          if (!err.$metadata) {
            err.$metadata = {};
          }
          err.$metadata.attempts = attempts;
          err.$metadata.totalRetryDelay = totalDelay;
          throw err;
        }
      }
    }
  }
  exports.StandardRetryStrategy = StandardRetryStrategy;
  var getDelayFromRetryAfterHeader = (response4) => {
    if (!protocol_http_1.HttpResponse.isInstance(response4))
      return;
    const retryAfterHeaderName = Object.keys(response4.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response4.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
  };
});

// node_modules/@smithy/middleware-retry/dist-cjs/AdaptiveRetryStrategy.js
var require_AdaptiveRetryStrategy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdaptiveRetryStrategy = undefined;
  var util_retry_1 = require_dist_cjs40();
  var StandardRetryStrategy_1 = require_StandardRetryStrategy2();

  class AdaptiveRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttemptsProvider, options5) {
      const { rateLimiter, ...superOptions } = options5 !== null && options5 !== undefined ? options5 : {};
      super(maxAttemptsProvider, superOptions);
      this.rateLimiter = rateLimiter !== null && rateLimiter !== undefined ? rateLimiter : new util_retry_1.DefaultRateLimiter;
      this.mode = util_retry_1.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
      return super.retry(next, args, {
        beforeRequest: async () => {
          return this.rateLimiter.getSendToken();
        },
        afterRequest: (response4) => {
          this.rateLimiter.updateClientSendingRate(response4);
        }
      });
    }
  }
  exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
});

// node_modules/@smithy/middleware-retry/dist-cjs/configurations.js
var require_configurations2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_RETRY_MODE_CONFIG_OPTIONS = exports.CONFIG_RETRY_MODE = exports.ENV_RETRY_MODE = exports.resolveRetryConfig = exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = exports.CONFIG_MAX_ATTEMPTS = exports.ENV_MAX_ATTEMPTS = undefined;
  var util_middleware_1 = require_dist_cjs23();
  var util_retry_1 = require_dist_cjs40();
  exports.ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
  exports.CONFIG_MAX_ATTEMPTS = "max_attempts";
  exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
      const value = env[exports.ENV_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Environment variable ${exports.ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    configFileSelector: (profile) => {
      const value = profile[exports.CONFIG_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Shared config file entry ${exports.CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    default: util_retry_1.DEFAULT_MAX_ATTEMPTS
  };
  var resolveRetryConfig = (input) => {
    var _a;
    const { retryStrategy } = input;
    const maxAttempts = (0, util_middleware_1.normalizeProvider)((_a = input.maxAttempts) !== null && _a !== undefined ? _a : util_retry_1.DEFAULT_MAX_ATTEMPTS);
    return {
      ...input,
      maxAttempts,
      retryStrategy: async () => {
        if (retryStrategy) {
          return retryStrategy;
        }
        const retryMode = await (0, util_middleware_1.normalizeProvider)(input.retryMode)();
        if (retryMode === util_retry_1.RETRY_MODES.ADAPTIVE) {
          return new util_retry_1.AdaptiveRetryStrategy(maxAttempts);
        }
        return new util_retry_1.StandardRetryStrategy(maxAttempts);
      }
    };
  };
  exports.resolveRetryConfig = resolveRetryConfig;
  exports.ENV_RETRY_MODE = "AWS_RETRY_MODE";
  exports.CONFIG_RETRY_MODE = "retry_mode";
  exports.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[exports.CONFIG_RETRY_MODE],
    default: util_retry_1.DEFAULT_RETRY_MODE
  };
});

// node_modules/@smithy/middleware-retry/dist-cjs/omitRetryHeadersMiddleware.js
var require_omitRetryHeadersMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOmitRetryHeadersPlugin = exports.omitRetryHeadersMiddlewareOptions = exports.omitRetryHeadersMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var util_retry_1 = require_dist_cjs40();
  var omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocol_http_1.HttpRequest.isInstance(request)) {
      delete request.headers[util_retry_1.INVOCATION_ID_HEADER];
      delete request.headers[util_retry_1.REQUEST_HEADER];
    }
    return next(args);
  };
  exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
  exports.omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
  };
  var getOmitRetryHeadersPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo((0, exports.omitRetryHeadersMiddleware)(), exports.omitRetryHeadersMiddlewareOptions);
    }
  });
  exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;
});

// node_modules/@smithy/middleware-retry/dist-cjs/retryMiddleware.js
var require_retryMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRetryAfterHint = exports.getRetryPlugin = exports.retryMiddlewareOptions = exports.retryMiddleware = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var service_error_classification_1 = require_dist_cjs39();
  var util_retry_1 = require_dist_cjs40();
  var uuid_1 = require_dist5();
  var util_1 = require_util2();
  var retryMiddleware = (options5) => (next, context) => async (args) => {
    let retryStrategy = await options5.retryStrategy();
    const maxAttempts = await options5.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
      retryStrategy = retryStrategy;
      let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
      let lastError = new Error;
      let attempts = 0;
      let totalRetryDelay = 0;
      const { request } = args;
      if (protocol_http_1.HttpRequest.isInstance(request)) {
        request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
      }
      while (true) {
        try {
          if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          const { response: response4, output } = await next(args);
          retryStrategy.recordSuccess(retryToken);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalRetryDelay;
          return { response: response4, output };
        } catch (e) {
          const retryErrorInfo = getRetryErrorInfo(e);
          lastError = (0, util_1.asSdkError)(e);
          try {
            retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
          } catch (refreshError) {
            if (!lastError.$metadata) {
              lastError.$metadata = {};
            }
            lastError.$metadata.attempts = attempts + 1;
            lastError.$metadata.totalRetryDelay = totalRetryDelay;
            throw lastError;
          }
          attempts = retryToken.getRetryCount();
          const delay2 = retryToken.getRetryDelay();
          totalRetryDelay += delay2;
          await new Promise((resolve) => setTimeout(resolve, delay2));
        }
      }
    } else {
      retryStrategy = retryStrategy;
      if (retryStrategy === null || retryStrategy === undefined ? undefined : retryStrategy.mode)
        context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
      return retryStrategy.retry(next, args);
    }
  };
  exports.retryMiddleware = retryMiddleware;
  var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
  var getRetryErrorInfo = (error) => {
    const errorInfo = {
      errorType: getRetryErrorType(error)
    };
    const retryAfterHint = (0, exports.getRetryAfterHint)(error.$response);
    if (retryAfterHint) {
      errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
  };
  var getRetryErrorType = (error) => {
    if ((0, service_error_classification_1.isThrottlingError)(error))
      return "THROTTLING";
    if ((0, service_error_classification_1.isTransientError)(error))
      return "TRANSIENT";
    if ((0, service_error_classification_1.isServerError)(error))
      return "SERVER_ERROR";
    return "CLIENT_ERROR";
  };
  exports.retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
  var getRetryPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.add((0, exports.retryMiddleware)(options5), exports.retryMiddlewareOptions);
    }
  });
  exports.getRetryPlugin = getRetryPlugin;
  var getRetryAfterHint = (response4) => {
    if (!protocol_http_1.HttpResponse.isInstance(response4))
      return;
    const retryAfterHeaderName = Object.keys(response4.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response4.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
  };
  exports.getRetryAfterHint = getRetryAfterHint;
});

// node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs41 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_AdaptiveRetryStrategy2(), exports);
  tslib_1.__exportStar(require_StandardRetryStrategy2(), exports);
  tslib_1.__exportStar(require_configurations2(), exports);
  tslib_1.__exportStar(require_delayDecider(), exports);
  tslib_1.__exportStar(require_omitRetryHeadersMiddleware(), exports);
  tslib_1.__exportStar(require_retryDecider(), exports);
  tslib_1.__exportStar(require_retryMiddleware(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/EndpointParameters.js
var require_EndpointParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveClientEndpointParameters = undefined;
  var resolveClientEndpointParameters = (options5) => {
    return {
      ...options5,
      useFipsEndpoint: options5.useFipsEndpoint ?? false,
      useDualstackEndpoint: options5.useDualstackEndpoint ?? false,
      forcePathStyle: options5.forcePathStyle ?? false,
      useAccelerateEndpoint: options5.useAccelerateEndpoint ?? false,
      useGlobalEndpoint: options5.useGlobalEndpoint ?? false,
      disableMultiregionAccessPoints: options5.disableMultiregionAccessPoints ?? false,
      defaultSigningName: "s3"
    };
  };
  exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
});

// node_modules/@aws-sdk/client-s3/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/client-s3",
    description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
    version: "3.441.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "tsc -p tsconfig.cjs.json",
      "build:docs": "typedoc",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
      test: "yarn test:unit",
      "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
      "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
      "test:e2e:node": "jest --c jest.config.e2e.js",
      "test:unit": "ts-mocha test/unit/**/*.spec.ts"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha1-browser": "3.0.0",
      "@aws-crypto/sha256-browser": "3.0.0",
      "@aws-crypto/sha256-js": "3.0.0",
      "@aws-sdk/client-sts": "3.441.0",
      "@aws-sdk/core": "3.441.0",
      "@aws-sdk/credential-provider-node": "3.441.0",
      "@aws-sdk/middleware-bucket-endpoint": "3.433.0",
      "@aws-sdk/middleware-expect-continue": "3.433.0",
      "@aws-sdk/middleware-flexible-checksums": "3.433.0",
      "@aws-sdk/middleware-host-header": "3.433.0",
      "@aws-sdk/middleware-location-constraint": "3.433.0",
      "@aws-sdk/middleware-logger": "3.433.0",
      "@aws-sdk/middleware-recursion-detection": "3.433.0",
      "@aws-sdk/middleware-sdk-s3": "3.440.0",
      "@aws-sdk/middleware-signing": "3.433.0",
      "@aws-sdk/middleware-ssec": "3.433.0",
      "@aws-sdk/middleware-user-agent": "3.438.0",
      "@aws-sdk/region-config-resolver": "3.433.0",
      "@aws-sdk/signature-v4-multi-region": "3.437.0",
      "@aws-sdk/types": "3.433.0",
      "@aws-sdk/util-endpoints": "3.438.0",
      "@aws-sdk/util-user-agent-browser": "3.433.0",
      "@aws-sdk/util-user-agent-node": "3.437.0",
      "@aws-sdk/xml-builder": "3.310.0",
      "@smithy/config-resolver": "^2.0.16",
      "@smithy/eventstream-serde-browser": "^2.0.12",
      "@smithy/eventstream-serde-config-resolver": "^2.0.12",
      "@smithy/eventstream-serde-node": "^2.0.12",
      "@smithy/fetch-http-handler": "^2.2.4",
      "@smithy/hash-blob-browser": "^2.0.12",
      "@smithy/hash-node": "^2.0.12",
      "@smithy/hash-stream-node": "^2.0.12",
      "@smithy/invalid-dependency": "^2.0.12",
      "@smithy/md5-js": "^2.0.12",
      "@smithy/middleware-content-length": "^2.0.14",
      "@smithy/middleware-endpoint": "^2.1.3",
      "@smithy/middleware-retry": "^2.0.18",
      "@smithy/middleware-serde": "^2.0.12",
      "@smithy/middleware-stack": "^2.0.6",
      "@smithy/node-config-provider": "^2.1.3",
      "@smithy/node-http-handler": "^2.1.8",
      "@smithy/protocol-http": "^3.0.8",
      "@smithy/smithy-client": "^2.1.12",
      "@smithy/types": "^2.4.0",
      "@smithy/url-parser": "^2.0.12",
      "@smithy/util-base64": "^2.0.0",
      "@smithy/util-body-length-browser": "^2.0.0",
      "@smithy/util-body-length-node": "^2.1.0",
      "@smithy/util-defaults-mode-browser": "^2.0.16",
      "@smithy/util-defaults-mode-node": "^2.0.21",
      "@smithy/util-endpoints": "^1.0.2",
      "@smithy/util-retry": "^2.0.5",
      "@smithy/util-stream": "^2.0.17",
      "@smithy/util-utf8": "^2.0.0",
      "@smithy/util-waiter": "^2.0.12",
      "fast-xml-parser": "4.2.5",
      tslib: "^2.5.0"
    },
    devDependencies: {
      "@smithy/service-client-documentation-generator": "^2.0.0",
      "@tsconfig/node14": "1.0.3",
      "@types/chai": "^4.2.11",
      "@types/mocha": "^8.0.4",
      "@types/node": "^14.14.31",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typedoc: "0.23.23",
      typescript: "~4.9.5"
    },
    engines: {
      node: ">=14.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-s3"
    }
  };
});

// node_modules/@aws-sdk/middleware-sdk-sts/dist-cjs/index.js
var require_dist_cjs42 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveStsAuthConfig = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var resolveStsAuthConfig = (input, { stsClientCtor }) => (0, middleware_signing_1.resolveAwsAuthConfig)({
    ...input,
    stsClientCtor
  });
  exports.resolveStsAuthConfig = resolveStsAuthConfig;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/endpoint/EndpointParameters.js
var require_EndpointParameters2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveClientEndpointParameters = undefined;
  var resolveClientEndpointParameters = (options5) => {
    return {
      ...options5,
      useDualstackEndpoint: options5.useDualstackEndpoint ?? false,
      useFipsEndpoint: options5.useFipsEndpoint ?? false,
      useGlobalEndpoint: options5.useGlobalEndpoint ?? false,
      defaultSigningName: "sts"
    };
  };
  exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
});

// node_modules/@aws-sdk/client-sts/package.json
var require_package4 = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/client-sts",
    description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
    version: "3.441.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "tsc -p tsconfig.cjs.json",
      "build:docs": "typedoc",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
      test: "yarn test:unit",
      "test:unit": "jest"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "3.0.0",
      "@aws-crypto/sha256-js": "3.0.0",
      "@aws-sdk/core": "3.441.0",
      "@aws-sdk/credential-provider-node": "3.441.0",
      "@aws-sdk/middleware-host-header": "3.433.0",
      "@aws-sdk/middleware-logger": "3.433.0",
      "@aws-sdk/middleware-recursion-detection": "3.433.0",
      "@aws-sdk/middleware-sdk-sts": "3.433.0",
      "@aws-sdk/middleware-signing": "3.433.0",
      "@aws-sdk/middleware-user-agent": "3.438.0",
      "@aws-sdk/region-config-resolver": "3.433.0",
      "@aws-sdk/types": "3.433.0",
      "@aws-sdk/util-endpoints": "3.438.0",
      "@aws-sdk/util-user-agent-browser": "3.433.0",
      "@aws-sdk/util-user-agent-node": "3.437.0",
      "@smithy/config-resolver": "^2.0.16",
      "@smithy/fetch-http-handler": "^2.2.4",
      "@smithy/hash-node": "^2.0.12",
      "@smithy/invalid-dependency": "^2.0.12",
      "@smithy/middleware-content-length": "^2.0.14",
      "@smithy/middleware-endpoint": "^2.1.3",
      "@smithy/middleware-retry": "^2.0.18",
      "@smithy/middleware-serde": "^2.0.12",
      "@smithy/middleware-stack": "^2.0.6",
      "@smithy/node-config-provider": "^2.1.3",
      "@smithy/node-http-handler": "^2.1.8",
      "@smithy/protocol-http": "^3.0.8",
      "@smithy/smithy-client": "^2.1.12",
      "@smithy/types": "^2.4.0",
      "@smithy/url-parser": "^2.0.12",
      "@smithy/util-base64": "^2.0.0",
      "@smithy/util-body-length-browser": "^2.0.0",
      "@smithy/util-body-length-node": "^2.1.0",
      "@smithy/util-defaults-mode-browser": "^2.0.16",
      "@smithy/util-defaults-mode-node": "^2.0.21",
      "@smithy/util-endpoints": "^1.0.2",
      "@smithy/util-retry": "^2.0.5",
      "@smithy/util-utf8": "^2.0.0",
      "fast-xml-parser": "4.2.5",
      tslib: "^2.5.0"
    },
    devDependencies: {
      "@smithy/service-client-documentation-generator": "^2.0.0",
      "@tsconfig/node14": "1.0.3",
      "@types/node": "^14.14.31",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typedoc: "0.23.23",
      typescript: "~4.9.5"
    },
    engines: {
      node: ">=14.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sts"
    }
  };
});

// node_modules/@aws-sdk/client-sts/dist-cjs/models/STSServiceException.js
var require_STSServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class STSServiceException extends smithy_client_1.ServiceException {
    constructor(options5) {
      super(options5);
      Object.setPrototypeOf(this, STSServiceException.prototype);
    }
  }
  exports.STSServiceException = STSServiceException;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/models/models_0.js
var require_models_0 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetSessionTokenResponseFilterSensitiveLog = exports.GetFederationTokenResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = exports.AssumeRoleResponseFilterSensitiveLog = exports.CredentialsFilterSensitiveLog = exports.InvalidAuthorizationMessageException = exports.IDPCommunicationErrorException = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var STSServiceException_1 = require_STSServiceException();

  class ExpiredTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      this.name = "ExpiredTokenException";
      this.$fault = "client";
      Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
  }
  exports.ExpiredTokenException = ExpiredTokenException;

  class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "MalformedPolicyDocumentException",
        $fault: "client",
        ...opts
      });
      this.name = "MalformedPolicyDocumentException";
      this.$fault = "client";
      Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
  }
  exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;

  class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "PackedPolicyTooLargeException",
        $fault: "client",
        ...opts
      });
      this.name = "PackedPolicyTooLargeException";
      this.$fault = "client";
      Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
  }
  exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;

  class RegionDisabledException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "RegionDisabledException",
        $fault: "client",
        ...opts
      });
      this.name = "RegionDisabledException";
      this.$fault = "client";
      Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
  }
  exports.RegionDisabledException = RegionDisabledException;

  class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "IDPRejectedClaimException",
        $fault: "client",
        ...opts
      });
      this.name = "IDPRejectedClaimException";
      this.$fault = "client";
      Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
  }
  exports.IDPRejectedClaimException = IDPRejectedClaimException;

  class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "InvalidIdentityTokenException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidIdentityTokenException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
  }
  exports.InvalidIdentityTokenException = InvalidIdentityTokenException;

  class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "IDPCommunicationErrorException",
        $fault: "client",
        ...opts
      });
      this.name = "IDPCommunicationErrorException";
      this.$fault = "client";
      Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
  }
  exports.IDPCommunicationErrorException = IDPCommunicationErrorException;

  class InvalidAuthorizationMessageException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
      super({
        name: "InvalidAuthorizationMessageException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidAuthorizationMessageException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
  }
  exports.InvalidAuthorizationMessageException = InvalidAuthorizationMessageException;
  var CredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SecretAccessKey && { SecretAccessKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CredentialsFilterSensitiveLog = CredentialsFilterSensitiveLog;
  var AssumeRoleResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }
  });
  exports.AssumeRoleResponseFilterSensitiveLog = AssumeRoleResponseFilterSensitiveLog;
  var AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SAMLAssertion && { SAMLAssertion: smithy_client_1.SENSITIVE_STRING }
  });
  exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = AssumeRoleWithSAMLRequestFilterSensitiveLog;
  var AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }
  });
  exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = AssumeRoleWithSAMLResponseFilterSensitiveLog;
  var AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.WebIdentityToken && { WebIdentityToken: smithy_client_1.SENSITIVE_STRING }
  });
  exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AssumeRoleWithWebIdentityRequestFilterSensitiveLog;
  var AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }
  });
  exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
  var GetFederationTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }
  });
  exports.GetFederationTokenResponseFilterSensitiveLog = GetFederationTokenResponseFilterSensitiveLog;
  var GetSessionTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }
  });
  exports.GetSessionTokenResponseFilterSensitiveLog = GetSessionTokenResponseFilterSensitiveLog;
});

// node_modules/fast-xml-parser/src/util.js
var require_util3 = __commonJS((exports) => {
  var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  var regexName = new RegExp("^" + nameRegexp + "$");
  var getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0;index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string);
    }
    return matches;
  };
  var isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v) {
    return typeof v !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i2 = 0;i2 < len; i2++) {
        if (arrayMode === "strict") {
          target[keys[i2]] = [a[keys[i2]]];
        } else {
          target[keys[i2]] = a[keys[i2]];
        }
      }
    }
  };
  exports.getValue = function(v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator2 = __commonJS((exports) => {
  var isWhiteSpace = function(char) {
    return char === " " || char === "\t" || char === "\n" || char === "\r";
  };
  var readPI = function(xmlData, i2) {
    const start = i2;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] == "?" || xmlData[i2] == " ") {
        const tagname = xmlData.substr(start, i2 - start);
        if (i2 > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
        } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
          i2++;
          break;
        } else {
          continue;
        }
      }
    }
    return i2;
  };
  var readCommentAndCDATA = function(xmlData, i2) {
    if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
      for (i2 += 3;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
          i2 += 2;
          break;
        }
      }
    } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
      let angleBracketsCount = 1;
      for (i2 += 8;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i2] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
      for (i2 += 8;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
          i2 += 2;
          break;
        }
      }
    }
    return i2;
  };
  var readAttributeStr = function(xmlData, i2) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i2];
        } else if (startChar !== xmlData[i2]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i2] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i2];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i2,
      tagClosed
    };
  };
  var validateAttributeString = function(attrStr, options5) {
    const matches = util5.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i2 = 0;i2 < matches.length; i2++) {
      if (matches[i2][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
      } else if (matches[i2][3] !== undefined && matches[i2][4] === undefined) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
      } else if (matches[i2][3] === undefined && !options5.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
      }
      const attrName = matches[i2][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
      }
    }
    return true;
  };
  var validateNumberAmpersand = function(xmlData, i2) {
    let re2 = /\d/;
    if (xmlData[i2] === "x") {
      i2++;
      re2 = /[\da-fA-F]/;
    }
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === ";")
        return i2;
      if (!xmlData[i2].match(re2))
        break;
    }
    return -1;
  };
  var validateAmpersand = function(xmlData, i2) {
    i2++;
    if (xmlData[i2] === ";")
      return -1;
    if (xmlData[i2] === "#") {
      i2++;
      return validateNumberAmpersand(xmlData, i2);
    }
    let count = 0;
    for (;i2 < xmlData.length; i2++, count++) {
      if (xmlData[i2].match(/\w/) && count < 20)
        continue;
      if (xmlData[i2] === ";")
        break;
      return -1;
    }
    return i2;
  };
  var getErrorObject = function(code, message, lineNumber) {
    return {
      err: {
        code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  };
  var validateAttrName = function(attrName) {
    return util5.isName(attrName);
  };
  var validateTagName = function(tagname) {
    return util5.isName(tagname);
  };
  var getLineNumberForPosition = function(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      col: lines[lines.length - 1].length + 1
    };
  };
  var getPositionFromMatch = function(match) {
    return match.startIndex + match[1].length;
  };
  var util5 = require_util3();
  var defaultOptions2 = {
    allowBooleanAttributes: false,
    unpairedTags: []
  };
  exports.validate = function(xmlData, options5) {
    options5 = Object.assign({}, defaultOptions2, options5);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i2 = 0;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
        i2 += 2;
        i2 = readPI(xmlData, i2);
        if (i2.err)
          return i2;
      } else if (xmlData[i2] === "<") {
        let tagStartPos = i2;
        i2++;
        if (xmlData[i2] === "!") {
          i2 = readCommentAndCDATA(xmlData, i2);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i2] === "/") {
            closingTag = true;
            i2++;
          }
          let tagName = "";
          for (;i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "\t" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
            tagName += xmlData[i2];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i2--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
          }
          const result = readAttributeStr(xmlData, i2);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
          }
          let attrStr = result.value;
          i2 = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i2 - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options5);
            if (isValid === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options5);
            if (isValid !== true) {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
            } else if (options5.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i2++;i2 < xmlData.length; i2++) {
            if (xmlData[i2] === "<") {
              if (xmlData[i2 + 1] === "!") {
                i2++;
                i2 = readCommentAndCDATA(xmlData, i2);
                continue;
              } else if (xmlData[i2 + 1] === "?") {
                i2 = readPI(xmlData, ++i2);
                if (i2.err)
                  return i2;
              } else {
                break;
              }
            } else if (xmlData[i2] === "&") {
              const afterAmp = validateAmpersand(xmlData, i2);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
              i2 = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
              }
            }
          }
          if (xmlData[i2] === "<") {
            i2--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i2])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  var doubleQuote = '"';
  var singleQuote = "'";
  var validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', "g");
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS((exports) => {
  var defaultOptions2 = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val2) {
      return val2;
    },
    attributeValueProcessor: function(attrName, val2) {
      return val2;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
  };
  var buildOptions = function(options5) {
    return Object.assign({}, defaultOptions2, options5);
  };
  exports.buildOptions = buildOptions;
  exports.defaultOptions = defaultOptions2;
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS((exports, module) => {
  class XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val2) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val2 });
    }
    addChild(node) {
      if (node.tagname === "__proto__")
        node.tagname = "#__proto__";
      if (node[":@"] && Object.keys(node[":@"]).length > 0) {
        this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
      } else {
        this.child.push({ [node.tagname]: node.child });
      }
    }
  }
  module.exports = XmlNode;
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS((exports, module) => {
  var readDocType = function(xmlData, i2) {
    const entities = {};
    if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
      i2 = i2 + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i2)) {
            i2 += 7;
            [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement(xmlData, i2))
            i2 += 8;
          else if (hasBody && isAttlist(xmlData, i2))
            i2 += 8;
          else if (hasBody && isNotation(xmlData, i2))
            i2 += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i2] === ">") {
          if (comment) {
            if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i2] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i2];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i: i2 };
  };
  var readEntityExp = function(xmlData, i2) {
    let entityName2 = "";
    for (;i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
      entityName2 += xmlData[i2];
    }
    entityName2 = entityName2.trim();
    if (entityName2.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i2++];
    let val2 = "";
    for (;i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
      val2 += xmlData[i2];
    }
    return [entityName2, val2, i2];
  };
  var isComment = function(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
      return true;
    return false;
  };
  var isEntity = function(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
      return true;
    return false;
  };
  var isElement = function(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
      return true;
    return false;
  };
  var isAttlist = function(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
      return true;
    return false;
  };
  var isNotation = function(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
      return true;
    return false;
  };
  var validateEntityName = function(name) {
    if (util5.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  };
  var util5 = require_util3();
  module.exports = readDocType;
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS((exports, module) => {
  var toNumber = function(str, options5 = {}) {
    options5 = Object.assign({}, consider, options5);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options5.skipLike !== undefined && options5.skipLike.test(trimmedStr))
      return str;
    else if (options5.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options5.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options5.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options5.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options5.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  };
  var trimZeros = function(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  };
  var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  var consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
  };
  module.exports = toNumber;
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS((exports, module) => {
  var addExternalEntities = function(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i2 = 0;i2 < entKeys.length; i2++) {
      const ent = entKeys[i2];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  };
  var parseTextData = function(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val2 !== undefined) {
      if (this.options.trimValues && !dontTrim) {
        val2 = val2.trim();
      }
      if (val2.length > 0) {
        if (!escapeEntities)
          val2 = this.replaceEntitiesValue(val2);
        const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === undefined) {
          return val2;
        } else if (typeof newval !== typeof val2 || newval !== val2) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val2.trim();
          if (trimmedVal === val2) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val2;
          }
        }
      }
    }
  };
  var resolveNameSpace = function(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  };
  var buildAttributesMap = function(attrStr, jPath, tagName) {
    if (!this.options.ignoreAttributes && typeof attrStr === "string") {
      const matches = util5.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i2 = 0;i2 < len; i2++) {
        const attrName = this.resolveNameSpace(matches[i2][1]);
        let oldVal = matches[i2][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== undefined) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === undefined) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  };
  var addChild = function(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {
    } else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  };
  var saveTextToParentTag = function(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === undefined)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
      if (textData !== undefined && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  };
  var isItStopNode = function(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  };
  var tagExpWithClosingIndex = function(xmlData, i2, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i2;index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "\t") {
        ch = " ";
      }
      tagExp += ch;
    }
  };
  var findClosingIndex = function(xmlData, str, i2, errMsg) {
    const closingIndex = xmlData.indexOf(str, i2);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  };
  var readTagExp = function(xmlData, i2, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
    if (!result)
      return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
      tagExp = tagExp.substr(separatorIndex + 1);
    }
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent
    };
  };
  var readStopNodeData = function(xmlData, tagName, i2) {
    const startIndex = i2;
    let openTagCount = 1;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<") {
        if (xmlData[i2 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i2),
                i: closeIndex
              };
            }
          }
          i2 = closeIndex;
        } else if (xmlData[i2 + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
          i2 = closeIndex;
        } else if (xmlData.substr(i2 + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
          i2 = closeIndex;
        } else if (xmlData.substr(i2 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
          i2 = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i2, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i2 = tagData.closeIndex;
          }
        }
      }
    }
  };
  var parseValue = function(val2, shouldParse, options5) {
    if (shouldParse && typeof val2 === "string") {
      const newval = val2.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val2, options5);
    } else {
      if (util5.isExist(val2)) {
        return val2;
      } else {
        return "";
      }
    }
  };
  var util5 = require_util3();
  var xmlNode = require_xmlNode();
  var readDocType = require_DocTypeReader();
  var toNumber = require_strnum();
  var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util5.nameRegexp);

  class OrderedObjParser {
    constructor(options5) {
      this.options = options5;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: "\"" }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        cent: { regex: /&(cent|#162);/g, val: "\xA2" },
        pound: { regex: /&(pound|#163);/g, val: "\xA3" },
        yen: { regex: /&(yen|#165);/g, val: "\xA5" },
        euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
        copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
        reg: { regex: /&(reg|#174);/g, val: "\xAE" },
        inr: { regex: /&(inr|#8377);/g, val: "\u20B9" }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
    }
  }
  var attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', "gm");
  var parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i2 = 0;i2 < xmlData.length; i2++) {
      const ch = xmlData[i2];
      if (ch === "<") {
        if (xmlData[i2 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i2 = closeIndex;
        } else if (xmlData[i2 + 1] === "?") {
          let tagData = readTagExp(xmlData, i2, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
          } else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i2 = tagData.closeIndex + 1;
        } else if (xmlData.substr(i2 + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i2 + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i2 = endIndex;
        } else if (xmlData.substr(i2 + 1, 2) === "!D") {
          const result = readDocType(xmlData, i2);
          this.docTypeEntities = result.entities;
          i2 = result.i;
        } else if (xmlData.substr(i2 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i2 + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
            if (val2 == undefined)
              val2 = "";
            currentNode.add(this.options.textNodeName, val2);
          }
          i2 = closeIndex + 2;
        } else {
          let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
          let tagName = result.tagName;
          let tagExp = result.tagExp;
          let attrExpPresent = result.attrExpPresent;
          let closeIndex = result.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              i2 = result.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i2 = result.closeIndex;
            } else {
              const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
              if (!result2)
                throw new Error(`Unexpected end of ${tagName}`);
              i2 = result2.i;
              tagContent = result2.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i2 = closeIndex;
          }
        }
      } else {
        textData += xmlData[i2];
      }
    }
    return xmlObj.child;
  };
  var replaceEntitiesValue = function(val2) {
    if (this.options.processEntities) {
      for (let entityName2 in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName2];
        val2 = val2.replace(entity.regx, entity.val);
      }
      for (let entityName2 in this.lastEntities) {
        const entity = this.lastEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName2 in this.htmlEntities) {
          const entity = this.htmlEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
      }
      val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val2;
  };
  module.exports = OrderedObjParser;
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS((exports) => {
  var prettify = function(node, options5) {
    return compress(node, options5);
  };
  var compress = function(arr, options5, jPath) {
    let text;
    const compressedObj = {};
    for (let i2 = 0;i2 < arr.length; i2++) {
      const tagObj = arr[i2];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === undefined)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options5.textNodeName) {
        if (text === undefined)
          text = tagObj[property];
        else
          text += "" + tagObj[property];
      } else if (property === undefined) {
        continue;
      } else if (tagObj[property]) {
        let val2 = compress(tagObj[property], options5, newJpath);
        const isLeaf = isLeafTag(val2, options5);
        if (tagObj[":@"]) {
          assignAttributes(val2, tagObj[":@"], newJpath, options5);
        } else if (Object.keys(val2).length === 1 && val2[options5.textNodeName] !== undefined && !options5.alwaysCreateTextNode) {
          val2 = val2[options5.textNodeName];
        } else if (Object.keys(val2).length === 0) {
          if (options5.alwaysCreateTextNode)
            val2[options5.textNodeName] = "";
          else
            val2 = "";
        }
        if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val2);
        } else {
          if (options5.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val2];
          } else {
            compressedObj[property] = val2;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0)
        compressedObj[options5.textNodeName] = text;
    } else if (text !== undefined)
      compressedObj[options5.textNodeName] = text;
    return compressedObj;
  };
  var propName = function(obj) {
    const keys = Object.keys(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (key !== ":@")
        return key;
    }
  };
  var assignAttributes = function(obj, attrMap, jpath, options5) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i2 = 0;i2 < len; i2++) {
        const atrrName = keys[i2];
        if (options5.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  };
  var isLeafTag = function(obj, options5) {
    const { textNodeName } = options5;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  };
  exports.prettify = prettify;
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS((exports, module) => {
  var { buildOptions } = require_OptionsBuilder();
  var OrderedObjParser = require_OrderedObjParser();
  var { prettify } = require_node2json();
  var validator = require_validator2();

  class XMLParser {
    constructor(options5) {
      this.externalEntities = {};
      this.options = buildOptions(options5);
    }
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {
      } else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    addEntity(key, value) {
      if (value.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value;
      }
    }
  }
  module.exports = XMLParser;
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS((exports, module) => {
  var toXml = function(jArray, options5) {
    let indentation = "";
    if (options5.format && options5.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options5, "", indentation);
  };
  var arrToStr = function(arr, options5, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i2 = 0;i2 < arr.length; i2++) {
      const tagObj = arr[i2];
      const tagName = propName(tagObj);
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options5.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options5)) {
          tagText = options5.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options5);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options5.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options5.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options5.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options5.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options5);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options5.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options5.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options5);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options5, newJPath, newIdentation);
      if (options5.unpairedTags.indexOf(tagName) !== -1) {
        if (options5.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options5.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options5.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  };
  var propName = function(obj) {
    const keys = Object.keys(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (key !== ":@")
        return key;
    }
  };
  var attr_to_str = function(attrMap, options5) {
    let attrStr = "";
    if (attrMap && !options5.ignoreAttributes) {
      for (let attr in attrMap) {
        let attrVal = options5.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options5);
        if (attrVal === true && options5.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options5.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options5.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  };
  var isStopNode = function(jPath, options5) {
    jPath = jPath.substr(0, jPath.length - options5.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options5.stopNodes) {
      if (options5.stopNodes[index] === jPath || options5.stopNodes[index] === "*." + tagName)
        return true;
    }
    return false;
  };
  var replaceEntitiesValue = function(textValue, options5) {
    if (textValue && textValue.length > 0 && options5.processEntities) {
      for (let i2 = 0;i2 < options5.entities.length; i2++) {
        const entity = options5.entities[i2];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  var EOL = "\n";
  module.exports = toXml;
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS((exports, module) => {
  var Builder = function(options5) {
    this.options = Object.assign({}, defaultOptions2, options5);
    if (this.options.ignoreAttributes || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = ">\n";
      this.newLine = "\n";
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  };
  var processTextOrObjNode = function(object, key, level) {
    const result = this.j2x(object, level + 1);
    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
      return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
    } else {
      return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
  };
  var indentate = function(level) {
    return this.options.indentBy.repeat(level);
  };
  var isAttribute = function(name) {
    if (name.startsWith(this.options.attributeNamePrefix)) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  };
  var buildFromOrderedJs = require_orderedJs2Xml();
  var defaultOptions2 = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a) {
      return a;
    },
    attributeValueProcessor: function(attrName, a) {
      return a;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("\'", "g"), val: "&apos;" },
      { regex: new RegExp("\"", "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    oneListGroup: false
  };
  Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0).val;
    }
  };
  Builder.prototype.j2x = function(jObj, level) {
    let attrStr = "";
    let val2 = "";
    for (let key in jObj) {
      if (typeof jObj[key] === "undefined") {
      } else if (jObj[key] === null) {
        if (key[0] === "?")
          val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        else
          val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
      } else if (jObj[key] instanceof Date) {
        val2 += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val2 += this.replaceEntitiesValue(newval);
          } else {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        for (let j = 0;j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === "undefined") {
          } else if (item === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              listTagVal += this.j2x(item, level + 1).val;
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level);
            }
          } else {
            listTagVal += this.buildTextValNode(item, key, "", level);
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, "", level);
        }
        val2 += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L = Ks.length;
          for (let j = 0;j < L; j++) {
            attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
          }
        } else {
          val2 += this.processTextOrObjNode(jObj[key], key, level);
        }
      }
    }
    return { attrStr, val: val2 };
  };
  Builder.prototype.buildAttrPairStr = function(attrName, val2) {
    val2 = this.options.attributeValueProcessor(attrName, "" + val2);
    val2 = this.replaceEntitiesValue(val2);
    if (this.options.suppressBooleanAttributes && val2 === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val2 + '"';
  };
  Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
    if (val2 === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if (attrStr && val2.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val2);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i2 = 0;i2 < this.options.entities.length; i2++) {
        const entity = this.options.entities[i2];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  module.exports = Builder;
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS((exports, module) => {
  var validator = require_validator2();
  var XMLParser = require_XMLParser();
  var XMLBuilder = require_json2xml();
  module.exports = {
    XMLParser,
    XMLValidator: validator,
    XMLBuilder
  };
});

// node_modules/@aws-sdk/client-sts/dist-cjs/protocols/Aws_query.js
var require_Aws_query = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.de_GetSessionTokenCommand = exports.de_GetFederationTokenCommand = exports.de_GetCallerIdentityCommand = exports.de_GetAccessKeyInfoCommand = exports.de_DecodeAuthorizationMessageCommand = exports.de_AssumeRoleWithWebIdentityCommand = exports.de_AssumeRoleWithSAMLCommand = exports.de_AssumeRoleCommand = exports.se_GetSessionTokenCommand = exports.se_GetFederationTokenCommand = exports.se_GetCallerIdentityCommand = exports.se_GetAccessKeyInfoCommand = exports.se_DecodeAuthorizationMessageCommand = exports.se_AssumeRoleWithWebIdentityCommand = exports.se_AssumeRoleWithSAMLCommand = exports.se_AssumeRoleCommand = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var fast_xml_parser_1 = require_fxp();
  var models_0_1 = require_models_0();
  var STSServiceException_1 = require_STSServiceException();
  var se_AssumeRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleRequest(input, context),
      Action: "AssumeRole",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_AssumeRoleCommand = se_AssumeRoleCommand;
  var se_AssumeRoleWithSAMLCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleWithSAMLRequest(input, context),
      Action: "AssumeRoleWithSAML",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_AssumeRoleWithSAMLCommand = se_AssumeRoleWithSAMLCommand;
  var se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleWithWebIdentityRequest(input, context),
      Action: "AssumeRoleWithWebIdentity",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_AssumeRoleWithWebIdentityCommand = se_AssumeRoleWithWebIdentityCommand;
  var se_DecodeAuthorizationMessageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_DecodeAuthorizationMessageRequest(input, context),
      Action: "DecodeAuthorizationMessage",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_DecodeAuthorizationMessageCommand = se_DecodeAuthorizationMessageCommand;
  var se_GetAccessKeyInfoCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_GetAccessKeyInfoRequest(input, context),
      Action: "GetAccessKeyInfo",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_GetAccessKeyInfoCommand = se_GetAccessKeyInfoCommand;
  var se_GetCallerIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_GetCallerIdentityRequest(input, context),
      Action: "GetCallerIdentity",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_GetCallerIdentityCommand = se_GetCallerIdentityCommand;
  var se_GetFederationTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_GetFederationTokenRequest(input, context),
      Action: "GetFederationToken",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_GetFederationTokenCommand = se_GetFederationTokenCommand;
  var se_GetSessionTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_GetSessionTokenRequest(input, context),
      Action: "GetSessionToken",
      Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  };
  exports.se_GetSessionTokenCommand = se_GetSessionTokenCommand;
  var de_AssumeRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_AssumeRoleCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_AssumeRoleCommand = de_AssumeRoleCommand;
  var de_AssumeRoleCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ExpiredTokenException":
      case "com.amazonaws.sts#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
      case "MalformedPolicyDocument":
      case "com.amazonaws.sts#MalformedPolicyDocumentException":
        throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
      case "PackedPolicyTooLarge":
      case "com.amazonaws.sts#PackedPolicyTooLargeException":
        throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_AssumeRoleWithSAMLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_AssumeRoleWithSAMLCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_AssumeRoleWithSAMLCommand = de_AssumeRoleWithSAMLCommand;
  var de_AssumeRoleWithSAMLCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ExpiredTokenException":
      case "com.amazonaws.sts#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
      case "IDPRejectedClaim":
      case "com.amazonaws.sts#IDPRejectedClaimException":
        throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
      case "InvalidIdentityToken":
      case "com.amazonaws.sts#InvalidIdentityTokenException":
        throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
      case "MalformedPolicyDocument":
      case "com.amazonaws.sts#MalformedPolicyDocumentException":
        throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
      case "PackedPolicyTooLarge":
      case "com.amazonaws.sts#PackedPolicyTooLargeException":
        throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_AssumeRoleWithWebIdentityCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_AssumeRoleWithWebIdentityCommand = de_AssumeRoleWithWebIdentityCommand;
  var de_AssumeRoleWithWebIdentityCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ExpiredTokenException":
      case "com.amazonaws.sts#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
      case "IDPCommunicationError":
      case "com.amazonaws.sts#IDPCommunicationErrorException":
        throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
      case "IDPRejectedClaim":
      case "com.amazonaws.sts#IDPRejectedClaimException":
        throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
      case "InvalidIdentityToken":
      case "com.amazonaws.sts#InvalidIdentityTokenException":
        throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
      case "MalformedPolicyDocument":
      case "com.amazonaws.sts#MalformedPolicyDocumentException":
        throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
      case "PackedPolicyTooLarge":
      case "com.amazonaws.sts#PackedPolicyTooLargeException":
        throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_DecodeAuthorizationMessageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_DecodeAuthorizationMessageCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_DecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_DecodeAuthorizationMessageCommand = de_DecodeAuthorizationMessageCommand;
  var de_DecodeAuthorizationMessageCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InvalidAuthorizationMessageException":
      case "com.amazonaws.sts#InvalidAuthorizationMessageException":
        throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_GetAccessKeyInfoCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_GetAccessKeyInfoCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_GetAccessKeyInfoCommand = de_GetAccessKeyInfoCommand;
  var de_GetAccessKeyInfoCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody: parsedBody.Error,
      errorCode
    });
  };
  var de_GetCallerIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_GetCallerIdentityCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_GetCallerIdentityResponse(data.GetCallerIdentityResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_GetCallerIdentityCommand = de_GetCallerIdentityCommand;
  var de_GetCallerIdentityCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody: parsedBody.Error,
      errorCode
    });
  };
  var de_GetFederationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_GetFederationTokenCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_GetFederationTokenResponse(data.GetFederationTokenResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_GetFederationTokenCommand = de_GetFederationTokenCommand;
  var de_GetFederationTokenCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "MalformedPolicyDocument":
      case "com.amazonaws.sts#MalformedPolicyDocumentException":
        throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
      case "PackedPolicyTooLarge":
      case "com.amazonaws.sts#PackedPolicyTooLargeException":
        throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_GetSessionTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_GetSessionTokenCommandError(output, context);
    }
    const data = await parseBody2(output.body, context);
    let contents = {};
    contents = de_GetSessionTokenResponse(data.GetSessionTokenResult, context);
    const response4 = {
      $metadata: deserializeMetadata(output),
      ...contents
    };
    return response4;
  };
  exports.de_GetSessionTokenCommand = de_GetSessionTokenCommand;
  var de_GetSessionTokenCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error, context);
    const exception = new models_0_1.ExpiredTokenException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error, context);
    const exception = new models_0_1.IDPCommunicationErrorException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error, context);
    const exception = new models_0_1.IDPRejectedClaimException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthorizationMessageException(body.Error, context);
    const exception = new models_0_1.InvalidAuthorizationMessageException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error, context);
    const exception = new models_0_1.InvalidIdentityTokenException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new models_0_1.MalformedPolicyDocumentException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
    const exception = new models_0_1.PackedPolicyTooLargeException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error, context);
    const exception = new models_0_1.RegionDisabledException({
      $metadata: deserializeMetadata(parsedOutput),
      ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
  };
  var se_AssumeRoleRequest = (input, context) => {
    const entries2 = {};
    if (input.RoleArn != null) {
      entries2["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
      entries2["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.PolicyArns != null) {
      const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
      if (input.PolicyArns?.length === 0) {
        entries2.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries2[loc] = value;
      });
    }
    if (input.Policy != null) {
      entries2["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
      entries2["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
      const memberEntries = se_tagListType(input.Tags, context);
      if (input.Tags?.length === 0) {
        entries2.Tags = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `Tags.${key}`;
        entries2[loc] = value;
      });
    }
    if (input.TransitiveTagKeys != null) {
      const memberEntries = se_tagKeyListType(input.TransitiveTagKeys, context);
      if (input.TransitiveTagKeys?.length === 0) {
        entries2.TransitiveTagKeys = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `TransitiveTagKeys.${key}`;
        entries2[loc] = value;
      });
    }
    if (input.ExternalId != null) {
      entries2["ExternalId"] = input.ExternalId;
    }
    if (input.SerialNumber != null) {
      entries2["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
      entries2["TokenCode"] = input.TokenCode;
    }
    if (input.SourceIdentity != null) {
      entries2["SourceIdentity"] = input.SourceIdentity;
    }
    if (input.ProvidedContexts != null) {
      const memberEntries = se_ProvidedContextsListType(input.ProvidedContexts, context);
      if (input.ProvidedContexts?.length === 0) {
        entries2.ProvidedContexts = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `ProvidedContexts.${key}`;
        entries2[loc] = value;
      });
    }
    return entries2;
  };
  var se_AssumeRoleWithSAMLRequest = (input, context) => {
    const entries2 = {};
    if (input.RoleArn != null) {
      entries2["RoleArn"] = input.RoleArn;
    }
    if (input.PrincipalArn != null) {
      entries2["PrincipalArn"] = input.PrincipalArn;
    }
    if (input.SAMLAssertion != null) {
      entries2["SAMLAssertion"] = input.SAMLAssertion;
    }
    if (input.PolicyArns != null) {
      const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
      if (input.PolicyArns?.length === 0) {
        entries2.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries2[loc] = value;
      });
    }
    if (input.Policy != null) {
      entries2["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
      entries2["DurationSeconds"] = input.DurationSeconds;
    }
    return entries2;
  };
  var se_AssumeRoleWithWebIdentityRequest = (input, context) => {
    const entries2 = {};
    if (input.RoleArn != null) {
      entries2["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
      entries2["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.WebIdentityToken != null) {
      entries2["WebIdentityToken"] = input.WebIdentityToken;
    }
    if (input.ProviderId != null) {
      entries2["ProviderId"] = input.ProviderId;
    }
    if (input.PolicyArns != null) {
      const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
      if (input.PolicyArns?.length === 0) {
        entries2.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries2[loc] = value;
      });
    }
    if (input.Policy != null) {
      entries2["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
      entries2["DurationSeconds"] = input.DurationSeconds;
    }
    return entries2;
  };
  var se_DecodeAuthorizationMessageRequest = (input, context) => {
    const entries2 = {};
    if (input.EncodedMessage != null) {
      entries2["EncodedMessage"] = input.EncodedMessage;
    }
    return entries2;
  };
  var se_GetAccessKeyInfoRequest = (input, context) => {
    const entries2 = {};
    if (input.AccessKeyId != null) {
      entries2["AccessKeyId"] = input.AccessKeyId;
    }
    return entries2;
  };
  var se_GetCallerIdentityRequest = (input, context) => {
    const entries2 = {};
    return entries2;
  };
  var se_GetFederationTokenRequest = (input, context) => {
    const entries2 = {};
    if (input.Name != null) {
      entries2["Name"] = input.Name;
    }
    if (input.Policy != null) {
      entries2["Policy"] = input.Policy;
    }
    if (input.PolicyArns != null) {
      const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
      if (input.PolicyArns?.length === 0) {
        entries2.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries2[loc] = value;
      });
    }
    if (input.DurationSeconds != null) {
      entries2["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
      const memberEntries = se_tagListType(input.Tags, context);
      if (input.Tags?.length === 0) {
        entries2.Tags = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `Tags.${key}`;
        entries2[loc] = value;
      });
    }
    return entries2;
  };
  var se_GetSessionTokenRequest = (input, context) => {
    const entries2 = {};
    if (input.DurationSeconds != null) {
      entries2["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.SerialNumber != null) {
      entries2["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
      entries2["TokenCode"] = input.TokenCode;
    }
    return entries2;
  };
  var se_policyDescriptorListType = (input, context) => {
    const entries2 = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_PolicyDescriptorType(entry, context);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries2[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries2;
  };
  var se_PolicyDescriptorType = (input, context) => {
    const entries2 = {};
    if (input.arn != null) {
      entries2["arn"] = input.arn;
    }
    return entries2;
  };
  var se_ProvidedContext = (input, context) => {
    const entries2 = {};
    if (input.ProviderArn != null) {
      entries2["ProviderArn"] = input.ProviderArn;
    }
    if (input.ContextAssertion != null) {
      entries2["ContextAssertion"] = input.ContextAssertion;
    }
    return entries2;
  };
  var se_ProvidedContextsListType = (input, context) => {
    const entries2 = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_ProvidedContext(entry, context);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries2[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries2;
  };
  var se_Tag = (input, context) => {
    const entries2 = {};
    if (input.Key != null) {
      entries2["Key"] = input.Key;
    }
    if (input.Value != null) {
      entries2["Value"] = input.Value;
    }
    return entries2;
  };
  var se_tagKeyListType = (input, context) => {
    const entries2 = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      entries2[`member.${counter}`] = entry;
      counter++;
    }
    return entries2;
  };
  var se_tagListType = (input, context) => {
    const entries2 = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_Tag(entry, context);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries2[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries2;
  };
  var de_AssumedRoleUser = (output, context) => {
    const contents = {};
    if (output["AssumedRoleId"] !== undefined) {
      contents.AssumedRoleId = (0, smithy_client_1.expectString)(output["AssumedRoleId"]);
    }
    if (output["Arn"] !== undefined) {
      contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
  };
  var de_AssumeRoleResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
      contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
      contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
      contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["SourceIdentity"] !== undefined) {
      contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
  };
  var de_AssumeRoleWithSAMLResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
      contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
      contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
      contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Subject"] !== undefined) {
      contents.Subject = (0, smithy_client_1.expectString)(output["Subject"]);
    }
    if (output["SubjectType"] !== undefined) {
      contents.SubjectType = (0, smithy_client_1.expectString)(output["SubjectType"]);
    }
    if (output["Issuer"] !== undefined) {
      contents.Issuer = (0, smithy_client_1.expectString)(output["Issuer"]);
    }
    if (output["Audience"] !== undefined) {
      contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["NameQualifier"] !== undefined) {
      contents.NameQualifier = (0, smithy_client_1.expectString)(output["NameQualifier"]);
    }
    if (output["SourceIdentity"] !== undefined) {
      contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
  };
  var de_AssumeRoleWithWebIdentityResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
      contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["SubjectFromWebIdentityToken"] !== undefined) {
      contents.SubjectFromWebIdentityToken = (0, smithy_client_1.expectString)(output["SubjectFromWebIdentityToken"]);
    }
    if (output["AssumedRoleUser"] !== undefined) {
      contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
      contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Provider"] !== undefined) {
      contents.Provider = (0, smithy_client_1.expectString)(output["Provider"]);
    }
    if (output["Audience"] !== undefined) {
      contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["SourceIdentity"] !== undefined) {
      contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
  };
  var de_Credentials = (output, context) => {
    const contents = {};
    if (output["AccessKeyId"] !== undefined) {
      contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
      contents.SecretAccessKey = (0, smithy_client_1.expectString)(output["SecretAccessKey"]);
    }
    if (output["SessionToken"] !== undefined) {
      contents.SessionToken = (0, smithy_client_1.expectString)(output["SessionToken"]);
    }
    if (output["Expiration"] !== undefined) {
      contents.Expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Expiration"]));
    }
    return contents;
  };
  var de_DecodeAuthorizationMessageResponse = (output, context) => {
    const contents = {};
    if (output["DecodedMessage"] !== undefined) {
      contents.DecodedMessage = (0, smithy_client_1.expectString)(output["DecodedMessage"]);
    }
    return contents;
  };
  var de_ExpiredTokenException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_FederatedUser = (output, context) => {
    const contents = {};
    if (output["FederatedUserId"] !== undefined) {
      contents.FederatedUserId = (0, smithy_client_1.expectString)(output["FederatedUserId"]);
    }
    if (output["Arn"] !== undefined) {
      contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
  };
  var de_GetAccessKeyInfoResponse = (output, context) => {
    const contents = {};
    if (output["Account"] !== undefined) {
      contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    return contents;
  };
  var de_GetCallerIdentityResponse = (output, context) => {
    const contents = {};
    if (output["UserId"] !== undefined) {
      contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    if (output["Account"] !== undefined) {
      contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    if (output["Arn"] !== undefined) {
      contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
  };
  var de_GetFederationTokenResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
      contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["FederatedUser"] !== undefined) {
      contents.FederatedUser = de_FederatedUser(output["FederatedUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
      contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    return contents;
  };
  var de_GetSessionTokenResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
      contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    return contents;
  };
  var de_IDPCommunicationErrorException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_IDPRejectedClaimException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_InvalidAuthorizationMessageException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_InvalidIdentityTokenException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_PackedPolicyTooLargeException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var de_RegionDisabledException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
      contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
  };
  var deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
  var throwDefaultError = (0, smithy_client_1.withBaseException)(STSServiceException_1.STSServiceException);
  var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const contents = {
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
      headers
    };
    if (resolvedHostname !== undefined) {
      contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
      contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
  };
  var SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded"
  };
  var parseBody2 = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      const parser = new fast_xml_parser_1.XMLParser({
        attributeNamePrefix: "",
        htmlEntities: true,
        ignoreAttributes: false,
        ignoreDeclaration: true,
        parseTagValue: false,
        trimValues: false,
        tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : undefined
      });
      parser.addEntity("#xD", "\r");
      parser.addEntity("#10", "\n");
      const parsedObj = parser.parse(encoded);
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
  });
  var parseErrorBody = async (errorBody, context) => {
    const value = await parseBody2(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  };
  var buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value)).join("&");
  var loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/AssumeRoleCommand.js
var require_AssumeRoleCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AssumeRoleCommand = exports.$Command = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_0();
  var Aws_query_1 = require_Aws_query();

  class AssumeRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "AssumeRoleCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.AssumeRoleResponseFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "AssumeRole"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_AssumeRoleCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_AssumeRoleCommand)(output, context);
    }
  }
  exports.AssumeRoleCommand = AssumeRoleCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/AssumeRoleWithWebIdentityCommand.js
var require_AssumeRoleWithWebIdentityCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AssumeRoleWithWebIdentityCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_0();
  var Aws_query_1 = require_Aws_query();

  class AssumeRoleWithWebIdentityCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "AssumeRoleWithWebIdentityCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "AssumeRoleWithWebIdentity"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_AssumeRoleWithWebIdentityCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_AssumeRoleWithWebIdentityCommand)(output, context);
    }
  }
  exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/defaultStsRoleAssumers.js
var require_defaultStsRoleAssumers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = undefined;
  var AssumeRoleCommand_1 = require_AssumeRoleCommand();
  var AssumeRoleWithWebIdentityCommand_1 = require_AssumeRoleWithWebIdentityCommand();
  var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
  var decorateDefaultRegion = (region) => {
    if (typeof region !== "function") {
      return region === undefined ? ASSUME_ROLE_DEFAULT_REGION : region;
    }
    return async () => {
      try {
        return await region();
      } catch (e) {
        return ASSUME_ROLE_DEFAULT_REGION;
      }
    };
  };
  var getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
      closureSourceCreds = sourceCreds;
      if (!stsClient) {
        const { logger, region, requestHandler } = stsOptions;
        stsClient = new stsClientCtor({
          logger,
          credentialDefaultProvider: () => async () => closureSourceCreds,
          region: decorateDefaultRegion(region || stsOptions.region),
          ...requestHandler ? { requestHandler } : {}
        });
      }
      const { Credentials } = await stsClient.send(new AssumeRoleCommand_1.AssumeRoleCommand(params));
      if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
      }
      return {
        accessKeyId: Credentials.AccessKeyId,
        secretAccessKey: Credentials.SecretAccessKey,
        sessionToken: Credentials.SessionToken,
        expiration: Credentials.Expiration
      };
    };
  };
  exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
  var getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
    let stsClient;
    return async (params) => {
      if (!stsClient) {
        const { logger, region, requestHandler } = stsOptions;
        stsClient = new stsClientCtor({
          logger,
          region: decorateDefaultRegion(region || stsOptions.region),
          ...requestHandler ? { requestHandler } : {}
        });
      }
      const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(params));
      if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
      }
      return {
        accessKeyId: Credentials.AccessKeyId,
        secretAccessKey: Credentials.SecretAccessKey,
        sessionToken: Credentials.SessionToken,
        expiration: Credentials.Expiration
      };
    };
  };
  exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
  var decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input, input.stsClientCtor),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input, input.stsClientCtor),
    ...input
  });
  exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;
});

// node_modules/@aws-sdk/core/dist-cjs/client/emitWarningIfUnsupportedVersion.js
var require_emitWarningIfUnsupportedVersion2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.emitWarningIfUnsupportedVersion = undefined;
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
      warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 14.x on May 1, 2024.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to an active Node.js LTS version.

More information can be found at: https://a.co/dzr2AJd`);
    }
  };
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
});

// node_modules/@aws-sdk/core/dist-cjs/client/index.js
var require_client4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_emitWarningIfUnsupportedVersion2(), exports);
});

// node_modules/@aws-sdk/core/dist-cjs/protocols/coercing-serializers.js
var require_coercing_serializers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._toNum = exports._toBool = exports._toStr = undefined;
  var _toStr = (val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "number" || typeof val2 === "bigint") {
      const warning = new Error(`Received number ${val2} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val2);
    }
    if (typeof val2 === "boolean") {
      const warning = new Error(`Received boolean ${val2} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val2);
    }
    return val2;
  };
  exports._toStr = _toStr;
  var _toBool = (val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "number") {
    }
    if (typeof val2 === "string") {
      const lowercase = val2.toLowerCase();
      if (val2 !== "" && lowercase !== "false" && lowercase !== "true") {
        const warning = new Error(`Received string "${val2}" where a boolean was expected.`);
        warning.name = "Warning";
        console.warn(warning);
      }
      return val2 !== "" && lowercase !== "false";
    }
    return val2;
  };
  exports._toBool = _toBool;
  var _toNum = (val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "boolean") {
    }
    if (typeof val2 === "string") {
      const num = Number(val2);
      if (num.toString() !== val2) {
        const warning = new Error(`Received string "${val2}" where a number was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return val2;
      }
      return num;
    }
    return val2;
  };
  exports._toNum = _toNum;
});

// node_modules/@aws-sdk/core/dist-cjs/protocols/json/awsExpectUnion.js
var require_awsExpectUnion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.awsExpectUnion = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var awsExpectUnion = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value === "object" && ("__type" in value)) {
      delete value.__type;
    }
    return (0, smithy_client_1.expectUnion)(value);
  };
  exports.awsExpectUnion = awsExpectUnion;
});

// node_modules/@aws-sdk/core/dist-cjs/protocols/index.js
var require_protocols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_coercing_serializers(), exports);
  tslib_1.__exportStar(require_awsExpectUnion(), exports);
});

// node_modules/@aws-sdk/core/dist-cjs/index.js
var require_dist_cjs43 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_client4(), exports);
  tslib_1.__exportStar(require_protocols(), exports);
});

// node_modules/@aws-sdk/credential-provider-env/dist-cjs/fromEnv.js
var require_fromEnv2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEnv = exports.ENV_EXPIRATION = exports.ENV_SESSION = exports.ENV_SECRET = exports.ENV_KEY = undefined;
  var property_provider_1 = require_dist_cjs19();
  exports.ENV_KEY = "AWS_ACCESS_KEY_ID";
  exports.ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
  exports.ENV_SESSION = "AWS_SESSION_TOKEN";
  exports.ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
  var fromEnv = () => async () => {
    const accessKeyId = process.env[exports.ENV_KEY];
    const secretAccessKey = process.env[exports.ENV_SECRET];
    const sessionToken = process.env[exports.ENV_SESSION];
    const expiry = process.env[exports.ENV_EXPIRATION];
    if (accessKeyId && secretAccessKey) {
      return {
        accessKeyId,
        secretAccessKey,
        ...sessionToken && { sessionToken },
        ...expiry && { expiration: new Date(expiry) }
      };
    }
    throw new property_provider_1.CredentialsProviderError("Unable to find environment variable credentials.");
  };
  exports.fromEnv = fromEnv;
});

// node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js
var require_dist_cjs44 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromEnv2(), exports);
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/remoteProvider/httpRequest.js
var require_httpRequest2 = __commonJS((exports) => {
  var httpRequest = function(options5) {
    return new Promise((resolve, reject) => {
      var _a;
      const req = (0, http_1.request)({
        method: "GET",
        ...options5,
        hostname: (_a = options5.hostname) === null || _a === undefined ? undefined : _a.replace(/^\[(.+)\]$/, "$1")
      });
      req.on("error", (err) => {
        reject(Object.assign(new property_provider_1.ProviderError("Unable to connect to instance metadata service"), err));
        req.destroy();
      });
      req.on("timeout", () => {
        reject(new property_provider_1.ProviderError("TimeoutError from instance metadata service"));
        req.destroy();
      });
      req.on("response", (res) => {
        const { statusCode = 400 } = res;
        if (statusCode < 200 || 300 <= statusCode) {
          reject(Object.assign(new property_provider_1.ProviderError("Error response received from instance metadata service"), { statusCode }));
          req.destroy();
        }
        const chunks = [];
        res.on("data", (chunk) => {
          chunks.push(chunk);
        });
        res.on("end", () => {
          resolve(buffer_1.Buffer.concat(chunks));
          req.destroy();
        });
      });
      req.end();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.httpRequest = undefined;
  var property_provider_1 = require_dist_cjs19();
  var buffer_1 = __require("buffer");
  var http_1 = __require("http");
  exports.httpRequest = httpRequest;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/remoteProvider/ImdsCredentials.js
var require_ImdsCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromImdsCredentials = exports.isImdsCredentials = undefined;
  var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
  exports.isImdsCredentials = isImdsCredentials;
  var fromImdsCredentials = (creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration)
  });
  exports.fromImdsCredentials = fromImdsCredentials;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/remoteProvider/RemoteProviderInit.js
var require_RemoteProviderInit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.providerConfigFromInit = exports.DEFAULT_MAX_RETRIES = exports.DEFAULT_TIMEOUT = undefined;
  exports.DEFAULT_TIMEOUT = 1000;
  exports.DEFAULT_MAX_RETRIES = 0;
  var providerConfigFromInit = ({ maxRetries = exports.DEFAULT_MAX_RETRIES, timeout = exports.DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });
  exports.providerConfigFromInit = providerConfigFromInit;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/remoteProvider/retry.js
var require_retry3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retry = undefined;
  var retry = (toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i2 = 0;i2 < maxRetries; i2++) {
      promise = promise.catch(toRetry);
    }
    return promise;
  };
  exports.retry = retry;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/fromContainerMetadata.js
var require_fromContainerMetadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromContainerMetadata = exports.ENV_CMDS_AUTH_TOKEN = exports.ENV_CMDS_RELATIVE_URI = exports.ENV_CMDS_FULL_URI = undefined;
  var property_provider_1 = require_dist_cjs19();
  var url_1 = __require("url");
  var httpRequest_1 = require_httpRequest2();
  var ImdsCredentials_1 = require_ImdsCredentials();
  var RemoteProviderInit_1 = require_RemoteProviderInit();
  var retry_1 = require_retry3();
  exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
  exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
  exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
  var fromContainerMetadata = (init2 = {}) => {
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init2);
    return () => (0, retry_1.retry)(async () => {
      const requestOptions2 = await getCmdsUri();
      const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions2));
      if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
        throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
      }
      return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
    }, maxRetries);
  };
  exports.fromContainerMetadata = fromContainerMetadata;
  var requestFromEcsImds = async (timeout, options5) => {
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
      options5.headers = {
        ...options5.headers,
        Authorization: process.env[exports.ENV_CMDS_AUTH_TOKEN]
      };
    }
    const buffer = await (0, httpRequest_1.httpRequest)({
      ...options5,
      timeout
    });
    return buffer.toString();
  };
  var CMDS_IP = "169.254.170.2";
  var GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
  };
  var GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
  };
  var getCmdsUri = async () => {
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
      return {
        hostname: CMDS_IP,
        path: process.env[exports.ENV_CMDS_RELATIVE_URI]
      };
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
      const parsed = (0, url_1.parse)(process.env[exports.ENV_CMDS_FULL_URI]);
      if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
        throw new property_provider_1.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
      }
      if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
        throw new property_provider_1.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
      }
      return {
        ...parsed,
        port: parsed.port ? parseInt(parsed.port, 10) : undefined
      };
    }
    throw new property_provider_1.CredentialsProviderError("The container metadata credential provider cannot be used unless" + ` the ${exports.ENV_CMDS_RELATIVE_URI} or ${exports.ENV_CMDS_FULL_URI} environment` + " variable is set", false);
  };
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/config/Endpoint.js
var require_Endpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Endpoint = undefined;
  var Endpoint;
  (function(Endpoint2) {
    Endpoint2["IPv4"] = "http://169.254.169.254";
    Endpoint2["IPv6"] = "http://[fd00:ec2::254]";
  })(Endpoint = exports.Endpoint || (exports.Endpoint = {}));
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/config/EndpointConfigOptions.js
var require_EndpointConfigOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ENDPOINT_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_NAME = exports.ENV_ENDPOINT_NAME = undefined;
  exports.ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
  exports.CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
  exports.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_NAME],
    default: undefined
  };
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/config/EndpointMode.js
var require_EndpointMode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointMode = undefined;
  var EndpointMode;
  (function(EndpointMode2) {
    EndpointMode2["IPv4"] = "IPv4";
    EndpointMode2["IPv6"] = "IPv6";
  })(EndpointMode = exports.EndpointMode || (exports.EndpointMode = {}));
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/config/EndpointModeConfigOptions.js
var require_EndpointModeConfigOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ENDPOINT_MODE_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_MODE_NAME = exports.ENV_ENDPOINT_MODE_NAME = undefined;
  var EndpointMode_1 = require_EndpointMode();
  exports.ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
  exports.CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
  exports.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode_1.EndpointMode.IPv4
  };
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/utils/getInstanceMetadataEndpoint.js
var require_getInstanceMetadataEndpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getInstanceMetadataEndpoint = undefined;
  var node_config_provider_1 = require_dist_cjs34();
  var url_parser_1 = require_dist_cjs36();
  var Endpoint_1 = require_Endpoint();
  var EndpointConfigOptions_1 = require_EndpointConfigOptions();
  var EndpointMode_1 = require_EndpointMode();
  var EndpointModeConfigOptions_1 = require_EndpointModeConfigOptions();
  var getInstanceMetadataEndpoint = async () => (0, url_parser_1.parseUrl)(await getFromEndpointConfig() || await getFromEndpointModeConfig());
  exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
  var getFromEndpointConfig = async () => (0, node_config_provider_1.loadConfig)(EndpointConfigOptions_1.ENDPOINT_CONFIG_OPTIONS)();
  var getFromEndpointModeConfig = async () => {
    const endpointMode = await (0, node_config_provider_1.loadConfig)(EndpointModeConfigOptions_1.ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch (endpointMode) {
      case EndpointMode_1.EndpointMode.IPv4:
        return Endpoint_1.Endpoint.IPv4;
      case EndpointMode_1.EndpointMode.IPv6:
        return Endpoint_1.Endpoint.IPv6;
      default:
        throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode_1.EndpointMode)}`);
    }
  };
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/utils/getExtendedInstanceMetadataCredentials.js
var require_getExtendedInstanceMetadataCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getExtendedInstanceMetadataCredentials = undefined;
  var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
  var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
  var STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
  var getExtendedInstanceMetadataCredentials = (credentials, logger) => {
    var _a;
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " + STATIC_STABILITY_DOC_URL);
    const originalExpiration = (_a = credentials.originalExpiration) !== null && _a !== undefined ? _a : credentials.expiration;
    return {
      ...credentials,
      ...originalExpiration ? { originalExpiration } : {},
      expiration: newExpiration
    };
  };
  exports.getExtendedInstanceMetadataCredentials = getExtendedInstanceMetadataCredentials;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/utils/staticStabilityProvider.js
var require_staticStabilityProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.staticStabilityProvider = undefined;
  var getExtendedInstanceMetadataCredentials_1 = require_getExtendedInstanceMetadataCredentials();
  var staticStabilityProvider = (provider, options5 = {}) => {
    const logger = (options5 === null || options5 === undefined ? undefined : options5.logger) || console;
    let pastCredentials;
    return async () => {
      let credentials;
      try {
        credentials = await provider();
        if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
          credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(credentials, logger);
        }
      } catch (e) {
        if (pastCredentials) {
          logger.warn("Credential renew failed: ", e);
          credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(pastCredentials, logger);
        } else {
          throw e;
        }
      }
      pastCredentials = credentials;
      return credentials;
    };
  };
  exports.staticStabilityProvider = staticStabilityProvider;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/fromInstanceMetadata.js
var require_fromInstanceMetadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromInstanceMetadata = undefined;
  var property_provider_1 = require_dist_cjs19();
  var httpRequest_1 = require_httpRequest2();
  var ImdsCredentials_1 = require_ImdsCredentials();
  var RemoteProviderInit_1 = require_RemoteProviderInit();
  var retry_1 = require_retry3();
  var getInstanceMetadataEndpoint_1 = require_getInstanceMetadataEndpoint();
  var staticStabilityProvider_1 = require_staticStabilityProvider();
  var IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
  var IMDS_TOKEN_PATH = "/latest/api/token";
  var fromInstanceMetadata = (init2 = {}) => (0, staticStabilityProvider_1.staticStabilityProvider)(getInstanceImdsProvider(init2), { logger: init2.logger });
  exports.fromInstanceMetadata = fromInstanceMetadata;
  var getInstanceImdsProvider = (init2) => {
    let disableFetchToken = false;
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init2);
    const getCredentials = async (maxRetries2, options5) => {
      const profile = (await (0, retry_1.retry)(async () => {
        let profile2;
        try {
          profile2 = await getProfile(options5);
        } catch (err) {
          if (err.statusCode === 401) {
            disableFetchToken = false;
          }
          throw err;
        }
        return profile2;
      }, maxRetries2)).trim();
      return (0, retry_1.retry)(async () => {
        let creds;
        try {
          creds = await getCredentialsFromProfile(profile, options5);
        } catch (err) {
          if (err.statusCode === 401) {
            disableFetchToken = false;
          }
          throw err;
        }
        return creds;
      }, maxRetries2);
    };
    return async () => {
      const endpoint = await (0, getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint)();
      if (disableFetchToken) {
        return getCredentials(maxRetries, { ...endpoint, timeout });
      } else {
        let token;
        try {
          token = (await getMetadataToken({ ...endpoint, timeout })).toString();
        } catch (error) {
          if ((error === null || error === undefined ? undefined : error.statusCode) === 400) {
            throw Object.assign(error, {
              message: "EC2 Metadata token request returned error"
            });
          } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
            disableFetchToken = true;
          }
          return getCredentials(maxRetries, { ...endpoint, timeout });
        }
        return getCredentials(maxRetries, {
          ...endpoint,
          headers: {
            "x-aws-ec2-metadata-token": token
          },
          timeout
        });
      }
    };
  };
  var getMetadataToken = async (options5) => (0, httpRequest_1.httpRequest)({
    ...options5,
    path: IMDS_TOKEN_PATH,
    method: "PUT",
    headers: {
      "x-aws-ec2-metadata-token-ttl-seconds": "21600"
    }
  });
  var getProfile = async (options5) => (await (0, httpRequest_1.httpRequest)({ ...options5, path: IMDS_PATH })).toString();
  var getCredentialsFromProfile = async (profile, options5) => {
    const credsResponse = JSON.parse((await (0, httpRequest_1.httpRequest)({
      ...options5,
      path: IMDS_PATH + profile
    })).toString());
    if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
      throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
  };
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/types.js
var require_types8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/index.js
var require_dist_cjs45 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getInstanceMetadataEndpoint = exports.httpRequest = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromContainerMetadata(), exports);
  tslib_1.__exportStar(require_fromInstanceMetadata(), exports);
  tslib_1.__exportStar(require_RemoteProviderInit(), exports);
  tslib_1.__exportStar(require_types8(), exports);
  var httpRequest_1 = require_httpRequest2();
  Object.defineProperty(exports, "httpRequest", { enumerable: true, get: function() {
    return httpRequest_1.httpRequest;
  } });
  var getInstanceMetadataEndpoint_1 = require_getInstanceMetadataEndpoint();
  Object.defineProperty(exports, "getInstanceMetadataEndpoint", { enumerable: true, get: function() {
    return getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint;
  } });
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveCredentialSource.js
var require_resolveCredentialSource = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveCredentialSource = undefined;
  var credential_provider_env_1 = require_dist_cjs44();
  var credential_provider_imds_1 = require_dist_cjs45();
  var property_provider_1 = require_dist_cjs19();
  var resolveCredentialSource = (credentialSource, profileName) => {
    const sourceProvidersMap = {
      EcsContainer: credential_provider_imds_1.fromContainerMetadata,
      Ec2InstanceMetadata: credential_provider_imds_1.fromInstanceMetadata,
      Environment: credential_provider_env_1.fromEnv
    };
    if (credentialSource in sourceProvidersMap) {
      return sourceProvidersMap[credentialSource]();
    } else {
      throw new property_provider_1.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` + `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
    }
  };
  exports.resolveCredentialSource = resolveCredentialSource;
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveAssumeRoleCredentials.js
var require_resolveAssumeRoleCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveAssumeRoleCredentials = exports.isAssumeRoleProfile = undefined;
  var property_provider_1 = require_dist_cjs19();
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var resolveCredentialSource_1 = require_resolveCredentialSource();
  var resolveProfileData_1 = require_resolveProfileData();
  var isAssumeRoleProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
  exports.isAssumeRoleProfile = isAssumeRoleProfile;
  var isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
  var isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
  var resolveAssumeRoleCredentials = async (profileName, profiles, options5, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (!options5.roleAssumer) {
      throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
    }
    const { source_profile } = data;
    if (source_profile && (source_profile in visitedProfiles)) {
      throw new property_provider_1.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` + ` ${(0, shared_ini_file_loader_1.getProfileName)(options5)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
    }
    const sourceCredsProvider = source_profile ? (0, resolveProfileData_1.resolveProfileData)(source_profile, profiles, options5, {
      ...visitedProfiles,
      [source_profile]: true
    }) : (0, resolveCredentialSource_1.resolveCredentialSource)(data.credential_source, profileName)();
    const params = {
      RoleArn: data.role_arn,
      RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
      ExternalId: data.external_id,
      DurationSeconds: parseInt(data.duration_seconds || "3600", 10)
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
      if (!options5.mfaCodeProvider) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
      }
      params.SerialNumber = mfa_serial;
      params.TokenCode = await options5.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options5.roleAssumer(sourceCreds, params);
  };
  exports.resolveAssumeRoleCredentials = resolveAssumeRoleCredentials;
});

// node_modules/@aws-sdk/credential-provider-process/dist-cjs/getValidatedProcessCredentials.js
var require_getValidatedProcessCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getValidatedProcessCredentials = undefined;
  var getValidatedProcessCredentials = (profileName, data) => {
    if (data.Version !== 1) {
      throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
      throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
      const currentTime = new Date;
      const expireTime = new Date(data.Expiration);
      if (expireTime < currentTime) {
        throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
      }
    }
    return {
      accessKeyId: data.AccessKeyId,
      secretAccessKey: data.SecretAccessKey,
      ...data.SessionToken && { sessionToken: data.SessionToken },
      ...data.Expiration && { expiration: new Date(data.Expiration) }
    };
  };
  exports.getValidatedProcessCredentials = getValidatedProcessCredentials;
});

// node_modules/@aws-sdk/credential-provider-process/dist-cjs/resolveProcessCredentials.js
var require_resolveProcessCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveProcessCredentials = undefined;
  var property_provider_1 = require_dist_cjs19();
  var child_process_1 = __require("child_process");
  var util_1 = __require("util");
  var getValidatedProcessCredentials_1 = require_getValidatedProcessCredentials();
  var resolveProcessCredentials = async (profileName, profiles) => {
    const profile = profiles[profileName];
    if (profiles[profileName]) {
      const credentialProcess = profile["credential_process"];
      if (credentialProcess !== undefined) {
        const execPromise = (0, util_1.promisify)(child_process_1.exec);
        try {
          const { stdout } = await execPromise(credentialProcess);
          let data;
          try {
            data = JSON.parse(stdout.trim());
          } catch (_a) {
            throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
          }
          return (0, getValidatedProcessCredentials_1.getValidatedProcessCredentials)(profileName, data);
        } catch (error) {
          throw new property_provider_1.CredentialsProviderError(error.message);
        }
      } else {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
      }
    } else {
      throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
    }
  };
  exports.resolveProcessCredentials = resolveProcessCredentials;
});

// node_modules/@aws-sdk/credential-provider-process/dist-cjs/fromProcess.js
var require_fromProcess = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromProcess = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var resolveProcessCredentials_1 = require_resolveProcessCredentials();
  var fromProcess = (init2 = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init2);
    return (0, resolveProcessCredentials_1.resolveProcessCredentials)((0, shared_ini_file_loader_1.getProfileName)(init2), profiles);
  };
  exports.fromProcess = fromProcess;
});

// node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js
var require_dist_cjs46 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromProcess(), exports);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveProcessCredentials.js
var require_resolveProcessCredentials2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveProcessCredentials = exports.isProcessProfile = undefined;
  var credential_provider_process_1 = require_dist_cjs46();
  var isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
  exports.isProcessProfile = isProcessProfile;
  var resolveProcessCredentials = async (options5, profile) => (0, credential_provider_process_1.fromProcess)({
    ...options5,
    profile
  })();
  exports.resolveProcessCredentials = resolveProcessCredentials;
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/isSsoProfile.js
var require_isSsoProfile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSsoProfile = undefined;
  var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
  exports.isSsoProfile = isSsoProfile;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/EndpointParameters.js
var require_EndpointParameters3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveClientEndpointParameters = undefined;
  var resolveClientEndpointParameters = (options5) => {
    return {
      ...options5,
      useDualstackEndpoint: options5.useDualstackEndpoint ?? false,
      useFipsEndpoint: options5.useFipsEndpoint ?? false,
      defaultSigningName: "awsssoportal"
    };
  };
  exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
});

// node_modules/@aws-sdk/client-sso/package.json
var require_package5 = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.441.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "tsc -p tsconfig.cjs.json",
      "build:docs": "typedoc",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "3.0.0",
      "@aws-crypto/sha256-js": "3.0.0",
      "@aws-sdk/core": "3.441.0",
      "@aws-sdk/middleware-host-header": "3.433.0",
      "@aws-sdk/middleware-logger": "3.433.0",
      "@aws-sdk/middleware-recursion-detection": "3.433.0",
      "@aws-sdk/middleware-user-agent": "3.438.0",
      "@aws-sdk/region-config-resolver": "3.433.0",
      "@aws-sdk/types": "3.433.0",
      "@aws-sdk/util-endpoints": "3.438.0",
      "@aws-sdk/util-user-agent-browser": "3.433.0",
      "@aws-sdk/util-user-agent-node": "3.437.0",
      "@smithy/config-resolver": "^2.0.16",
      "@smithy/fetch-http-handler": "^2.2.4",
      "@smithy/hash-node": "^2.0.12",
      "@smithy/invalid-dependency": "^2.0.12",
      "@smithy/middleware-content-length": "^2.0.14",
      "@smithy/middleware-endpoint": "^2.1.3",
      "@smithy/middleware-retry": "^2.0.18",
      "@smithy/middleware-serde": "^2.0.12",
      "@smithy/middleware-stack": "^2.0.6",
      "@smithy/node-config-provider": "^2.1.3",
      "@smithy/node-http-handler": "^2.1.8",
      "@smithy/protocol-http": "^3.0.8",
      "@smithy/smithy-client": "^2.1.12",
      "@smithy/types": "^2.4.0",
      "@smithy/url-parser": "^2.0.12",
      "@smithy/util-base64": "^2.0.0",
      "@smithy/util-body-length-browser": "^2.0.0",
      "@smithy/util-body-length-node": "^2.1.0",
      "@smithy/util-defaults-mode-browser": "^2.0.16",
      "@smithy/util-defaults-mode-node": "^2.0.21",
      "@smithy/util-endpoints": "^1.0.2",
      "@smithy/util-retry": "^2.0.5",
      "@smithy/util-utf8": "^2.0.0",
      tslib: "^2.5.0"
    },
    devDependencies: {
      "@smithy/service-client-documentation-generator": "^2.0.0",
      "@tsconfig/node14": "1.0.3",
      "@types/node": "^14.14.31",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typedoc: "0.23.23",
      typescript: "~4.9.5"
    },
    engines: {
      node: ">=14.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  };
});

// node_modules/@aws-sdk/util-user-agent-node/dist-cjs/crt-availability.js
var require_crt_availability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crtAvailability = undefined;
  exports.crtAvailability = {
    isCrtAvailable: false
  };
});

// node_modules/@aws-sdk/util-user-agent-node/dist-cjs/is-crt-available.js
var require_is_crt_available = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCrtAvailable = undefined;
  var crt_availability_1 = require_crt_availability();
  var isCrtAvailable = () => {
    if (crt_availability_1.crtAvailability.isCrtAvailable) {
      return ["md/crt-avail"];
    }
    return null;
  };
  exports.isCrtAvailable = isCrtAvailable;
});

// node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs47 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultUserAgent = exports.UA_APP_ID_INI_NAME = exports.UA_APP_ID_ENV_NAME = exports.crtAvailability = undefined;
  var node_config_provider_1 = require_dist_cjs34();
  var os_1 = __require("os");
  var process_1 = __require("process");
  var is_crt_available_1 = require_is_crt_available();
  var crt_availability_1 = require_crt_availability();
  Object.defineProperty(exports, "crtAvailability", { enumerable: true, get: function() {
    return crt_availability_1.crtAvailability;
  } });
  exports.UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
  exports.UA_APP_ID_INI_NAME = "sdk-ua-app-id";
  var defaultUserAgent = ({ serviceId, clientVersion }) => {
    const sections = [
      ["aws-sdk-js", clientVersion],
      ["ua", "2.0"],
      [`os/${(0, os_1.platform)()}`, (0, os_1.release)()],
      ["lang/js"],
      ["md/nodejs", `${process_1.versions.node}`]
    ];
    const crtAvailable = (0, is_crt_available_1.isCrtAvailable)();
    if (crtAvailable) {
      sections.push(crtAvailable);
    }
    if (serviceId) {
      sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (process_1.env.AWS_EXECUTION_ENV) {
      sections.push([`exec-env/${process_1.env.AWS_EXECUTION_ENV}`]);
    }
    const appIdPromise = (0, node_config_provider_1.loadConfig)({
      environmentVariableSelector: (env) => env[exports.UA_APP_ID_ENV_NAME],
      configFileSelector: (profile) => profile[exports.UA_APP_ID_INI_NAME],
      default: undefined
    })();
    let resolvedUserAgent = undefined;
    return async () => {
      if (!resolvedUserAgent) {
        const appId = await appIdPromise;
        resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
      }
      return resolvedUserAgent;
    };
  };
  exports.defaultUserAgent = defaultUserAgent;
});

// node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs48 = __commonJS((exports) => {
  var castSourceData = function(toCast, encoding) {
    if (buffer_1.Buffer.isBuffer(toCast)) {
      return toCast;
    }
    if (typeof toCast === "string") {
      return (0, util_buffer_from_1.fromString)(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
      return (0, util_buffer_from_1.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(toCast);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var util_utf8_1 = require_dist_cjs11();
  var buffer_1 = __require("buffer");
  var crypto_1 = __require("crypto");

  class Hash {
    constructor(algorithmIdentifier, secret) {
      this.algorithmIdentifier = algorithmIdentifier;
      this.secret = secret;
      this.reset();
    }
    update(toHash, encoding) {
      this.hash.update((0, util_utf8_1.toUint8Array)(castSourceData(toHash, encoding)));
    }
    digest() {
      return Promise.resolve(this.hash.digest());
    }
    reset() {
      this.hash = this.secret ? (0, crypto_1.createHmac)(this.algorithmIdentifier, castSourceData(this.secret)) : (0, crypto_1.createHash)(this.algorithmIdentifier);
    }
  }
  exports.Hash = Hash;
});

// node_modules/@smithy/util-body-length-node/dist-cjs/calculateBodyLength.js
var require_calculateBodyLength = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.calculateBodyLength = undefined;
  var fs_1 = __require("fs");
  var calculateBodyLength = (body) => {
    if (!body) {
      return 0;
    }
    if (typeof body === "string") {
      return Buffer.from(body).length;
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    } else if (typeof body.start === "number" && typeof body.end === "number") {
      return body.end + 1 - body.start;
    } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
      return (0, fs_1.lstatSync)(body.path).size;
    } else if (typeof body.fd === "number") {
      return (0, fs_1.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
  };
  exports.calculateBodyLength = calculateBodyLength;
});

// node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs49 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_calculateBodyLength(), exports);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/ruleset.js
var require_ruleset = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var u = "required";
  var v = "fn";
  var w = "argv";
  var x = "ref";
  var a = true;
  var b = "isSet";
  var c = "booleanEquals";
  var d = "error";
  var e = "endpoint";
  var f = "tree";
  var g = "PartitionResult";
  var h = "getAttr";
  var i2 = { [u]: false, type: "String" };
  var j = { [u]: true, default: false, type: "Boolean" };
  var k = { [x]: "Endpoint" };
  var l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
  var m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
  var n = {};
  var o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] };
  var p = { [x]: g };
  var q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
  var r = [l];
  var s = [m];
  var t = [{ [x]: "Region" }];
  var _data = { version: "1.0", parameters: { Region: i2, UseDualStack: j, UseFIPS: j, Endpoint: i2 }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  var ruleset_1 = require_ruleset();
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    });
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var url_parser_1 = require_dist_cjs36();
  var util_base64_1 = require_dist_cjs10();
  var util_utf8_1 = require_dist_cjs11();
  var endpointResolver_1 = require_endpointResolver();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2019-06-10",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      serviceId: config?.serviceId ?? "SSO",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/constants.js
var require_constants9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IMDS_REGION_PATH = exports.DEFAULTS_MODE_OPTIONS = exports.ENV_IMDS_DISABLED = exports.AWS_DEFAULT_REGION_ENV = exports.AWS_REGION_ENV = exports.AWS_EXECUTION_ENV = undefined;
  exports.AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
  exports.AWS_REGION_ENV = "AWS_REGION";
  exports.AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
  exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
  exports.DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
  exports.IMDS_REGION_PATH = "/latest/meta-data/placement/region";
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/defaultsModeConfig.js
var require_defaultsModeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = undefined;
  var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
  var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
  exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
      return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
      return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
  };
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/resolveDefaultsModeConfig.js
var require_resolveDefaultsModeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveDefaultsModeConfig = undefined;
  var config_resolver_1 = require_dist_cjs30();
  var credential_provider_imds_1 = require_dist_cjs45();
  var node_config_provider_1 = require_dist_cjs34();
  var property_provider_1 = require_dist_cjs19();
  var constants_1 = require_constants9();
  var defaultsModeConfig_1 = require_defaultsModeConfig();
  var resolveDefaultsModeConfig = ({ region = (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS), defaultsMode = (0, node_config_provider_1.loadConfig)(defaultsModeConfig_1.NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => (0, property_provider_1.memoize)(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode === null || mode === undefined ? undefined : mode.toLowerCase()) {
      case "auto":
        return resolveNodeDefaultsModeAuto(region);
      case "in-region":
      case "cross-region":
      case "mobile":
      case "standard":
      case "legacy":
        return Promise.resolve(mode === null || mode === undefined ? undefined : mode.toLocaleLowerCase());
      case undefined:
        return Promise.resolve("legacy");
      default:
        throw new Error(`Invalid parameter for "defaultsMode", expect ${constants_1.DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
  });
  exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
  var resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
      const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
      const inferredRegion = await inferPhysicalRegion();
      if (!inferredRegion) {
        return "standard";
      }
      if (resolvedRegion === inferredRegion) {
        return "in-region";
      } else {
        return "cross-region";
      }
    }
    return "standard";
  };
  var inferPhysicalRegion = async () => {
    var _a;
    if (process.env[constants_1.AWS_EXECUTION_ENV] && (process.env[constants_1.AWS_REGION_ENV] || process.env[constants_1.AWS_DEFAULT_REGION_ENV])) {
      return (_a = process.env[constants_1.AWS_REGION_ENV]) !== null && _a !== undefined ? _a : process.env[constants_1.AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[constants_1.ENV_IMDS_DISABLED]) {
      try {
        const endpoint = await (0, credential_provider_imds_1.getInstanceMetadataEndpoint)();
        return (await (0, credential_provider_imds_1.httpRequest)({ ...endpoint, path: constants_1.IMDS_REGION_PATH })).toString();
      } catch (e) {
      }
    }
  };
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs50 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_resolveDefaultsModeConfig(), exports);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.js
var require_runtimeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package5());
  var core_1 = require_dist_cjs43();
  var util_user_agent_node_1 = require_dist_cjs47();
  var config_resolver_1 = require_dist_cjs30();
  var hash_node_1 = require_dist_cjs48();
  var middleware_retry_1 = require_dist_cjs41();
  var node_config_provider_1 = require_dist_cjs34();
  var node_http_handler_1 = require_dist_cjs14();
  var util_body_length_node_1 = require_dist_cjs49();
  var util_retry_1 = require_dist_cjs40();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared();
  var smithy_client_1 = require_dist_cjs16();
  var util_defaults_mode_node_1 = require_dist_cjs50();
  var smithy_client_2 = require_dist_cjs16();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
      requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/extensions/index.js
var require_extensions4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveAwsRegionExtensionConfiguration = exports.getAwsRegionExtensionConfiguration = undefined;
  var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    let runtimeConfigRegion = async () => {
      if (runtimeConfig.region === undefined) {
        throw new Error("Region is missing from runtimeConfig");
      }
      const region = runtimeConfig.region;
      if (typeof region === "string") {
        return region;
      }
      return region();
    };
    return {
      setRegion(region) {
        runtimeConfigRegion = region;
      },
      region() {
        return runtimeConfigRegion;
      }
    };
  };
  exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration;
  var resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
      region: awsRegionExtensionConfiguration.region()
    };
  };
  exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/config.js
var require_config4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = undefined;
  exports.REGION_ENV_NAME = "AWS_REGION";
  exports.REGION_INI_NAME = "region";
  exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
    configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
  };
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/isFipsRegion.js
var require_isFipsRegion2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFipsRegion = undefined;
  var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  exports.isFipsRegion = isFipsRegion;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/getRealRegion.js
var require_getRealRegion2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRealRegion = undefined;
  var isFipsRegion_1 = require_isFipsRegion2();
  var getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  exports.getRealRegion = getRealRegion;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/resolveRegionConfig.js
var require_resolveRegionConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRegionConfig = undefined;
  var getRealRegion_1 = require_getRealRegion2();
  var isFipsRegion_1 = require_isFipsRegion2();
  var resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return {
      ...input,
      region: async () => {
        if (typeof region === "string") {
          return (0, getRealRegion_1.getRealRegion)(region);
        }
        const providedRegion = await region();
        return (0, getRealRegion_1.getRealRegion)(providedRegion);
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    };
  };
  exports.resolveRegionConfig = resolveRegionConfig;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/index.js
var require_regionConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_config4(), exports);
  tslib_1.__exportStar(require_resolveRegionConfig2(), exports);
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs51 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_extensions4(), exports);
  tslib_1.__exportStar(require_regionConfig2(), exports);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/runtimeExtensions.js
var require_runtimeExtensions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRuntimeExtensions = undefined;
  var region_config_resolver_1 = require_dist_cjs51();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var asPartial = (t) => t;
  var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
      ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
      ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
      ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration)
    };
  };
  exports.resolveRuntimeExtensions = resolveRuntimeExtensions;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/SSOClient.js
var require_SSOClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SSOClient = exports.__Client = undefined;
  var middleware_host_header_1 = require_dist_cjs4();
  var middleware_logger_1 = require_dist_cjs5();
  var middleware_recursion_detection_1 = require_dist_cjs6();
  var middleware_user_agent_1 = require_dist_cjs28();
  var config_resolver_1 = require_dist_cjs30();
  var middleware_content_length_1 = require_dist_cjs32();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_retry_1 = require_dist_cjs41();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "__Client", { enumerable: true, get: function() {
    return smithy_client_1.Client;
  } });
  var EndpointParameters_1 = require_EndpointParameters3();
  var runtimeConfig_1 = require_runtimeConfig();
  var runtimeExtensions_1 = require_runtimeExtensions();

  class SSOClient extends smithy_client_1.Client {
    constructor(...[configuration]) {
      const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
      const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
      const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
      const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
      const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
      const _config_7 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_6, configuration?.extensions || []);
      super(_config_7);
      this.config = _config_7;
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  }
  exports.SSOClient = SSOClient;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/models/SSOServiceException.js
var require_SSOServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SSOServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class SSOServiceException extends smithy_client_1.ServiceException {
    constructor(options5) {
      super(options5);
      Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
  }
  exports.SSOServiceException = SSOServiceException;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/models/models_0.js
var require_models_02 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogoutRequestFilterSensitiveLog = exports.ListAccountsRequestFilterSensitiveLog = exports.ListAccountRolesRequestFilterSensitiveLog = exports.GetRoleCredentialsResponseFilterSensitiveLog = exports.RoleCredentialsFilterSensitiveLog = exports.GetRoleCredentialsRequestFilterSensitiveLog = exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var SSOServiceException_1 = require_SSOServiceException();

  class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidRequestException";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
  }
  exports.InvalidRequestException = InvalidRequestException;

  class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
      super({
        name: "ResourceNotFoundException",
        $fault: "client",
        ...opts
      });
      this.name = "ResourceNotFoundException";
      this.$fault = "client";
      Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
  }
  exports.ResourceNotFoundException = ResourceNotFoundException;

  class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
      super({
        name: "TooManyRequestsException",
        $fault: "client",
        ...opts
      });
      this.name = "TooManyRequestsException";
      this.$fault = "client";
      Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
  }
  exports.TooManyRequestsException = TooManyRequestsException;

  class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
      super({
        name: "UnauthorizedException",
        $fault: "client",
        ...opts
      });
      this.name = "UnauthorizedException";
      this.$fault = "client";
      Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
  }
  exports.UnauthorizedException = UnauthorizedException;
  var GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }
  });
  exports.GetRoleCredentialsRequestFilterSensitiveLog = GetRoleCredentialsRequestFilterSensitiveLog;
  var RoleCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.secretAccessKey && { secretAccessKey: smithy_client_1.SENSITIVE_STRING },
    ...obj.sessionToken && { sessionToken: smithy_client_1.SENSITIVE_STRING }
  });
  exports.RoleCredentialsFilterSensitiveLog = RoleCredentialsFilterSensitiveLog;
  var GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.roleCredentials && { roleCredentials: (0, exports.RoleCredentialsFilterSensitiveLog)(obj.roleCredentials) }
  });
  exports.GetRoleCredentialsResponseFilterSensitiveLog = GetRoleCredentialsResponseFilterSensitiveLog;
  var ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }
  });
  exports.ListAccountRolesRequestFilterSensitiveLog = ListAccountRolesRequestFilterSensitiveLog;
  var ListAccountsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }
  });
  exports.ListAccountsRequestFilterSensitiveLog = ListAccountsRequestFilterSensitiveLog;
  var LogoutRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }
  });
  exports.LogoutRequestFilterSensitiveLog = LogoutRequestFilterSensitiveLog;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/protocols/Aws_restJson1.js
var require_Aws_restJson1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.de_LogoutCommand = exports.de_ListAccountsCommand = exports.de_ListAccountRolesCommand = exports.de_GetRoleCredentialsCommand = exports.se_LogoutCommand = exports.se_ListAccountsCommand = exports.se_ListAccountRolesCommand = exports.se_GetRoleCredentialsCommand = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var models_0_1 = require_models_02();
  var SSOServiceException_1 = require_SSOServiceException();
  var se_GetRoleCredentialsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/federation/credentials";
    const query = (0, smithy_client_1.map)({
      role_name: [, (0, smithy_client_1.expectNonNull)(input.roleName, `roleName`)],
      account_id: [, (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetRoleCredentialsCommand = se_GetRoleCredentialsCommand;
  var se_ListAccountRolesCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/roles";
    const query = (0, smithy_client_1.map)({
      next_token: [, input.nextToken],
      max_result: [() => input.maxResults !== undefined, () => input.maxResults.toString()],
      account_id: [, (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListAccountRolesCommand = se_ListAccountRolesCommand;
  var se_ListAccountsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/accounts";
    const query = (0, smithy_client_1.map)({
      next_token: [, input.nextToken],
      max_result: [() => input.maxResults !== undefined, () => input.maxResults.toString()]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListAccountsCommand = se_ListAccountsCommand;
  var se_LogoutCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/logout";
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      body
    });
  };
  exports.se_LogoutCommand = se_LogoutCommand;
  var de_GetRoleCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetRoleCredentialsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
      roleCredentials: smithy_client_1._json
    });
    Object.assign(contents, doc);
    return contents;
  };
  exports.de_GetRoleCredentialsCommand = de_GetRoleCredentialsCommand;
  var de_GetRoleCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InvalidRequestException":
      case "com.amazonaws.sso#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "ResourceNotFoundException":
      case "com.amazonaws.sso#ResourceNotFoundException":
        throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
      case "TooManyRequestsException":
      case "com.amazonaws.sso#TooManyRequestsException":
        throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
      case "UnauthorizedException":
      case "com.amazonaws.sso#UnauthorizedException":
        throw await de_UnauthorizedExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_ListAccountRolesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListAccountRolesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
      nextToken: smithy_client_1.expectString,
      roleList: smithy_client_1._json
    });
    Object.assign(contents, doc);
    return contents;
  };
  exports.de_ListAccountRolesCommand = de_ListAccountRolesCommand;
  var de_ListAccountRolesCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InvalidRequestException":
      case "com.amazonaws.sso#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "ResourceNotFoundException":
      case "com.amazonaws.sso#ResourceNotFoundException":
        throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
      case "TooManyRequestsException":
      case "com.amazonaws.sso#TooManyRequestsException":
        throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
      case "UnauthorizedException":
      case "com.amazonaws.sso#UnauthorizedException":
        throw await de_UnauthorizedExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_ListAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListAccountsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
      accountList: smithy_client_1._json,
      nextToken: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    return contents;
  };
  exports.de_ListAccountsCommand = de_ListAccountsCommand;
  var de_ListAccountsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InvalidRequestException":
      case "com.amazonaws.sso#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "ResourceNotFoundException":
      case "com.amazonaws.sso#ResourceNotFoundException":
        throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
      case "TooManyRequestsException":
      case "com.amazonaws.sso#TooManyRequestsException":
        throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
      case "UnauthorizedException":
      case "com.amazonaws.sso#UnauthorizedException":
        throw await de_UnauthorizedExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_LogoutCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_LogoutCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_LogoutCommand = de_LogoutCommand;
  var de_LogoutCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InvalidRequestException":
      case "com.amazonaws.sso#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "TooManyRequestsException":
      case "com.amazonaws.sso#TooManyRequestsException":
        throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
      case "UnauthorizedException":
      case "com.amazonaws.sso#UnauthorizedException":
        throw await de_UnauthorizedExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var throwDefaultError = (0, smithy_client_1.withBaseException)(SSOServiceException_1.SSOServiceException);
  var de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
      message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidRequestException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
      message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
      message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
      message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
  var isSerializableHeaderValue = (value) => value !== undefined && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
  var parseBody2 = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
  var parseErrorBody = async (errorBody, context) => {
    const value = await parseBody2(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  };
  var loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
      return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
      return sanitizeErrorCode(data["__type"]);
    }
  };
});

// node_modules/@aws-sdk/client-sso/dist-cjs/commands/GetRoleCredentialsCommand.js
var require_GetRoleCredentialsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetRoleCredentialsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_02();
  var Aws_restJson1_1 = require_Aws_restJson1();

  class GetRoleCredentialsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetRoleCredentialsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOClient";
      const commandName = "GetRoleCredentialsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.GetRoleCredentialsRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.GetRoleCredentialsResponseFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "SWBPortalService",
          operation: "GetRoleCredentials"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restJson1_1.se_GetRoleCredentialsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restJson1_1.de_GetRoleCredentialsCommand)(output, context);
    }
  }
  exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/commands/ListAccountRolesCommand.js
var require_ListAccountRolesCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListAccountRolesCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_02();
  var Aws_restJson1_1 = require_Aws_restJson1();

  class ListAccountRolesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountRolesCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOClient";
      const commandName = "ListAccountRolesCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.ListAccountRolesRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "SWBPortalService",
          operation: "ListAccountRoles"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restJson1_1.se_ListAccountRolesCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restJson1_1.de_ListAccountRolesCommand)(output, context);
    }
  }
  exports.ListAccountRolesCommand = ListAccountRolesCommand;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/commands/ListAccountsCommand.js
var require_ListAccountsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListAccountsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_02();
  var Aws_restJson1_1 = require_Aws_restJson1();

  class ListAccountsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOClient";
      const commandName = "ListAccountsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.ListAccountsRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "SWBPortalService",
          operation: "ListAccounts"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restJson1_1.se_ListAccountsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restJson1_1.de_ListAccountsCommand)(output, context);
    }
  }
  exports.ListAccountsCommand = ListAccountsCommand;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/commands/LogoutCommand.js
var require_LogoutCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogoutCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_02();
  var Aws_restJson1_1 = require_Aws_restJson1();

  class LogoutCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, LogoutCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOClient";
      const commandName = "LogoutCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.LogoutRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "SWBPortalService",
          operation: "Logout"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restJson1_1.se_LogoutCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restJson1_1.de_LogoutCommand)(output, context);
    }
  }
  exports.LogoutCommand = LogoutCommand;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/SSO.js
var require_SSO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SSO = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var GetRoleCredentialsCommand_1 = require_GetRoleCredentialsCommand();
  var ListAccountRolesCommand_1 = require_ListAccountRolesCommand();
  var ListAccountsCommand_1 = require_ListAccountsCommand();
  var LogoutCommand_1 = require_LogoutCommand();
  var SSOClient_1 = require_SSOClient();
  var commands = {
    GetRoleCredentialsCommand: GetRoleCredentialsCommand_1.GetRoleCredentialsCommand,
    ListAccountRolesCommand: ListAccountRolesCommand_1.ListAccountRolesCommand,
    ListAccountsCommand: ListAccountsCommand_1.ListAccountsCommand,
    LogoutCommand: LogoutCommand_1.LogoutCommand
  };

  class SSO extends SSOClient_1.SSOClient {
  }
  exports.SSO = SSO;
  (0, smithy_client_1.createAggregatedClient)(commands, SSO);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/commands/index.js
var require_commands = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_GetRoleCredentialsCommand(), exports);
  tslib_1.__exportStar(require_ListAccountRolesCommand(), exports);
  tslib_1.__exportStar(require_ListAccountsCommand(), exports);
  tslib_1.__exportStar(require_LogoutCommand(), exports);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/pagination/Interfaces.js
var require_Interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/client-sso/dist-cjs/pagination/ListAccountRolesPaginator.js
var require_ListAccountRolesPaginator = __commonJS((exports) => {
  async function* paginateListAccountRoles(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
      input.nextToken = token;
      input["maxResults"] = config.pageSize;
      if (config.client instanceof SSOClient_1.SSOClient) {
        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
      } else {
        throw new Error("Invalid client, expected SSO | SSOClient");
      }
      yield page;
      const prevToken = token;
      token = page.nextToken;
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.paginateListAccountRoles = undefined;
  var ListAccountRolesCommand_1 = require_ListAccountRolesCommand();
  var SSOClient_1 = require_SSOClient();
  var makePagedClientRequest = async (client2, input, ...args) => {
    return await client2.send(new ListAccountRolesCommand_1.ListAccountRolesCommand(input), ...args);
  };
  exports.paginateListAccountRoles = paginateListAccountRoles;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/pagination/ListAccountsPaginator.js
var require_ListAccountsPaginator = __commonJS((exports) => {
  async function* paginateListAccounts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
      input.nextToken = token;
      input["maxResults"] = config.pageSize;
      if (config.client instanceof SSOClient_1.SSOClient) {
        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
      } else {
        throw new Error("Invalid client, expected SSO | SSOClient");
      }
      yield page;
      const prevToken = token;
      token = page.nextToken;
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.paginateListAccounts = undefined;
  var ListAccountsCommand_1 = require_ListAccountsCommand();
  var SSOClient_1 = require_SSOClient();
  var makePagedClientRequest = async (client2, input, ...args) => {
    return await client2.send(new ListAccountsCommand_1.ListAccountsCommand(input), ...args);
  };
  exports.paginateListAccounts = paginateListAccounts;
});

// node_modules/@aws-sdk/client-sso/dist-cjs/pagination/index.js
var require_pagination2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_Interfaces(), exports);
  tslib_1.__exportStar(require_ListAccountRolesPaginator(), exports);
  tslib_1.__exportStar(require_ListAccountsPaginator(), exports);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/models/index.js
var require_models = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_models_02(), exports);
});

// node_modules/@aws-sdk/client-sso/dist-cjs/index.js
var require_dist_cjs52 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SSOServiceException = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_SSOClient(), exports);
  tslib_1.__exportStar(require_SSO(), exports);
  tslib_1.__exportStar(require_commands(), exports);
  tslib_1.__exportStar(require_pagination2(), exports);
  tslib_1.__exportStar(require_models(), exports);
  require_dist_cjs27();
  var SSOServiceException_1 = require_SSOServiceException();
  Object.defineProperty(exports, "SSOServiceException", { enumerable: true, get: function() {
    return SSOServiceException_1.SSOServiceException;
  } });
});

// node_modules/@aws-sdk/token-providers/dist-cjs/bundle/client-sso-oidc-node.js
var require_client_sso_oidc_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsupportedGrantTypeException = exports.UnauthorizedClientException = exports.SlowDownException = exports.SSOOIDCClient = exports.InvalidScopeException = exports.InvalidRequestException = exports.InvalidClientException = exports.InternalServerException = exports.ExpiredTokenException = exports.CreateTokenCommand = exports.AuthorizationPendingException = exports.AccessDeniedException = undefined;
  var middleware_host_header_1 = require_dist_cjs4();
  var middleware_logger_1 = require_dist_cjs5();
  var middleware_recursion_detection_1 = require_dist_cjs6();
  var middleware_user_agent_1 = require_dist_cjs28();
  var config_resolver_1 = require_dist_cjs30();
  var middleware_content_length_1 = require_dist_cjs32();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_retry_1 = require_dist_cjs41();
  var smithy_client_1 = require_dist_cjs16();
  var resolveClientEndpointParameters = (options5) => {
    var _a, _b;
    return {
      ...options5,
      useDualstackEndpoint: (_a = options5.useDualstackEndpoint) !== null && _a !== undefined ? _a : false,
      useFipsEndpoint: (_b = options5.useFipsEndpoint) !== null && _b !== undefined ? _b : false,
      defaultSigningName: "awsssooidc"
    };
  };
  var package_default = { version: "3.429.0" };
  var util_user_agent_node_1 = require_dist_cjs47();
  var config_resolver_2 = require_dist_cjs30();
  var hash_node_1 = require_dist_cjs48();
  var middleware_retry_2 = require_dist_cjs41();
  var node_config_provider_1 = require_dist_cjs34();
  var node_http_handler_1 = require_dist_cjs14();
  var util_body_length_node_1 = require_dist_cjs49();
  var util_retry_1 = require_dist_cjs40();
  var smithy_client_2 = require_dist_cjs16();
  var url_parser_1 = require_dist_cjs36();
  var util_base64_1 = require_dist_cjs10();
  var util_utf8_1 = require_dist_cjs11();
  var util_endpoints_1 = require_dist_cjs26();
  var s = "required";
  var t = "fn";
  var u = "argv";
  var v = "ref";
  var a = "isSet";
  var b = "tree";
  var c = "error";
  var d = "endpoint";
  var e = "PartitionResult";
  var f = "getAttr";
  var g = { [s]: false, type: "String" };
  var h = { [s]: true, default: false, type: "Boolean" };
  var i2 = { [v]: "Endpoint" };
  var j = { [t]: "booleanEquals", [u]: [{ [v]: "UseFIPS" }, true] };
  var k = { [t]: "booleanEquals", [u]: [{ [v]: "UseDualStack" }, true] };
  var l = {};
  var m = { [t]: "booleanEquals", [u]: [true, { [t]: f, [u]: [{ [v]: e }, "supportsFIPS"] }] };
  var n = { [v]: e };
  var o = { [t]: "booleanEquals", [u]: [true, { [t]: f, [u]: [n, "supportsDualStack"] }] };
  var p = [j];
  var q = [k];
  var r = [{ [v]: "Region" }];
  var _data = {
    version: "1.0",
    parameters: { Region: g, UseDualStack: h, UseFIPS: h, Endpoint: g },
    rules: [
      {
        conditions: [{ [t]: a, [u]: [i2] }],
        type: b,
        rules: [
          { conditions: p, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c },
          { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c },
          { endpoint: { url: i2, properties: l, headers: l }, type: d }
        ]
      },
      {
        conditions: [{ [t]: a, [u]: r }],
        type: b,
        rules: [
          {
            conditions: [{ [t]: "aws.partition", [u]: r, assign: e }],
            type: b,
            rules: [
              {
                conditions: [j, k],
                type: b,
                rules: [
                  {
                    conditions: [m, o],
                    type: b,
                    rules: [
                      {
                        endpoint: {
                          url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: l,
                          headers: l
                        },
                        type: d
                      }
                    ]
                  },
                  { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }
                ]
              },
              {
                conditions: p,
                type: b,
                rules: [
                  {
                    conditions: [m],
                    type: b,
                    rules: [
                      {
                        conditions: [{ [t]: "stringEquals", [u]: ["aws-us-gov", { [t]: f, [u]: [n, "name"] }] }],
                        endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: l, headers: l },
                        type: d
                      },
                      {
                        endpoint: {
                          url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                          properties: l,
                          headers: l
                        },
                        type: d
                      }
                    ]
                  },
                  { error: "FIPS is enabled but this partition does not support FIPS", type: c }
                ]
              },
              {
                conditions: q,
                type: b,
                rules: [
                  {
                    conditions: [o],
                    type: b,
                    rules: [
                      {
                        endpoint: {
                          url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: l,
                          headers: l
                        },
                        type: d
                      }
                    ]
                  },
                  { error: "DualStack is enabled but this partition does not support DualStack", type: c }
                ]
              },
              {
                endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: l, headers: l },
                type: d
              }
            ]
          }
        ]
      },
      { error: "Invalid Configuration: Missing Region", type: c }
    ]
  };
  var ruleSet = _data;
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleSet, {
      endpointParams,
      logger: context.logger
    });
  };
  var getRuntimeConfig = (config) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return {
      apiVersion: "2019-06-10",
      base64Decoder: (_a = config === null || config === undefined ? undefined : config.base64Decoder) !== null && _a !== undefined ? _a : util_base64_1.fromBase64,
      base64Encoder: (_b = config === null || config === undefined ? undefined : config.base64Encoder) !== null && _b !== undefined ? _b : util_base64_1.toBase64,
      disableHostPrefix: (_c = config === null || config === undefined ? undefined : config.disableHostPrefix) !== null && _c !== undefined ? _c : false,
      endpointProvider: (_d = config === null || config === undefined ? undefined : config.endpointProvider) !== null && _d !== undefined ? _d : defaultEndpointResolver,
      extensions: (_e = config === null || config === undefined ? undefined : config.extensions) !== null && _e !== undefined ? _e : [],
      logger: (_f = config === null || config === undefined ? undefined : config.logger) !== null && _f !== undefined ? _f : new smithy_client_2.NoOpLogger,
      serviceId: (_g = config === null || config === undefined ? undefined : config.serviceId) !== null && _g !== undefined ? _g : "SSO OIDC",
      urlParser: (_h = config === null || config === undefined ? undefined : config.urlParser) !== null && _h !== undefined ? _h : url_parser_1.parseUrl,
      utf8Decoder: (_j = config === null || config === undefined ? undefined : config.utf8Decoder) !== null && _j !== undefined ? _j : util_utf8_1.fromUtf8,
      utf8Encoder: (_k = config === null || config === undefined ? undefined : config.utf8Encoder) !== null && _k !== undefined ? _k : util_utf8_1.toUtf8
    };
  };
  var smithy_client_3 = require_dist_cjs16();
  var util_defaults_mode_node_1 = require_dist_cjs50();
  var smithy_client_4 = require_dist_cjs16();
  var getRuntimeConfig2 = (config) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    (0, smithy_client_4.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_3.loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      bodyLengthChecker: (_a = config === null || config === undefined ? undefined : config.bodyLengthChecker) !== null && _a !== undefined ? _a : util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: (_b = config === null || config === undefined ? undefined : config.defaultUserAgentProvider) !== null && _b !== undefined ? _b : (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
      maxAttempts: (_c = config === null || config === undefined ? undefined : config.maxAttempts) !== null && _c !== undefined ? _c : (0, node_config_provider_1.loadConfig)(middleware_retry_2.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
      region: (_d = config === null || config === undefined ? undefined : config.region) !== null && _d !== undefined ? _d : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_REGION_CONFIG_OPTIONS, config_resolver_2.NODE_REGION_CONFIG_FILE_OPTIONS),
      requestHandler: (_e = config === null || config === undefined ? undefined : config.requestHandler) !== null && _e !== undefined ? _e : new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
      retryMode: (_f = config === null || config === undefined ? undefined : config.retryMode) !== null && _f !== undefined ? _f : (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_2.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }),
      sha256: (_g = config === null || config === undefined ? undefined : config.sha256) !== null && _g !== undefined ? _g : hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: (_h = config === null || config === undefined ? undefined : config.streamCollector) !== null && _h !== undefined ? _h : node_http_handler_1.streamCollector,
      useDualstackEndpoint: (_j = config === null || config === undefined ? undefined : config.useDualstackEndpoint) !== null && _j !== undefined ? _j : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
      useFipsEndpoint: (_k = config === null || config === undefined ? undefined : config.useFipsEndpoint) !== null && _k !== undefined ? _k : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
  };
  var region_config_resolver_1 = require_dist_cjs51();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_5 = require_dist_cjs16();
  var asPartial = (t2) => t2;
  var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
      ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, smithy_client_5.getDefaultExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
      ...(0, smithy_client_5.resolveDefaultRuntimeConfig)(extensionConfiguration),
      ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration)
    };
  };
  var SSOOIDCClient = class extends smithy_client_1.Client {
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig2(configuration || {});
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
      const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
      const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
      const _config_7 = resolveRuntimeExtensions(_config_6, (configuration === null || configuration === undefined ? undefined : configuration.extensions) || []);
      super(_config_7);
      this.config = _config_7;
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
  exports.SSOOIDCClient = SSOOIDCClient;
  var smithy_client_6 = require_dist_cjs16();
  var middleware_endpoint_2 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_7 = require_dist_cjs16();
  var types_1 = require_dist_cjs();
  var protocol_http_2 = require_dist_cjs2();
  var smithy_client_8 = require_dist_cjs16();
  var smithy_client_9 = require_dist_cjs16();
  var SSOOIDCServiceException = class _SSOOIDCServiceException extends smithy_client_9.ServiceException {
    constructor(options5) {
      super(options5);
      Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
    }
  };
  var AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "AccessDeniedException",
        $fault: "client",
        ...opts
      });
      this.name = "AccessDeniedException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _AccessDeniedException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.AccessDeniedException = AccessDeniedException;
  var AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "AuthorizationPendingException",
        $fault: "client",
        ...opts
      });
      this.name = "AuthorizationPendingException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.AuthorizationPendingException = AuthorizationPendingException;
  var ExpiredTokenException = class _ExpiredTokenException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      this.name = "ExpiredTokenException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.ExpiredTokenException = ExpiredTokenException;
  var InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InternalServerException",
        $fault: "server",
        ...opts
      });
      this.name = "InternalServerException";
      this.$fault = "server";
      Object.setPrototypeOf(this, _InternalServerException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.InternalServerException = InternalServerException;
  var InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidClientException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidClientException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _InvalidClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.InvalidClientException = InvalidClientException;
  var InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidGrantException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidGrantException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _InvalidGrantException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var InvalidRequestException = class _InvalidRequestException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidRequestException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _InvalidRequestException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.InvalidRequestException = InvalidRequestException;
  var InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidScopeException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidScopeException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _InvalidScopeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.InvalidScopeException = InvalidScopeException;
  var SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "SlowDownException",
        $fault: "client",
        ...opts
      });
      this.name = "SlowDownException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _SlowDownException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.SlowDownException = SlowDownException;
  var UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "UnauthorizedClientException",
        $fault: "client",
        ...opts
      });
      this.name = "UnauthorizedClientException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.UnauthorizedClientException = UnauthorizedClientException;
  var UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "UnsupportedGrantTypeException",
        $fault: "client",
        ...opts
      });
      this.name = "UnsupportedGrantTypeException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
  var InvalidClientMetadataException = class _InvalidClientMetadataException extends SSOOIDCServiceException {
    constructor(opts) {
      super({
        name: "InvalidClientMetadataException",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidClientMetadataException";
      this.$fault = "client";
      Object.setPrototypeOf(this, _InvalidClientMetadataException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var se_CreateTokenCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {
      "content-type": "application/json"
    };
    const resolvedPath = `${(basePath === null || basePath === undefined ? undefined : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/token`;
    let body;
    body = JSON.stringify((0, smithy_client_8.take)(input, {
      clientId: [],
      clientSecret: [],
      code: [],
      deviceCode: [],
      grantType: [],
      redirectUri: [],
      refreshToken: [],
      scope: (_) => (0, smithy_client_8._json)(_)
    }));
    return new protocol_http_2.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      body
    });
  };
  var se_RegisterClientCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {
      "content-type": "application/json"
    };
    const resolvedPath = `${(basePath === null || basePath === undefined ? undefined : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/client/register`;
    let body;
    body = JSON.stringify((0, smithy_client_8.take)(input, {
      clientName: [],
      clientType: [],
      scopes: (_) => (0, smithy_client_8._json)(_)
    }));
    return new protocol_http_2.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      body
    });
  };
  var se_StartDeviceAuthorizationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {
      "content-type": "application/json"
    };
    const resolvedPath = `${(basePath === null || basePath === undefined ? undefined : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/device_authorization`;
    let body;
    body = JSON.stringify((0, smithy_client_8.take)(input, {
      clientId: [],
      clientSecret: [],
      startUrl: []
    }));
    return new protocol_http_2.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      body
    });
  };
  var de_CreateTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CreateTokenCommandError(output, context);
    }
    const contents = (0, smithy_client_8.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_8.expectNonNull)((0, smithy_client_8.expectObject)(await parseBody2(output.body, context)), "body");
    const doc = (0, smithy_client_8.take)(data, {
      accessToken: smithy_client_8.expectString,
      expiresIn: smithy_client_8.expectInt32,
      idToken: smithy_client_8.expectString,
      refreshToken: smithy_client_8.expectString,
      tokenType: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    return contents;
  };
  var de_CreateTokenCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "AccessDeniedException":
      case "com.amazonaws.ssooidc#AccessDeniedException":
        throw await de_AccessDeniedExceptionRes(parsedOutput, context);
      case "AuthorizationPendingException":
      case "com.amazonaws.ssooidc#AuthorizationPendingException":
        throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
      case "ExpiredTokenException":
      case "com.amazonaws.ssooidc#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
      case "InternalServerException":
      case "com.amazonaws.ssooidc#InternalServerException":
        throw await de_InternalServerExceptionRes(parsedOutput, context);
      case "InvalidClientException":
      case "com.amazonaws.ssooidc#InvalidClientException":
        throw await de_InvalidClientExceptionRes(parsedOutput, context);
      case "InvalidGrantException":
      case "com.amazonaws.ssooidc#InvalidGrantException":
        throw await de_InvalidGrantExceptionRes(parsedOutput, context);
      case "InvalidRequestException":
      case "com.amazonaws.ssooidc#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "InvalidScopeException":
      case "com.amazonaws.ssooidc#InvalidScopeException":
        throw await de_InvalidScopeExceptionRes(parsedOutput, context);
      case "SlowDownException":
      case "com.amazonaws.ssooidc#SlowDownException":
        throw await de_SlowDownExceptionRes(parsedOutput, context);
      case "UnauthorizedClientException":
      case "com.amazonaws.ssooidc#UnauthorizedClientException":
        throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
      case "UnsupportedGrantTypeException":
      case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
        throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_RegisterClientCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_RegisterClientCommandError(output, context);
    }
    const contents = (0, smithy_client_8.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_8.expectNonNull)((0, smithy_client_8.expectObject)(await parseBody2(output.body, context)), "body");
    const doc = (0, smithy_client_8.take)(data, {
      authorizationEndpoint: smithy_client_8.expectString,
      clientId: smithy_client_8.expectString,
      clientIdIssuedAt: smithy_client_8.expectLong,
      clientSecret: smithy_client_8.expectString,
      clientSecretExpiresAt: smithy_client_8.expectLong,
      tokenEndpoint: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    return contents;
  };
  var de_RegisterClientCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InternalServerException":
      case "com.amazonaws.ssooidc#InternalServerException":
        throw await de_InternalServerExceptionRes(parsedOutput, context);
      case "InvalidClientMetadataException":
      case "com.amazonaws.ssooidc#InvalidClientMetadataException":
        throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context);
      case "InvalidRequestException":
      case "com.amazonaws.ssooidc#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "InvalidScopeException":
      case "com.amazonaws.ssooidc#InvalidScopeException":
        throw await de_InvalidScopeExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_StartDeviceAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_StartDeviceAuthorizationCommandError(output, context);
    }
    const contents = (0, smithy_client_8.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_8.expectNonNull)((0, smithy_client_8.expectObject)(await parseBody2(output.body, context)), "body");
    const doc = (0, smithy_client_8.take)(data, {
      deviceCode: smithy_client_8.expectString,
      expiresIn: smithy_client_8.expectInt32,
      interval: smithy_client_8.expectInt32,
      userCode: smithy_client_8.expectString,
      verificationUri: smithy_client_8.expectString,
      verificationUriComplete: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    return contents;
  };
  var de_StartDeviceAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InternalServerException":
      case "com.amazonaws.ssooidc#InternalServerException":
        throw await de_InternalServerExceptionRes(parsedOutput, context);
      case "InvalidClientException":
      case "com.amazonaws.ssooidc#InvalidClientException":
        throw await de_InvalidClientExceptionRes(parsedOutput, context);
      case "InvalidRequestException":
      case "com.amazonaws.ssooidc#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "SlowDownException":
      case "com.amazonaws.ssooidc#SlowDownException":
        throw await de_SlowDownExceptionRes(parsedOutput, context);
      case "UnauthorizedClientException":
      case "com.amazonaws.ssooidc#UnauthorizedClientException":
        throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var throwDefaultError = (0, smithy_client_8.withBaseException)(SSOOIDCServiceException);
  var de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new AuthorizationPendingException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new ExpiredTokenException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InvalidClientExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InvalidClientMetadataExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientMetadataException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidGrantException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidScopeException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_SlowDownExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new SlowDownException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
      error: smithy_client_8.expectString,
      error_description: smithy_client_8.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedGrantTypeException({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
  };
  var deserializeMetadata = (output) => {
    var _a, _b;
    return {
      httpStatusCode: output.statusCode,
      requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== undefined ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== undefined ? _b : output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    };
  };
  var collectBodyString = (streamBody, context) => (0, smithy_client_8.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
  var parseBody2 = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
  var parseErrorBody = async (errorBody, context) => {
    var _a;
    const value = await parseBody2(errorBody, context);
    value.message = (_a = value.message) !== null && _a !== undefined ? _a : value.Message;
    return value;
  };
  var loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k2) => k2.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
      return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
      return sanitizeErrorCode(data["__type"]);
    }
  };
  var CreateTokenCommand = class _CreateTokenCommand extends smithy_client_7.Command {
    constructor(input) {
      super();
      this.input = input;
    }
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_2.getEndpointPlugin)(configuration, _CreateTokenCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOOIDCClient";
      const commandName = "CreateTokenCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSSOOIDCService",
          operation: "CreateToken"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return se_CreateTokenCommand(input, context);
    }
    deserialize(output, context) {
      return de_CreateTokenCommand(output, context);
    }
  };
  exports.CreateTokenCommand = CreateTokenCommand;
  var middleware_endpoint_3 = require_dist_cjs38();
  var middleware_serde_2 = require_dist_cjs37();
  var smithy_client_10 = require_dist_cjs16();
  var types_2 = require_dist_cjs();
  var RegisterClientCommand = class _RegisterClientCommand extends smithy_client_10.Command {
    constructor(input) {
      super();
      this.input = input;
    }
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_2.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_3.getEndpointPlugin)(configuration, _RegisterClientCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOOIDCClient";
      const commandName = "RegisterClientCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_2.SMITHY_CONTEXT_KEY]: {
          service: "AWSSSOOIDCService",
          operation: "RegisterClient"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return se_RegisterClientCommand(input, context);
    }
    deserialize(output, context) {
      return de_RegisterClientCommand(output, context);
    }
  };
  var middleware_endpoint_4 = require_dist_cjs38();
  var middleware_serde_3 = require_dist_cjs37();
  var smithy_client_11 = require_dist_cjs16();
  var types_3 = require_dist_cjs();
  var StartDeviceAuthorizationCommand = class _StartDeviceAuthorizationCommand extends smithy_client_11.Command {
    constructor(input) {
      super();
      this.input = input;
    }
    static getEndpointParameterInstructions() {
      return {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_3.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_4.getEndpointPlugin)(configuration, _StartDeviceAuthorizationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "SSOOIDCClient";
      const commandName = "StartDeviceAuthorizationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_3.SMITHY_CONTEXT_KEY]: {
          service: "AWSSSOOIDCService",
          operation: "StartDeviceAuthorization"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return se_StartDeviceAuthorizationCommand(input, context);
    }
    deserialize(output, context) {
      return de_StartDeviceAuthorizationCommand(output, context);
    }
  };
  var commands = {
    CreateTokenCommand,
    RegisterClientCommand,
    StartDeviceAuthorizationCommand
  };
  var SSOOIDC = class extends SSOOIDCClient {
  };
  (0, smithy_client_6.createAggregatedClient)(commands, SSOOIDC);
});

// node_modules/@aws-sdk/token-providers/dist-cjs/constants.js
var require_constants10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REFRESH_MESSAGE = exports.EXPIRE_WINDOW_MS = undefined;
  exports.EXPIRE_WINDOW_MS = 5 * 60 * 1000;
  exports.REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/getSsoOidcClient.js
var require_getSsoOidcClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSsoOidcClient = undefined;
  var client_sso_oidc_node_1 = require_client_sso_oidc_node();
  var ssoOidcClientsHash = {};
  var getSsoOidcClient = (ssoRegion) => {
    if (ssoOidcClientsHash[ssoRegion]) {
      return ssoOidcClientsHash[ssoRegion];
    }
    const ssoOidcClient = new client_sso_oidc_node_1.SSOOIDCClient({ region: ssoRegion });
    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
    return ssoOidcClient;
  };
  exports.getSsoOidcClient = getSsoOidcClient;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/getNewSsoOidcToken.js
var require_getNewSsoOidcToken = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getNewSsoOidcToken = undefined;
  var client_sso_oidc_node_1 = require_client_sso_oidc_node();
  var getSsoOidcClient_1 = require_getSsoOidcClient();
  var getNewSsoOidcToken = (ssoToken, ssoRegion) => {
    const ssoOidcClient = (0, getSsoOidcClient_1.getSsoOidcClient)(ssoRegion);
    return ssoOidcClient.send(new client_sso_oidc_node_1.CreateTokenCommand({
      clientId: ssoToken.clientId,
      clientSecret: ssoToken.clientSecret,
      refreshToken: ssoToken.refreshToken,
      grantType: "refresh_token"
    }));
  };
  exports.getNewSsoOidcToken = getNewSsoOidcToken;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/validateTokenExpiry.js
var require_validateTokenExpiry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTokenExpiry = undefined;
  var property_provider_1 = require_dist_cjs19();
  var constants_1 = require_constants10();
  var validateTokenExpiry = (token) => {
    if (token.expiration && token.expiration.getTime() < Date.now()) {
      throw new property_provider_1.TokenProviderError(`Token is expired. ${constants_1.REFRESH_MESSAGE}`, false);
    }
  };
  exports.validateTokenExpiry = validateTokenExpiry;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/validateTokenKey.js
var require_validateTokenKey = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTokenKey = undefined;
  var property_provider_1 = require_dist_cjs19();
  var constants_1 = require_constants10();
  var validateTokenKey = (key, value, forRefresh = false) => {
    if (typeof value === "undefined") {
      throw new property_provider_1.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${constants_1.REFRESH_MESSAGE}`, false);
    }
  };
  exports.validateTokenKey = validateTokenKey;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/writeSSOTokenToFile.js
var require_writeSSOTokenToFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeSSOTokenToFile = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var fs_1 = __require("fs");
  var { writeFile } = fs_1.promises;
  var writeSSOTokenToFile = (id, ssoToken) => {
    const tokenFilepath = (0, shared_ini_file_loader_1.getSSOTokenFilepath)(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
  };
  exports.writeSSOTokenToFile = writeSSOTokenToFile;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/fromSso.js
var require_fromSso = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSso = undefined;
  var property_provider_1 = require_dist_cjs19();
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var constants_1 = require_constants10();
  var getNewSsoOidcToken_1 = require_getNewSsoOidcToken();
  var validateTokenExpiry_1 = require_validateTokenExpiry();
  var validateTokenKey_1 = require_validateTokenKey();
  var writeSSOTokenToFile_1 = require_writeSSOTokenToFile();
  var lastRefreshAttemptTime = new Date(0);
  var fromSso = (init2 = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init2);
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init2);
    const profile = profiles[profileName];
    if (!profile) {
      throw new property_provider_1.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
    } else if (!profile["sso_session"]) {
      throw new property_provider_1.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
    }
    const ssoSessionName = profile["sso_session"];
    const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init2);
    const ssoSession = ssoSessions[ssoSessionName];
    if (!ssoSession) {
      throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
    }
    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
      if (!ssoSession[ssoSessionRequiredKey]) {
        throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
      }
    }
    const ssoStartUrl = ssoSession["sso_start_url"];
    const ssoRegion = ssoSession["sso_region"];
    let ssoToken;
    try {
      ssoToken = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoSessionName);
    } catch (e) {
      throw new property_provider_1.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${constants_1.REFRESH_MESSAGE}`, false);
    }
    (0, validateTokenKey_1.validateTokenKey)("accessToken", ssoToken.accessToken);
    (0, validateTokenKey_1.validateTokenKey)("expiresAt", ssoToken.expiresAt);
    const { accessToken, expiresAt } = ssoToken;
    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
    if (existingToken.expiration.getTime() - Date.now() > constants_1.EXPIRE_WINDOW_MS) {
      return existingToken;
    }
    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
      (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
      return existingToken;
    }
    (0, validateTokenKey_1.validateTokenKey)("clientId", ssoToken.clientId, true);
    (0, validateTokenKey_1.validateTokenKey)("clientSecret", ssoToken.clientSecret, true);
    (0, validateTokenKey_1.validateTokenKey)("refreshToken", ssoToken.refreshToken, true);
    try {
      lastRefreshAttemptTime.setTime(Date.now());
      const newSsoOidcToken = await (0, getNewSsoOidcToken_1.getNewSsoOidcToken)(ssoToken, ssoRegion);
      (0, validateTokenKey_1.validateTokenKey)("accessToken", newSsoOidcToken.accessToken);
      (0, validateTokenKey_1.validateTokenKey)("expiresIn", newSsoOidcToken.expiresIn);
      const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
      try {
        await (0, writeSSOTokenToFile_1.writeSSOTokenToFile)(ssoSessionName, {
          ...ssoToken,
          accessToken: newSsoOidcToken.accessToken,
          expiresAt: newTokenExpiration.toISOString(),
          refreshToken: newSsoOidcToken.refreshToken
        });
      } catch (error) {
      }
      return {
        token: newSsoOidcToken.accessToken,
        expiration: newTokenExpiration
      };
    } catch (error) {
      (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
      return existingToken;
    }
  };
  exports.fromSso = fromSso;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/fromStatic.js
var require_fromStatic3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromStatic = undefined;
  var property_provider_1 = require_dist_cjs19();
  var fromStatic = ({ token }) => async () => {
    if (!token || !token.token) {
      throw new property_provider_1.TokenProviderError(`Please pass a valid token to fromStatic`, false);
    }
    return token;
  };
  exports.fromStatic = fromStatic;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/nodeProvider.js
var require_nodeProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nodeProvider = undefined;
  var property_provider_1 = require_dist_cjs19();
  var fromSso_1 = require_fromSso();
  var nodeProvider = (init2 = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromSso_1.fromSso)(init2), async () => {
    throw new property_provider_1.TokenProviderError("Could not load token from any providers", false);
  }), (token) => token.expiration !== undefined && token.expiration.getTime() - Date.now() < 300000, (token) => token.expiration !== undefined);
  exports.nodeProvider = nodeProvider;
});

// node_modules/@aws-sdk/token-providers/dist-cjs/index.js
var require_dist_cjs53 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_client_sso_oidc_node(), exports);
  tslib_1.__exportStar(require_fromSso(), exports);
  tslib_1.__exportStar(require_fromStatic3(), exports);
  tslib_1.__exportStar(require_nodeProvider(), exports);
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/resolveSSOCredentials.js
var require_resolveSSOCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSSOCredentials = undefined;
  var client_sso_1 = require_dist_cjs52();
  var token_providers_1 = require_dist_cjs53();
  var property_provider_1 = require_dist_cjs19();
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
  var resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
    let token;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
      try {
        const _token = await (0, token_providers_1.fromSso)({ profile })();
        token = {
          accessToken: _token.token,
          expiresAt: new Date(_token.expiration).toISOString()
        };
      } catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
      }
    } else {
      try {
        token = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoStartUrl);
      } catch (e) {
        throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
      }
    }
    if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
      throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { accessToken } = token;
    const sso = ssoClient || new client_sso_1.SSOClient({ region: ssoRegion });
    let ssoResp;
    try {
      ssoResp = await sso.send(new client_sso_1.GetRoleCredentialsCommand({
        accountId: ssoAccountId,
        roleName: ssoRoleName,
        accessToken
      }));
    } catch (e) {
      throw property_provider_1.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
      throw new property_provider_1.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
  };
  exports.resolveSSOCredentials = resolveSSOCredentials;
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/validateSsoProfile.js
var require_validateSsoProfile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSsoProfile = undefined;
  var property_provider_1 = require_dist_cjs19();
  var validateSsoProfile = (profile) => {
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
      throw new property_provider_1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` + `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
    }
    return profile;
  };
  exports.validateSsoProfile = validateSsoProfile;
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/fromSSO.js
var require_fromSSO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSSO = undefined;
  var property_provider_1 = require_dist_cjs19();
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var isSsoProfile_1 = require_isSsoProfile();
  var resolveSSOCredentials_1 = require_resolveSSOCredentials();
  var validateSsoProfile_1 = require_validateSsoProfile();
  var fromSSO = (init2 = {}) => async () => {
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init2;
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init2);
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
      const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init2);
      const profile = profiles[profileName];
      if (!profile) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} was not found.`);
      }
      if (!(0, isSsoProfile_1.isSsoProfile)(profile)) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
      }
      if (profile === null || profile === undefined ? undefined : profile.sso_session) {
        const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init2);
        const session = ssoSessions[profile.sso_session];
        const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
        if (ssoRegion && ssoRegion !== session.sso_region) {
          throw new property_provider_1.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
        }
        if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
          throw new property_provider_1.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
        }
        profile.sso_region = session.sso_region;
        profile.sso_start_url = session.sso_start_url;
      }
      const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = (0, validateSsoProfile_1.validateSsoProfile)(profile);
      return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
        ssoStartUrl: sso_start_url,
        ssoSession: sso_session,
        ssoAccountId: sso_account_id,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name,
        ssoClient,
        profile: profileName
      });
    } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
      throw new property_provider_1.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
    } else {
      return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
        ssoStartUrl,
        ssoSession,
        ssoAccountId,
        ssoRegion,
        ssoRoleName,
        ssoClient,
        profile: profileName
      });
    }
  };
  exports.fromSSO = fromSSO;
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/types.js
var require_types9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js
var require_dist_cjs54 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromSSO(), exports);
  tslib_1.__exportStar(require_isSsoProfile(), exports);
  tslib_1.__exportStar(require_types9(), exports);
  tslib_1.__exportStar(require_validateSsoProfile(), exports);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveSsoCredentials.js
var require_resolveSsoCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSsoCredentials = exports.isSsoProfile = undefined;
  var credential_provider_sso_1 = require_dist_cjs54();
  var credential_provider_sso_2 = require_dist_cjs54();
  Object.defineProperty(exports, "isSsoProfile", { enumerable: true, get: function() {
    return credential_provider_sso_2.isSsoProfile;
  } });
  var resolveSsoCredentials = (data) => {
    const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = (0, credential_provider_sso_1.validateSsoProfile)(data);
    return (0, credential_provider_sso_1.fromSSO)({
      ssoStartUrl: sso_start_url,
      ssoAccountId: sso_account_id,
      ssoSession: sso_session,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name
    })();
  };
  exports.resolveSsoCredentials = resolveSsoCredentials;
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveStaticCredentials.js
var require_resolveStaticCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveStaticCredentials = exports.isStaticCredsProfile = undefined;
  var isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
  exports.isStaticCredsProfile = isStaticCredsProfile;
  var resolveStaticCredentials = (profile) => Promise.resolve({
    accessKeyId: profile.aws_access_key_id,
    secretAccessKey: profile.aws_secret_access_key,
    sessionToken: profile.aws_session_token
  });
  exports.resolveStaticCredentials = resolveStaticCredentials;
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js
var require_fromWebToken = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromWebToken = undefined;
  var property_provider_1 = require_dist_cjs19();
  var fromWebToken = (init2) => () => {
    const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init2;
    if (!roleAssumerWithWebIdentity) {
      throw new property_provider_1.CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity,` + ` but no role assumption callback was provided.`, false);
    }
    return roleAssumerWithWebIdentity({
      RoleArn: roleArn,
      RoleSessionName: roleSessionName !== null && roleSessionName !== undefined ? roleSessionName : `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: webIdentityToken,
      ProviderId: providerId,
      PolicyArns: policyArns,
      Policy: policy,
      DurationSeconds: durationSeconds
    });
  };
  exports.fromWebToken = fromWebToken;
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js
var require_fromTokenFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromTokenFile = undefined;
  var property_provider_1 = require_dist_cjs19();
  var fs_1 = __require("fs");
  var fromWebToken_1 = require_fromWebToken();
  var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
  var ENV_ROLE_ARN = "AWS_ROLE_ARN";
  var ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
  var fromTokenFile = (init2 = {}) => async () => {
    var _a, _b, _c;
    const webIdentityTokenFile = (_a = init2 === null || init2 === undefined ? undefined : init2.webIdentityTokenFile) !== null && _a !== undefined ? _a : process.env[ENV_TOKEN_FILE];
    const roleArn = (_b = init2 === null || init2 === undefined ? undefined : init2.roleArn) !== null && _b !== undefined ? _b : process.env[ENV_ROLE_ARN];
    const roleSessionName = (_c = init2 === null || init2 === undefined ? undefined : init2.roleSessionName) !== null && _c !== undefined ? _c : process.env[ENV_ROLE_SESSION_NAME];
    if (!webIdentityTokenFile || !roleArn) {
      throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified");
    }
    return (0, fromWebToken_1.fromWebToken)({
      ...init2,
      webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
      roleArn,
      roleSessionName
    })();
  };
  exports.fromTokenFile = fromTokenFile;
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js
var require_dist_cjs55 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromTokenFile(), exports);
  tslib_1.__exportStar(require_fromWebToken(), exports);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveWebIdentityCredentials.js
var require_resolveWebIdentityCredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveWebIdentityCredentials = exports.isWebIdentityProfile = undefined;
  var credential_provider_web_identity_1 = require_dist_cjs55();
  var isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
  exports.isWebIdentityProfile = isWebIdentityProfile;
  var resolveWebIdentityCredentials = async (profile, options5) => (0, credential_provider_web_identity_1.fromTokenFile)({
    webIdentityTokenFile: profile.web_identity_token_file,
    roleArn: profile.role_arn,
    roleSessionName: profile.role_session_name,
    roleAssumerWithWebIdentity: options5.roleAssumerWithWebIdentity
  })();
  exports.resolveWebIdentityCredentials = resolveWebIdentityCredentials;
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/resolveProfileData.js
var require_resolveProfileData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveProfileData = undefined;
  var property_provider_1 = require_dist_cjs19();
  var resolveAssumeRoleCredentials_1 = require_resolveAssumeRoleCredentials();
  var resolveProcessCredentials_1 = require_resolveProcessCredentials2();
  var resolveSsoCredentials_1 = require_resolveSsoCredentials();
  var resolveStaticCredentials_1 = require_resolveStaticCredentials();
  var resolveWebIdentityCredentials_1 = require_resolveWebIdentityCredentials();
  var resolveProfileData = async (profileName, profiles, options5, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && (0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
      return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveAssumeRoleCredentials_1.isAssumeRoleProfile)(data)) {
      return (0, resolveAssumeRoleCredentials_1.resolveAssumeRoleCredentials)(profileName, profiles, options5, visitedProfiles);
    }
    if ((0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
      return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveWebIdentityCredentials_1.isWebIdentityProfile)(data)) {
      return (0, resolveWebIdentityCredentials_1.resolveWebIdentityCredentials)(data, options5);
    }
    if ((0, resolveProcessCredentials_1.isProcessProfile)(data)) {
      return (0, resolveProcessCredentials_1.resolveProcessCredentials)(options5, profileName);
    }
    if ((0, resolveSsoCredentials_1.isSsoProfile)(data)) {
      return (0, resolveSsoCredentials_1.resolveSsoCredentials)(data);
    }
    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
  };
  exports.resolveProfileData = resolveProfileData;
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/fromIni.js
var require_fromIni = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromIni = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var resolveProfileData_1 = require_resolveProfileData();
  var fromIni = (init2 = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init2);
    return (0, resolveProfileData_1.resolveProfileData)((0, shared_ini_file_loader_1.getProfileName)(init2), profiles, init2);
  };
  exports.fromIni = fromIni;
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js
var require_dist_cjs56 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fromIni(), exports);
});

// node_modules/@aws-sdk/credential-provider-node/dist-cjs/remoteProvider.js
var require_remoteProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.remoteProvider = exports.ENV_IMDS_DISABLED = undefined;
  var credential_provider_imds_1 = require_dist_cjs45();
  var property_provider_1 = require_dist_cjs19();
  exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
  var remoteProvider = (init2) => {
    if (process.env[credential_provider_imds_1.ENV_CMDS_RELATIVE_URI] || process.env[credential_provider_imds_1.ENV_CMDS_FULL_URI]) {
      return (0, credential_provider_imds_1.fromContainerMetadata)(init2);
    }
    if (process.env[exports.ENV_IMDS_DISABLED]) {
      return async () => {
        throw new property_provider_1.CredentialsProviderError("EC2 Instance Metadata Service access disabled");
      };
    }
    return (0, credential_provider_imds_1.fromInstanceMetadata)(init2);
  };
  exports.remoteProvider = remoteProvider;
});

// node_modules/@aws-sdk/credential-provider-node/dist-cjs/defaultProvider.js
var require_defaultProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultProvider = undefined;
  var credential_provider_env_1 = require_dist_cjs44();
  var credential_provider_ini_1 = require_dist_cjs56();
  var credential_provider_process_1 = require_dist_cjs46();
  var credential_provider_sso_1 = require_dist_cjs54();
  var credential_provider_web_identity_1 = require_dist_cjs55();
  var property_provider_1 = require_dist_cjs19();
  var shared_ini_file_loader_1 = require_dist_cjs33();
  var remoteProvider_1 = require_remoteProvider();
  var defaultProvider = (init2 = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)(...init2.profile || process.env[shared_ini_file_loader_1.ENV_PROFILE] ? [] : [(0, credential_provider_env_1.fromEnv)()], (0, credential_provider_sso_1.fromSSO)(init2), (0, credential_provider_ini_1.fromIni)(init2), (0, credential_provider_process_1.fromProcess)(init2), (0, credential_provider_web_identity_1.fromTokenFile)(init2), (0, remoteProvider_1.remoteProvider)(init2), async () => {
    throw new property_provider_1.CredentialsProviderError("Could not load credentials from any providers", false);
  }), (credentials) => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000, (credentials) => credentials.expiration !== undefined);
  exports.defaultProvider = defaultProvider;
});

// node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js
var require_dist_cjs57 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_defaultProvider(), exports);
});

// node_modules/@aws-sdk/client-sts/dist-cjs/endpoint/ruleset.js
var require_ruleset2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var F = "required";
  var G = "type";
  var H = "fn";
  var I = "argv";
  var J = "ref";
  var a = false;
  var b = true;
  var c = "booleanEquals";
  var d = "stringEquals";
  var e = "sigv4";
  var f = "sts";
  var g = "us-east-1";
  var h = "endpoint";
  var i2 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
  var j = "tree";
  var k = "error";
  var l = "getAttr";
  var m = { [F]: false, [G]: "String" };
  var n = { [F]: true, default: false, [G]: "Boolean" };
  var o = { [J]: "Endpoint" };
  var p = { [H]: "isSet", [I]: [{ [J]: "Region" }] };
  var q = { [J]: "Region" };
  var r = { [H]: "aws.partition", [I]: [q], assign: "PartitionResult" };
  var s = { [J]: "UseFIPS" };
  var t = { [J]: "UseDualStack" };
  var u = { url: "https://sts.amazonaws.com", properties: { authSchemes: [{ name: e, signingName: f, signingRegion: g }] }, headers: {} };
  var v = {};
  var w = { conditions: [{ [H]: d, [I]: [q, "aws-global"] }], [h]: u, [G]: h };
  var x = { [H]: c, [I]: [s, true] };
  var y = { [H]: c, [I]: [t, true] };
  var z = { [H]: l, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] };
  var A = { [J]: "PartitionResult" };
  var B = { [H]: c, [I]: [true, { [H]: l, [I]: [A, "supportsDualStack"] }] };
  var C = [{ [H]: "isSet", [I]: [o] }];
  var D = [x];
  var E = [y];
  var _data = { version: "1.0", parameters: { Region: m, UseDualStack: n, UseFIPS: n, Endpoint: m, UseGlobalEndpoint: n }, rules: [{ conditions: [{ [H]: c, [I]: [{ [J]: "UseGlobalEndpoint" }, b] }, { [H]: "not", [I]: C }, p, r, { [H]: c, [I]: [s, a] }, { [H]: c, [I]: [t, a] }], rules: [{ conditions: [{ [H]: d, [I]: [q, "ap-northeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-south-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-2"] }], endpoint: u, [G]: h }, w, { conditions: [{ [H]: d, [I]: [q, "ca-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-north-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-3"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "sa-east-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, g] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-east-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-2"] }], endpoint: u, [G]: h }, { endpoint: { url: i2, properties: { authSchemes: [{ name: e, signingName: f, signingRegion: "{Region}" }] }, headers: v }, [G]: h }], [G]: j }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k }, { endpoint: { url: o, properties: v, headers: v }, [G]: h }], [G]: j }, { conditions: [p], rules: [{ conditions: [r], rules: [{ conditions: [x, y], rules: [{ conditions: [{ [H]: c, [I]: [b, z] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k }], [G]: j }, { conditions: D, rules: [{ conditions: [{ [H]: c, [I]: [z, b] }], rules: [{ conditions: [{ [H]: d, [I]: [{ [H]: l, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v }, [G]: h }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k }], [G]: j }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k }], [G]: j }, w, { endpoint: { url: i2, properties: v, headers: v }, [G]: h }], [G]: j }], [G]: j }, { error: "Invalid Configuration: Missing Region", [G]: k }] };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  var ruleset_1 = require_ruleset2();
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    });
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var url_parser_1 = require_dist_cjs36();
  var util_base64_1 = require_dist_cjs10();
  var util_utf8_1 = require_dist_cjs11();
  var endpointResolver_1 = require_endpointResolver2();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2011-06-15",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      serviceId: config?.serviceId ?? "STS",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/runtimeConfig.js
var require_runtimeConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package4());
  var defaultStsRoleAssumers_1 = require_defaultStsRoleAssumers();
  var core_1 = require_dist_cjs43();
  var credential_provider_node_1 = require_dist_cjs57();
  var util_user_agent_node_1 = require_dist_cjs47();
  var config_resolver_1 = require_dist_cjs30();
  var hash_node_1 = require_dist_cjs48();
  var middleware_retry_1 = require_dist_cjs41();
  var node_config_provider_1 = require_dist_cjs34();
  var node_http_handler_1 = require_dist_cjs14();
  var util_body_length_node_1 = require_dist_cjs49();
  var util_retry_1 = require_dist_cjs40();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared2();
  var smithy_client_1 = require_dist_cjs16();
  var util_defaults_mode_node_1 = require_dist_cjs50();
  var smithy_client_2 = require_dist_cjs16();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
      requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/runtimeExtensions.js
var require_runtimeExtensions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRuntimeExtensions = undefined;
  var region_config_resolver_1 = require_dist_cjs51();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var asPartial = (t) => t;
  var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
      ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
      ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
      ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration)
    };
  };
  exports.resolveRuntimeExtensions = resolveRuntimeExtensions;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/STSClient.js
var require_STSClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSClient = exports.__Client = undefined;
  var middleware_host_header_1 = require_dist_cjs4();
  var middleware_logger_1 = require_dist_cjs5();
  var middleware_recursion_detection_1 = require_dist_cjs6();
  var middleware_sdk_sts_1 = require_dist_cjs42();
  var middleware_user_agent_1 = require_dist_cjs28();
  var config_resolver_1 = require_dist_cjs30();
  var middleware_content_length_1 = require_dist_cjs32();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_retry_1 = require_dist_cjs41();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "__Client", { enumerable: true, get: function() {
    return smithy_client_1.Client;
  } });
  var EndpointParameters_1 = require_EndpointParameters2();
  var runtimeConfig_1 = require_runtimeConfig2();
  var runtimeExtensions_1 = require_runtimeExtensions2();

  class STSClient extends smithy_client_1.Client {
    constructor(...[configuration]) {
      const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
      const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
      const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
      const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
      const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_sdk_sts_1.resolveStsAuthConfig)(_config_5, { stsClientCtor: STSClient });
      const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
      const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  }
  exports.STSClient = STSClient;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/AssumeRoleWithSAMLCommand.js
var require_AssumeRoleWithSAMLCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AssumeRoleWithSAMLCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_0();
  var Aws_query_1 = require_Aws_query();

  class AssumeRoleWithSAMLCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithSAMLCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "AssumeRoleWithSAMLCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLResponseFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "AssumeRoleWithSAML"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_AssumeRoleWithSAMLCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_AssumeRoleWithSAMLCommand)(output, context);
    }
  }
  exports.AssumeRoleWithSAMLCommand = AssumeRoleWithSAMLCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/DecodeAuthorizationMessageCommand.js
var require_DecodeAuthorizationMessageCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DecodeAuthorizationMessageCommand = exports.$Command = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_query_1 = require_Aws_query();

  class DecodeAuthorizationMessageCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DecodeAuthorizationMessageCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "DecodeAuthorizationMessageCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "DecodeAuthorizationMessage"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_DecodeAuthorizationMessageCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_DecodeAuthorizationMessageCommand)(output, context);
    }
  }
  exports.DecodeAuthorizationMessageCommand = DecodeAuthorizationMessageCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/GetAccessKeyInfoCommand.js
var require_GetAccessKeyInfoCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetAccessKeyInfoCommand = exports.$Command = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_query_1 = require_Aws_query();

  class GetAccessKeyInfoCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccessKeyInfoCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "GetAccessKeyInfoCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "GetAccessKeyInfo"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_GetAccessKeyInfoCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_GetAccessKeyInfoCommand)(output, context);
    }
  }
  exports.GetAccessKeyInfoCommand = GetAccessKeyInfoCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/GetCallerIdentityCommand.js
var require_GetCallerIdentityCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetCallerIdentityCommand = exports.$Command = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_query_1 = require_Aws_query();

  class GetCallerIdentityCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetCallerIdentityCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "GetCallerIdentityCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "GetCallerIdentity"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_GetCallerIdentityCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_GetCallerIdentityCommand)(output, context);
    }
  }
  exports.GetCallerIdentityCommand = GetCallerIdentityCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/GetFederationTokenCommand.js
var require_GetFederationTokenCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetFederationTokenCommand = exports.$Command = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_0();
  var Aws_query_1 = require_Aws_query();

  class GetFederationTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFederationTokenCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "GetFederationTokenCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.GetFederationTokenResponseFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "GetFederationToken"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_GetFederationTokenCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_GetFederationTokenCommand)(output, context);
    }
  }
  exports.GetFederationTokenCommand = GetFederationTokenCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/GetSessionTokenCommand.js
var require_GetSessionTokenCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetSessionTokenCommand = exports.$Command = undefined;
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_0();
  var Aws_query_1 = require_Aws_query();

  class GetSessionTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSessionTokenCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "STSClient";
      const commandName = "GetSessionTokenCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.GetSessionTokenResponseFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AWSSecurityTokenServiceV20110615",
          operation: "GetSessionToken"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_query_1.se_GetSessionTokenCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_query_1.de_GetSessionTokenCommand)(output, context);
    }
  }
  exports.GetSessionTokenCommand = GetSessionTokenCommand;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/STS.js
var require_STS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STS = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var AssumeRoleCommand_1 = require_AssumeRoleCommand();
  var AssumeRoleWithSAMLCommand_1 = require_AssumeRoleWithSAMLCommand();
  var AssumeRoleWithWebIdentityCommand_1 = require_AssumeRoleWithWebIdentityCommand();
  var DecodeAuthorizationMessageCommand_1 = require_DecodeAuthorizationMessageCommand();
  var GetAccessKeyInfoCommand_1 = require_GetAccessKeyInfoCommand();
  var GetCallerIdentityCommand_1 = require_GetCallerIdentityCommand();
  var GetFederationTokenCommand_1 = require_GetFederationTokenCommand();
  var GetSessionTokenCommand_1 = require_GetSessionTokenCommand();
  var STSClient_1 = require_STSClient();
  var commands = {
    AssumeRoleCommand: AssumeRoleCommand_1.AssumeRoleCommand,
    AssumeRoleWithSAMLCommand: AssumeRoleWithSAMLCommand_1.AssumeRoleWithSAMLCommand,
    AssumeRoleWithWebIdentityCommand: AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand,
    DecodeAuthorizationMessageCommand: DecodeAuthorizationMessageCommand_1.DecodeAuthorizationMessageCommand,
    GetAccessKeyInfoCommand: GetAccessKeyInfoCommand_1.GetAccessKeyInfoCommand,
    GetCallerIdentityCommand: GetCallerIdentityCommand_1.GetCallerIdentityCommand,
    GetFederationTokenCommand: GetFederationTokenCommand_1.GetFederationTokenCommand,
    GetSessionTokenCommand: GetSessionTokenCommand_1.GetSessionTokenCommand
  };

  class STS extends STSClient_1.STSClient {
  }
  exports.STS = STS;
  (0, smithy_client_1.createAggregatedClient)(commands, STS);
});

// node_modules/@aws-sdk/client-sts/dist-cjs/commands/index.js
var require_commands2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_AssumeRoleCommand(), exports);
  tslib_1.__exportStar(require_AssumeRoleWithSAMLCommand(), exports);
  tslib_1.__exportStar(require_AssumeRoleWithWebIdentityCommand(), exports);
  tslib_1.__exportStar(require_DecodeAuthorizationMessageCommand(), exports);
  tslib_1.__exportStar(require_GetAccessKeyInfoCommand(), exports);
  tslib_1.__exportStar(require_GetCallerIdentityCommand(), exports);
  tslib_1.__exportStar(require_GetFederationTokenCommand(), exports);
  tslib_1.__exportStar(require_GetSessionTokenCommand(), exports);
});

// node_modules/@aws-sdk/client-sts/dist-cjs/models/index.js
var require_models2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_models_0(), exports);
});

// node_modules/@aws-sdk/client-sts/dist-cjs/defaultRoleAssumers.js
var require_defaultRoleAssumers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = undefined;
  var defaultStsRoleAssumers_1 = require_defaultStsRoleAssumers();
  var STSClient_1 = require_STSClient();
  var getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
      return baseCtor;
    else
      return class CustomizableSTSClient extends baseCtor {
        constructor(config) {
          super(config);
          for (const customization of customizations) {
            this.middlewareStack.use(customization);
          }
        }
      };
  };
  var getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumer)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
  exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
  var getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumerWithWebIdentity)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
  exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
  var decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input),
    ...input
  });
  exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;
});

// node_modules/@aws-sdk/client-sts/dist-cjs/index.js
var require_dist_cjs58 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSServiceException = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_STSClient(), exports);
  tslib_1.__exportStar(require_STS(), exports);
  tslib_1.__exportStar(require_commands2(), exports);
  tslib_1.__exportStar(require_models2(), exports);
  tslib_1.__exportStar(require_defaultRoleAssumers(), exports);
  require_dist_cjs27();
  var STSServiceException_1 = require_STSServiceException();
  Object.defineProperty(exports, "STSServiceException", { enumerable: true, get: function() {
    return STSServiceException_1.STSServiceException;
  } });
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/NodeDisableMultiregionAccessPointConfigOptions.js
var require_NodeDisableMultiregionAccessPointConfigOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = undefined;
  var util_config_provider_1 = require_dist_cjs29();
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = "s3_disable_multiregion_access_points";
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME, util_config_provider_1.SelectorType.CONFIG),
    default: false
  };
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/NodeUseArnRegionConfigOptions.js
var require_NodeUseArnRegionConfigOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NODE_USE_ARN_REGION_CONFIG_OPTIONS = exports.NODE_USE_ARN_REGION_INI_NAME = exports.NODE_USE_ARN_REGION_ENV_NAME = undefined;
  var util_config_provider_1 = require_dist_cjs29();
  exports.NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
  exports.NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
  exports.NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.NODE_USE_ARN_REGION_ENV_NAME, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.NODE_USE_ARN_REGION_INI_NAME, util_config_provider_1.SelectorType.CONFIG),
    default: false
  };
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/bucketHostnameUtils.js
var require_bucketHostnameUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateMrapAlias = exports.validateNoFIPS = exports.validateNoDualstack = exports.getArnResources = exports.validateCustomEndpoint = exports.validateDNSHostLabel = exports.validateAccountId = exports.validateRegionalClient = exports.validateRegion = exports.validatePartition = exports.validateOutpostService = exports.validateS3Service = exports.validateService = exports.validateArnEndpointOptions = exports.getSuffixForArnEndpoint = exports.getSuffix = exports.isDnsCompatibleBucketName = exports.isBucketNameOptions = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = undefined;
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  exports.DOT_PATTERN = /\./;
  exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
  var S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\.amazonaws\.com$/;
  var AWS_PARTITION_SUFFIX = "amazonaws.com";
  var isBucketNameOptions = (options5) => typeof options5.bucketName === "string";
  exports.isBucketNameOptions = isBucketNameOptions;
  var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
  exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
  var getRegionalSuffix = (hostname) => {
    const parts2 = hostname.match(exports.S3_HOSTNAME_PATTERN);
    return [parts2[4], hostname.replace(new RegExp(`^${parts2[0]}`), "")];
  };
  var getSuffix = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? ["us-east-1", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
  exports.getSuffix = getSuffix;
  var getSuffixForArnEndpoint = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, ""), AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
  exports.getSuffixForArnEndpoint = getSuffixForArnEndpoint;
  var validateArnEndpointOptions = (options5) => {
    if (options5.pathStyleEndpoint) {
      throw new Error("Path-style S3 endpoint is not supported when bucket is an ARN");
    }
    if (options5.accelerateEndpoint) {
      throw new Error("Accelerate endpoint is not supported when bucket is an ARN");
    }
    if (!options5.tlsCompatible) {
      throw new Error("HTTPS is required when bucket is an ARN");
    }
  };
  exports.validateArnEndpointOptions = validateArnEndpointOptions;
  var validateService = (service) => {
    if (service !== "s3" && service !== "s3-outposts" && service !== "s3-object-lambda") {
      throw new Error("Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component");
    }
  };
  exports.validateService = validateService;
  var validateS3Service = (service) => {
    if (service !== "s3") {
      throw new Error("Expect 's3' in Accesspoint ARN service component");
    }
  };
  exports.validateS3Service = validateS3Service;
  var validateOutpostService = (service) => {
    if (service !== "s3-outposts") {
      throw new Error("Expect 's3-posts' in Outpost ARN service component");
    }
  };
  exports.validateOutpostService = validateOutpostService;
  var validatePartition = (partition, options5) => {
    if (partition !== options5.clientPartition) {
      throw new Error(`Partition in ARN is incompatible, got "${partition}" but expected "${options5.clientPartition}"`);
    }
  };
  exports.validatePartition = validatePartition;
  var validateRegion = (region, options5) => {
    if (region === "") {
      throw new Error("ARN region is empty");
    }
    if (options5.useFipsEndpoint) {
      if (!options5.allowFipsRegion) {
        throw new Error("FIPS region is not supported");
      } else if (!isEqualRegions(region, options5.clientRegion)) {
        throw new Error(`Client FIPS region ${options5.clientRegion} doesn't match region ${region} in ARN`);
      }
    }
    if (!options5.useArnRegion && !isEqualRegions(region, options5.clientRegion || "") && !isEqualRegions(region, options5.clientSigningRegion || "")) {
      throw new Error(`Region in ARN is incompatible, got ${region} but expected ${options5.clientRegion}`);
    }
  };
  exports.validateRegion = validateRegion;
  var validateRegionalClient = (region) => {
    if (["s3-external-1", "aws-global"].includes(region)) {
      throw new Error(`Client region ${region} is not regional`);
    }
  };
  exports.validateRegionalClient = validateRegionalClient;
  var isEqualRegions = (regionA, regionB) => regionA === regionB;
  var validateAccountId = (accountId) => {
    if (!/[0-9]{12}/.exec(accountId)) {
      throw new Error("Access point ARN accountID does not match regex '[0-9]{12}'");
    }
  };
  exports.validateAccountId = validateAccountId;
  var validateDNSHostLabel = (label, options5 = { tlsCompatible: true }) => {
    if (label.length >= 64 || !/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(label) || /(\d+\.){3}\d+/.test(label) || /[.-]{2}/.test(label) || (options5 === null || options5 === undefined ? undefined : options5.tlsCompatible) && exports.DOT_PATTERN.test(label)) {
      throw new Error(`Invalid DNS label ${label}`);
    }
  };
  exports.validateDNSHostLabel = validateDNSHostLabel;
  var validateCustomEndpoint = (options5) => {
    if (options5.isCustomEndpoint) {
      if (options5.dualstackEndpoint)
        throw new Error("Dualstack endpoint is not supported with custom endpoint");
      if (options5.accelerateEndpoint)
        throw new Error("Accelerate endpoint is not supported with custom endpoint");
    }
  };
  exports.validateCustomEndpoint = validateCustomEndpoint;
  var getArnResources = (resource) => {
    const delimiter = resource.includes(":") ? ":" : "/";
    const [resourceType, ...rest] = resource.split(delimiter);
    if (resourceType === "accesspoint") {
      if (rest.length !== 1 || rest[0] === "") {
        throw new Error(`Access Point ARN should have one resource accesspoint${delimiter}{accesspointname}`);
      }
      return { accesspointName: rest[0] };
    } else if (resourceType === "outpost") {
      if (!rest[0] || rest[1] !== "accesspoint" || !rest[2] || rest.length !== 3) {
        throw new Error(`Outpost ARN should have resource outpost${delimiter}{outpostId}${delimiter}accesspoint${delimiter}{accesspointName}`);
      }
      const [outpostId, _, accesspointName] = rest;
      return { outpostId, accesspointName };
    } else {
      throw new Error(`ARN resource should begin with 'accesspoint${delimiter}' or 'outpost${delimiter}'`);
    }
  };
  exports.getArnResources = getArnResources;
  var validateNoDualstack = (dualstackEndpoint) => {
    if (dualstackEndpoint)
      throw new Error("Dualstack endpoint is not supported with Outpost or Multi-region Access Point ARN.");
  };
  exports.validateNoDualstack = validateNoDualstack;
  var validateNoFIPS = (useFipsEndpoint) => {
    if (useFipsEndpoint)
      throw new Error(`FIPS region is not supported with Outpost.`);
  };
  exports.validateNoFIPS = validateNoFIPS;
  var validateMrapAlias = (name) => {
    try {
      name.split(".").forEach((label) => {
        (0, exports.validateDNSHostLabel)(label);
      });
    } catch (e) {
      throw new Error(`"${name}" is not a DNS compatible name.`);
    }
  };
  exports.validateMrapAlias = validateMrapAlias;
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/bucketHostname.js
var require_bucketHostname = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bucketHostname = undefined;
  var bucketHostnameUtils_1 = require_bucketHostnameUtils();
  var bucketHostname = (options5) => {
    (0, bucketHostnameUtils_1.validateCustomEndpoint)(options5);
    return (0, bucketHostnameUtils_1.isBucketNameOptions)(options5) ? getEndpointFromBucketName(options5) : getEndpointFromArn(options5);
  };
  exports.bucketHostname = bucketHostname;
  var getEndpointFromBucketName = ({ accelerateEndpoint = false, clientRegion: region, baseHostname, bucketName, dualstackEndpoint = false, fipsEndpoint = false, pathStyleEndpoint = false, tlsCompatible = true, isCustomEndpoint = false }) => {
    const [clientRegion, hostnameSuffix] = isCustomEndpoint ? [region, baseHostname] : (0, bucketHostnameUtils_1.getSuffix)(baseHostname);
    if (pathStyleEndpoint || !(0, bucketHostnameUtils_1.isDnsCompatibleBucketName)(bucketName) || tlsCompatible && bucketHostnameUtils_1.DOT_PATTERN.test(bucketName)) {
      return {
        bucketEndpoint: false,
        hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname
      };
    }
    if (accelerateEndpoint) {
      baseHostname = `s3-accelerate${dualstackEndpoint ? ".dualstack" : ""}.${hostnameSuffix}`;
    } else if (dualstackEndpoint) {
      baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;
    }
    return {
      bucketEndpoint: true,
      hostname: `${bucketName}.${baseHostname}`
    };
  };
  var getEndpointFromArn = (options5) => {
    const { isCustomEndpoint, baseHostname, clientRegion } = options5;
    const hostnameSuffix = isCustomEndpoint ? baseHostname : (0, bucketHostnameUtils_1.getSuffixForArnEndpoint)(baseHostname)[1];
    const { pathStyleEndpoint, accelerateEndpoint = false, fipsEndpoint = false, tlsCompatible = true, bucketName, clientPartition = "aws" } = options5;
    (0, bucketHostnameUtils_1.validateArnEndpointOptions)({ pathStyleEndpoint, accelerateEndpoint, tlsCompatible });
    const { service, partition, accountId, region, resource } = bucketName;
    (0, bucketHostnameUtils_1.validateService)(service);
    (0, bucketHostnameUtils_1.validatePartition)(partition, { clientPartition });
    (0, bucketHostnameUtils_1.validateAccountId)(accountId);
    const { accesspointName, outpostId } = (0, bucketHostnameUtils_1.getArnResources)(resource);
    if (service === "s3-object-lambda") {
      return getEndpointFromObjectLambdaArn({ ...options5, tlsCompatible, bucketName, accesspointName, hostnameSuffix });
    }
    if (region === "") {
      return getEndpointFromMRAPArn({ ...options5, clientRegion, mrapAlias: accesspointName, hostnameSuffix });
    }
    if (outpostId) {
      return getEndpointFromOutpostArn({ ...options5, clientRegion, outpostId, accesspointName, hostnameSuffix });
    }
    return getEndpointFromAccessPointArn({ ...options5, clientRegion, accesspointName, hostnameSuffix });
  };
  var getEndpointFromObjectLambdaArn = ({ dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, useArnRegion, clientRegion, clientSigningRegion = clientRegion, accesspointName, bucketName, hostnameSuffix }) => {
    const { accountId, region, service } = bucketName;
    (0, bucketHostnameUtils_1.validateRegionalClient)(clientRegion);
    (0, bucketHostnameUtils_1.validateRegion)(region, {
      useArnRegion,
      clientRegion,
      clientSigningRegion,
      allowFipsRegion: true,
      useFipsEndpoint: fipsEndpoint
    });
    (0, bucketHostnameUtils_1.validateNoDualstack)(dualstackEndpoint);
    const DNSHostLabel = `${accesspointName}-${accountId}`;
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(DNSHostLabel, { tlsCompatible });
    const endpointRegion = useArnRegion ? region : clientRegion;
    const signingRegion = useArnRegion ? region : clientSigningRegion;
    return {
      bucketEndpoint: true,
      hostname: `${DNSHostLabel}.${service}${fipsEndpoint ? "-fips" : ""}.${endpointRegion}.${hostnameSuffix}`,
      signingRegion,
      signingService: service
    };
  };
  var getEndpointFromMRAPArn = ({ disableMultiregionAccessPoints, dualstackEndpoint = false, isCustomEndpoint, mrapAlias, hostnameSuffix }) => {
    if (disableMultiregionAccessPoints === true) {
      throw new Error("SDK is attempting to use a MRAP ARN. Please enable to feature.");
    }
    (0, bucketHostnameUtils_1.validateMrapAlias)(mrapAlias);
    (0, bucketHostnameUtils_1.validateNoDualstack)(dualstackEndpoint);
    return {
      bucketEndpoint: true,
      hostname: `${mrapAlias}${isCustomEndpoint ? "" : `.accesspoint.s3-global`}.${hostnameSuffix}`,
      signingRegion: "*"
    };
  };
  var getEndpointFromOutpostArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, outpostId, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix }) => {
    (0, bucketHostnameUtils_1.validateRegionalClient)(clientRegion);
    (0, bucketHostnameUtils_1.validateRegion)(bucketName.region, { useArnRegion, clientRegion, clientSigningRegion, useFipsEndpoint: fipsEndpoint });
    const DNSHostLabel = `${accesspointName}-${bucketName.accountId}`;
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(DNSHostLabel, { tlsCompatible });
    const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    (0, bucketHostnameUtils_1.validateOutpostService)(bucketName.service);
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(outpostId, { tlsCompatible });
    (0, bucketHostnameUtils_1.validateNoDualstack)(dualstackEndpoint);
    (0, bucketHostnameUtils_1.validateNoFIPS)(fipsEndpoint);
    const hostnamePrefix = `${DNSHostLabel}.${outpostId}`;
    return {
      bucketEndpoint: true,
      hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-outposts.${endpointRegion}`}.${hostnameSuffix}`,
      signingRegion,
      signingService: "s3-outposts"
    };
  };
  var getEndpointFromAccessPointArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix }) => {
    (0, bucketHostnameUtils_1.validateRegionalClient)(clientRegion);
    (0, bucketHostnameUtils_1.validateRegion)(bucketName.region, {
      useArnRegion,
      clientRegion,
      clientSigningRegion,
      allowFipsRegion: true,
      useFipsEndpoint: fipsEndpoint
    });
    const hostnamePrefix = `${accesspointName}-${bucketName.accountId}`;
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(hostnamePrefix, { tlsCompatible });
    const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    (0, bucketHostnameUtils_1.validateS3Service)(bucketName.service);
    return {
      bucketEndpoint: true,
      hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-accesspoint${fipsEndpoint ? "-fips" : ""}${dualstackEndpoint ? ".dualstack" : ""}.${endpointRegion}`}.${hostnameSuffix}`,
      signingRegion
    };
  };
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/bucketEndpointMiddleware.js
var require_bucketEndpointMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBucketEndpointPlugin = exports.bucketEndpointMiddlewareOptions = exports.bucketEndpointMiddleware = undefined;
  var util_arn_parser_1 = require_dist_cjs17();
  var protocol_http_1 = require_dist_cjs2();
  var bucketHostname_1 = require_bucketHostname();
  var bucketEndpointMiddleware = (options5) => (next, context) => async (args) => {
    const { Bucket: bucketName } = args.input;
    let replaceBucketInPath = options5.bucketEndpoint;
    const request = args.request;
    if (protocol_http_1.HttpRequest.isInstance(request)) {
      if (options5.bucketEndpoint) {
        request.hostname = bucketName;
      } else if ((0, util_arn_parser_1.validate)(bucketName)) {
        const bucketArn = (0, util_arn_parser_1.parse)(bucketName);
        const clientRegion = await options5.region();
        const useDualstackEndpoint = await options5.useDualstackEndpoint();
        const useFipsEndpoint = await options5.useFipsEndpoint();
        const { partition, signingRegion = clientRegion } = await options5.regionInfoProvider(clientRegion, { useDualstackEndpoint, useFipsEndpoint }) || {};
        const useArnRegion = await options5.useArnRegion();
        const { hostname, bucketEndpoint, signingRegion: modifiedSigningRegion, signingService } = (0, bucketHostname_1.bucketHostname)({
          bucketName: bucketArn,
          baseHostname: request.hostname,
          accelerateEndpoint: options5.useAccelerateEndpoint,
          dualstackEndpoint: useDualstackEndpoint,
          fipsEndpoint: useFipsEndpoint,
          pathStyleEndpoint: options5.forcePathStyle,
          tlsCompatible: request.protocol === "https:",
          useArnRegion,
          clientPartition: partition,
          clientSigningRegion: signingRegion,
          clientRegion,
          isCustomEndpoint: options5.isCustomEndpoint,
          disableMultiregionAccessPoints: await options5.disableMultiregionAccessPoints()
        });
        if (modifiedSigningRegion && modifiedSigningRegion !== signingRegion) {
          context["signing_region"] = modifiedSigningRegion;
        }
        if (signingService && signingService !== "s3") {
          context["signing_service"] = signingService;
        }
        request.hostname = hostname;
        replaceBucketInPath = bucketEndpoint;
      } else {
        const clientRegion = await options5.region();
        const dualstackEndpoint = await options5.useDualstackEndpoint();
        const fipsEndpoint = await options5.useFipsEndpoint();
        const { hostname, bucketEndpoint } = (0, bucketHostname_1.bucketHostname)({
          bucketName,
          clientRegion,
          baseHostname: request.hostname,
          accelerateEndpoint: options5.useAccelerateEndpoint,
          dualstackEndpoint,
          fipsEndpoint,
          pathStyleEndpoint: options5.forcePathStyle,
          tlsCompatible: request.protocol === "https:",
          isCustomEndpoint: options5.isCustomEndpoint
        });
        request.hostname = hostname;
        replaceBucketInPath = bucketEndpoint;
      }
      if (replaceBucketInPath) {
        request.path = request.path.replace(/^(\/)?[^\/]+/, "");
        if (request.path === "") {
          request.path = "/";
        }
      }
    }
    return next({ ...args, request });
  };
  exports.bucketEndpointMiddleware = bucketEndpointMiddleware;
  exports.bucketEndpointMiddlewareOptions = {
    tags: ["BUCKET_ENDPOINT"],
    name: "bucketEndpointMiddleware",
    relation: "before",
    toMiddleware: "hostHeaderMiddleware",
    override: true
  };
  var getBucketEndpointPlugin = (options5) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo((0, exports.bucketEndpointMiddleware)(options5), exports.bucketEndpointMiddlewareOptions);
    }
  });
  exports.getBucketEndpointPlugin = getBucketEndpointPlugin;
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/configurations.js
var require_configurations3 = __commonJS((exports) => {
  var resolveBucketEndpointConfig = function(input) {
    const { bucketEndpoint = false, forcePathStyle = false, useAccelerateEndpoint = false, useArnRegion = false, disableMultiregionAccessPoints = false } = input;
    return {
      ...input,
      bucketEndpoint,
      forcePathStyle,
      useAccelerateEndpoint,
      useArnRegion: typeof useArnRegion === "function" ? useArnRegion : () => Promise.resolve(useArnRegion),
      disableMultiregionAccessPoints: typeof disableMultiregionAccessPoints === "function" ? disableMultiregionAccessPoints : () => Promise.resolve(disableMultiregionAccessPoints)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveBucketEndpointConfig = undefined;
  exports.resolveBucketEndpointConfig = resolveBucketEndpointConfig;
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/index.js
var require_dist_cjs59 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNoFIPS = exports.validateNoDualstack = exports.validateDNSHostLabel = exports.validateRegion = exports.validateAccountId = exports.validatePartition = exports.validateOutpostService = exports.getSuffixForArnEndpoint = exports.getArnResources = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_NodeDisableMultiregionAccessPointConfigOptions(), exports);
  tslib_1.__exportStar(require_NodeUseArnRegionConfigOptions(), exports);
  tslib_1.__exportStar(require_bucketEndpointMiddleware(), exports);
  tslib_1.__exportStar(require_bucketHostname(), exports);
  tslib_1.__exportStar(require_configurations3(), exports);
  var bucketHostnameUtils_1 = require_bucketHostnameUtils();
  Object.defineProperty(exports, "getArnResources", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.getArnResources;
  } });
  Object.defineProperty(exports, "getSuffixForArnEndpoint", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.getSuffixForArnEndpoint;
  } });
  Object.defineProperty(exports, "validateOutpostService", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validateOutpostService;
  } });
  Object.defineProperty(exports, "validatePartition", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validatePartition;
  } });
  Object.defineProperty(exports, "validateAccountId", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validateAccountId;
  } });
  Object.defineProperty(exports, "validateRegion", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validateRegion;
  } });
  Object.defineProperty(exports, "validateDNSHostLabel", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validateDNSHostLabel;
  } });
  Object.defineProperty(exports, "validateNoDualstack", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validateNoDualstack;
  } });
  Object.defineProperty(exports, "validateNoFIPS", { enumerable: true, get: function() {
    return bucketHostnameUtils_1.validateNoFIPS;
  } });
});

// node_modules/@smithy/eventstream-serde-universal/dist-cjs/getChunkedStream.js
var require_getChunkedStream = __commonJS((exports) => {
  var getChunkedStream = function(source) {
    let currentMessageTotalLength = 0;
    let currentMessagePendingLength = 0;
    let currentMessage = null;
    let messageLengthBuffer = null;
    const allocateMessage = (size) => {
      if (typeof size !== "number") {
        throw new Error("Attempted to allocate an event message where size was not a number: " + size);
      }
      currentMessageTotalLength = size;
      currentMessagePendingLength = 4;
      currentMessage = new Uint8Array(size);
      const currentMessageView = new DataView(currentMessage.buffer);
      currentMessageView.setUint32(0, size, false);
    };
    const iterator = async function* () {
      const sourceIterator = source[Symbol.asyncIterator]();
      while (true) {
        const { value, done } = await sourceIterator.next();
        if (done) {
          if (!currentMessageTotalLength) {
            return;
          } else if (currentMessageTotalLength === currentMessagePendingLength) {
            yield currentMessage;
          } else {
            throw new Error("Truncated event message received.");
          }
          return;
        }
        const chunkLength = value.length;
        let currentOffset = 0;
        while (currentOffset < chunkLength) {
          if (!currentMessage) {
            const bytesRemaining = chunkLength - currentOffset;
            if (!messageLengthBuffer) {
              messageLengthBuffer = new Uint8Array(4);
            }
            const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
            currentMessagePendingLength += numBytesForTotal;
            currentOffset += numBytesForTotal;
            if (currentMessagePendingLength < 4) {
              break;
            }
            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
            messageLengthBuffer = null;
          }
          const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
          currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
          currentMessagePendingLength += numBytesToWrite;
          currentOffset += numBytesToWrite;
          if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
            yield currentMessage;
            currentMessage = null;
            currentMessageTotalLength = 0;
            currentMessagePendingLength = 0;
          }
        }
      }
    };
    return {
      [Symbol.asyncIterator]: iterator
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChunkedStream = undefined;
  exports.getChunkedStream = getChunkedStream;
});

// node_modules/@smithy/eventstream-serde-universal/dist-cjs/getUnmarshalledStream.js
var require_getUnmarshalledStream = __commonJS((exports) => {
  var getUnmarshalledStream = function(source, options5) {
    const messageUnmarshaller = getMessageUnmarshaller(options5.deserializer, options5.toUtf8);
    return {
      [Symbol.asyncIterator]: async function* () {
        for await (const chunk of source) {
          const message = options5.eventStreamCodec.decode(chunk);
          const type = await messageUnmarshaller(message);
          if (type === undefined)
            continue;
          yield type;
        }
      }
    };
  };
  var getMessageUnmarshaller = function(deserializer, toUtf8) {
    return async function(message) {
      const { value: messageType } = message.headers[":message-type"];
      if (messageType === "error") {
        const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
        unmodeledError.name = message.headers[":error-code"].value;
        throw unmodeledError;
      } else if (messageType === "exception") {
        const code = message.headers[":exception-type"].value;
        const exception = { [code]: message };
        const deserializedException = await deserializer(exception);
        if (deserializedException.$unknown) {
          const error = new Error(toUtf8(message.body));
          error.name = code;
          throw error;
        }
        throw deserializedException[code];
      } else if (messageType === "event") {
        const event = {
          [message.headers[":event-type"].value]: message
        };
        const deserialized = await deserializer(event);
        if (deserialized.$unknown)
          return;
        return deserialized;
      } else {
        throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMessageUnmarshaller = exports.getUnmarshalledStream = undefined;
  exports.getUnmarshalledStream = getUnmarshalledStream;
  exports.getMessageUnmarshaller = getMessageUnmarshaller;
});

// node_modules/@smithy/eventstream-serde-universal/dist-cjs/EventStreamMarshaller.js
var require_EventStreamMarshaller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventStreamMarshaller = undefined;
  var eventstream_codec_1 = require_dist_cjs22();
  var getChunkedStream_1 = require_getChunkedStream();
  var getUnmarshalledStream_1 = require_getUnmarshalledStream();

  class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
      this.eventStreamCodec = new eventstream_codec_1.EventStreamCodec(utf8Encoder, utf8Decoder);
      this.utfEncoder = utf8Encoder;
    }
    deserialize(body, deserializer) {
      const inputStream = (0, getChunkedStream_1.getChunkedStream)(body);
      return new eventstream_codec_1.SmithyMessageDecoderStream({
        messageStream: new eventstream_codec_1.MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
        deserializer: (0, getUnmarshalledStream_1.getMessageUnmarshaller)(deserializer, this.utfEncoder)
      });
    }
    serialize(inputStream, serializer) {
      return new eventstream_codec_1.MessageEncoderStream({
        messageStream: new eventstream_codec_1.SmithyMessageEncoderStream({ inputStream, serializer }),
        encoder: this.eventStreamCodec,
        includeEndFrame: true
      });
    }
  }
  exports.EventStreamMarshaller = EventStreamMarshaller;
});

// node_modules/@smithy/eventstream-serde-universal/dist-cjs/provider.js
var require_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.eventStreamSerdeProvider = undefined;
  var EventStreamMarshaller_1 = require_EventStreamMarshaller();
  var eventStreamSerdeProvider = (options5) => new EventStreamMarshaller_1.EventStreamMarshaller(options5);
  exports.eventStreamSerdeProvider = eventStreamSerdeProvider;
});

// node_modules/@smithy/eventstream-serde-universal/dist-cjs/index.js
var require_dist_cjs60 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EventStreamMarshaller(), exports);
  tslib_1.__exportStar(require_provider(), exports);
});

// node_modules/@smithy/eventstream-serde-node/dist-cjs/utils.js
var require_utils3 = __commonJS((exports) => {
  async function* readabletoIterable(readStream2) {
    let streamEnded = false;
    let generationEnded = false;
    const records = new Array;
    readStream2.on("error", (err) => {
      if (!streamEnded) {
        streamEnded = true;
      }
      if (err) {
        throw err;
      }
    });
    readStream2.on("data", (data) => {
      records.push(data);
    });
    readStream2.on("end", () => {
      streamEnded = true;
    });
    while (!generationEnded) {
      const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
      if (value) {
        yield value;
      }
      generationEnded = streamEnded && records.length === 0;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readabletoIterable = undefined;
  exports.readabletoIterable = readabletoIterable;
});

// node_modules/@smithy/eventstream-serde-node/dist-cjs/EventStreamMarshaller.js
var require_EventStreamMarshaller2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventStreamMarshaller = undefined;
  var eventstream_serde_universal_1 = require_dist_cjs60();
  var stream_1 = __require("stream");
  var utils_1 = require_utils3();

  class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
      this.universalMarshaller = new eventstream_serde_universal_1.EventStreamMarshaller({
        utf8Decoder,
        utf8Encoder
      });
    }
    deserialize(body, deserializer) {
      const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : (0, utils_1.readabletoIterable)(body);
      return this.universalMarshaller.deserialize(bodyIterable, deserializer);
    }
    serialize(input, serializer) {
      return stream_1.Readable.from(this.universalMarshaller.serialize(input, serializer));
    }
  }
  exports.EventStreamMarshaller = EventStreamMarshaller;
});

// node_modules/@smithy/eventstream-serde-node/dist-cjs/provider.js
var require_provider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.eventStreamSerdeProvider = undefined;
  var EventStreamMarshaller_1 = require_EventStreamMarshaller2();
  var eventStreamSerdeProvider = (options5) => new EventStreamMarshaller_1.EventStreamMarshaller(options5);
  exports.eventStreamSerdeProvider = eventStreamSerdeProvider;
});

// node_modules/@smithy/eventstream-serde-node/dist-cjs/index.js
var require_dist_cjs61 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_EventStreamMarshaller2(), exports);
  tslib_1.__exportStar(require_provider2(), exports);
});

// node_modules/@smithy/hash-stream-node/dist-cjs/HashCalculator.js
var require_HashCalculator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HashCalculator = undefined;
  var util_utf8_1 = require_dist_cjs11();
  var stream_1 = __require("stream");

  class HashCalculator extends stream_1.Writable {
    constructor(hash, options5) {
      super(options5);
      this.hash = hash;
    }
    _write(chunk, encoding, callback) {
      try {
        this.hash.update((0, util_utf8_1.toUint8Array)(chunk));
      } catch (err) {
        return callback(err);
      }
      callback();
    }
  }
  exports.HashCalculator = HashCalculator;
});

// node_modules/@smithy/hash-stream-node/dist-cjs/fileStreamHasher.js
var require_fileStreamHasher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fileStreamHasher = undefined;
  var fs_1 = __require("fs");
  var HashCalculator_1 = require_HashCalculator();
  var fileStreamHasher = (hashCtor, fileStream) => new Promise((resolve, reject) => {
    if (!isReadStream(fileStream)) {
      reject(new Error("Unable to calculate hash for non-file streams."));
      return;
    }
    const fileStreamTee = (0, fs_1.createReadStream)(fileStream.path, {
      start: fileStream.start,
      end: fileStream.end
    });
    const hash = new hashCtor;
    const hashCalculator = new HashCalculator_1.HashCalculator(hash);
    fileStreamTee.pipe(hashCalculator);
    fileStreamTee.on("error", (err) => {
      hashCalculator.end();
      reject(err);
    });
    hashCalculator.on("error", reject);
    hashCalculator.on("finish", function() {
      hash.digest().then(resolve).catch(reject);
    });
  });
  exports.fileStreamHasher = fileStreamHasher;
  var isReadStream = (stream3) => typeof stream3.path === "string";
});

// node_modules/@smithy/hash-stream-node/dist-cjs/readableStreamHasher.js
var require_readableStreamHasher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readableStreamHasher = undefined;
  var HashCalculator_1 = require_HashCalculator();
  var readableStreamHasher = (hashCtor, readableStream) => {
    if (readableStream.readableFlowing !== null) {
      throw new Error("Unable to calculate hash for flowing readable stream");
    }
    const hash = new hashCtor;
    const hashCalculator = new HashCalculator_1.HashCalculator(hash);
    readableStream.pipe(hashCalculator);
    return new Promise((resolve, reject) => {
      readableStream.on("error", (err) => {
        hashCalculator.end();
        reject(err);
      });
      hashCalculator.on("error", reject);
      hashCalculator.on("finish", () => {
        hash.digest().then(resolve).catch(reject);
      });
    });
  };
  exports.readableStreamHasher = readableStreamHasher;
});

// node_modules/@smithy/hash-stream-node/dist-cjs/index.js
var require_dist_cjs62 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_fileStreamHasher(), exports);
  tslib_1.__exportStar(require_readableStreamHasher(), exports);
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-cjs/signature-v4-crt-container.js
var require_signature_v4_crt_container = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signatureV4CrtContainer = undefined;
  exports.signatureV4CrtContainer = {
    CrtSignerV4: null
  };
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-cjs/SignatureV4MultiRegion.js
var require_SignatureV4MultiRegion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SignatureV4MultiRegion = undefined;
  var signature_v4_1 = require_dist_cjs24();
  var signature_v4_crt_container_1 = require_signature_v4_crt_container();

  class SignatureV4MultiRegion {
    constructor(options5) {
      this.sigv4Signer = new signature_v4_1.SignatureV4(options5);
      this.signerOptions = options5;
    }
    async sign(requestToSign, options5 = {}) {
      if (options5.signingRegion === "*") {
        if (this.signerOptions.runtime !== "node")
          throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
        return this.getSigv4aSigner().sign(requestToSign, options5);
      }
      return this.sigv4Signer.sign(requestToSign, options5);
    }
    async presign(originalRequest, options5 = {}) {
      if (options5.signingRegion === "*") {
        if (this.signerOptions.runtime !== "node")
          throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
        return this.getSigv4aSigner().presign(originalRequest, options5);
      }
      return this.sigv4Signer.presign(originalRequest, options5);
    }
    getSigv4aSigner() {
      if (!this.sigv4aSigner) {
        let CrtSignerV4 = null;
        try {
          CrtSignerV4 = signature_v4_crt_container_1.signatureV4CrtContainer.CrtSignerV4;
          if (typeof CrtSignerV4 !== "function")
            throw new Error;
        } catch (e) {
          e.message = `${e.message}\n` + `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. \nYou must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. \nFor more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
          throw e;
        }
        this.sigv4aSigner = new CrtSignerV4({
          ...this.signerOptions,
          signingAlgorithm: 1
        });
      }
      return this.sigv4aSigner;
    }
  }
  exports.SignatureV4MultiRegion = SignatureV4MultiRegion;
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-cjs/index.js
var require_dist_cjs63 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_SignatureV4MultiRegion(), exports);
  tslib_1.__exportStar(require_signature_v4_crt_container(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/ruleset.js
var require_ruleset3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var bJ = "required";
  var bK = "type";
  var bL = "conditions";
  var bM = "fn";
  var bN = "argv";
  var bO = "ref";
  var bP = "assign";
  var bQ = "url";
  var bR = "properties";
  var bS = "authSchemes";
  var bT = "disableDoubleEncoding";
  var bU = "signingName";
  var bV = "signingRegion";
  var bW = "headers";
  var a = false;
  var b = true;
  var c = "isSet";
  var d = "tree";
  var e = "booleanEquals";
  var f = "error";
  var g = "aws.partition";
  var h = "stringEquals";
  var i2 = "getAttr";
  var j = "name";
  var k = "substring";
  var l = "hardwareType";
  var m = "regionPrefix";
  var n = "bucketAliasSuffix";
  var o = "outpostId";
  var p = "isValidHostLabel";
  var q = "not";
  var r = "parseURL";
  var s = "s3-outposts";
  var t = "endpoint";
  var u = "aws.isVirtualHostableS3Bucket";
  var v = "s3";
  var w = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
  var x = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
  var y = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
  var z = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
  var A = "aws.parseArn";
  var B = "bucketArn";
  var C = "arnType";
  var D = "";
  var E = "s3-object-lambda";
  var F = "accesspoint";
  var G = "accessPointName";
  var H = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
  var I = "mrapPartition";
  var J = "outpostType";
  var K = "arnPrefix";
  var L = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
  var M = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
  var N = "{url#scheme}://{url#authority}{url#path}";
  var O = "https://s3.{partitionResult#dnsSuffix}";
  var P = { [bJ]: false, [bK]: "String" };
  var Q = { [bJ]: true, default: false, [bK]: "Boolean" };
  var R = { [bJ]: false, [bK]: "Boolean" };
  var S = { [bM]: e, [bN]: [{ [bO]: "Accelerate" }, true] };
  var T = { [bM]: e, [bN]: [{ [bO]: "UseFIPS" }, true] };
  var U = { [bM]: e, [bN]: [{ [bO]: "UseDualStack" }, true] };
  var V = { [bM]: c, [bN]: [{ [bO]: "Endpoint" }] };
  var W = { [bM]: g, [bN]: [{ [bO]: "Region" }], [bP]: "partitionResult" };
  var X = { [bM]: h, [bN]: [{ [bM]: i2, [bN]: [{ [bO]: "partitionResult" }, j] }, "aws-cn"] };
  var Y = { [bM]: c, [bN]: [{ [bO]: "Bucket" }] };
  var Z = { [bO]: "Bucket" };
  var aa = { [bO]: l };
  var ab = { [bL]: [{ [bM]: q, [bN]: [V] }], [f]: "Expected a endpoint to be specified but no endpoint was found", [bK]: f };
  var ac = { [bM]: q, [bN]: [V] };
  var ad = { [bM]: r, [bN]: [{ [bO]: "Endpoint" }], [bP]: "url" };
  var ae = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: s, [bV]: "{Region}" }] };
  var af = {};
  var ag = { [bM]: e, [bN]: [{ [bO]: "ForcePathStyle" }, false] };
  var ah = { [bO]: "ForcePathStyle" };
  var ai = { [bM]: e, [bN]: [{ [bO]: "Accelerate" }, false] };
  var aj = { [bM]: h, [bN]: [{ [bO]: "Region" }, "aws-global"] };
  var ak = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: v, [bV]: "us-east-1" }] };
  var al = { [bM]: q, [bN]: [aj] };
  var am = { [bM]: e, [bN]: [{ [bO]: "UseGlobalEndpoint" }, true] };
  var an = { [bQ]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [bR]: { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: v, [bV]: "{Region}" }] }, [bW]: {} };
  var ao = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: v, [bV]: "{Region}" }] };
  var ap = { [bM]: e, [bN]: [{ [bO]: "UseGlobalEndpoint" }, false] };
  var aq = { [bM]: e, [bN]: [{ [bO]: "UseDualStack" }, false] };
  var ar = { [bQ]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var as = { [bM]: e, [bN]: [{ [bO]: "UseFIPS" }, false] };
  var at = { [bQ]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var au = { [bQ]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var av = { [bM]: e, [bN]: [{ [bM]: i2, [bN]: [{ [bO]: "url" }, "isIp"] }, true] };
  var aw = { [bO]: "url" };
  var ax = { [bM]: e, [bN]: [{ [bM]: i2, [bN]: [aw, "isIp"] }, false] };
  var ay = { [bQ]: w, [bR]: ao, [bW]: {} };
  var az = { [bQ]: x, [bR]: ao, [bW]: {} };
  var aA = { [t]: az, [bK]: t };
  var aB = { [bQ]: y, [bR]: ao, [bW]: {} };
  var aC = { [bQ]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var aD = { [f]: "Invalid region: region was not a valid DNS name.", [bK]: f };
  var aE = { [bO]: B };
  var aF = { [bO]: C };
  var aG = { [bM]: i2, [bN]: [aE, "service"] };
  var aH = { [bO]: G };
  var aI = { [bL]: [U], [f]: "S3 Object Lambda does not support Dual-stack", [bK]: f };
  var aJ = { [bL]: [S], [f]: "S3 Object Lambda does not support S3 Accelerate", [bK]: f };
  var aK = { [bL]: [{ [bM]: c, [bN]: [{ [bO]: "DisableAccessPoints" }] }, { [bM]: e, [bN]: [{ [bO]: "DisableAccessPoints" }, true] }], [f]: "Access points are not supported for this operation", [bK]: f };
  var aL = { [bL]: [{ [bM]: c, [bN]: [{ [bO]: "UseArnRegion" }] }, { [bM]: e, [bN]: [{ [bO]: "UseArnRegion" }, false] }, { [bM]: q, [bN]: [{ [bM]: h, [bN]: [{ [bM]: i2, [bN]: [aE, "region"] }, "{Region}"] }] }], [f]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [bK]: f };
  var aM = { [bM]: i2, [bN]: [{ [bO]: "bucketPartition" }, j] };
  var aN = { [bM]: i2, [bN]: [aE, "accountId"] };
  var aO = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: E, [bV]: "{bucketArn#region}" }] };
  var aP = { [f]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [bK]: f };
  var aQ = { [f]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [bK]: f };
  var aR = { [f]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [bK]: f };
  var aS = { [f]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [bK]: f };
  var aT = { [f]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [bK]: f };
  var aU = { [f]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [bK]: f };
  var aV = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: v, [bV]: "{bucketArn#region}" }] };
  var aW = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: s, [bV]: "{bucketArn#region}" }] };
  var aX = { [bM]: A, [bN]: [Z] };
  var aY = { [bQ]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ao, [bW]: {} };
  var aZ = { [bQ]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ao, [bW]: {} };
  var ba = { [bQ]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ao, [bW]: {} };
  var bb = { [bQ]: L, [bR]: ao, [bW]: {} };
  var bc = { [bQ]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ao, [bW]: {} };
  var bd = { [bO]: "UseObjectLambdaEndpoint" };
  var be = { [bS]: [{ [bT]: true, [j]: "sigv4", [bU]: E, [bV]: "{Region}" }] };
  var bf = { [bQ]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var bg = { [bQ]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var bh = { [bQ]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var bi = { [bQ]: N, [bR]: ao, [bW]: {} };
  var bj = { [bQ]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [bR]: ao, [bW]: {} };
  var bk = [{ [bO]: "Region" }];
  var bl = [{ [bO]: "Endpoint" }];
  var bm = [Z];
  var bn = [{ [bM]: p, [bN]: [{ [bO]: o }, false] }];
  var bo = [{ [bM]: h, [bN]: [{ [bO]: m }, "beta"] }];
  var bp = [V, ad];
  var bq = [Y];
  var br = [W];
  var bs = [{ [bM]: p, [bN]: [{ [bO]: "Region" }, false] }];
  var bt = [{ [bM]: h, [bN]: [{ [bO]: "Region" }, "us-east-1"] }];
  var bu = [{ [bM]: h, [bN]: [aF, F] }];
  var bv = [{ [bM]: i2, [bN]: [aE, "resourceId[1]"], [bP]: G }, { [bM]: q, [bN]: [{ [bM]: h, [bN]: [aH, D] }] }];
  var bw = [aE, "resourceId[1]"];
  var bx = [U];
  var by = [S];
  var bz = [{ [bM]: q, [bN]: [{ [bM]: h, [bN]: [{ [bM]: i2, [bN]: [aE, "region"] }, D] }] }];
  var bA = [{ [bM]: q, [bN]: [{ [bM]: c, [bN]: [{ [bM]: i2, [bN]: [aE, "resourceId[2]"] }] }] }];
  var bB = [aE, "resourceId[2]"];
  var bC = [{ [bM]: g, [bN]: [{ [bM]: i2, [bN]: [aE, "region"] }], [bP]: "bucketPartition" }];
  var bD = [{ [bM]: h, [bN]: [aM, { [bM]: i2, [bN]: [{ [bO]: "partitionResult" }, j] }] }];
  var bE = [{ [bM]: p, [bN]: [{ [bM]: i2, [bN]: [aE, "region"] }, true] }];
  var bF = [{ [bM]: p, [bN]: [aN, false] }];
  var bG = [{ [bM]: p, [bN]: [aH, false] }];
  var bH = [T];
  var bI = [{ [bM]: p, [bN]: [{ [bO]: "Region" }, true] }];
  var _data = { version: "1.0", parameters: { Bucket: P, Region: P, UseFIPS: Q, UseDualStack: Q, Endpoint: P, ForcePathStyle: Q, Accelerate: Q, UseGlobalEndpoint: Q, UseObjectLambdaEndpoint: R, DisableAccessPoints: R, DisableMultiRegionAccessPoints: Q, UseArnRegion: R }, rules: [{ [bL]: [{ [bM]: c, [bN]: bk }], [bK]: d, rules: [{ [bL]: [S, T], error: "Accelerate cannot be used with FIPS", [bK]: f }, { [bL]: [U, V], error: "Cannot set dual-stack in combination with a custom endpoint.", [bK]: f }, { [bL]: [V, T], error: "A custom endpoint cannot be combined with FIPS", [bK]: f }, { [bL]: [V, S], error: "A custom endpoint cannot be combined with S3 Accelerate", [bK]: f }, { [bL]: [T, W, X], error: "Partition does not support FIPS", [bK]: f }, { [bL]: [Y, { [bM]: k, [bN]: [Z, 49, 50, b], [bP]: l }, { [bM]: k, [bN]: [Z, 8, 12, b], [bP]: m }, { [bM]: k, [bN]: [Z, 0, 7, b], [bP]: n }, { [bM]: k, [bN]: [Z, 32, 49, b], [bP]: o }, { [bM]: g, [bN]: bk, [bP]: "regionPartition" }, { [bM]: h, [bN]: [{ [bO]: n }, "--op-s3"] }], [bK]: d, rules: [{ [bL]: bn, [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [aa, "e"] }], [bK]: d, rules: [{ [bL]: bo, [bK]: d, rules: [ab, { [bL]: bp, endpoint: { [bQ]: "https://{Bucket}.ec2.{url#authority}", [bR]: ae, [bW]: af }, [bK]: t }] }, { endpoint: { [bQ]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [bR]: ae, [bW]: af }, [bK]: t }] }, { [bL]: [{ [bM]: h, [bN]: [aa, "o"] }], [bK]: d, rules: [{ [bL]: bo, [bK]: d, rules: [ab, { [bL]: bp, endpoint: { [bQ]: "https://{Bucket}.op-{outpostId}.{url#authority}", [bR]: ae, [bW]: af }, [bK]: t }] }, { endpoint: { [bQ]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [bR]: ae, [bW]: af }, [bK]: t }] }, { error: "Unrecognized hardware type: \"Expected hardware type o or e but got {hardwareType}\"", [bK]: f }] }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [bK]: f }] }, { [bL]: bq, [bK]: d, rules: [{ [bL]: [V, { [bM]: q, [bN]: [{ [bM]: c, [bN]: [{ [bM]: r, [bN]: bl }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [bK]: f }, { [bL]: [ag, { [bM]: u, [bN]: [Z, a] }], [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: bs, [bK]: d, rules: [{ [bL]: [S, X], error: "S3 Accelerate cannot be used in this region", [bK]: f }, { [bL]: [U, T, ai, ac, aj], endpoint: { [bQ]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [U, T, ai, ac, al, am], [bK]: d, rules: [{ endpoint: an, [bK]: t }] }, { [bL]: [U, T, ai, ac, al, ap], endpoint: an, [bK]: t }, { [bL]: [aq, T, ai, ac, aj], endpoint: { [bQ]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, T, ai, ac, al, am], [bK]: d, rules: [{ endpoint: ar, [bK]: t }] }, { [bL]: [aq, T, ai, ac, al, ap], endpoint: ar, [bK]: t }, { [bL]: [U, as, S, ac, aj], endpoint: { [bQ]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [U, as, S, ac, al, am], [bK]: d, rules: [{ endpoint: at, [bK]: t }] }, { [bL]: [U, as, S, ac, al, ap], endpoint: at, [bK]: t }, { [bL]: [U, as, ai, ac, aj], endpoint: { [bQ]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [U, as, ai, ac, al, am], [bK]: d, rules: [{ endpoint: au, [bK]: t }] }, { [bL]: [U, as, ai, ac, al, ap], endpoint: au, [bK]: t }, { [bL]: [aq, as, ai, V, ad, av, aj], endpoint: { [bQ]: w, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, as, ai, V, ad, ax, aj], endpoint: { [bQ]: x, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, as, ai, V, ad, av, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: ay, [bK]: t }, { endpoint: ay, [bK]: t }] }, { [bL]: [aq, as, ai, V, ad, ax, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: az, [bK]: t }, aA] }, { [bL]: [aq, as, ai, V, ad, av, al, ap], endpoint: ay, [bK]: t }, { [bL]: [aq, as, ai, V, ad, ax, al, ap], endpoint: az, [bK]: t }, { [bL]: [aq, as, S, ac, aj], endpoint: { [bQ]: y, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, as, S, ac, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: aB, [bK]: t }, { endpoint: aB, [bK]: t }] }, { [bL]: [aq, as, S, ac, al, ap], endpoint: aB, [bK]: t }, { [bL]: [aq, as, ai, ac, aj], endpoint: { [bQ]: z, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, as, ai, ac, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: { [bQ]: z, [bR]: ao, [bW]: af }, [bK]: t }, { endpoint: aC, [bK]: t }] }, { [bL]: [aq, as, ai, ac, al, ap], endpoint: aC, [bK]: t }] }, aD] }] }, { [bL]: [V, ad, { [bM]: h, [bN]: [{ [bM]: i2, [bN]: [aw, "scheme"] }, "http"] }, { [bM]: u, [bN]: [Z, b] }, ag, as, aq, ai], [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: bs, [bK]: d, rules: [aA] }, aD] }] }, { [bL]: [ag, { [bM]: A, [bN]: bm, [bP]: B }], [bK]: d, rules: [{ [bL]: [{ [bM]: i2, [bN]: [aE, "resourceId[0]"], [bP]: C }, { [bM]: q, [bN]: [{ [bM]: h, [bN]: [aF, D] }] }], [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [aG, E] }], [bK]: d, rules: [{ [bL]: bu, [bK]: d, rules: [{ [bL]: bv, [bK]: d, rules: [aI, aJ, { [bL]: bz, [bK]: d, rules: [aK, { [bL]: bA, [bK]: d, rules: [aL, { [bL]: bC, [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: bD, [bK]: d, rules: [{ [bL]: bE, [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [aN, D] }], error: "Invalid ARN: Missing account id", [bK]: f }, { [bL]: bF, [bK]: d, rules: [{ [bL]: bG, [bK]: d, rules: [{ [bL]: bp, endpoint: { [bQ]: H, [bR]: aO, [bW]: af }, [bK]: t }, { [bL]: bH, endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aO, [bW]: af }, [bK]: t }, { endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aO, [bW]: af }, [bK]: t }] }, aP] }, aQ] }, aR] }, aS] }] }] }, aT] }, { error: "Invalid ARN: bucket ARN is missing a region", [bK]: f }] }, aU] }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [bK]: f }] }, { [bL]: bu, [bK]: d, rules: [{ [bL]: bv, [bK]: d, rules: [{ [bL]: bz, [bK]: d, rules: [{ [bL]: bu, [bK]: d, rules: [{ [bL]: bz, [bK]: d, rules: [aK, { [bL]: bA, [bK]: d, rules: [aL, { [bL]: bC, [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [aM, "{partitionResult#name}"] }], [bK]: d, rules: [{ [bL]: bE, [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [aG, v] }], [bK]: d, rules: [{ [bL]: bF, [bK]: d, rules: [{ [bL]: bG, [bK]: d, rules: [{ [bL]: by, error: "Access Points do not support S3 Accelerate", [bK]: f }, { [bL]: [T, U], endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aV, [bW]: af }, [bK]: t }, { [bL]: [T, aq], endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aV, [bW]: af }, [bK]: t }, { [bL]: [as, U], endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aV, [bW]: af }, [bK]: t }, { [bL]: [as, aq, V, ad], endpoint: { [bQ]: H, [bR]: aV, [bW]: af }, [bK]: t }, { [bL]: [as, aq], endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aV, [bW]: af }, [bK]: t }] }, aP] }, aQ] }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [bK]: f }] }, aR] }, aS] }] }] }, aT] }] }] }, { [bL]: [{ [bM]: p, [bN]: [aH, b] }], [bK]: d, rules: [{ [bL]: bx, error: "S3 MRAP does not support dual-stack", [bK]: f }, { [bL]: bH, error: "S3 MRAP does not support FIPS", [bK]: f }, { [bL]: by, error: "S3 MRAP does not support S3 Accelerate", [bK]: f }, { [bL]: [{ [bM]: e, [bN]: [{ [bO]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [bK]: f }, { [bL]: [{ [bM]: g, [bN]: bk, [bP]: I }], [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [{ [bM]: i2, [bN]: [{ [bO]: I }, j] }, { [bM]: i2, [bN]: [aE, "partition"] }] }], [bK]: d, rules: [{ endpoint: { [bQ]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [bR]: { [bS]: [{ [bT]: b, name: "sigv4a", [bU]: v, signingRegionSet: ["*"] }] }, [bW]: af }, [bK]: t }] }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [bK]: f }] }] }, { error: "Invalid Access Point Name", [bK]: f }] }, aU] }, { [bL]: [{ [bM]: h, [bN]: [aG, s] }], [bK]: d, rules: [{ [bL]: bx, error: "S3 Outposts does not support Dual-stack", [bK]: f }, { [bL]: bH, error: "S3 Outposts does not support FIPS", [bK]: f }, { [bL]: by, error: "S3 Outposts does not support S3 Accelerate", [bK]: f }, { [bL]: [{ [bM]: c, [bN]: [{ [bM]: i2, [bN]: [aE, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [bK]: f }, { [bL]: [{ [bM]: i2, [bN]: bw, [bP]: o }], [bK]: d, rules: [{ [bL]: bn, [bK]: d, rules: [aL, { [bL]: bC, [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: bD, [bK]: d, rules: [{ [bL]: bE, [bK]: d, rules: [{ [bL]: bF, [bK]: d, rules: [{ [bL]: [{ [bM]: i2, [bN]: bB, [bP]: J }], [bK]: d, rules: [{ [bL]: [{ [bM]: i2, [bN]: [aE, "resourceId[3]"], [bP]: G }], [bK]: d, rules: [{ [bL]: [{ [bM]: h, [bN]: [{ [bO]: J }, F] }], [bK]: d, rules: [{ [bL]: bp, endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [bR]: aW, [bW]: af }, [bK]: t }, { endpoint: { [bQ]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [bR]: aW, [bW]: af }, [bK]: t }] }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [bK]: f }] }, { error: "Invalid ARN: expected an access point name", [bK]: f }] }, { error: "Invalid ARN: Expected a 4-component resource", [bK]: f }] }, aQ] }, aR] }, aS] }] }] }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [bK]: f }] }, { error: "Invalid ARN: The Outpost Id was not set", [bK]: f }] }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [bK]: f }] }, { error: "Invalid ARN: No ARN type specified", [bK]: f }] }, { [bL]: [{ [bM]: k, [bN]: [Z, 0, 4, a], [bP]: K }, { [bM]: h, [bN]: [{ [bO]: K }, "arn:"] }, { [bM]: q, [bN]: [{ [bM]: c, [bN]: [aX] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [bK]: f }, { [bL]: [{ [bM]: e, [bN]: [ah, b] }, aX], error: "Path-style addressing cannot be used with ARN buckets", [bK]: f }, { [bL]: [{ [bM]: "uriEncode", [bN]: bm, [bP]: "uri_encoded_bucket" }], [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: [ai], [bK]: d, rules: [{ [bL]: [U, ac, T, aj], endpoint: { [bQ]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [U, ac, T, al, am], [bK]: d, rules: [{ endpoint: aY, [bK]: t }] }, { [bL]: [U, ac, T, al, ap], endpoint: aY, [bK]: t }, { [bL]: [aq, ac, T, aj], endpoint: { [bQ]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, ac, T, al, am], [bK]: d, rules: [{ endpoint: aZ, [bK]: t }] }, { [bL]: [aq, ac, T, al, ap], endpoint: aZ, [bK]: t }, { [bL]: [U, ac, as, aj], endpoint: { [bQ]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [U, ac, as, al, am], [bK]: d, rules: [{ endpoint: ba, [bK]: t }] }, { [bL]: [U, ac, as, al, ap], endpoint: ba, [bK]: t }, { [bL]: [aq, V, ad, as, aj], endpoint: { [bQ]: L, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, V, ad, as, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: bb, [bK]: t }, { endpoint: bb, [bK]: t }] }, { [bL]: [aq, V, ad, as, al, ap], endpoint: bb, [bK]: t }, { [bL]: [aq, ac, as, aj], endpoint: { [bQ]: M, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [aq, ac, as, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: { [bQ]: M, [bR]: ao, [bW]: af }, [bK]: t }, { endpoint: bc, [bK]: t }] }, { [bL]: [aq, ac, as, al, ap], endpoint: bc, [bK]: t }] }, { error: "Path-style addressing cannot be used with S3 Accelerate", [bK]: f }] }] }] }, { [bL]: [{ [bM]: c, [bN]: [bd] }, { [bM]: e, [bN]: [bd, b] }], [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: bI, [bK]: d, rules: [aI, aJ, { [bL]: bp, endpoint: { [bQ]: N, [bR]: be, [bW]: af }, [bK]: t }, { [bL]: bH, endpoint: { [bQ]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [bR]: be, [bW]: af }, [bK]: t }, { endpoint: { [bQ]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [bR]: be, [bW]: af }, [bK]: t }] }, aD] }] }, { [bL]: [{ [bM]: q, [bN]: bq }], [bK]: d, rules: [{ [bL]: br, [bK]: d, rules: [{ [bL]: bI, [bK]: d, rules: [{ [bL]: [T, U, ac, aj], endpoint: { [bQ]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [T, U, ac, al, am], [bK]: d, rules: [{ endpoint: bf, [bK]: t }] }, { [bL]: [T, U, ac, al, ap], endpoint: bf, [bK]: t }, { [bL]: [T, aq, ac, aj], endpoint: { [bQ]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [T, aq, ac, al, am], [bK]: d, rules: [{ endpoint: bg, [bK]: t }] }, { [bL]: [T, aq, ac, al, ap], endpoint: bg, [bK]: t }, { [bL]: [as, U, ac, aj], endpoint: { [bQ]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [as, U, ac, al, am], [bK]: d, rules: [{ endpoint: bh, [bK]: t }] }, { [bL]: [as, U, ac, al, ap], endpoint: bh, [bK]: t }, { [bL]: [as, aq, V, ad, aj], endpoint: { [bQ]: N, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [as, aq, V, ad, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: bi, [bK]: t }, { endpoint: bi, [bK]: t }] }, { [bL]: [as, aq, V, ad, al, ap], endpoint: bi, [bK]: t }, { [bL]: [as, aq, ac, aj], endpoint: { [bQ]: O, [bR]: ak, [bW]: af }, [bK]: t }, { [bL]: [as, aq, ac, al, am], [bK]: d, rules: [{ [bL]: bt, endpoint: { [bQ]: O, [bR]: ao, [bW]: af }, [bK]: t }, { endpoint: bj, [bK]: t }] }, { [bL]: [as, aq, ac, al, ap], endpoint: bj, [bK]: t }] }, aD] }] }] }, { error: "A region must be set when sending requests to S3.", [bK]: f }] };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs26();
  var ruleset_1 = require_ruleset3();
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    });
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var signature_v4_multi_region_1 = require_dist_cjs63();
  var smithy_client_1 = require_dist_cjs16();
  var url_parser_1 = require_dist_cjs36();
  var util_base64_1 = require_dist_cjs10();
  var util_stream_1 = require_dist_cjs15();
  var util_utf8_1 = require_dist_cjs11();
  var endpointResolver_1 = require_endpointResolver3();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2006-03-01",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? util_stream_1.getAwsChunkedEncodingStream,
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      sdkStreamMixin: config?.sdkStreamMixin ?? util_stream_1.sdkStreamMixin,
      serviceId: config?.serviceId ?? "S3",
      signerConstructor: config?.signerConstructor ?? signature_v4_multi_region_1.SignatureV4MultiRegion,
      signingEscapePath: config?.signingEscapePath ?? false,
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      useArnRegion: config?.useArnRegion ?? false,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.js
var require_runtimeConfig3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package3());
  var client_sts_1 = require_dist_cjs58();
  var core_1 = require_dist_cjs43();
  var credential_provider_node_1 = require_dist_cjs57();
  var middleware_bucket_endpoint_1 = require_dist_cjs59();
  var util_user_agent_node_1 = require_dist_cjs47();
  var config_resolver_1 = require_dist_cjs30();
  var eventstream_serde_node_1 = require_dist_cjs61();
  var hash_node_1 = require_dist_cjs48();
  var hash_stream_node_1 = require_dist_cjs62();
  var middleware_retry_1 = require_dist_cjs41();
  var node_config_provider_1 = require_dist_cjs34();
  var node_http_handler_1 = require_dist_cjs14();
  var util_body_length_node_1 = require_dist_cjs49();
  var util_retry_1 = require_dist_cjs40();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared3();
  var smithy_client_1 = require_dist_cjs16();
  var util_defaults_mode_node_1 = require_dist_cjs50();
  var smithy_client_2 = require_dist_cjs16();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventstream_serde_node_1.eventStreamSerdeProvider,
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
      md5: config?.md5 ?? hash_node_1.Hash.bind(null, "md5"),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
      requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }),
      sha1: config?.sha1 ?? hash_node_1.Hash.bind(null, "sha1"),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      streamHasher: config?.streamHasher ?? hash_stream_node_1.readableStreamHasher,
      useArnRegion: config?.useArnRegion ?? (0, node_config_provider_1.loadConfig)(middleware_bucket_endpoint_1.NODE_USE_ARN_REGION_CONFIG_OPTIONS),
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/runtimeExtensions.js
var require_runtimeExtensions3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRuntimeExtensions = undefined;
  var region_config_resolver_1 = require_dist_cjs51();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var asPartial = (t) => t;
  var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
      ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
      ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
      ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration)
    };
  };
  exports.resolveRuntimeExtensions = resolveRuntimeExtensions;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/S3Client.js
var require_S3Client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3Client = exports.__Client = undefined;
  var middleware_expect_continue_1 = require_dist_cjs3();
  var middleware_host_header_1 = require_dist_cjs4();
  var middleware_logger_1 = require_dist_cjs5();
  var middleware_recursion_detection_1 = require_dist_cjs6();
  var middleware_sdk_s3_1 = require_dist_cjs18();
  var middleware_signing_1 = require_dist_cjs25();
  var middleware_user_agent_1 = require_dist_cjs28();
  var config_resolver_1 = require_dist_cjs30();
  var eventstream_serde_config_resolver_1 = require_dist_cjs31();
  var middleware_content_length_1 = require_dist_cjs32();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_retry_1 = require_dist_cjs41();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "__Client", { enumerable: true, get: function() {
    return smithy_client_1.Client;
  } });
  var EndpointParameters_1 = require_EndpointParameters();
  var runtimeConfig_1 = require_runtimeConfig3();
  var runtimeExtensions_1 = require_runtimeExtensions3();

  class S3Client extends smithy_client_1.Client {
    constructor(...[configuration]) {
      const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
      const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
      const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
      const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
      const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
      const _config_7 = (0, middleware_sdk_s3_1.resolveS3Config)(_config_6);
      const _config_8 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_7);
      const _config_9 = (0, eventstream_serde_config_resolver_1.resolveEventStreamSerdeConfig)(_config_8);
      const _config_10 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_9, configuration?.extensions || []);
      super(_config_10);
      this.config = _config_10;
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_sdk_s3_1.getValidateBucketNamePlugin)(this.config));
      this.middlewareStack.use((0, middleware_expect_continue_1.getAddExpectContinuePlugin)(this.config));
      this.middlewareStack.use((0, middleware_sdk_s3_1.getRegionRedirectMiddlewarePlugin)(this.config));
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  }
  exports.S3Client = S3Client;
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/escape-attribute.js
var require_escape_attribute = __commonJS((exports) => {
  var escapeAttribute = function(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeAttribute = undefined;
  exports.escapeAttribute = escapeAttribute;
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/escape-element.js
var require_escape_element = __commonJS((exports) => {
  var escapeElement = function(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeElement = undefined;
  exports.escapeElement = escapeElement;
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/XmlText.js
var require_XmlText = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XmlText = undefined;
  var escape_element_1 = require_escape_element();

  class XmlText {
    constructor(value) {
      this.value = value;
    }
    toString() {
      return (0, escape_element_1.escapeElement)("" + this.value);
    }
  }
  exports.XmlText = XmlText;
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/XmlNode.js
var require_XmlNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XmlNode = undefined;
  var escape_attribute_1 = require_escape_attribute();
  var XmlText_1 = require_XmlText();

  class XmlNode {
    static of(name, childText, withName) {
      const node = new XmlNode(name);
      if (childText !== undefined) {
        node.addChildNode(new XmlText_1.XmlText(childText));
      }
      if (withName !== undefined) {
        node.withName(withName);
      }
      return node;
    }
    constructor(name, children = []) {
      this.name = name;
      this.children = children;
      this.attributes = {};
    }
    withName(name) {
      this.name = name;
      return this;
    }
    addAttribute(name, value) {
      this.attributes[name] = value;
      return this;
    }
    addChildNode(child) {
      this.children.push(child);
      return this;
    }
    removeAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    toString() {
      const hasChildren = Boolean(this.children.length);
      let xmlText = `<${this.name}`;
      const attributes = this.attributes;
      for (const attributeName of Object.keys(attributes)) {
        const attribute = attributes[attributeName];
        if (typeof attribute !== "undefined" && attribute !== null) {
          xmlText += ` ${attributeName}="${(0, escape_attribute_1.escapeAttribute)("" + attribute)}"`;
        }
      }
      return xmlText += !hasChildren ? "/>" : `>${this.children.map((c) => c.toString()).join("")}</${this.name}>`;
    }
  }
  exports.XmlNode = XmlNode;
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/index.js
var require_dist_cjs64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_XmlNode(), exports);
  tslib_1.__exportStar(require_XmlText(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/models/S3ServiceException.js
var require_S3ServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3ServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class S3ServiceException extends smithy_client_1.ServiceException {
    constructor(options5) {
      super(options5);
      Object.setPrototypeOf(this, S3ServiceException.prototype);
    }
  }
  exports.S3ServiceException = S3ServiceException;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/models/models_0.js
var require_models_03 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplicationStatus = exports.Protocol = exports.BucketVersioningStatus = exports.MFADeleteStatus = exports.Payer = exports.ReplicationRuleStatus = exports.SseKmsEncryptedObjectsStatus = exports.ReplicaModificationsStatus = exports.ReplicationRuleFilter = exports.ExistingObjectReplicationStatus = exports.ReplicationTimeStatus = exports.MetricsStatus = exports.DeleteMarkerReplicationStatus = exports.FilterRuleName = exports.Event = exports.MetricsFilter = exports.BucketLogsPermission = exports.ExpirationStatus = exports.TransitionStorageClass = exports.LifecycleRuleFilter = exports.InventoryFrequency = exports.InventoryOptionalField = exports.InventoryIncludedObjectVersions = exports.InventoryFormat = exports.IntelligentTieringAccessTier = exports.IntelligentTieringStatus = exports.StorageClassAnalysisSchemaVersion = exports.AnalyticsS3ExportFileFormat = exports.AnalyticsFilter = exports.ObjectOwnership = exports.BucketLocationConstraint = exports.BucketCannedACL = exports.BucketAlreadyOwnedByYou = exports.BucketAlreadyExists = exports.ObjectNotInActiveTierError = exports.TaggingDirective = exports.StorageClass = exports.ObjectLockMode = exports.ObjectLockLegalHoldStatus = exports.MetadataDirective = exports.ChecksumAlgorithm = exports.ObjectCannedACL = exports.ServerSideEncryption = exports.OwnerOverride = exports.Permission = exports.Type = exports.BucketAccelerateStatus = exports.NoSuchUpload = exports.RequestPayer = exports.RequestCharged = undefined;
  exports.PutObjectRequestFilterSensitiveLog = exports.PutObjectOutputFilterSensitiveLog = exports.PutBucketInventoryConfigurationRequestFilterSensitiveLog = exports.PutBucketEncryptionRequestFilterSensitiveLog = exports.ListPartsRequestFilterSensitiveLog = exports.ListBucketInventoryConfigurationsOutputFilterSensitiveLog = exports.HeadObjectRequestFilterSensitiveLog = exports.HeadObjectOutputFilterSensitiveLog = exports.GetObjectTorrentOutputFilterSensitiveLog = exports.GetObjectAttributesRequestFilterSensitiveLog = exports.GetObjectRequestFilterSensitiveLog = exports.GetObjectOutputFilterSensitiveLog = exports.GetBucketInventoryConfigurationOutputFilterSensitiveLog = exports.InventoryConfigurationFilterSensitiveLog = exports.InventoryDestinationFilterSensitiveLog = exports.InventoryS3BucketDestinationFilterSensitiveLog = exports.InventoryEncryptionFilterSensitiveLog = exports.SSEKMSFilterSensitiveLog = exports.GetBucketEncryptionOutputFilterSensitiveLog = exports.ServerSideEncryptionConfigurationFilterSensitiveLog = exports.ServerSideEncryptionRuleFilterSensitiveLog = exports.ServerSideEncryptionByDefaultFilterSensitiveLog = exports.CreateMultipartUploadRequestFilterSensitiveLog = exports.CreateMultipartUploadOutputFilterSensitiveLog = exports.CopyObjectRequestFilterSensitiveLog = exports.CopyObjectOutputFilterSensitiveLog = exports.CompleteMultipartUploadRequestFilterSensitiveLog = exports.CompleteMultipartUploadOutputFilterSensitiveLog = exports.MFADelete = exports.ObjectVersionStorageClass = exports.NoSuchBucket = exports.OptionalObjectAttributes = exports.ObjectStorageClass = exports.EncodingType = exports.ArchiveStatus = exports.NotFound = exports.ObjectLockRetentionMode = exports.ObjectLockEnabled = exports.ObjectAttributes = exports.NoSuchKey = exports.InvalidObjectState = exports.ChecksumMode = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var S3ServiceException_1 = require_S3ServiceException();
  exports.RequestCharged = {
    requester: "requester"
  };
  exports.RequestPayer = {
    requester: "requester"
  };

  class NoSuchUpload extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "NoSuchUpload",
        $fault: "client",
        ...opts
      });
      this.name = "NoSuchUpload";
      this.$fault = "client";
      Object.setPrototypeOf(this, NoSuchUpload.prototype);
    }
  }
  exports.NoSuchUpload = NoSuchUpload;
  exports.BucketAccelerateStatus = {
    Enabled: "Enabled",
    Suspended: "Suspended"
  };
  exports.Type = {
    AmazonCustomerByEmail: "AmazonCustomerByEmail",
    CanonicalUser: "CanonicalUser",
    Group: "Group"
  };
  exports.Permission = {
    FULL_CONTROL: "FULL_CONTROL",
    READ: "READ",
    READ_ACP: "READ_ACP",
    WRITE: "WRITE",
    WRITE_ACP: "WRITE_ACP"
  };
  exports.OwnerOverride = {
    Destination: "Destination"
  };
  exports.ServerSideEncryption = {
    AES256: "AES256",
    aws_kms: "aws:kms",
    aws_kms_dsse: "aws:kms:dsse"
  };
  exports.ObjectCannedACL = {
    authenticated_read: "authenticated-read",
    aws_exec_read: "aws-exec-read",
    bucket_owner_full_control: "bucket-owner-full-control",
    bucket_owner_read: "bucket-owner-read",
    private: "private",
    public_read: "public-read",
    public_read_write: "public-read-write"
  };
  exports.ChecksumAlgorithm = {
    CRC32: "CRC32",
    CRC32C: "CRC32C",
    SHA1: "SHA1",
    SHA256: "SHA256"
  };
  exports.MetadataDirective = {
    COPY: "COPY",
    REPLACE: "REPLACE"
  };
  exports.ObjectLockLegalHoldStatus = {
    OFF: "OFF",
    ON: "ON"
  };
  exports.ObjectLockMode = {
    COMPLIANCE: "COMPLIANCE",
    GOVERNANCE: "GOVERNANCE"
  };
  exports.StorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    OUTPOSTS: "OUTPOSTS",
    REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
    SNOW: "SNOW",
    STANDARD: "STANDARD",
    STANDARD_IA: "STANDARD_IA"
  };
  exports.TaggingDirective = {
    COPY: "COPY",
    REPLACE: "REPLACE"
  };

  class ObjectNotInActiveTierError extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "ObjectNotInActiveTierError",
        $fault: "client",
        ...opts
      });
      this.name = "ObjectNotInActiveTierError";
      this.$fault = "client";
      Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
    }
  }
  exports.ObjectNotInActiveTierError = ObjectNotInActiveTierError;

  class BucketAlreadyExists extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "BucketAlreadyExists",
        $fault: "client",
        ...opts
      });
      this.name = "BucketAlreadyExists";
      this.$fault = "client";
      Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
    }
  }
  exports.BucketAlreadyExists = BucketAlreadyExists;

  class BucketAlreadyOwnedByYou extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "BucketAlreadyOwnedByYou",
        $fault: "client",
        ...opts
      });
      this.name = "BucketAlreadyOwnedByYou";
      this.$fault = "client";
      Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
    }
  }
  exports.BucketAlreadyOwnedByYou = BucketAlreadyOwnedByYou;
  exports.BucketCannedACL = {
    authenticated_read: "authenticated-read",
    private: "private",
    public_read: "public-read",
    public_read_write: "public-read-write"
  };
  exports.BucketLocationConstraint = {
    EU: "EU",
    af_south_1: "af-south-1",
    ap_east_1: "ap-east-1",
    ap_northeast_1: "ap-northeast-1",
    ap_northeast_2: "ap-northeast-2",
    ap_northeast_3: "ap-northeast-3",
    ap_south_1: "ap-south-1",
    ap_south_2: "ap-south-2",
    ap_southeast_1: "ap-southeast-1",
    ap_southeast_2: "ap-southeast-2",
    ap_southeast_3: "ap-southeast-3",
    ca_central_1: "ca-central-1",
    cn_north_1: "cn-north-1",
    cn_northwest_1: "cn-northwest-1",
    eu_central_1: "eu-central-1",
    eu_north_1: "eu-north-1",
    eu_south_1: "eu-south-1",
    eu_south_2: "eu-south-2",
    eu_west_1: "eu-west-1",
    eu_west_2: "eu-west-2",
    eu_west_3: "eu-west-3",
    me_south_1: "me-south-1",
    sa_east_1: "sa-east-1",
    us_east_2: "us-east-2",
    us_gov_east_1: "us-gov-east-1",
    us_gov_west_1: "us-gov-west-1",
    us_west_1: "us-west-1",
    us_west_2: "us-west-2"
  };
  exports.ObjectOwnership = {
    BucketOwnerEnforced: "BucketOwnerEnforced",
    BucketOwnerPreferred: "BucketOwnerPreferred",
    ObjectWriter: "ObjectWriter"
  };
  var AnalyticsFilter;
  (function(AnalyticsFilter2) {
    AnalyticsFilter2.visit = (value, visitor) => {
      if (value.Prefix !== undefined)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== undefined)
        return visitor.Tag(value.Tag);
      if (value.And !== undefined)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(AnalyticsFilter = exports.AnalyticsFilter || (exports.AnalyticsFilter = {}));
  exports.AnalyticsS3ExportFileFormat = {
    CSV: "CSV"
  };
  exports.StorageClassAnalysisSchemaVersion = {
    V_1: "V_1"
  };
  exports.IntelligentTieringStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.IntelligentTieringAccessTier = {
    ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
    DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
  };
  exports.InventoryFormat = {
    CSV: "CSV",
    ORC: "ORC",
    Parquet: "Parquet"
  };
  exports.InventoryIncludedObjectVersions = {
    All: "All",
    Current: "Current"
  };
  exports.InventoryOptionalField = {
    BucketKeyStatus: "BucketKeyStatus",
    ChecksumAlgorithm: "ChecksumAlgorithm",
    ETag: "ETag",
    EncryptionStatus: "EncryptionStatus",
    IntelligentTieringAccessTier: "IntelligentTieringAccessTier",
    IsMultipartUploaded: "IsMultipartUploaded",
    LastModifiedDate: "LastModifiedDate",
    ObjectAccessControlList: "ObjectAccessControlList",
    ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus",
    ObjectLockMode: "ObjectLockMode",
    ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate",
    ObjectOwner: "ObjectOwner",
    ReplicationStatus: "ReplicationStatus",
    Size: "Size",
    StorageClass: "StorageClass"
  };
  exports.InventoryFrequency = {
    Daily: "Daily",
    Weekly: "Weekly"
  };
  var LifecycleRuleFilter;
  (function(LifecycleRuleFilter2) {
    LifecycleRuleFilter2.visit = (value, visitor) => {
      if (value.Prefix !== undefined)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== undefined)
        return visitor.Tag(value.Tag);
      if (value.ObjectSizeGreaterThan !== undefined)
        return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
      if (value.ObjectSizeLessThan !== undefined)
        return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
      if (value.And !== undefined)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(LifecycleRuleFilter = exports.LifecycleRuleFilter || (exports.LifecycleRuleFilter = {}));
  exports.TransitionStorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    STANDARD_IA: "STANDARD_IA"
  };
  exports.ExpirationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.BucketLogsPermission = {
    FULL_CONTROL: "FULL_CONTROL",
    READ: "READ",
    WRITE: "WRITE"
  };
  var MetricsFilter;
  (function(MetricsFilter2) {
    MetricsFilter2.visit = (value, visitor) => {
      if (value.Prefix !== undefined)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== undefined)
        return visitor.Tag(value.Tag);
      if (value.AccessPointArn !== undefined)
        return visitor.AccessPointArn(value.AccessPointArn);
      if (value.And !== undefined)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(MetricsFilter = exports.MetricsFilter || (exports.MetricsFilter = {}));
  exports.Event = {
    s3_IntelligentTiering: "s3:IntelligentTiering",
    s3_LifecycleExpiration_: "s3:LifecycleExpiration:*",
    s3_LifecycleExpiration_Delete: "s3:LifecycleExpiration:Delete",
    s3_LifecycleExpiration_DeleteMarkerCreated: "s3:LifecycleExpiration:DeleteMarkerCreated",
    s3_LifecycleTransition: "s3:LifecycleTransition",
    s3_ObjectAcl_Put: "s3:ObjectAcl:Put",
    s3_ObjectCreated_: "s3:ObjectCreated:*",
    s3_ObjectCreated_CompleteMultipartUpload: "s3:ObjectCreated:CompleteMultipartUpload",
    s3_ObjectCreated_Copy: "s3:ObjectCreated:Copy",
    s3_ObjectCreated_Post: "s3:ObjectCreated:Post",
    s3_ObjectCreated_Put: "s3:ObjectCreated:Put",
    s3_ObjectRemoved_: "s3:ObjectRemoved:*",
    s3_ObjectRemoved_Delete: "s3:ObjectRemoved:Delete",
    s3_ObjectRemoved_DeleteMarkerCreated: "s3:ObjectRemoved:DeleteMarkerCreated",
    s3_ObjectRestore_: "s3:ObjectRestore:*",
    s3_ObjectRestore_Completed: "s3:ObjectRestore:Completed",
    s3_ObjectRestore_Delete: "s3:ObjectRestore:Delete",
    s3_ObjectRestore_Post: "s3:ObjectRestore:Post",
    s3_ObjectTagging_: "s3:ObjectTagging:*",
    s3_ObjectTagging_Delete: "s3:ObjectTagging:Delete",
    s3_ObjectTagging_Put: "s3:ObjectTagging:Put",
    s3_ReducedRedundancyLostObject: "s3:ReducedRedundancyLostObject",
    s3_Replication_: "s3:Replication:*",
    s3_Replication_OperationFailedReplication: "s3:Replication:OperationFailedReplication",
    s3_Replication_OperationMissedThreshold: "s3:Replication:OperationMissedThreshold",
    s3_Replication_OperationNotTracked: "s3:Replication:OperationNotTracked",
    s3_Replication_OperationReplicatedAfterThreshold: "s3:Replication:OperationReplicatedAfterThreshold"
  };
  exports.FilterRuleName = {
    prefix: "prefix",
    suffix: "suffix"
  };
  exports.DeleteMarkerReplicationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.MetricsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.ReplicationTimeStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.ExistingObjectReplicationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var ReplicationRuleFilter;
  (function(ReplicationRuleFilter2) {
    ReplicationRuleFilter2.visit = (value, visitor) => {
      if (value.Prefix !== undefined)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== undefined)
        return visitor.Tag(value.Tag);
      if (value.And !== undefined)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(ReplicationRuleFilter = exports.ReplicationRuleFilter || (exports.ReplicationRuleFilter = {}));
  exports.ReplicaModificationsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.SseKmsEncryptedObjectsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.ReplicationRuleStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.Payer = {
    BucketOwner: "BucketOwner",
    Requester: "Requester"
  };
  exports.MFADeleteStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  exports.BucketVersioningStatus = {
    Enabled: "Enabled",
    Suspended: "Suspended"
  };
  exports.Protocol = {
    http: "http",
    https: "https"
  };
  exports.ReplicationStatus = {
    COMPLETE: "COMPLETE",
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    PENDING: "PENDING",
    REPLICA: "REPLICA"
  };
  exports.ChecksumMode = {
    ENABLED: "ENABLED"
  };

  class InvalidObjectState extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "InvalidObjectState",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidObjectState";
      this.$fault = "client";
      Object.setPrototypeOf(this, InvalidObjectState.prototype);
      this.StorageClass = opts.StorageClass;
      this.AccessTier = opts.AccessTier;
    }
  }
  exports.InvalidObjectState = InvalidObjectState;

  class NoSuchKey extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "NoSuchKey",
        $fault: "client",
        ...opts
      });
      this.name = "NoSuchKey";
      this.$fault = "client";
      Object.setPrototypeOf(this, NoSuchKey.prototype);
    }
  }
  exports.NoSuchKey = NoSuchKey;
  exports.ObjectAttributes = {
    CHECKSUM: "Checksum",
    ETAG: "ETag",
    OBJECT_PARTS: "ObjectParts",
    OBJECT_SIZE: "ObjectSize",
    STORAGE_CLASS: "StorageClass"
  };
  exports.ObjectLockEnabled = {
    Enabled: "Enabled"
  };
  exports.ObjectLockRetentionMode = {
    COMPLIANCE: "COMPLIANCE",
    GOVERNANCE: "GOVERNANCE"
  };

  class NotFound extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "NotFound",
        $fault: "client",
        ...opts
      });
      this.name = "NotFound";
      this.$fault = "client";
      Object.setPrototypeOf(this, NotFound.prototype);
    }
  }
  exports.NotFound = NotFound;
  exports.ArchiveStatus = {
    ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
    DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
  };
  exports.EncodingType = {
    url: "url"
  };
  exports.ObjectStorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    OUTPOSTS: "OUTPOSTS",
    REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
    SNOW: "SNOW",
    STANDARD: "STANDARD",
    STANDARD_IA: "STANDARD_IA"
  };
  exports.OptionalObjectAttributes = {
    RESTORE_STATUS: "RestoreStatus"
  };

  class NoSuchBucket extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "NoSuchBucket",
        $fault: "client",
        ...opts
      });
      this.name = "NoSuchBucket";
      this.$fault = "client";
      Object.setPrototypeOf(this, NoSuchBucket.prototype);
    }
  }
  exports.NoSuchBucket = NoSuchBucket;
  exports.ObjectVersionStorageClass = {
    STANDARD: "STANDARD"
  };
  exports.MFADelete = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var CompleteMultipartUploadOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CompleteMultipartUploadOutputFilterSensitiveLog = CompleteMultipartUploadOutputFilterSensitiveLog;
  var CompleteMultipartUploadRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CompleteMultipartUploadRequestFilterSensitiveLog = CompleteMultipartUploadRequestFilterSensitiveLog;
  var CopyObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CopyObjectOutputFilterSensitiveLog = CopyObjectOutputFilterSensitiveLog;
  var CopyObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING },
    ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CopyObjectRequestFilterSensitiveLog = CopyObjectRequestFilterSensitiveLog;
  var CreateMultipartUploadOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CreateMultipartUploadOutputFilterSensitiveLog = CreateMultipartUploadOutputFilterSensitiveLog;
  var CreateMultipartUploadRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }
  });
  exports.CreateMultipartUploadRequestFilterSensitiveLog = CreateMultipartUploadRequestFilterSensitiveLog;
  var ServerSideEncryptionByDefaultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.KMSMasterKeyID && { KMSMasterKeyID: smithy_client_1.SENSITIVE_STRING }
  });
  exports.ServerSideEncryptionByDefaultFilterSensitiveLog = ServerSideEncryptionByDefaultFilterSensitiveLog;
  var ServerSideEncryptionRuleFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.ApplyServerSideEncryptionByDefault && {
      ApplyServerSideEncryptionByDefault: (0, exports.ServerSideEncryptionByDefaultFilterSensitiveLog)(obj.ApplyServerSideEncryptionByDefault)
    }
  });
  exports.ServerSideEncryptionRuleFilterSensitiveLog = ServerSideEncryptionRuleFilterSensitiveLog;
  var ServerSideEncryptionConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Rules && { Rules: obj.Rules.map((item) => (0, exports.ServerSideEncryptionRuleFilterSensitiveLog)(item)) }
  });
  exports.ServerSideEncryptionConfigurationFilterSensitiveLog = ServerSideEncryptionConfigurationFilterSensitiveLog;
  var GetBucketEncryptionOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.ServerSideEncryptionConfiguration && {
      ServerSideEncryptionConfiguration: (0, exports.ServerSideEncryptionConfigurationFilterSensitiveLog)(obj.ServerSideEncryptionConfiguration)
    }
  });
  exports.GetBucketEncryptionOutputFilterSensitiveLog = GetBucketEncryptionOutputFilterSensitiveLog;
  var SSEKMSFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.KeyId && { KeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.SSEKMSFilterSensitiveLog = SSEKMSFilterSensitiveLog;
  var InventoryEncryptionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMS && { SSEKMS: (0, exports.SSEKMSFilterSensitiveLog)(obj.SSEKMS) }
  });
  exports.InventoryEncryptionFilterSensitiveLog = InventoryEncryptionFilterSensitiveLog;
  var InventoryS3BucketDestinationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Encryption && { Encryption: (0, exports.InventoryEncryptionFilterSensitiveLog)(obj.Encryption) }
  });
  exports.InventoryS3BucketDestinationFilterSensitiveLog = InventoryS3BucketDestinationFilterSensitiveLog;
  var InventoryDestinationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.S3BucketDestination && {
      S3BucketDestination: (0, exports.InventoryS3BucketDestinationFilterSensitiveLog)(obj.S3BucketDestination)
    }
  });
  exports.InventoryDestinationFilterSensitiveLog = InventoryDestinationFilterSensitiveLog;
  var InventoryConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Destination && { Destination: (0, exports.InventoryDestinationFilterSensitiveLog)(obj.Destination) }
  });
  exports.InventoryConfigurationFilterSensitiveLog = InventoryConfigurationFilterSensitiveLog;
  var GetBucketInventoryConfigurationOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.InventoryConfiguration && {
      InventoryConfiguration: (0, exports.InventoryConfigurationFilterSensitiveLog)(obj.InventoryConfiguration)
    }
  });
  exports.GetBucketInventoryConfigurationOutputFilterSensitiveLog = GetBucketInventoryConfigurationOutputFilterSensitiveLog;
  var GetObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.GetObjectOutputFilterSensitiveLog = GetObjectOutputFilterSensitiveLog;
  var GetObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.GetObjectRequestFilterSensitiveLog = GetObjectRequestFilterSensitiveLog;
  var GetObjectAttributesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.GetObjectAttributesRequestFilterSensitiveLog = GetObjectAttributesRequestFilterSensitiveLog;
  var GetObjectTorrentOutputFilterSensitiveLog = (obj) => ({
    ...obj
  });
  exports.GetObjectTorrentOutputFilterSensitiveLog = GetObjectTorrentOutputFilterSensitiveLog;
  var HeadObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.HeadObjectOutputFilterSensitiveLog = HeadObjectOutputFilterSensitiveLog;
  var HeadObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.HeadObjectRequestFilterSensitiveLog = HeadObjectRequestFilterSensitiveLog;
  var ListBucketInventoryConfigurationsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.InventoryConfigurationList && {
      InventoryConfigurationList: obj.InventoryConfigurationList.map((item) => (0, exports.InventoryConfigurationFilterSensitiveLog)(item))
    }
  });
  exports.ListBucketInventoryConfigurationsOutputFilterSensitiveLog = ListBucketInventoryConfigurationsOutputFilterSensitiveLog;
  var ListPartsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.ListPartsRequestFilterSensitiveLog = ListPartsRequestFilterSensitiveLog;
  var PutBucketEncryptionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.ServerSideEncryptionConfiguration && {
      ServerSideEncryptionConfiguration: (0, exports.ServerSideEncryptionConfigurationFilterSensitiveLog)(obj.ServerSideEncryptionConfiguration)
    }
  });
  exports.PutBucketEncryptionRequestFilterSensitiveLog = PutBucketEncryptionRequestFilterSensitiveLog;
  var PutBucketInventoryConfigurationRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.InventoryConfiguration && {
      InventoryConfiguration: (0, exports.InventoryConfigurationFilterSensitiveLog)(obj.InventoryConfiguration)
    }
  });
  exports.PutBucketInventoryConfigurationRequestFilterSensitiveLog = PutBucketInventoryConfigurationRequestFilterSensitiveLog;
  var PutObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }
  });
  exports.PutObjectOutputFilterSensitiveLog = PutObjectOutputFilterSensitiveLog;
  var PutObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }
  });
  exports.PutObjectRequestFilterSensitiveLog = PutObjectRequestFilterSensitiveLog;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/models/models_1.js
var require_models_1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteGetObjectResponseRequestFilterSensitiveLog = exports.UploadPartCopyRequestFilterSensitiveLog = exports.UploadPartCopyOutputFilterSensitiveLog = exports.UploadPartRequestFilterSensitiveLog = exports.UploadPartOutputFilterSensitiveLog = exports.SelectObjectContentRequestFilterSensitiveLog = exports.SelectObjectContentOutputFilterSensitiveLog = exports.SelectObjectContentEventStreamFilterSensitiveLog = exports.RestoreObjectRequestFilterSensitiveLog = exports.RestoreRequestFilterSensitiveLog = exports.OutputLocationFilterSensitiveLog = exports.S3LocationFilterSensitiveLog = exports.EncryptionFilterSensitiveLog = exports.SelectObjectContentEventStream = exports.RestoreRequestType = exports.QuoteFields = exports.JSONType = exports.FileHeaderInfo = exports.CompressionType = exports.ExpressionType = exports.Tier = exports.ObjectAlreadyInActiveTierError = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var S3ServiceException_1 = require_S3ServiceException();

  class ObjectAlreadyInActiveTierError extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
      super({
        name: "ObjectAlreadyInActiveTierError",
        $fault: "client",
        ...opts
      });
      this.name = "ObjectAlreadyInActiveTierError";
      this.$fault = "client";
      Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
    }
  }
  exports.ObjectAlreadyInActiveTierError = ObjectAlreadyInActiveTierError;
  exports.Tier = {
    Bulk: "Bulk",
    Expedited: "Expedited",
    Standard: "Standard"
  };
  exports.ExpressionType = {
    SQL: "SQL"
  };
  exports.CompressionType = {
    BZIP2: "BZIP2",
    GZIP: "GZIP",
    NONE: "NONE"
  };
  exports.FileHeaderInfo = {
    IGNORE: "IGNORE",
    NONE: "NONE",
    USE: "USE"
  };
  exports.JSONType = {
    DOCUMENT: "DOCUMENT",
    LINES: "LINES"
  };
  exports.QuoteFields = {
    ALWAYS: "ALWAYS",
    ASNEEDED: "ASNEEDED"
  };
  exports.RestoreRequestType = {
    SELECT: "SELECT"
  };
  var SelectObjectContentEventStream;
  (function(SelectObjectContentEventStream2) {
    SelectObjectContentEventStream2.visit = (value, visitor) => {
      if (value.Records !== undefined)
        return visitor.Records(value.Records);
      if (value.Stats !== undefined)
        return visitor.Stats(value.Stats);
      if (value.Progress !== undefined)
        return visitor.Progress(value.Progress);
      if (value.Cont !== undefined)
        return visitor.Cont(value.Cont);
      if (value.End !== undefined)
        return visitor.End(value.End);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(SelectObjectContentEventStream = exports.SelectObjectContentEventStream || (exports.SelectObjectContentEventStream = {}));
  var EncryptionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.KMSKeyId && { KMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.EncryptionFilterSensitiveLog = EncryptionFilterSensitiveLog;
  var S3LocationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Encryption && { Encryption: (0, exports.EncryptionFilterSensitiveLog)(obj.Encryption) }
  });
  exports.S3LocationFilterSensitiveLog = S3LocationFilterSensitiveLog;
  var OutputLocationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.S3 && { S3: (0, exports.S3LocationFilterSensitiveLog)(obj.S3) }
  });
  exports.OutputLocationFilterSensitiveLog = OutputLocationFilterSensitiveLog;
  var RestoreRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.OutputLocation && { OutputLocation: (0, exports.OutputLocationFilterSensitiveLog)(obj.OutputLocation) }
  });
  exports.RestoreRequestFilterSensitiveLog = RestoreRequestFilterSensitiveLog;
  var RestoreObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.RestoreRequest && { RestoreRequest: (0, exports.RestoreRequestFilterSensitiveLog)(obj.RestoreRequest) }
  });
  exports.RestoreObjectRequestFilterSensitiveLog = RestoreObjectRequestFilterSensitiveLog;
  var SelectObjectContentEventStreamFilterSensitiveLog = (obj) => {
    if (obj.Records !== undefined)
      return { Records: obj.Records };
    if (obj.Stats !== undefined)
      return { Stats: obj.Stats };
    if (obj.Progress !== undefined)
      return { Progress: obj.Progress };
    if (obj.Cont !== undefined)
      return { Cont: obj.Cont };
    if (obj.End !== undefined)
      return { End: obj.End };
    if (obj.$unknown !== undefined)
      return { [obj.$unknown[0]]: "UNKNOWN" };
  };
  exports.SelectObjectContentEventStreamFilterSensitiveLog = SelectObjectContentEventStreamFilterSensitiveLog;
  var SelectObjectContentOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Payload && { Payload: "STREAMING_CONTENT" }
  });
  exports.SelectObjectContentOutputFilterSensitiveLog = SelectObjectContentOutputFilterSensitiveLog;
  var SelectObjectContentRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.SelectObjectContentRequestFilterSensitiveLog = SelectObjectContentRequestFilterSensitiveLog;
  var UploadPartOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.UploadPartOutputFilterSensitiveLog = UploadPartOutputFilterSensitiveLog;
  var UploadPartRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.UploadPartRequestFilterSensitiveLog = UploadPartRequestFilterSensitiveLog;
  var UploadPartCopyOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.UploadPartCopyOutputFilterSensitiveLog = UploadPartCopyOutputFilterSensitiveLog;
  var UploadPartCopyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING },
    ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: smithy_client_1.SENSITIVE_STRING }
  });
  exports.UploadPartCopyRequestFilterSensitiveLog = UploadPartCopyRequestFilterSensitiveLog;
  var WriteGetObjectResponseRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }
  });
  exports.WriteGetObjectResponseRequestFilterSensitiveLog = WriteGetObjectResponseRequestFilterSensitiveLog;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/protocols/Aws_restXml.js
var require_Aws_restXml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.se_GetObjectTorrentCommand = exports.se_GetObjectTaggingCommand = exports.se_GetObjectRetentionCommand = exports.se_GetObjectLockConfigurationCommand = exports.se_GetObjectLegalHoldCommand = exports.se_GetObjectAttributesCommand = exports.se_GetObjectAclCommand = exports.se_GetObjectCommand = exports.se_GetBucketWebsiteCommand = exports.se_GetBucketVersioningCommand = exports.se_GetBucketTaggingCommand = exports.se_GetBucketRequestPaymentCommand = exports.se_GetBucketReplicationCommand = exports.se_GetBucketPolicyStatusCommand = exports.se_GetBucketPolicyCommand = exports.se_GetBucketOwnershipControlsCommand = exports.se_GetBucketNotificationConfigurationCommand = exports.se_GetBucketMetricsConfigurationCommand = exports.se_GetBucketLoggingCommand = exports.se_GetBucketLocationCommand = exports.se_GetBucketLifecycleConfigurationCommand = exports.se_GetBucketInventoryConfigurationCommand = exports.se_GetBucketIntelligentTieringConfigurationCommand = exports.se_GetBucketEncryptionCommand = exports.se_GetBucketCorsCommand = exports.se_GetBucketAnalyticsConfigurationCommand = exports.se_GetBucketAclCommand = exports.se_GetBucketAccelerateConfigurationCommand = exports.se_DeletePublicAccessBlockCommand = exports.se_DeleteObjectTaggingCommand = exports.se_DeleteObjectsCommand = exports.se_DeleteObjectCommand = exports.se_DeleteBucketWebsiteCommand = exports.se_DeleteBucketTaggingCommand = exports.se_DeleteBucketReplicationCommand = exports.se_DeleteBucketPolicyCommand = exports.se_DeleteBucketOwnershipControlsCommand = exports.se_DeleteBucketMetricsConfigurationCommand = exports.se_DeleteBucketLifecycleCommand = exports.se_DeleteBucketInventoryConfigurationCommand = exports.se_DeleteBucketIntelligentTieringConfigurationCommand = exports.se_DeleteBucketEncryptionCommand = exports.se_DeleteBucketCorsCommand = exports.se_DeleteBucketAnalyticsConfigurationCommand = exports.se_DeleteBucketCommand = exports.se_CreateMultipartUploadCommand = exports.se_CreateBucketCommand = exports.se_CopyObjectCommand = exports.se_CompleteMultipartUploadCommand = exports.se_AbortMultipartUploadCommand = undefined;
  exports.de_DeleteBucketAnalyticsConfigurationCommand = exports.de_DeleteBucketCommand = exports.de_CreateMultipartUploadCommand = exports.de_CreateBucketCommand = exports.de_CopyObjectCommand = exports.de_CompleteMultipartUploadCommand = exports.de_AbortMultipartUploadCommand = exports.se_WriteGetObjectResponseCommand = exports.se_UploadPartCopyCommand = exports.se_UploadPartCommand = exports.se_SelectObjectContentCommand = exports.se_RestoreObjectCommand = exports.se_PutPublicAccessBlockCommand = exports.se_PutObjectTaggingCommand = exports.se_PutObjectRetentionCommand = exports.se_PutObjectLockConfigurationCommand = exports.se_PutObjectLegalHoldCommand = exports.se_PutObjectAclCommand = exports.se_PutObjectCommand = exports.se_PutBucketWebsiteCommand = exports.se_PutBucketVersioningCommand = exports.se_PutBucketTaggingCommand = exports.se_PutBucketRequestPaymentCommand = exports.se_PutBucketReplicationCommand = exports.se_PutBucketPolicyCommand = exports.se_PutBucketOwnershipControlsCommand = exports.se_PutBucketNotificationConfigurationCommand = exports.se_PutBucketMetricsConfigurationCommand = exports.se_PutBucketLoggingCommand = exports.se_PutBucketLifecycleConfigurationCommand = exports.se_PutBucketInventoryConfigurationCommand = exports.se_PutBucketIntelligentTieringConfigurationCommand = exports.se_PutBucketEncryptionCommand = exports.se_PutBucketCorsCommand = exports.se_PutBucketAnalyticsConfigurationCommand = exports.se_PutBucketAclCommand = exports.se_PutBucketAccelerateConfigurationCommand = exports.se_ListPartsCommand = exports.se_ListObjectVersionsCommand = exports.se_ListObjectsV2Command = exports.se_ListObjectsCommand = exports.se_ListMultipartUploadsCommand = exports.se_ListBucketsCommand = exports.se_ListBucketMetricsConfigurationsCommand = exports.se_ListBucketInventoryConfigurationsCommand = exports.se_ListBucketIntelligentTieringConfigurationsCommand = exports.se_ListBucketAnalyticsConfigurationsCommand = exports.se_HeadObjectCommand = exports.se_HeadBucketCommand = exports.se_GetPublicAccessBlockCommand = undefined;
  exports.de_ListBucketMetricsConfigurationsCommand = exports.de_ListBucketInventoryConfigurationsCommand = exports.de_ListBucketIntelligentTieringConfigurationsCommand = exports.de_ListBucketAnalyticsConfigurationsCommand = exports.de_HeadObjectCommand = exports.de_HeadBucketCommand = exports.de_GetPublicAccessBlockCommand = exports.de_GetObjectTorrentCommand = exports.de_GetObjectTaggingCommand = exports.de_GetObjectRetentionCommand = exports.de_GetObjectLockConfigurationCommand = exports.de_GetObjectLegalHoldCommand = exports.de_GetObjectAttributesCommand = exports.de_GetObjectAclCommand = exports.de_GetObjectCommand = exports.de_GetBucketWebsiteCommand = exports.de_GetBucketVersioningCommand = exports.de_GetBucketTaggingCommand = exports.de_GetBucketRequestPaymentCommand = exports.de_GetBucketReplicationCommand = exports.de_GetBucketPolicyStatusCommand = exports.de_GetBucketPolicyCommand = exports.de_GetBucketOwnershipControlsCommand = exports.de_GetBucketNotificationConfigurationCommand = exports.de_GetBucketMetricsConfigurationCommand = exports.de_GetBucketLoggingCommand = exports.de_GetBucketLocationCommand = exports.de_GetBucketLifecycleConfigurationCommand = exports.de_GetBucketInventoryConfigurationCommand = exports.de_GetBucketIntelligentTieringConfigurationCommand = exports.de_GetBucketEncryptionCommand = exports.de_GetBucketCorsCommand = exports.de_GetBucketAnalyticsConfigurationCommand = exports.de_GetBucketAclCommand = exports.de_GetBucketAccelerateConfigurationCommand = exports.de_DeletePublicAccessBlockCommand = exports.de_DeleteObjectTaggingCommand = exports.de_DeleteObjectsCommand = exports.de_DeleteObjectCommand = exports.de_DeleteBucketWebsiteCommand = exports.de_DeleteBucketTaggingCommand = exports.de_DeleteBucketReplicationCommand = exports.de_DeleteBucketPolicyCommand = exports.de_DeleteBucketOwnershipControlsCommand = exports.de_DeleteBucketMetricsConfigurationCommand = exports.de_DeleteBucketLifecycleCommand = exports.de_DeleteBucketInventoryConfigurationCommand = exports.de_DeleteBucketIntelligentTieringConfigurationCommand = exports.de_DeleteBucketEncryptionCommand = exports.de_DeleteBucketCorsCommand = undefined;
  exports.de_WriteGetObjectResponseCommand = exports.de_UploadPartCopyCommand = exports.de_UploadPartCommand = exports.de_SelectObjectContentCommand = exports.de_RestoreObjectCommand = exports.de_PutPublicAccessBlockCommand = exports.de_PutObjectTaggingCommand = exports.de_PutObjectRetentionCommand = exports.de_PutObjectLockConfigurationCommand = exports.de_PutObjectLegalHoldCommand = exports.de_PutObjectAclCommand = exports.de_PutObjectCommand = exports.de_PutBucketWebsiteCommand = exports.de_PutBucketVersioningCommand = exports.de_PutBucketTaggingCommand = exports.de_PutBucketRequestPaymentCommand = exports.de_PutBucketReplicationCommand = exports.de_PutBucketPolicyCommand = exports.de_PutBucketOwnershipControlsCommand = exports.de_PutBucketNotificationConfigurationCommand = exports.de_PutBucketMetricsConfigurationCommand = exports.de_PutBucketLoggingCommand = exports.de_PutBucketLifecycleConfigurationCommand = exports.de_PutBucketInventoryConfigurationCommand = exports.de_PutBucketIntelligentTieringConfigurationCommand = exports.de_PutBucketEncryptionCommand = exports.de_PutBucketCorsCommand = exports.de_PutBucketAnalyticsConfigurationCommand = exports.de_PutBucketAclCommand = exports.de_PutBucketAccelerateConfigurationCommand = exports.de_ListPartsCommand = exports.de_ListObjectVersionsCommand = exports.de_ListObjectsV2Command = exports.de_ListObjectsCommand = exports.de_ListMultipartUploadsCommand = exports.de_ListBucketsCommand = undefined;
  var xml_builder_1 = require_dist_cjs64();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs16();
  var fast_xml_parser_1 = require_fxp();
  var models_0_1 = require_models_03();
  var models_1_1 = require_models_1();
  var S3ServiceException_1 = require_S3ServiceException();
  var se_AbortMultipartUploadCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "AbortMultipartUpload"],
      uploadId: [, (0, smithy_client_1.expectNonNull)(input.UploadId, `UploadId`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_AbortMultipartUploadCommand = se_AbortMultipartUploadCommand;
  var se_CompleteMultipartUploadCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-checksum-crc32": input.ChecksumCRC32,
      "x-amz-checksum-crc32c": input.ChecksumCRC32C,
      "x-amz-checksum-sha1": input.ChecksumSHA1,
      "x-amz-checksum-sha256": input.ChecksumSHA256,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "CompleteMultipartUpload"],
      uploadId: [, (0, smithy_client_1.expectNonNull)(input.UploadId, `UploadId`)]
    });
    let body;
    if (input.MultipartUpload !== undefined) {
      body = se_CompletedMultipartUpload(input.MultipartUpload, context);
    }
    let contents;
    if (input.MultipartUpload !== undefined) {
      contents = se_CompletedMultipartUpload(input.MultipartUpload, context);
      contents = contents.withName("CompleteMultipartUpload");
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_CompleteMultipartUploadCommand = se_CompleteMultipartUploadCommand;
  var se_CopyObjectCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-acl": input.ACL,
      "cache-control": input.CacheControl,
      "x-amz-checksum-algorithm": input.ChecksumAlgorithm,
      "content-disposition": input.ContentDisposition,
      "content-encoding": input.ContentEncoding,
      "content-language": input.ContentLanguage,
      "content-type": input.ContentType,
      "x-amz-copy-source": input.CopySource,
      "x-amz-copy-source-if-match": input.CopySourceIfMatch,
      "x-amz-copy-source-if-modified-since": [
        () => isSerializableHeaderValue(input.CopySourceIfModifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.CopySourceIfModifiedSince).toString()
      ],
      "x-amz-copy-source-if-none-match": input.CopySourceIfNoneMatch,
      "x-amz-copy-source-if-unmodified-since": [
        () => isSerializableHeaderValue(input.CopySourceIfUnmodifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.CopySourceIfUnmodifiedSince).toString()
      ],
      expires: [() => isSerializableHeaderValue(input.Expires), () => (0, smithy_client_1.dateToUtcString)(input.Expires).toString()],
      "x-amz-grant-full-control": input.GrantFullControl,
      "x-amz-grant-read": input.GrantRead,
      "x-amz-grant-read-acp": input.GrantReadACP,
      "x-amz-grant-write-acp": input.GrantWriteACP,
      "x-amz-metadata-directive": input.MetadataDirective,
      "x-amz-tagging-directive": input.TaggingDirective,
      "x-amz-server-side-encryption": input.ServerSideEncryption,
      "x-amz-storage-class": input.StorageClass,
      "x-amz-website-redirect-location": input.WebsiteRedirectLocation,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
      "x-amz-server-side-encryption-context": input.SSEKMSEncryptionContext,
      "x-amz-server-side-encryption-bucket-key-enabled": [
        () => isSerializableHeaderValue(input.BucketKeyEnabled),
        () => input.BucketKeyEnabled.toString()
      ],
      "x-amz-copy-source-server-side-encryption-customer-algorithm": input.CopySourceSSECustomerAlgorithm,
      "x-amz-copy-source-server-side-encryption-customer-key": input.CopySourceSSECustomerKey,
      "x-amz-copy-source-server-side-encryption-customer-key-md5": input.CopySourceSSECustomerKeyMD5,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-tagging": input.Tagging,
      "x-amz-object-lock-mode": input.ObjectLockMode,
      "x-amz-object-lock-retain-until-date": [
        () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
        () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
      ],
      "x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-source-expected-bucket-owner": input.ExpectedSourceBucketOwner,
      ...input.Metadata !== undefined && Object.keys(input.Metadata).reduce((acc, suffix) => {
        acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
        return acc;
      }, {})
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "CopyObject"]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_CopyObjectCommand = se_CopyObjectCommand;
  var se_CreateBucketCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-acl": input.ACL,
      "x-amz-grant-full-control": input.GrantFullControl,
      "x-amz-grant-read": input.GrantRead,
      "x-amz-grant-read-acp": input.GrantReadACP,
      "x-amz-grant-write": input.GrantWrite,
      "x-amz-grant-write-acp": input.GrantWriteACP,
      "x-amz-bucket-object-lock-enabled": [
        () => isSerializableHeaderValue(input.ObjectLockEnabledForBucket),
        () => input.ObjectLockEnabledForBucket.toString()
      ],
      "x-amz-object-ownership": input.ObjectOwnership
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    if (input.CreateBucketConfiguration !== undefined) {
      body = se_CreateBucketConfiguration(input.CreateBucketConfiguration, context);
    }
    let contents;
    if (input.CreateBucketConfiguration !== undefined) {
      contents = se_CreateBucketConfiguration(input.CreateBucketConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      body
    });
  };
  exports.se_CreateBucketCommand = se_CreateBucketCommand;
  var se_CreateMultipartUploadCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-acl": input.ACL,
      "cache-control": input.CacheControl,
      "content-disposition": input.ContentDisposition,
      "content-encoding": input.ContentEncoding,
      "content-language": input.ContentLanguage,
      "content-type": input.ContentType,
      expires: [() => isSerializableHeaderValue(input.Expires), () => (0, smithy_client_1.dateToUtcString)(input.Expires).toString()],
      "x-amz-grant-full-control": input.GrantFullControl,
      "x-amz-grant-read": input.GrantRead,
      "x-amz-grant-read-acp": input.GrantReadACP,
      "x-amz-grant-write-acp": input.GrantWriteACP,
      "x-amz-server-side-encryption": input.ServerSideEncryption,
      "x-amz-storage-class": input.StorageClass,
      "x-amz-website-redirect-location": input.WebsiteRedirectLocation,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
      "x-amz-server-side-encryption-context": input.SSEKMSEncryptionContext,
      "x-amz-server-side-encryption-bucket-key-enabled": [
        () => isSerializableHeaderValue(input.BucketKeyEnabled),
        () => input.BucketKeyEnabled.toString()
      ],
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-tagging": input.Tagging,
      "x-amz-object-lock-mode": input.ObjectLockMode,
      "x-amz-object-lock-retain-until-date": [
        () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
        () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
      ],
      "x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-checksum-algorithm": input.ChecksumAlgorithm,
      ...input.Metadata !== undefined && Object.keys(input.Metadata).reduce((acc, suffix) => {
        acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
        return acc;
      }, {})
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      uploads: [, ""],
      "x-id": [, "CreateMultipartUpload"]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_CreateMultipartUploadCommand = se_CreateMultipartUploadCommand;
  var se_DeleteBucketCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      body
    });
  };
  exports.se_DeleteBucketCommand = se_DeleteBucketCommand;
  var se_DeleteBucketAnalyticsConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      analytics: [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketAnalyticsConfigurationCommand = se_DeleteBucketAnalyticsConfigurationCommand;
  var se_DeleteBucketCorsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      cors: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketCorsCommand = se_DeleteBucketCorsCommand;
  var se_DeleteBucketEncryptionCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      encryption: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketEncryptionCommand = se_DeleteBucketEncryptionCommand;
  var se_DeleteBucketIntelligentTieringConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "intelligent-tiering": [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketIntelligentTieringConfigurationCommand = se_DeleteBucketIntelligentTieringConfigurationCommand;
  var se_DeleteBucketInventoryConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      inventory: [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketInventoryConfigurationCommand = se_DeleteBucketInventoryConfigurationCommand;
  var se_DeleteBucketLifecycleCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      lifecycle: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketLifecycleCommand = se_DeleteBucketLifecycleCommand;
  var se_DeleteBucketMetricsConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      metrics: [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketMetricsConfigurationCommand = se_DeleteBucketMetricsConfigurationCommand;
  var se_DeleteBucketOwnershipControlsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      ownershipControls: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketOwnershipControlsCommand = se_DeleteBucketOwnershipControlsCommand;
  var se_DeleteBucketPolicyCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      policy: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketPolicyCommand = se_DeleteBucketPolicyCommand;
  var se_DeleteBucketReplicationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      replication: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketReplicationCommand = se_DeleteBucketReplicationCommand;
  var se_DeleteBucketTaggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      tagging: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketTaggingCommand = se_DeleteBucketTaggingCommand;
  var se_DeleteBucketWebsiteCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      website: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteBucketWebsiteCommand = se_DeleteBucketWebsiteCommand;
  var se_DeleteObjectCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-mfa": input.MFA,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-bypass-governance-retention": [
        () => isSerializableHeaderValue(input.BypassGovernanceRetention),
        () => input.BypassGovernanceRetention.toString()
      ],
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "DeleteObject"],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteObjectCommand = se_DeleteObjectCommand;
  var se_DeleteObjectsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-mfa": input.MFA,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-bypass-governance-retention": [
        () => isSerializableHeaderValue(input.BypassGovernanceRetention),
        () => input.BypassGovernanceRetention.toString()
      ],
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      delete: [, ""],
      "x-id": [, "DeleteObjects"]
    });
    let body;
    if (input.Delete !== undefined) {
      body = se_Delete(input.Delete, context);
    }
    let contents;
    if (input.Delete !== undefined) {
      contents = se_Delete(input.Delete, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteObjectsCommand = se_DeleteObjectsCommand;
  var se_DeleteObjectTaggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      tagging: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeleteObjectTaggingCommand = se_DeleteObjectTaggingCommand;
  var se_DeletePublicAccessBlockCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      publicAccessBlock: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "DELETE",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_DeletePublicAccessBlockCommand = se_DeletePublicAccessBlockCommand;
  var se_GetBucketAccelerateConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-request-payer": input.RequestPayer
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      accelerate: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketAccelerateConfigurationCommand = se_GetBucketAccelerateConfigurationCommand;
  var se_GetBucketAclCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      acl: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketAclCommand = se_GetBucketAclCommand;
  var se_GetBucketAnalyticsConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      analytics: [, ""],
      "x-id": [, "GetBucketAnalyticsConfiguration"],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketAnalyticsConfigurationCommand = se_GetBucketAnalyticsConfigurationCommand;
  var se_GetBucketCorsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      cors: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketCorsCommand = se_GetBucketCorsCommand;
  var se_GetBucketEncryptionCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      encryption: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketEncryptionCommand = se_GetBucketEncryptionCommand;
  var se_GetBucketIntelligentTieringConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "intelligent-tiering": [, ""],
      "x-id": [, "GetBucketIntelligentTieringConfiguration"],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketIntelligentTieringConfigurationCommand = se_GetBucketIntelligentTieringConfigurationCommand;
  var se_GetBucketInventoryConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      inventory: [, ""],
      "x-id": [, "GetBucketInventoryConfiguration"],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketInventoryConfigurationCommand = se_GetBucketInventoryConfigurationCommand;
  var se_GetBucketLifecycleConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      lifecycle: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketLifecycleConfigurationCommand = se_GetBucketLifecycleConfigurationCommand;
  var se_GetBucketLocationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      location: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketLocationCommand = se_GetBucketLocationCommand;
  var se_GetBucketLoggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      logging: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketLoggingCommand = se_GetBucketLoggingCommand;
  var se_GetBucketMetricsConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      metrics: [, ""],
      "x-id": [, "GetBucketMetricsConfiguration"],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketMetricsConfigurationCommand = se_GetBucketMetricsConfigurationCommand;
  var se_GetBucketNotificationConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      notification: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketNotificationConfigurationCommand = se_GetBucketNotificationConfigurationCommand;
  var se_GetBucketOwnershipControlsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      ownershipControls: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketOwnershipControlsCommand = se_GetBucketOwnershipControlsCommand;
  var se_GetBucketPolicyCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      policy: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketPolicyCommand = se_GetBucketPolicyCommand;
  var se_GetBucketPolicyStatusCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      policyStatus: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketPolicyStatusCommand = se_GetBucketPolicyStatusCommand;
  var se_GetBucketReplicationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      replication: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketReplicationCommand = se_GetBucketReplicationCommand;
  var se_GetBucketRequestPaymentCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      requestPayment: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketRequestPaymentCommand = se_GetBucketRequestPaymentCommand;
  var se_GetBucketTaggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      tagging: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketTaggingCommand = se_GetBucketTaggingCommand;
  var se_GetBucketVersioningCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      versioning: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketVersioningCommand = se_GetBucketVersioningCommand;
  var se_GetBucketWebsiteCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      website: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetBucketWebsiteCommand = se_GetBucketWebsiteCommand;
  var se_GetObjectCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "if-match": input.IfMatch,
      "if-modified-since": [
        () => isSerializableHeaderValue(input.IfModifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.IfModifiedSince).toString()
      ],
      "if-none-match": input.IfNoneMatch,
      "if-unmodified-since": [
        () => isSerializableHeaderValue(input.IfUnmodifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.IfUnmodifiedSince).toString()
      ],
      range: input.Range,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-checksum-mode": input.ChecksumMode
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "GetObject"],
      "response-cache-control": [, input.ResponseCacheControl],
      "response-content-disposition": [, input.ResponseContentDisposition],
      "response-content-encoding": [, input.ResponseContentEncoding],
      "response-content-language": [, input.ResponseContentLanguage],
      "response-content-type": [, input.ResponseContentType],
      "response-expires": [
        () => input.ResponseExpires !== undefined,
        () => (0, smithy_client_1.dateToUtcString)(input.ResponseExpires).toString()
      ],
      versionId: [, input.VersionId],
      partNumber: [() => input.PartNumber !== undefined, () => input.PartNumber.toString()]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectCommand = se_GetObjectCommand;
  var se_GetObjectAclCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      acl: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectAclCommand = se_GetObjectAclCommand;
  var se_GetObjectAttributesCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-max-parts": [() => isSerializableHeaderValue(input.MaxParts), () => input.MaxParts.toString()],
      "x-amz-part-number-marker": input.PartNumberMarker,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-object-attributes": [
        () => isSerializableHeaderValue(input.ObjectAttributes),
        () => (input.ObjectAttributes || []).map((_entry) => _entry).join(", ")
      ]
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      attributes: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectAttributesCommand = se_GetObjectAttributesCommand;
  var se_GetObjectLegalHoldCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "legal-hold": [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectLegalHoldCommand = se_GetObjectLegalHoldCommand;
  var se_GetObjectLockConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "object-lock": [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectLockConfigurationCommand = se_GetObjectLockConfigurationCommand;
  var se_GetObjectRetentionCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      retention: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectRetentionCommand = se_GetObjectRetentionCommand;
  var se_GetObjectTaggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-request-payer": input.RequestPayer
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      tagging: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectTaggingCommand = se_GetObjectTaggingCommand;
  var se_GetObjectTorrentCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      torrent: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetObjectTorrentCommand = se_GetObjectTorrentCommand;
  var se_GetPublicAccessBlockCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      publicAccessBlock: [, ""]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_GetPublicAccessBlockCommand = se_GetPublicAccessBlockCommand;
  var se_HeadBucketCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "HEAD",
      headers,
      path: resolvedPath,
      body
    });
  };
  exports.se_HeadBucketCommand = se_HeadBucketCommand;
  var se_HeadObjectCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "if-match": input.IfMatch,
      "if-modified-since": [
        () => isSerializableHeaderValue(input.IfModifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.IfModifiedSince).toString()
      ],
      "if-none-match": input.IfNoneMatch,
      "if-unmodified-since": [
        () => isSerializableHeaderValue(input.IfUnmodifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.IfUnmodifiedSince).toString()
      ],
      range: input.Range,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-checksum-mode": input.ChecksumMode
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      versionId: [, input.VersionId],
      partNumber: [() => input.PartNumber !== undefined, () => input.PartNumber.toString()]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "HEAD",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_HeadObjectCommand = se_HeadObjectCommand;
  var se_ListBucketAnalyticsConfigurationsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      analytics: [, ""],
      "x-id": [, "ListBucketAnalyticsConfigurations"],
      "continuation-token": [, input.ContinuationToken]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListBucketAnalyticsConfigurationsCommand = se_ListBucketAnalyticsConfigurationsCommand;
  var se_ListBucketIntelligentTieringConfigurationsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "intelligent-tiering": [, ""],
      "x-id": [, "ListBucketIntelligentTieringConfigurations"],
      "continuation-token": [, input.ContinuationToken]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListBucketIntelligentTieringConfigurationsCommand = se_ListBucketIntelligentTieringConfigurationsCommand;
  var se_ListBucketInventoryConfigurationsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      inventory: [, ""],
      "x-id": [, "ListBucketInventoryConfigurations"],
      "continuation-token": [, input.ContinuationToken]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListBucketInventoryConfigurationsCommand = se_ListBucketInventoryConfigurationsCommand;
  var se_ListBucketMetricsConfigurationsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      metrics: [, ""],
      "x-id": [, "ListBucketMetricsConfigurations"],
      "continuation-token": [, input.ContinuationToken]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListBucketMetricsConfigurationsCommand = se_ListBucketMetricsConfigurationsCommand;
  var se_ListBucketsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {
      "content-type": "application/xml"
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      body
    });
  };
  exports.se_ListBucketsCommand = se_ListBucketsCommand;
  var se_ListMultipartUploadsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-request-payer": input.RequestPayer
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      uploads: [, ""],
      delimiter: [, input.Delimiter],
      "encoding-type": [, input.EncodingType],
      "key-marker": [, input.KeyMarker],
      "max-uploads": [() => input.MaxUploads !== undefined, () => input.MaxUploads.toString()],
      prefix: [, input.Prefix],
      "upload-id-marker": [, input.UploadIdMarker]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListMultipartUploadsCommand = se_ListMultipartUploadsCommand;
  var se_ListObjectsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-optional-object-attributes": [
        () => isSerializableHeaderValue(input.OptionalObjectAttributes),
        () => (input.OptionalObjectAttributes || []).map((_entry) => _entry).join(", ")
      ]
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      delimiter: [, input.Delimiter],
      "encoding-type": [, input.EncodingType],
      marker: [, input.Marker],
      "max-keys": [() => input.MaxKeys !== undefined, () => input.MaxKeys.toString()],
      prefix: [, input.Prefix]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListObjectsCommand = se_ListObjectsCommand;
  var se_ListObjectsV2Command = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-optional-object-attributes": [
        () => isSerializableHeaderValue(input.OptionalObjectAttributes),
        () => (input.OptionalObjectAttributes || []).map((_entry) => _entry).join(", ")
      ]
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "list-type": [, "2"],
      delimiter: [, input.Delimiter],
      "encoding-type": [, input.EncodingType],
      "max-keys": [() => input.MaxKeys !== undefined, () => input.MaxKeys.toString()],
      prefix: [, input.Prefix],
      "continuation-token": [, input.ContinuationToken],
      "fetch-owner": [() => input.FetchOwner !== undefined, () => input.FetchOwner.toString()],
      "start-after": [, input.StartAfter]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListObjectsV2Command = se_ListObjectsV2Command;
  var se_ListObjectVersionsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-optional-object-attributes": [
        () => isSerializableHeaderValue(input.OptionalObjectAttributes),
        () => (input.OptionalObjectAttributes || []).map((_entry) => _entry).join(", ")
      ]
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      versions: [, ""],
      delimiter: [, input.Delimiter],
      "encoding-type": [, input.EncodingType],
      "key-marker": [, input.KeyMarker],
      "max-keys": [() => input.MaxKeys !== undefined, () => input.MaxKeys.toString()],
      prefix: [, input.Prefix],
      "version-id-marker": [, input.VersionIdMarker]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListObjectVersionsCommand = se_ListObjectVersionsCommand;
  var se_ListPartsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "ListParts"],
      "max-parts": [() => input.MaxParts !== undefined, () => input.MaxParts.toString()],
      "part-number-marker": [, input.PartNumberMarker],
      uploadId: [, (0, smithy_client_1.expectNonNull)(input.UploadId, `UploadId`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "GET",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_ListPartsCommand = se_ListPartsCommand;
  var se_PutBucketAccelerateConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      accelerate: [, ""]
    });
    let body;
    if (input.AccelerateConfiguration !== undefined) {
      body = se_AccelerateConfiguration(input.AccelerateConfiguration, context);
    }
    let contents;
    if (input.AccelerateConfiguration !== undefined) {
      contents = se_AccelerateConfiguration(input.AccelerateConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketAccelerateConfigurationCommand = se_PutBucketAccelerateConfigurationCommand;
  var se_PutBucketAclCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-acl": input.ACL,
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-grant-full-control": input.GrantFullControl,
      "x-amz-grant-read": input.GrantRead,
      "x-amz-grant-read-acp": input.GrantReadACP,
      "x-amz-grant-write": input.GrantWrite,
      "x-amz-grant-write-acp": input.GrantWriteACP,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      acl: [, ""]
    });
    let body;
    if (input.AccessControlPolicy !== undefined) {
      body = se_AccessControlPolicy(input.AccessControlPolicy, context);
    }
    let contents;
    if (input.AccessControlPolicy !== undefined) {
      contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketAclCommand = se_PutBucketAclCommand;
  var se_PutBucketAnalyticsConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      analytics: [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    if (input.AnalyticsConfiguration !== undefined) {
      body = se_AnalyticsConfiguration(input.AnalyticsConfiguration, context);
    }
    let contents;
    if (input.AnalyticsConfiguration !== undefined) {
      contents = se_AnalyticsConfiguration(input.AnalyticsConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketAnalyticsConfigurationCommand = se_PutBucketAnalyticsConfigurationCommand;
  var se_PutBucketCorsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      cors: [, ""]
    });
    let body;
    if (input.CORSConfiguration !== undefined) {
      body = se_CORSConfiguration(input.CORSConfiguration, context);
    }
    let contents;
    if (input.CORSConfiguration !== undefined) {
      contents = se_CORSConfiguration(input.CORSConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketCorsCommand = se_PutBucketCorsCommand;
  var se_PutBucketEncryptionCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      encryption: [, ""]
    });
    let body;
    if (input.ServerSideEncryptionConfiguration !== undefined) {
      body = se_ServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, context);
    }
    let contents;
    if (input.ServerSideEncryptionConfiguration !== undefined) {
      contents = se_ServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketEncryptionCommand = se_PutBucketEncryptionCommand;
  var se_PutBucketIntelligentTieringConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = {
      "content-type": "application/xml"
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "intelligent-tiering": [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    if (input.IntelligentTieringConfiguration !== undefined) {
      body = se_IntelligentTieringConfiguration(input.IntelligentTieringConfiguration, context);
    }
    let contents;
    if (input.IntelligentTieringConfiguration !== undefined) {
      contents = se_IntelligentTieringConfiguration(input.IntelligentTieringConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketIntelligentTieringConfigurationCommand = se_PutBucketIntelligentTieringConfigurationCommand;
  var se_PutBucketInventoryConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      inventory: [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    if (input.InventoryConfiguration !== undefined) {
      body = se_InventoryConfiguration(input.InventoryConfiguration, context);
    }
    let contents;
    if (input.InventoryConfiguration !== undefined) {
      contents = se_InventoryConfiguration(input.InventoryConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketInventoryConfigurationCommand = se_PutBucketInventoryConfigurationCommand;
  var se_PutBucketLifecycleConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      lifecycle: [, ""]
    });
    let body;
    if (input.LifecycleConfiguration !== undefined) {
      body = se_BucketLifecycleConfiguration(input.LifecycleConfiguration, context);
    }
    let contents;
    if (input.LifecycleConfiguration !== undefined) {
      contents = se_BucketLifecycleConfiguration(input.LifecycleConfiguration, context);
      contents = contents.withName("LifecycleConfiguration");
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketLifecycleConfigurationCommand = se_PutBucketLifecycleConfigurationCommand;
  var se_PutBucketLoggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      logging: [, ""]
    });
    let body;
    if (input.BucketLoggingStatus !== undefined) {
      body = se_BucketLoggingStatus(input.BucketLoggingStatus, context);
    }
    let contents;
    if (input.BucketLoggingStatus !== undefined) {
      contents = se_BucketLoggingStatus(input.BucketLoggingStatus, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketLoggingCommand = se_PutBucketLoggingCommand;
  var se_PutBucketMetricsConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      metrics: [, ""],
      id: [, (0, smithy_client_1.expectNonNull)(input.Id, `Id`)]
    });
    let body;
    if (input.MetricsConfiguration !== undefined) {
      body = se_MetricsConfiguration(input.MetricsConfiguration, context);
    }
    let contents;
    if (input.MetricsConfiguration !== undefined) {
      contents = se_MetricsConfiguration(input.MetricsConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketMetricsConfigurationCommand = se_PutBucketMetricsConfigurationCommand;
  var se_PutBucketNotificationConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-skip-destination-validation": [
        () => isSerializableHeaderValue(input.SkipDestinationValidation),
        () => input.SkipDestinationValidation.toString()
      ]
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      notification: [, ""]
    });
    let body;
    if (input.NotificationConfiguration !== undefined) {
      body = se_NotificationConfiguration(input.NotificationConfiguration, context);
    }
    let contents;
    if (input.NotificationConfiguration !== undefined) {
      contents = se_NotificationConfiguration(input.NotificationConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketNotificationConfigurationCommand = se_PutBucketNotificationConfigurationCommand;
  var se_PutBucketOwnershipControlsCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      ownershipControls: [, ""]
    });
    let body;
    if (input.OwnershipControls !== undefined) {
      body = se_OwnershipControls(input.OwnershipControls, context);
    }
    let contents;
    if (input.OwnershipControls !== undefined) {
      contents = se_OwnershipControls(input.OwnershipControls, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketOwnershipControlsCommand = se_PutBucketOwnershipControlsCommand;
  var se_PutBucketPolicyCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "text/plain",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-confirm-remove-self-bucket-access": [
        () => isSerializableHeaderValue(input.ConfirmRemoveSelfBucketAccess),
        () => input.ConfirmRemoveSelfBucketAccess.toString()
      ],
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      policy: [, ""]
    });
    let body;
    if (input.Policy !== undefined) {
      body = input.Policy;
    }
    let contents;
    if (input.Policy !== undefined) {
      contents = input.Policy;
      body = contents;
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketPolicyCommand = se_PutBucketPolicyCommand;
  var se_PutBucketReplicationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-bucket-object-lock-token": input.Token,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      replication: [, ""]
    });
    let body;
    if (input.ReplicationConfiguration !== undefined) {
      body = se_ReplicationConfiguration(input.ReplicationConfiguration, context);
    }
    let contents;
    if (input.ReplicationConfiguration !== undefined) {
      contents = se_ReplicationConfiguration(input.ReplicationConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketReplicationCommand = se_PutBucketReplicationCommand;
  var se_PutBucketRequestPaymentCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      requestPayment: [, ""]
    });
    let body;
    if (input.RequestPaymentConfiguration !== undefined) {
      body = se_RequestPaymentConfiguration(input.RequestPaymentConfiguration, context);
    }
    let contents;
    if (input.RequestPaymentConfiguration !== undefined) {
      contents = se_RequestPaymentConfiguration(input.RequestPaymentConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketRequestPaymentCommand = se_PutBucketRequestPaymentCommand;
  var se_PutBucketTaggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      tagging: [, ""]
    });
    let body;
    if (input.Tagging !== undefined) {
      body = se_Tagging(input.Tagging, context);
    }
    let contents;
    if (input.Tagging !== undefined) {
      contents = se_Tagging(input.Tagging, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketTaggingCommand = se_PutBucketTaggingCommand;
  var se_PutBucketVersioningCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-mfa": input.MFA,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      versioning: [, ""]
    });
    let body;
    if (input.VersioningConfiguration !== undefined) {
      body = se_VersioningConfiguration(input.VersioningConfiguration, context);
    }
    let contents;
    if (input.VersioningConfiguration !== undefined) {
      contents = se_VersioningConfiguration(input.VersioningConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketVersioningCommand = se_PutBucketVersioningCommand;
  var se_PutBucketWebsiteCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      website: [, ""]
    });
    let body;
    if (input.WebsiteConfiguration !== undefined) {
      body = se_WebsiteConfiguration(input.WebsiteConfiguration, context);
    }
    let contents;
    if (input.WebsiteConfiguration !== undefined) {
      contents = se_WebsiteConfiguration(input.WebsiteConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutBucketWebsiteCommand = se_PutBucketWebsiteCommand;
  var se_PutObjectCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": input.ContentType || "application/octet-stream",
      "x-amz-acl": input.ACL,
      "cache-control": input.CacheControl,
      "content-disposition": input.ContentDisposition,
      "content-encoding": input.ContentEncoding,
      "content-language": input.ContentLanguage,
      "content-length": [() => isSerializableHeaderValue(input.ContentLength), () => input.ContentLength.toString()],
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-checksum-crc32": input.ChecksumCRC32,
      "x-amz-checksum-crc32c": input.ChecksumCRC32C,
      "x-amz-checksum-sha1": input.ChecksumSHA1,
      "x-amz-checksum-sha256": input.ChecksumSHA256,
      expires: [() => isSerializableHeaderValue(input.Expires), () => (0, smithy_client_1.dateToUtcString)(input.Expires).toString()],
      "x-amz-grant-full-control": input.GrantFullControl,
      "x-amz-grant-read": input.GrantRead,
      "x-amz-grant-read-acp": input.GrantReadACP,
      "x-amz-grant-write-acp": input.GrantWriteACP,
      "x-amz-server-side-encryption": input.ServerSideEncryption,
      "x-amz-storage-class": input.StorageClass,
      "x-amz-website-redirect-location": input.WebsiteRedirectLocation,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
      "x-amz-server-side-encryption-context": input.SSEKMSEncryptionContext,
      "x-amz-server-side-encryption-bucket-key-enabled": [
        () => isSerializableHeaderValue(input.BucketKeyEnabled),
        () => input.BucketKeyEnabled.toString()
      ],
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-tagging": input.Tagging,
      "x-amz-object-lock-mode": input.ObjectLockMode,
      "x-amz-object-lock-retain-until-date": [
        () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
        () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
      ],
      "x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      ...input.Metadata !== undefined && Object.keys(input.Metadata).reduce((acc, suffix) => {
        acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
        return acc;
      }, {})
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "PutObject"]
    });
    let body;
    if (input.Body !== undefined) {
      body = input.Body;
    }
    let contents;
    if (input.Body !== undefined) {
      contents = input.Body;
      body = contents;
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutObjectCommand = se_PutObjectCommand;
  var se_PutObjectAclCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-acl": input.ACL,
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-grant-full-control": input.GrantFullControl,
      "x-amz-grant-read": input.GrantRead,
      "x-amz-grant-read-acp": input.GrantReadACP,
      "x-amz-grant-write": input.GrantWrite,
      "x-amz-grant-write-acp": input.GrantWriteACP,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      acl: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    if (input.AccessControlPolicy !== undefined) {
      body = se_AccessControlPolicy(input.AccessControlPolicy, context);
    }
    let contents;
    if (input.AccessControlPolicy !== undefined) {
      contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutObjectAclCommand = se_PutObjectAclCommand;
  var se_PutObjectLegalHoldCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-request-payer": input.RequestPayer,
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "legal-hold": [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    if (input.LegalHold !== undefined) {
      body = se_ObjectLockLegalHold(input.LegalHold, context);
    }
    let contents;
    if (input.LegalHold !== undefined) {
      contents = se_ObjectLockLegalHold(input.LegalHold, context);
      contents = contents.withName("LegalHold");
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutObjectLegalHoldCommand = se_PutObjectLegalHoldCommand;
  var se_PutObjectLockConfigurationCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-bucket-object-lock-token": input.Token,
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      "object-lock": [, ""]
    });
    let body;
    if (input.ObjectLockConfiguration !== undefined) {
      body = se_ObjectLockConfiguration(input.ObjectLockConfiguration, context);
    }
    let contents;
    if (input.ObjectLockConfiguration !== undefined) {
      contents = se_ObjectLockConfiguration(input.ObjectLockConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutObjectLockConfigurationCommand = se_PutObjectLockConfigurationCommand;
  var se_PutObjectRetentionCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-bypass-governance-retention": [
        () => isSerializableHeaderValue(input.BypassGovernanceRetention),
        () => input.BypassGovernanceRetention.toString()
      ],
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      retention: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    if (input.Retention !== undefined) {
      body = se_ObjectLockRetention(input.Retention, context);
    }
    let contents;
    if (input.Retention !== undefined) {
      contents = se_ObjectLockRetention(input.Retention, context);
      contents = contents.withName("Retention");
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutObjectRetentionCommand = se_PutObjectRetentionCommand;
  var se_PutObjectTaggingCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-request-payer": input.RequestPayer
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      tagging: [, ""],
      versionId: [, input.VersionId]
    });
    let body;
    if (input.Tagging !== undefined) {
      body = se_Tagging(input.Tagging, context);
    }
    let contents;
    if (input.Tagging !== undefined) {
      contents = se_Tagging(input.Tagging, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutObjectTaggingCommand = se_PutObjectTaggingCommand;
  var se_PutPublicAccessBlockCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
      publicAccessBlock: [, ""]
    });
    let body;
    if (input.PublicAccessBlockConfiguration !== undefined) {
      body = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);
    }
    let contents;
    if (input.PublicAccessBlockConfiguration !== undefined) {
      contents = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_PutPublicAccessBlockCommand = se_PutPublicAccessBlockCommand;
  var se_RestoreObjectCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      restore: [, ""],
      "x-id": [, "RestoreObject"],
      versionId: [, input.VersionId]
    });
    let body;
    if (input.RestoreRequest !== undefined) {
      body = se_RestoreRequest(input.RestoreRequest, context);
    }
    let contents;
    if (input.RestoreRequest !== undefined) {
      contents = se_RestoreRequest(input.RestoreRequest, context);
      body = '<?xml version="1.0" encoding="UTF-8"?>';
      contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_RestoreObjectCommand = se_RestoreObjectCommand;
  var se_SelectObjectContentCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/xml",
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      select: [, ""],
      "select-type": [, "2"],
      "x-id": [, "SelectObjectContent"]
    });
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("SelectObjectContentRequest");
    bodyNode.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    if (input.Expression !== undefined) {
      const node = xml_builder_1.XmlNode.of("Expression", input.Expression).withName("Expression");
      bodyNode.addChildNode(node);
    }
    if (input.ExpressionType !== undefined) {
      const node = xml_builder_1.XmlNode.of("ExpressionType", input.ExpressionType).withName("ExpressionType");
      bodyNode.addChildNode(node);
    }
    if (input.InputSerialization !== undefined) {
      const node = se_InputSerialization(input.InputSerialization, context).withName("InputSerialization");
      bodyNode.addChildNode(node);
    }
    if (input.OutputSerialization !== undefined) {
      const node = se_OutputSerialization(input.OutputSerialization, context).withName("OutputSerialization");
      bodyNode.addChildNode(node);
    }
    if (input.RequestProgress !== undefined) {
      const node = se_RequestProgress(input.RequestProgress, context).withName("RequestProgress");
      bodyNode.addChildNode(node);
    }
    if (input.ScanRange !== undefined) {
      const node = se_ScanRange(input.ScanRange, context).withName("ScanRange");
      bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_SelectObjectContentCommand = se_SelectObjectContentCommand;
  var se_UploadPartCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "content-type": "application/octet-stream",
      "content-length": [() => isSerializableHeaderValue(input.ContentLength), () => input.ContentLength.toString()],
      "content-md5": input.ContentMD5,
      "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
      "x-amz-checksum-crc32": input.ChecksumCRC32,
      "x-amz-checksum-crc32c": input.ChecksumCRC32C,
      "x-amz-checksum-sha1": input.ChecksumSHA1,
      "x-amz-checksum-sha256": input.ChecksumSHA256,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "UploadPart"],
      partNumber: [(0, smithy_client_1.expectNonNull)(input.PartNumber, `PartNumber`) != null, () => input.PartNumber.toString()],
      uploadId: [, (0, smithy_client_1.expectNonNull)(input.UploadId, `UploadId`)]
    });
    let body;
    if (input.Body !== undefined) {
      body = input.Body;
    }
    let contents;
    if (input.Body !== undefined) {
      contents = input.Body;
      body = contents;
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_UploadPartCommand = se_UploadPartCommand;
  var se_UploadPartCopyCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-copy-source": input.CopySource,
      "x-amz-copy-source-if-match": input.CopySourceIfMatch,
      "x-amz-copy-source-if-modified-since": [
        () => isSerializableHeaderValue(input.CopySourceIfModifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.CopySourceIfModifiedSince).toString()
      ],
      "x-amz-copy-source-if-none-match": input.CopySourceIfNoneMatch,
      "x-amz-copy-source-if-unmodified-since": [
        () => isSerializableHeaderValue(input.CopySourceIfUnmodifiedSince),
        () => (0, smithy_client_1.dateToUtcString)(input.CopySourceIfUnmodifiedSince).toString()
      ],
      "x-amz-copy-source-range": input.CopySourceRange,
      "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
      "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-copy-source-server-side-encryption-customer-algorithm": input.CopySourceSSECustomerAlgorithm,
      "x-amz-copy-source-server-side-encryption-customer-key": input.CopySourceSSECustomerKey,
      "x-amz-copy-source-server-side-encryption-customer-key-md5": input.CopySourceSSECustomerKeyMD5,
      "x-amz-request-payer": input.RequestPayer,
      "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
      "x-amz-source-expected-bucket-owner": input.ExpectedSourceBucketOwner
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/{Key+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
      "x-id": [, "UploadPartCopy"],
      partNumber: [(0, smithy_client_1.expectNonNull)(input.PartNumber, `PartNumber`) != null, () => input.PartNumber.toString()],
      uploadId: [, (0, smithy_client_1.expectNonNull)(input.UploadId, `UploadId`)]
    });
    let body;
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname,
      port,
      method: "PUT",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_UploadPartCopyCommand = se_UploadPartCopyCommand;
  var se_WriteGetObjectResponseCommand = async (input, context) => {
    const { hostname, protocol: protocol4 = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
      "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
      "content-type": "application/octet-stream",
      "x-amz-request-route": input.RequestRoute,
      "x-amz-request-token": input.RequestToken,
      "x-amz-fwd-status": [() => isSerializableHeaderValue(input.StatusCode), () => input.StatusCode.toString()],
      "x-amz-fwd-error-code": input.ErrorCode,
      "x-amz-fwd-error-message": input.ErrorMessage,
      "x-amz-fwd-header-accept-ranges": input.AcceptRanges,
      "x-amz-fwd-header-cache-control": input.CacheControl,
      "x-amz-fwd-header-content-disposition": input.ContentDisposition,
      "x-amz-fwd-header-content-encoding": input.ContentEncoding,
      "x-amz-fwd-header-content-language": input.ContentLanguage,
      "content-length": [() => isSerializableHeaderValue(input.ContentLength), () => input.ContentLength.toString()],
      "x-amz-fwd-header-content-range": input.ContentRange,
      "x-amz-fwd-header-content-type": input.ContentType,
      "x-amz-fwd-header-x-amz-checksum-crc32": input.ChecksumCRC32,
      "x-amz-fwd-header-x-amz-checksum-crc32c": input.ChecksumCRC32C,
      "x-amz-fwd-header-x-amz-checksum-sha1": input.ChecksumSHA1,
      "x-amz-fwd-header-x-amz-checksum-sha256": input.ChecksumSHA256,
      "x-amz-fwd-header-x-amz-delete-marker": [
        () => isSerializableHeaderValue(input.DeleteMarker),
        () => input.DeleteMarker.toString()
      ],
      "x-amz-fwd-header-etag": input.ETag,
      "x-amz-fwd-header-expires": [
        () => isSerializableHeaderValue(input.Expires),
        () => (0, smithy_client_1.dateToUtcString)(input.Expires).toString()
      ],
      "x-amz-fwd-header-x-amz-expiration": input.Expiration,
      "x-amz-fwd-header-last-modified": [
        () => isSerializableHeaderValue(input.LastModified),
        () => (0, smithy_client_1.dateToUtcString)(input.LastModified).toString()
      ],
      "x-amz-fwd-header-x-amz-missing-meta": [
        () => isSerializableHeaderValue(input.MissingMeta),
        () => input.MissingMeta.toString()
      ],
      "x-amz-fwd-header-x-amz-object-lock-mode": input.ObjectLockMode,
      "x-amz-fwd-header-x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
      "x-amz-fwd-header-x-amz-object-lock-retain-until-date": [
        () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
        () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
      ],
      "x-amz-fwd-header-x-amz-mp-parts-count": [
        () => isSerializableHeaderValue(input.PartsCount),
        () => input.PartsCount.toString()
      ],
      "x-amz-fwd-header-x-amz-replication-status": input.ReplicationStatus,
      "x-amz-fwd-header-x-amz-request-charged": input.RequestCharged,
      "x-amz-fwd-header-x-amz-restore": input.Restore,
      "x-amz-fwd-header-x-amz-server-side-encryption": input.ServerSideEncryption,
      "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
      "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
      "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
      "x-amz-fwd-header-x-amz-storage-class": input.StorageClass,
      "x-amz-fwd-header-x-amz-tagging-count": [
        () => isSerializableHeaderValue(input.TagCount),
        () => input.TagCount.toString()
      ],
      "x-amz-fwd-header-x-amz-version-id": input.VersionId,
      "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled": [
        () => isSerializableHeaderValue(input.BucketKeyEnabled),
        () => input.BucketKeyEnabled.toString()
      ],
      ...input.Metadata !== undefined && Object.keys(input.Metadata).reduce((acc, suffix) => {
        acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
        return acc;
      }, {})
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/WriteGetObjectResponse";
    const query = (0, smithy_client_1.map)({
      "x-id": [, "WriteGetObjectResponse"]
    });
    let body;
    if (input.Body !== undefined) {
      body = input.Body;
    }
    let contents;
    if (input.Body !== undefined) {
      contents = input.Body;
      body = contents;
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
      resolvedHostname = "{RequestRoute}." + resolvedHostname;
      if (input.RequestRoute === undefined) {
        throw new Error("Empty value provided for input host prefix: RequestRoute.");
      }
      resolvedHostname = resolvedHostname.replace("{RequestRoute}", input.RequestRoute);
      if (!(0, protocol_http_1.isValidHostname)(resolvedHostname)) {
        throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
      }
    }
    return new protocol_http_1.HttpRequest({
      protocol: protocol4,
      hostname: resolvedHostname,
      port,
      method: "POST",
      headers,
      path: resolvedPath,
      query,
      body
    });
  };
  exports.se_WriteGetObjectResponseCommand = se_WriteGetObjectResponseCommand;
  var de_AbortMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_AbortMultipartUploadCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_AbortMultipartUploadCommand = de_AbortMultipartUploadCommand;
  var de_AbortMultipartUploadCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchUpload":
      case "com.amazonaws.s3#NoSuchUpload":
        throw await de_NoSuchUploadRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_CompleteMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CompleteMultipartUploadCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      Expiration: [, output.headers["x-amz-expiration"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      VersionId: [, output.headers["x-amz-version-id"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(data["Bucket"]);
    }
    if (data["ChecksumCRC32"] !== undefined) {
      contents.ChecksumCRC32 = (0, smithy_client_1.expectString)(data["ChecksumCRC32"]);
    }
    if (data["ChecksumCRC32C"] !== undefined) {
      contents.ChecksumCRC32C = (0, smithy_client_1.expectString)(data["ChecksumCRC32C"]);
    }
    if (data["ChecksumSHA1"] !== undefined) {
      contents.ChecksumSHA1 = (0, smithy_client_1.expectString)(data["ChecksumSHA1"]);
    }
    if (data["ChecksumSHA256"] !== undefined) {
      contents.ChecksumSHA256 = (0, smithy_client_1.expectString)(data["ChecksumSHA256"]);
    }
    if (data["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(data["ETag"]);
    }
    if (data["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(data["Key"]);
    }
    if (data["Location"] !== undefined) {
      contents.Location = (0, smithy_client_1.expectString)(data["Location"]);
    }
    return contents;
  };
  exports.de_CompleteMultipartUploadCommand = de_CompleteMultipartUploadCommand;
  var de_CompleteMultipartUploadCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_CopyObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CopyObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      Expiration: [, output.headers["x-amz-expiration"]],
      CopySourceVersionId: [, output.headers["x-amz-copy-source-version-id"]],
      VersionId: [, output.headers["x-amz-version-id"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      SSEKMSEncryptionContext: [, output.headers["x-amz-server-side-encryption-context"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.CopyObjectResult = de_CopyObjectResult(data, context);
    return contents;
  };
  exports.de_CopyObjectCommand = de_CopyObjectCommand;
  var de_CopyObjectCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ObjectNotInActiveTierError":
      case "com.amazonaws.s3#ObjectNotInActiveTierError":
        throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_CreateBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CreateBucketCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      Location: [, output.headers["location"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_CreateBucketCommand = de_CreateBucketCommand;
  var de_CreateBucketCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "BucketAlreadyExists":
      case "com.amazonaws.s3#BucketAlreadyExists":
        throw await de_BucketAlreadyExistsRes(parsedOutput, context);
      case "BucketAlreadyOwnedByYou":
      case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
        throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_CreateMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CreateMultipartUploadCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      AbortDate: [
        () => output.headers["x-amz-abort-date"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["x-amz-abort-date"]))
      ],
      AbortRuleId: [, output.headers["x-amz-abort-rule-id"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      SSEKMSEncryptionContext: [, output.headers["x-amz-server-side-encryption-context"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      RequestCharged: [, output.headers["x-amz-request-charged"]],
      ChecksumAlgorithm: [, output.headers["x-amz-checksum-algorithm"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(data["Bucket"]);
    }
    if (data["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(data["Key"]);
    }
    if (data["UploadId"] !== undefined) {
      contents.UploadId = (0, smithy_client_1.expectString)(data["UploadId"]);
    }
    return contents;
  };
  exports.de_CreateMultipartUploadCommand = de_CreateMultipartUploadCommand;
  var de_CreateMultipartUploadCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketCommand = de_DeleteBucketCommand;
  var de_DeleteBucketCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketAnalyticsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketAnalyticsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketAnalyticsConfigurationCommand = de_DeleteBucketAnalyticsConfigurationCommand;
  var de_DeleteBucketAnalyticsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketCorsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketCorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketCorsCommand = de_DeleteBucketCorsCommand;
  var de_DeleteBucketCorsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketEncryptionCommand = de_DeleteBucketEncryptionCommand;
  var de_DeleteBucketEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketIntelligentTieringConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketIntelligentTieringConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketIntelligentTieringConfigurationCommand = de_DeleteBucketIntelligentTieringConfigurationCommand;
  var de_DeleteBucketIntelligentTieringConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketInventoryConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketInventoryConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketInventoryConfigurationCommand = de_DeleteBucketInventoryConfigurationCommand;
  var de_DeleteBucketInventoryConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketLifecycleCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketLifecycleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketLifecycleCommand = de_DeleteBucketLifecycleCommand;
  var de_DeleteBucketLifecycleCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketMetricsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketMetricsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketMetricsConfigurationCommand = de_DeleteBucketMetricsConfigurationCommand;
  var de_DeleteBucketMetricsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketOwnershipControlsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketOwnershipControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketOwnershipControlsCommand = de_DeleteBucketOwnershipControlsCommand;
  var de_DeleteBucketOwnershipControlsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketPolicyCommand = de_DeleteBucketPolicyCommand;
  var de_DeleteBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketReplicationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketReplicationCommand = de_DeleteBucketReplicationCommand;
  var de_DeleteBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketTaggingCommand = de_DeleteBucketTaggingCommand;
  var de_DeleteBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteBucketWebsiteCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteBucketWebsiteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteBucketWebsiteCommand = de_DeleteBucketWebsiteCommand;
  var de_DeleteBucketWebsiteCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteObjectCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      DeleteMarker: [
        () => output.headers["x-amz-delete-marker"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-delete-marker"])
      ],
      VersionId: [, output.headers["x-amz-version-id"]],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteObjectCommand = de_DeleteObjectCommand;
  var de_DeleteObjectCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_DeleteObjectsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.Deleted === "") {
      contents.Deleted = [];
    } else if (data["Deleted"] !== undefined) {
      contents.Deleted = de_DeletedObjects((0, smithy_client_1.getArrayIfSingleItem)(data["Deleted"]), context);
    }
    if (data.Error === "") {
      contents.Errors = [];
    } else if (data["Error"] !== undefined) {
      contents.Errors = de_Errors((0, smithy_client_1.getArrayIfSingleItem)(data["Error"]), context);
    }
    return contents;
  };
  exports.de_DeleteObjectsCommand = de_DeleteObjectsCommand;
  var de_DeleteObjectsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeleteObjectTaggingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeleteObjectTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      VersionId: [, output.headers["x-amz-version-id"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeleteObjectTaggingCommand = de_DeleteObjectTaggingCommand;
  var de_DeleteObjectTaggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_DeletePublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
      return de_DeletePublicAccessBlockCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_DeletePublicAccessBlockCommand = de_DeletePublicAccessBlockCommand;
  var de_DeletePublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketAccelerateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketAccelerateConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(data["Status"]);
    }
    return contents;
  };
  exports.de_GetBucketAccelerateConfigurationCommand = de_GetBucketAccelerateConfigurationCommand;
  var de_GetBucketAccelerateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.AccessControlList === "") {
      contents.Grants = [];
    } else if (data["AccessControlList"] !== undefined && data["AccessControlList"]["Grant"] !== undefined) {
      contents.Grants = de_Grants((0, smithy_client_1.getArrayIfSingleItem)(data["AccessControlList"]["Grant"]), context);
    }
    if (data["Owner"] !== undefined) {
      contents.Owner = de_Owner(data["Owner"], context);
    }
    return contents;
  };
  exports.de_GetBucketAclCommand = de_GetBucketAclCommand;
  var de_GetBucketAclCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketAnalyticsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketAnalyticsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.AnalyticsConfiguration = de_AnalyticsConfiguration(data, context);
    return contents;
  };
  exports.de_GetBucketAnalyticsConfigurationCommand = de_GetBucketAnalyticsConfigurationCommand;
  var de_GetBucketAnalyticsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketCorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketCorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.CORSRule === "") {
      contents.CORSRules = [];
    } else if (data["CORSRule"] !== undefined) {
      contents.CORSRules = de_CORSRules((0, smithy_client_1.getArrayIfSingleItem)(data["CORSRule"]), context);
    }
    return contents;
  };
  exports.de_GetBucketCorsCommand = de_GetBucketCorsCommand;
  var de_GetBucketCorsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.ServerSideEncryptionConfiguration = de_ServerSideEncryptionConfiguration(data, context);
    return contents;
  };
  exports.de_GetBucketEncryptionCommand = de_GetBucketEncryptionCommand;
  var de_GetBucketEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketIntelligentTieringConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketIntelligentTieringConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.IntelligentTieringConfiguration = de_IntelligentTieringConfiguration(data, context);
    return contents;
  };
  exports.de_GetBucketIntelligentTieringConfigurationCommand = de_GetBucketIntelligentTieringConfigurationCommand;
  var de_GetBucketIntelligentTieringConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketInventoryConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketInventoryConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.InventoryConfiguration = de_InventoryConfiguration(data, context);
    return contents;
  };
  exports.de_GetBucketInventoryConfigurationCommand = de_GetBucketInventoryConfigurationCommand;
  var de_GetBucketInventoryConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.Rule === "") {
      contents.Rules = [];
    } else if (data["Rule"] !== undefined) {
      contents.Rules = de_LifecycleRules((0, smithy_client_1.getArrayIfSingleItem)(data["Rule"]), context);
    }
    return contents;
  };
  exports.de_GetBucketLifecycleConfigurationCommand = de_GetBucketLifecycleConfigurationCommand;
  var de_GetBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketLocationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["LocationConstraint"] !== undefined) {
      contents.LocationConstraint = (0, smithy_client_1.expectString)(data["LocationConstraint"]);
    }
    return contents;
  };
  exports.de_GetBucketLocationCommand = de_GetBucketLocationCommand;
  var de_GetBucketLocationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketLoggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketLoggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["LoggingEnabled"] !== undefined) {
      contents.LoggingEnabled = de_LoggingEnabled(data["LoggingEnabled"], context);
    }
    return contents;
  };
  exports.de_GetBucketLoggingCommand = de_GetBucketLoggingCommand;
  var de_GetBucketLoggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketMetricsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketMetricsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.MetricsConfiguration = de_MetricsConfiguration(data, context);
    return contents;
  };
  exports.de_GetBucketMetricsConfigurationCommand = de_GetBucketMetricsConfigurationCommand;
  var de_GetBucketMetricsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketNotificationConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["EventBridgeConfiguration"] !== undefined) {
      contents.EventBridgeConfiguration = de_EventBridgeConfiguration(data["EventBridgeConfiguration"], context);
    }
    if (data.CloudFunctionConfiguration === "") {
      contents.LambdaFunctionConfigurations = [];
    } else if (data["CloudFunctionConfiguration"] !== undefined) {
      contents.LambdaFunctionConfigurations = de_LambdaFunctionConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["CloudFunctionConfiguration"]), context);
    }
    if (data.QueueConfiguration === "") {
      contents.QueueConfigurations = [];
    } else if (data["QueueConfiguration"] !== undefined) {
      contents.QueueConfigurations = de_QueueConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["QueueConfiguration"]), context);
    }
    if (data.TopicConfiguration === "") {
      contents.TopicConfigurations = [];
    } else if (data["TopicConfiguration"] !== undefined) {
      contents.TopicConfigurations = de_TopicConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["TopicConfiguration"]), context);
    }
    return contents;
  };
  exports.de_GetBucketNotificationConfigurationCommand = de_GetBucketNotificationConfigurationCommand;
  var de_GetBucketNotificationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketOwnershipControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketOwnershipControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.OwnershipControls = de_OwnershipControls(data, context);
    return contents;
  };
  exports.de_GetBucketOwnershipControlsCommand = de_GetBucketOwnershipControlsCommand;
  var de_GetBucketOwnershipControlsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = await collectBodyString(output.body, context);
    contents.Policy = (0, smithy_client_1.expectString)(data);
    return contents;
  };
  exports.de_GetBucketPolicyCommand = de_GetBucketPolicyCommand;
  var de_GetBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketPolicyStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketPolicyStatusCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.PolicyStatus = de_PolicyStatus(data, context);
    return contents;
  };
  exports.de_GetBucketPolicyStatusCommand = de_GetBucketPolicyStatusCommand;
  var de_GetBucketPolicyStatusCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketReplicationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.ReplicationConfiguration = de_ReplicationConfiguration(data, context);
    return contents;
  };
  exports.de_GetBucketReplicationCommand = de_GetBucketReplicationCommand;
  var de_GetBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketRequestPaymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketRequestPaymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Payer"] !== undefined) {
      contents.Payer = (0, smithy_client_1.expectString)(data["Payer"]);
    }
    return contents;
  };
  exports.de_GetBucketRequestPaymentCommand = de_GetBucketRequestPaymentCommand;
  var de_GetBucketRequestPaymentCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.TagSet === "") {
      contents.TagSet = [];
    } else if (data["TagSet"] !== undefined && data["TagSet"]["Tag"] !== undefined) {
      contents.TagSet = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(data["TagSet"]["Tag"]), context);
    }
    return contents;
  };
  exports.de_GetBucketTaggingCommand = de_GetBucketTaggingCommand;
  var de_GetBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketVersioningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketVersioningCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["MfaDelete"] !== undefined) {
      contents.MFADelete = (0, smithy_client_1.expectString)(data["MfaDelete"]);
    }
    if (data["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(data["Status"]);
    }
    return contents;
  };
  exports.de_GetBucketVersioningCommand = de_GetBucketVersioningCommand;
  var de_GetBucketVersioningCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetBucketWebsiteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetBucketWebsiteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["ErrorDocument"] !== undefined) {
      contents.ErrorDocument = de_ErrorDocument(data["ErrorDocument"], context);
    }
    if (data["IndexDocument"] !== undefined) {
      contents.IndexDocument = de_IndexDocument(data["IndexDocument"], context);
    }
    if (data["RedirectAllRequestsTo"] !== undefined) {
      contents.RedirectAllRequestsTo = de_RedirectAllRequestsTo(data["RedirectAllRequestsTo"], context);
    }
    if (data.RoutingRules === "") {
      contents.RoutingRules = [];
    } else if (data["RoutingRules"] !== undefined && data["RoutingRules"]["RoutingRule"] !== undefined) {
      contents.RoutingRules = de_RoutingRules((0, smithy_client_1.getArrayIfSingleItem)(data["RoutingRules"]["RoutingRule"]), context);
    }
    return contents;
  };
  exports.de_GetBucketWebsiteCommand = de_GetBucketWebsiteCommand;
  var de_GetBucketWebsiteCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      DeleteMarker: [
        () => output.headers["x-amz-delete-marker"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-delete-marker"])
      ],
      AcceptRanges: [, output.headers["accept-ranges"]],
      Expiration: [, output.headers["x-amz-expiration"]],
      Restore: [, output.headers["x-amz-restore"]],
      LastModified: [
        () => output.headers["last-modified"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["last-modified"]))
      ],
      ContentLength: [
        () => output.headers["content-length"] !== undefined,
        () => (0, smithy_client_1.strictParseLong)(output.headers["content-length"])
      ],
      ETag: [, output.headers["etag"]],
      ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
      ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
      ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
      ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
      MissingMeta: [
        () => output.headers["x-amz-missing-meta"] !== undefined,
        () => (0, smithy_client_1.strictParseInt32)(output.headers["x-amz-missing-meta"])
      ],
      VersionId: [, output.headers["x-amz-version-id"]],
      CacheControl: [, output.headers["cache-control"]],
      ContentDisposition: [, output.headers["content-disposition"]],
      ContentEncoding: [, output.headers["content-encoding"]],
      ContentLanguage: [, output.headers["content-language"]],
      ContentRange: [, output.headers["content-range"]],
      ContentType: [, output.headers["content-type"]],
      Expires: [
        () => output.headers["expires"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["expires"]))
      ],
      WebsiteRedirectLocation: [, output.headers["x-amz-website-redirect-location"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      StorageClass: [, output.headers["x-amz-storage-class"]],
      RequestCharged: [, output.headers["x-amz-request-charged"]],
      ReplicationStatus: [, output.headers["x-amz-replication-status"]],
      PartsCount: [
        () => output.headers["x-amz-mp-parts-count"] !== undefined,
        () => (0, smithy_client_1.strictParseInt32)(output.headers["x-amz-mp-parts-count"])
      ],
      TagCount: [
        () => output.headers["x-amz-tagging-count"] !== undefined,
        () => (0, smithy_client_1.strictParseInt32)(output.headers["x-amz-tagging-count"])
      ],
      ObjectLockMode: [, output.headers["x-amz-object-lock-mode"]],
      ObjectLockRetainUntilDate: [
        () => output.headers["x-amz-object-lock-retain-until-date"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output.headers["x-amz-object-lock-retain-until-date"]))
      ],
      ObjectLockLegalHoldStatus: [, output.headers["x-amz-object-lock-legal-hold"]],
      Metadata: [
        ,
        Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
          acc[header.substring(11)] = output.headers[header];
          return acc;
        }, {})
      ]
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.Body = data;
    return contents;
  };
  exports.de_GetObjectCommand = de_GetObjectCommand;
  var de_GetObjectCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "InvalidObjectState":
      case "com.amazonaws.s3#InvalidObjectState":
        throw await de_InvalidObjectStateRes(parsedOutput, context);
      case "NoSuchKey":
      case "com.amazonaws.s3#NoSuchKey":
        throw await de_NoSuchKeyRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_GetObjectAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.AccessControlList === "") {
      contents.Grants = [];
    } else if (data["AccessControlList"] !== undefined && data["AccessControlList"]["Grant"] !== undefined) {
      contents.Grants = de_Grants((0, smithy_client_1.getArrayIfSingleItem)(data["AccessControlList"]["Grant"]), context);
    }
    if (data["Owner"] !== undefined) {
      contents.Owner = de_Owner(data["Owner"], context);
    }
    return contents;
  };
  exports.de_GetObjectAclCommand = de_GetObjectAclCommand;
  var de_GetObjectAclCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchKey":
      case "com.amazonaws.s3#NoSuchKey":
        throw await de_NoSuchKeyRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_GetObjectAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectAttributesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      DeleteMarker: [
        () => output.headers["x-amz-delete-marker"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-delete-marker"])
      ],
      LastModified: [
        () => output.headers["last-modified"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["last-modified"]))
      ],
      VersionId: [, output.headers["x-amz-version-id"]],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Checksum"] !== undefined) {
      contents.Checksum = de_Checksum(data["Checksum"], context);
    }
    if (data["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(data["ETag"]);
    }
    if (data["ObjectParts"] !== undefined) {
      contents.ObjectParts = de_GetObjectAttributesParts(data["ObjectParts"], context);
    }
    if (data["ObjectSize"] !== undefined) {
      contents.ObjectSize = (0, smithy_client_1.strictParseLong)(data["ObjectSize"]);
    }
    if (data["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(data["StorageClass"]);
    }
    return contents;
  };
  exports.de_GetObjectAttributesCommand = de_GetObjectAttributesCommand;
  var de_GetObjectAttributesCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchKey":
      case "com.amazonaws.s3#NoSuchKey":
        throw await de_NoSuchKeyRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_GetObjectLegalHoldCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectLegalHoldCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.LegalHold = de_ObjectLockLegalHold(data, context);
    return contents;
  };
  exports.de_GetObjectLegalHoldCommand = de_GetObjectLegalHoldCommand;
  var de_GetObjectLegalHoldCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetObjectLockConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectLockConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.ObjectLockConfiguration = de_ObjectLockConfiguration(data, context);
    return contents;
  };
  exports.de_GetObjectLockConfigurationCommand = de_GetObjectLockConfigurationCommand;
  var de_GetObjectLockConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetObjectRetentionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectRetentionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.Retention = de_ObjectLockRetention(data, context);
    return contents;
  };
  exports.de_GetObjectRetentionCommand = de_GetObjectRetentionCommand;
  var de_GetObjectRetentionCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetObjectTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      VersionId: [, output.headers["x-amz-version-id"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.TagSet === "") {
      contents.TagSet = [];
    } else if (data["TagSet"] !== undefined && data["TagSet"]["Tag"] !== undefined) {
      contents.TagSet = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(data["TagSet"]["Tag"]), context);
    }
    return contents;
  };
  exports.de_GetObjectTaggingCommand = de_GetObjectTaggingCommand;
  var de_GetObjectTaggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetObjectTorrentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetObjectTorrentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.Body = data;
    return contents;
  };
  exports.de_GetObjectTorrentCommand = de_GetObjectTorrentCommand;
  var de_GetObjectTorrentCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_GetPublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_GetPublicAccessBlockCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data, context);
    return contents;
  };
  exports.de_GetPublicAccessBlockCommand = de_GetPublicAccessBlockCommand;
  var de_GetPublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_HeadBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_HeadBucketCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_HeadBucketCommand = de_HeadBucketCommand;
  var de_HeadBucketCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NotFound":
      case "com.amazonaws.s3#NotFound":
        throw await de_NotFoundRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_HeadObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_HeadObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      DeleteMarker: [
        () => output.headers["x-amz-delete-marker"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-delete-marker"])
      ],
      AcceptRanges: [, output.headers["accept-ranges"]],
      Expiration: [, output.headers["x-amz-expiration"]],
      Restore: [, output.headers["x-amz-restore"]],
      ArchiveStatus: [, output.headers["x-amz-archive-status"]],
      LastModified: [
        () => output.headers["last-modified"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["last-modified"]))
      ],
      ContentLength: [
        () => output.headers["content-length"] !== undefined,
        () => (0, smithy_client_1.strictParseLong)(output.headers["content-length"])
      ],
      ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
      ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
      ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
      ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
      ETag: [, output.headers["etag"]],
      MissingMeta: [
        () => output.headers["x-amz-missing-meta"] !== undefined,
        () => (0, smithy_client_1.strictParseInt32)(output.headers["x-amz-missing-meta"])
      ],
      VersionId: [, output.headers["x-amz-version-id"]],
      CacheControl: [, output.headers["cache-control"]],
      ContentDisposition: [, output.headers["content-disposition"]],
      ContentEncoding: [, output.headers["content-encoding"]],
      ContentLanguage: [, output.headers["content-language"]],
      ContentType: [, output.headers["content-type"]],
      Expires: [
        () => output.headers["expires"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["expires"]))
      ],
      WebsiteRedirectLocation: [, output.headers["x-amz-website-redirect-location"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      StorageClass: [, output.headers["x-amz-storage-class"]],
      RequestCharged: [, output.headers["x-amz-request-charged"]],
      ReplicationStatus: [, output.headers["x-amz-replication-status"]],
      PartsCount: [
        () => output.headers["x-amz-mp-parts-count"] !== undefined,
        () => (0, smithy_client_1.strictParseInt32)(output.headers["x-amz-mp-parts-count"])
      ],
      ObjectLockMode: [, output.headers["x-amz-object-lock-mode"]],
      ObjectLockRetainUntilDate: [
        () => output.headers["x-amz-object-lock-retain-until-date"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output.headers["x-amz-object-lock-retain-until-date"]))
      ],
      ObjectLockLegalHoldStatus: [, output.headers["x-amz-object-lock-legal-hold"]],
      Metadata: [
        ,
        Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
          acc[header.substring(11)] = output.headers[header];
          return acc;
        }, {})
      ]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_HeadObjectCommand = de_HeadObjectCommand;
  var de_HeadObjectCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NotFound":
      case "com.amazonaws.s3#NotFound":
        throw await de_NotFoundRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_ListBucketAnalyticsConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListBucketAnalyticsConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.AnalyticsConfiguration === "") {
      contents.AnalyticsConfigurationList = [];
    } else if (data["AnalyticsConfiguration"] !== undefined) {
      contents.AnalyticsConfigurationList = de_AnalyticsConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["AnalyticsConfiguration"]), context);
    }
    if (data["ContinuationToken"] !== undefined) {
      contents.ContinuationToken = (0, smithy_client_1.expectString)(data["ContinuationToken"]);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["NextContinuationToken"] !== undefined) {
      contents.NextContinuationToken = (0, smithy_client_1.expectString)(data["NextContinuationToken"]);
    }
    return contents;
  };
  exports.de_ListBucketAnalyticsConfigurationsCommand = de_ListBucketAnalyticsConfigurationsCommand;
  var de_ListBucketAnalyticsConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListBucketIntelligentTieringConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListBucketIntelligentTieringConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["ContinuationToken"] !== undefined) {
      contents.ContinuationToken = (0, smithy_client_1.expectString)(data["ContinuationToken"]);
    }
    if (data.IntelligentTieringConfiguration === "") {
      contents.IntelligentTieringConfigurationList = [];
    } else if (data["IntelligentTieringConfiguration"] !== undefined) {
      contents.IntelligentTieringConfigurationList = de_IntelligentTieringConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["IntelligentTieringConfiguration"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["NextContinuationToken"] !== undefined) {
      contents.NextContinuationToken = (0, smithy_client_1.expectString)(data["NextContinuationToken"]);
    }
    return contents;
  };
  exports.de_ListBucketIntelligentTieringConfigurationsCommand = de_ListBucketIntelligentTieringConfigurationsCommand;
  var de_ListBucketIntelligentTieringConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListBucketInventoryConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListBucketInventoryConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["ContinuationToken"] !== undefined) {
      contents.ContinuationToken = (0, smithy_client_1.expectString)(data["ContinuationToken"]);
    }
    if (data.InventoryConfiguration === "") {
      contents.InventoryConfigurationList = [];
    } else if (data["InventoryConfiguration"] !== undefined) {
      contents.InventoryConfigurationList = de_InventoryConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["InventoryConfiguration"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["NextContinuationToken"] !== undefined) {
      contents.NextContinuationToken = (0, smithy_client_1.expectString)(data["NextContinuationToken"]);
    }
    return contents;
  };
  exports.de_ListBucketInventoryConfigurationsCommand = de_ListBucketInventoryConfigurationsCommand;
  var de_ListBucketInventoryConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListBucketMetricsConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListBucketMetricsConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["ContinuationToken"] !== undefined) {
      contents.ContinuationToken = (0, smithy_client_1.expectString)(data["ContinuationToken"]);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data.MetricsConfiguration === "") {
      contents.MetricsConfigurationList = [];
    } else if (data["MetricsConfiguration"] !== undefined) {
      contents.MetricsConfigurationList = de_MetricsConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data["MetricsConfiguration"]), context);
    }
    if (data["NextContinuationToken"] !== undefined) {
      contents.NextContinuationToken = (0, smithy_client_1.expectString)(data["NextContinuationToken"]);
    }
    return contents;
  };
  exports.de_ListBucketMetricsConfigurationsCommand = de_ListBucketMetricsConfigurationsCommand;
  var de_ListBucketMetricsConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListBucketsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListBucketsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.Buckets === "") {
      contents.Buckets = [];
    } else if (data["Buckets"] !== undefined && data["Buckets"]["Bucket"] !== undefined) {
      contents.Buckets = de_Buckets((0, smithy_client_1.getArrayIfSingleItem)(data["Buckets"]["Bucket"]), context);
    }
    if (data["Owner"] !== undefined) {
      contents.Owner = de_Owner(data["Owner"], context);
    }
    return contents;
  };
  exports.de_ListBucketsCommand = de_ListBucketsCommand;
  var de_ListBucketsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListMultipartUploadsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListMultipartUploadsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(data["Bucket"]);
    }
    if (data.CommonPrefixes === "") {
      contents.CommonPrefixes = [];
    } else if (data["CommonPrefixes"] !== undefined) {
      contents.CommonPrefixes = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data["CommonPrefixes"]), context);
    }
    if (data["Delimiter"] !== undefined) {
      contents.Delimiter = (0, smithy_client_1.expectString)(data["Delimiter"]);
    }
    if (data["EncodingType"] !== undefined) {
      contents.EncodingType = (0, smithy_client_1.expectString)(data["EncodingType"]);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["KeyMarker"] !== undefined) {
      contents.KeyMarker = (0, smithy_client_1.expectString)(data["KeyMarker"]);
    }
    if (data["MaxUploads"] !== undefined) {
      contents.MaxUploads = (0, smithy_client_1.strictParseInt32)(data["MaxUploads"]);
    }
    if (data["NextKeyMarker"] !== undefined) {
      contents.NextKeyMarker = (0, smithy_client_1.expectString)(data["NextKeyMarker"]);
    }
    if (data["NextUploadIdMarker"] !== undefined) {
      contents.NextUploadIdMarker = (0, smithy_client_1.expectString)(data["NextUploadIdMarker"]);
    }
    if (data["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(data["Prefix"]);
    }
    if (data["UploadIdMarker"] !== undefined) {
      contents.UploadIdMarker = (0, smithy_client_1.expectString)(data["UploadIdMarker"]);
    }
    if (data.Upload === "") {
      contents.Uploads = [];
    } else if (data["Upload"] !== undefined) {
      contents.Uploads = de_MultipartUploadList((0, smithy_client_1.getArrayIfSingleItem)(data["Upload"]), context);
    }
    return contents;
  };
  exports.de_ListMultipartUploadsCommand = de_ListMultipartUploadsCommand;
  var de_ListMultipartUploadsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListObjectsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.CommonPrefixes === "") {
      contents.CommonPrefixes = [];
    } else if (data["CommonPrefixes"] !== undefined) {
      contents.CommonPrefixes = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data["CommonPrefixes"]), context);
    }
    if (data.Contents === "") {
      contents.Contents = [];
    } else if (data["Contents"] !== undefined) {
      contents.Contents = de_ObjectList((0, smithy_client_1.getArrayIfSingleItem)(data["Contents"]), context);
    }
    if (data["Delimiter"] !== undefined) {
      contents.Delimiter = (0, smithy_client_1.expectString)(data["Delimiter"]);
    }
    if (data["EncodingType"] !== undefined) {
      contents.EncodingType = (0, smithy_client_1.expectString)(data["EncodingType"]);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["Marker"] !== undefined) {
      contents.Marker = (0, smithy_client_1.expectString)(data["Marker"]);
    }
    if (data["MaxKeys"] !== undefined) {
      contents.MaxKeys = (0, smithy_client_1.strictParseInt32)(data["MaxKeys"]);
    }
    if (data["Name"] !== undefined) {
      contents.Name = (0, smithy_client_1.expectString)(data["Name"]);
    }
    if (data["NextMarker"] !== undefined) {
      contents.NextMarker = (0, smithy_client_1.expectString)(data["NextMarker"]);
    }
    if (data["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(data["Prefix"]);
    }
    return contents;
  };
  exports.de_ListObjectsCommand = de_ListObjectsCommand;
  var de_ListObjectsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchBucket":
      case "com.amazonaws.s3#NoSuchBucket":
        throw await de_NoSuchBucketRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_ListObjectsV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListObjectsV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.CommonPrefixes === "") {
      contents.CommonPrefixes = [];
    } else if (data["CommonPrefixes"] !== undefined) {
      contents.CommonPrefixes = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data["CommonPrefixes"]), context);
    }
    if (data.Contents === "") {
      contents.Contents = [];
    } else if (data["Contents"] !== undefined) {
      contents.Contents = de_ObjectList((0, smithy_client_1.getArrayIfSingleItem)(data["Contents"]), context);
    }
    if (data["ContinuationToken"] !== undefined) {
      contents.ContinuationToken = (0, smithy_client_1.expectString)(data["ContinuationToken"]);
    }
    if (data["Delimiter"] !== undefined) {
      contents.Delimiter = (0, smithy_client_1.expectString)(data["Delimiter"]);
    }
    if (data["EncodingType"] !== undefined) {
      contents.EncodingType = (0, smithy_client_1.expectString)(data["EncodingType"]);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["KeyCount"] !== undefined) {
      contents.KeyCount = (0, smithy_client_1.strictParseInt32)(data["KeyCount"]);
    }
    if (data["MaxKeys"] !== undefined) {
      contents.MaxKeys = (0, smithy_client_1.strictParseInt32)(data["MaxKeys"]);
    }
    if (data["Name"] !== undefined) {
      contents.Name = (0, smithy_client_1.expectString)(data["Name"]);
    }
    if (data["NextContinuationToken"] !== undefined) {
      contents.NextContinuationToken = (0, smithy_client_1.expectString)(data["NextContinuationToken"]);
    }
    if (data["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(data["Prefix"]);
    }
    if (data["StartAfter"] !== undefined) {
      contents.StartAfter = (0, smithy_client_1.expectString)(data["StartAfter"]);
    }
    return contents;
  };
  exports.de_ListObjectsV2Command = de_ListObjectsV2Command;
  var de_ListObjectsV2CommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchBucket":
      case "com.amazonaws.s3#NoSuchBucket":
        throw await de_NoSuchBucketRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_ListObjectVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListObjectVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data.CommonPrefixes === "") {
      contents.CommonPrefixes = [];
    } else if (data["CommonPrefixes"] !== undefined) {
      contents.CommonPrefixes = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data["CommonPrefixes"]), context);
    }
    if (data.DeleteMarker === "") {
      contents.DeleteMarkers = [];
    } else if (data["DeleteMarker"] !== undefined) {
      contents.DeleteMarkers = de_DeleteMarkers((0, smithy_client_1.getArrayIfSingleItem)(data["DeleteMarker"]), context);
    }
    if (data["Delimiter"] !== undefined) {
      contents.Delimiter = (0, smithy_client_1.expectString)(data["Delimiter"]);
    }
    if (data["EncodingType"] !== undefined) {
      contents.EncodingType = (0, smithy_client_1.expectString)(data["EncodingType"]);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["KeyMarker"] !== undefined) {
      contents.KeyMarker = (0, smithy_client_1.expectString)(data["KeyMarker"]);
    }
    if (data["MaxKeys"] !== undefined) {
      contents.MaxKeys = (0, smithy_client_1.strictParseInt32)(data["MaxKeys"]);
    }
    if (data["Name"] !== undefined) {
      contents.Name = (0, smithy_client_1.expectString)(data["Name"]);
    }
    if (data["NextKeyMarker"] !== undefined) {
      contents.NextKeyMarker = (0, smithy_client_1.expectString)(data["NextKeyMarker"]);
    }
    if (data["NextVersionIdMarker"] !== undefined) {
      contents.NextVersionIdMarker = (0, smithy_client_1.expectString)(data["NextVersionIdMarker"]);
    }
    if (data["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(data["Prefix"]);
    }
    if (data["VersionIdMarker"] !== undefined) {
      contents.VersionIdMarker = (0, smithy_client_1.expectString)(data["VersionIdMarker"]);
    }
    if (data.Version === "") {
      contents.Versions = [];
    } else if (data["Version"] !== undefined) {
      contents.Versions = de_ObjectVersionList((0, smithy_client_1.getArrayIfSingleItem)(data["Version"]), context);
    }
    return contents;
  };
  exports.de_ListObjectVersionsCommand = de_ListObjectVersionsCommand;
  var de_ListObjectVersionsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_ListPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_ListPartsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      AbortDate: [
        () => output.headers["x-amz-abort-date"] !== undefined,
        () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers["x-amz-abort-date"]))
      ],
      AbortRuleId: [, output.headers["x-amz-abort-rule-id"]],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody2(output.body, context)), "body");
    if (data["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(data["Bucket"]);
    }
    if (data["ChecksumAlgorithm"] !== undefined) {
      contents.ChecksumAlgorithm = (0, smithy_client_1.expectString)(data["ChecksumAlgorithm"]);
    }
    if (data["Initiator"] !== undefined) {
      contents.Initiator = de_Initiator(data["Initiator"], context);
    }
    if (data["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(data["IsTruncated"]);
    }
    if (data["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(data["Key"]);
    }
    if (data["MaxParts"] !== undefined) {
      contents.MaxParts = (0, smithy_client_1.strictParseInt32)(data["MaxParts"]);
    }
    if (data["NextPartNumberMarker"] !== undefined) {
      contents.NextPartNumberMarker = (0, smithy_client_1.expectString)(data["NextPartNumberMarker"]);
    }
    if (data["Owner"] !== undefined) {
      contents.Owner = de_Owner(data["Owner"], context);
    }
    if (data["PartNumberMarker"] !== undefined) {
      contents.PartNumberMarker = (0, smithy_client_1.expectString)(data["PartNumberMarker"]);
    }
    if (data.Part === "") {
      contents.Parts = [];
    } else if (data["Part"] !== undefined) {
      contents.Parts = de_Parts((0, smithy_client_1.getArrayIfSingleItem)(data["Part"]), context);
    }
    if (data["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(data["StorageClass"]);
    }
    if (data["UploadId"] !== undefined) {
      contents.UploadId = (0, smithy_client_1.expectString)(data["UploadId"]);
    }
    return contents;
  };
  exports.de_ListPartsCommand = de_ListPartsCommand;
  var de_ListPartsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketAccelerateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketAccelerateConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketAccelerateConfigurationCommand = de_PutBucketAccelerateConfigurationCommand;
  var de_PutBucketAccelerateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketAclCommand = de_PutBucketAclCommand;
  var de_PutBucketAclCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketAnalyticsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketAnalyticsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketAnalyticsConfigurationCommand = de_PutBucketAnalyticsConfigurationCommand;
  var de_PutBucketAnalyticsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketCorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketCorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketCorsCommand = de_PutBucketCorsCommand;
  var de_PutBucketCorsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketEncryptionCommand = de_PutBucketEncryptionCommand;
  var de_PutBucketEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketIntelligentTieringConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketIntelligentTieringConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketIntelligentTieringConfigurationCommand = de_PutBucketIntelligentTieringConfigurationCommand;
  var de_PutBucketIntelligentTieringConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketInventoryConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketInventoryConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketInventoryConfigurationCommand = de_PutBucketInventoryConfigurationCommand;
  var de_PutBucketInventoryConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketLifecycleConfigurationCommand = de_PutBucketLifecycleConfigurationCommand;
  var de_PutBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketLoggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketLoggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketLoggingCommand = de_PutBucketLoggingCommand;
  var de_PutBucketLoggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketMetricsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketMetricsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketMetricsConfigurationCommand = de_PutBucketMetricsConfigurationCommand;
  var de_PutBucketMetricsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketNotificationConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketNotificationConfigurationCommand = de_PutBucketNotificationConfigurationCommand;
  var de_PutBucketNotificationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketOwnershipControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketOwnershipControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketOwnershipControlsCommand = de_PutBucketOwnershipControlsCommand;
  var de_PutBucketOwnershipControlsCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketPolicyCommand = de_PutBucketPolicyCommand;
  var de_PutBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketReplicationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketReplicationCommand = de_PutBucketReplicationCommand;
  var de_PutBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketRequestPaymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketRequestPaymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketRequestPaymentCommand = de_PutBucketRequestPaymentCommand;
  var de_PutBucketRequestPaymentCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketTaggingCommand = de_PutBucketTaggingCommand;
  var de_PutBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketVersioningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketVersioningCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketVersioningCommand = de_PutBucketVersioningCommand;
  var de_PutBucketVersioningCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutBucketWebsiteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutBucketWebsiteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutBucketWebsiteCommand = de_PutBucketWebsiteCommand;
  var de_PutBucketWebsiteCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      Expiration: [, output.headers["x-amz-expiration"]],
      ETag: [, output.headers["etag"]],
      ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
      ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
      ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
      ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      VersionId: [, output.headers["x-amz-version-id"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      SSEKMSEncryptionContext: [, output.headers["x-amz-server-side-encryption-context"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutObjectCommand = de_PutObjectCommand;
  var de_PutObjectCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutObjectAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutObjectAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutObjectAclCommand = de_PutObjectAclCommand;
  var de_PutObjectAclCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchKey":
      case "com.amazonaws.s3#NoSuchKey":
        throw await de_NoSuchKeyRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_PutObjectLegalHoldCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutObjectLegalHoldCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutObjectLegalHoldCommand = de_PutObjectLegalHoldCommand;
  var de_PutObjectLegalHoldCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutObjectLockConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutObjectLockConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutObjectLockConfigurationCommand = de_PutObjectLockConfigurationCommand;
  var de_PutObjectLockConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutObjectRetentionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutObjectRetentionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutObjectRetentionCommand = de_PutObjectRetentionCommand;
  var de_PutObjectRetentionCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutObjectTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutObjectTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      VersionId: [, output.headers["x-amz-version-id"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutObjectTaggingCommand = de_PutObjectTaggingCommand;
  var de_PutObjectTaggingCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_PutPublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_PutPublicAccessBlockCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_PutPublicAccessBlockCommand = de_PutPublicAccessBlockCommand;
  var de_PutPublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_RestoreObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_RestoreObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      RequestCharged: [, output.headers["x-amz-request-charged"]],
      RestoreOutputPath: [, output.headers["x-amz-restore-output-path"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_RestoreObjectCommand = de_RestoreObjectCommand;
  var de_RestoreObjectCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ObjectAlreadyInActiveTierError":
      case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
        throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var de_SelectObjectContentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_SelectObjectContentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    const data = output.body;
    contents.Payload = de_SelectObjectContentEventStream(data, context);
    return contents;
  };
  exports.de_SelectObjectContentCommand = de_SelectObjectContentCommand;
  var de_SelectObjectContentCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_UploadPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_UploadPartCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      ETag: [, output.headers["etag"]],
      ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
      ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
      ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
      ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_UploadPartCommand = de_UploadPartCommand;
  var de_UploadPartCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_UploadPartCopyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_UploadPartCopyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output),
      CopySourceVersionId: [, output.headers["x-amz-copy-source-version-id"]],
      ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
      SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
      SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
      SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
      BucketKeyEnabled: [
        () => output.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== undefined,
        () => (0, smithy_client_1.parseBoolean)(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
      ],
      RequestCharged: [, output.headers["x-amz-request-charged"]]
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody2(output.body, context));
    contents.CopyPartResult = de_CopyPartResult(data, context);
    return contents;
  };
  exports.de_UploadPartCopyCommand = de_UploadPartCopyCommand;
  var de_UploadPartCopyCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var de_WriteGetObjectResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_WriteGetObjectResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
      $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
  };
  exports.de_WriteGetObjectResponseCommand = de_WriteGetObjectResponseCommand;
  var de_WriteGetObjectResponseCommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
      output,
      parsedBody,
      errorCode
    });
  };
  var throwDefaultError = (0, smithy_client_1.withBaseException)(S3ServiceException_1.S3ServiceException);
  var de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.BucketAlreadyExists({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.BucketAlreadyOwnedByYou({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_InvalidObjectStateRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    if (data["AccessTier"] !== undefined) {
      contents.AccessTier = (0, smithy_client_1.expectString)(data["AccessTier"]);
    }
    if (data["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(data["StorageClass"]);
    }
    const exception = new models_0_1.InvalidObjectState({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_NoSuchBucketRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NoSuchBucket({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_NoSuchKeyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NoSuchKey({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_NoSuchUploadRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NoSuchUpload({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_NotFoundRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NotFound({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_1_1.ObjectAlreadyInActiveTierError({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.ObjectNotInActiveTierError({
      $metadata: deserializeMetadata(parsedOutput),
      ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
  };
  var de_SelectObjectContentEventStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
      if (event["Records"] != null) {
        return {
          Records: await de_RecordsEvent_event(event["Records"], context)
        };
      }
      if (event["Stats"] != null) {
        return {
          Stats: await de_StatsEvent_event(event["Stats"], context)
        };
      }
      if (event["Progress"] != null) {
        return {
          Progress: await de_ProgressEvent_event(event["Progress"], context)
        };
      }
      if (event["Cont"] != null) {
        return {
          Cont: await de_ContinuationEvent_event(event["Cont"], context)
        };
      }
      if (event["End"] != null) {
        return {
          End: await de_EndEvent_event(event["End"], context)
        };
      }
      return { $unknown: output };
    });
  };
  var de_ContinuationEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody2(output.body, context);
    Object.assign(contents, de_ContinuationEvent(data, context));
    return contents;
  };
  var de_EndEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody2(output.body, context);
    Object.assign(contents, de_EndEvent(data, context));
    return contents;
  };
  var de_ProgressEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody2(output.body, context);
    contents.Details = de_Progress(data, context);
    return contents;
  };
  var de_RecordsEvent_event = async (output, context) => {
    const contents = {};
    contents.Payload = output.body;
    return contents;
  };
  var de_StatsEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody2(output.body, context);
    contents.Details = de_Stats(data, context);
    return contents;
  };
  var se_AbortIncompleteMultipartUpload = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AbortIncompleteMultipartUpload");
    if (input.DaysAfterInitiation != null) {
      const node = xml_builder_1.XmlNode.of("DaysAfterInitiation", String(input.DaysAfterInitiation)).withName("DaysAfterInitiation");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_AccelerateConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AccelerateConfiguration");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("BucketAccelerateStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_AccessControlPolicy = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AccessControlPolicy");
    if (input.Grants != null) {
      const nodes = se_Grants(input.Grants, context);
      const containerNode = new xml_builder_1.XmlNode("AccessControlList");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    if (input.Owner != null) {
      const node = se_Owner(input.Owner, context).withName("Owner");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_AccessControlTranslation = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AccessControlTranslation");
    if (input.Owner != null) {
      const node = xml_builder_1.XmlNode.of("OwnerOverride", input.Owner).withName("Owner");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_AllowedHeaders = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = xml_builder_1.XmlNode.of("AllowedHeader", entry);
      return node.withName("member");
    });
  };
  var se_AllowedMethods = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = xml_builder_1.XmlNode.of("AllowedMethod", entry);
      return node.withName("member");
    });
  };
  var se_AllowedOrigins = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = xml_builder_1.XmlNode.of("AllowedOrigin", entry);
      return node.withName("member");
    });
  };
  var se_AnalyticsAndOperator = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AnalyticsAndOperator");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
      const nodes = se_TagSet(input.Tags, context);
      nodes.map((node) => {
        node = node.withName("Tag");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_AnalyticsConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AnalyticsConfiguration");
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("AnalyticsId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
      const node = se_AnalyticsFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    if (input.StorageClassAnalysis != null) {
      const node = se_StorageClassAnalysis(input.StorageClassAnalysis, context).withName("StorageClassAnalysis");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_AnalyticsExportDestination = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AnalyticsExportDestination");
    if (input.S3BucketDestination != null) {
      const node = se_AnalyticsS3BucketDestination(input.S3BucketDestination, context).withName("S3BucketDestination");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_AnalyticsFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AnalyticsFilter");
    models_0_1.AnalyticsFilter.visit(input, {
      Prefix: (value) => {
        const node = xml_builder_1.XmlNode.of("Prefix", value).withName("Prefix");
        bodyNode.addChildNode(node);
      },
      Tag: (value) => {
        const node = se_Tag(value, context).withName("Tag");
        bodyNode.addChildNode(node);
      },
      And: (value) => {
        const node = se_AnalyticsAndOperator(value, context).withName("And");
        bodyNode.addChildNode(node);
      },
      _: (name, value) => {
        if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
          throw new Error("Unable to serialize unknown union members in XML.");
        }
        bodyNode.addChildNode(new xml_builder_1.XmlNode(name).addChildNode(value));
      }
    });
    return bodyNode;
  };
  var se_AnalyticsS3BucketDestination = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AnalyticsS3BucketDestination");
    if (input.Format != null) {
      const node = xml_builder_1.XmlNode.of("AnalyticsS3ExportFileFormat", input.Format).withName("Format");
      bodyNode.addChildNode(node);
    }
    if (input.BucketAccountId != null) {
      const node = xml_builder_1.XmlNode.of("AccountId", input.BucketAccountId).withName("BucketAccountId");
      bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
      const node = xml_builder_1.XmlNode.of("BucketName", input.Bucket).withName("Bucket");
      bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_BucketLifecycleConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("BucketLifecycleConfiguration");
    if (input.Rules != null) {
      const nodes = se_LifecycleRules(input.Rules, context);
      nodes.map((node) => {
        node = node.withName("Rule");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_BucketLoggingStatus = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("BucketLoggingStatus");
    if (input.LoggingEnabled != null) {
      const node = se_LoggingEnabled(input.LoggingEnabled, context).withName("LoggingEnabled");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_CompletedMultipartUpload = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CompletedMultipartUpload");
    if (input.Parts != null) {
      const nodes = se_CompletedPartList(input.Parts, context);
      nodes.map((node) => {
        node = node.withName("Part");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_CompletedPart = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CompletedPart");
    if (input.ETag != null) {
      const node = xml_builder_1.XmlNode.of("ETag", input.ETag).withName("ETag");
      bodyNode.addChildNode(node);
    }
    if (input.ChecksumCRC32 != null) {
      const node = xml_builder_1.XmlNode.of("ChecksumCRC32", input.ChecksumCRC32).withName("ChecksumCRC32");
      bodyNode.addChildNode(node);
    }
    if (input.ChecksumCRC32C != null) {
      const node = xml_builder_1.XmlNode.of("ChecksumCRC32C", input.ChecksumCRC32C).withName("ChecksumCRC32C");
      bodyNode.addChildNode(node);
    }
    if (input.ChecksumSHA1 != null) {
      const node = xml_builder_1.XmlNode.of("ChecksumSHA1", input.ChecksumSHA1).withName("ChecksumSHA1");
      bodyNode.addChildNode(node);
    }
    if (input.ChecksumSHA256 != null) {
      const node = xml_builder_1.XmlNode.of("ChecksumSHA256", input.ChecksumSHA256).withName("ChecksumSHA256");
      bodyNode.addChildNode(node);
    }
    if (input.PartNumber != null) {
      const node = xml_builder_1.XmlNode.of("PartNumber", String(input.PartNumber)).withName("PartNumber");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_CompletedPartList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_CompletedPart(entry, context);
      return node.withName("member");
    });
  };
  var se_Condition = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Condition");
    if (input.HttpErrorCodeReturnedEquals != null) {
      const node = xml_builder_1.XmlNode.of("HttpErrorCodeReturnedEquals", input.HttpErrorCodeReturnedEquals).withName("HttpErrorCodeReturnedEquals");
      bodyNode.addChildNode(node);
    }
    if (input.KeyPrefixEquals != null) {
      const node = xml_builder_1.XmlNode.of("KeyPrefixEquals", input.KeyPrefixEquals).withName("KeyPrefixEquals");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_CORSConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CORSConfiguration");
    if (input.CORSRules != null) {
      const nodes = se_CORSRules(input.CORSRules, context);
      nodes.map((node) => {
        node = node.withName("CORSRule");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_CORSRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CORSRule");
    if (input.ID != null) {
      const node = xml_builder_1.XmlNode.of("ID", input.ID).withName("ID");
      bodyNode.addChildNode(node);
    }
    if (input.AllowedHeaders != null) {
      const nodes = se_AllowedHeaders(input.AllowedHeaders, context);
      nodes.map((node) => {
        node = node.withName("AllowedHeader");
        bodyNode.addChildNode(node);
      });
    }
    if (input.AllowedMethods != null) {
      const nodes = se_AllowedMethods(input.AllowedMethods, context);
      nodes.map((node) => {
        node = node.withName("AllowedMethod");
        bodyNode.addChildNode(node);
      });
    }
    if (input.AllowedOrigins != null) {
      const nodes = se_AllowedOrigins(input.AllowedOrigins, context);
      nodes.map((node) => {
        node = node.withName("AllowedOrigin");
        bodyNode.addChildNode(node);
      });
    }
    if (input.ExposeHeaders != null) {
      const nodes = se_ExposeHeaders(input.ExposeHeaders, context);
      nodes.map((node) => {
        node = node.withName("ExposeHeader");
        bodyNode.addChildNode(node);
      });
    }
    if (input.MaxAgeSeconds != null) {
      const node = xml_builder_1.XmlNode.of("MaxAgeSeconds", String(input.MaxAgeSeconds)).withName("MaxAgeSeconds");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_CORSRules = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_CORSRule(entry, context);
      return node.withName("member");
    });
  };
  var se_CreateBucketConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CreateBucketConfiguration");
    if (input.LocationConstraint != null) {
      const node = xml_builder_1.XmlNode.of("BucketLocationConstraint", input.LocationConstraint).withName("LocationConstraint");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_CSVInput = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CSVInput");
    if (input.FileHeaderInfo != null) {
      const node = xml_builder_1.XmlNode.of("FileHeaderInfo", input.FileHeaderInfo).withName("FileHeaderInfo");
      bodyNode.addChildNode(node);
    }
    if (input.Comments != null) {
      const node = xml_builder_1.XmlNode.of("Comments", input.Comments).withName("Comments");
      bodyNode.addChildNode(node);
    }
    if (input.QuoteEscapeCharacter != null) {
      const node = xml_builder_1.XmlNode.of("QuoteEscapeCharacter", input.QuoteEscapeCharacter).withName("QuoteEscapeCharacter");
      bodyNode.addChildNode(node);
    }
    if (input.RecordDelimiter != null) {
      const node = xml_builder_1.XmlNode.of("RecordDelimiter", input.RecordDelimiter).withName("RecordDelimiter");
      bodyNode.addChildNode(node);
    }
    if (input.FieldDelimiter != null) {
      const node = xml_builder_1.XmlNode.of("FieldDelimiter", input.FieldDelimiter).withName("FieldDelimiter");
      bodyNode.addChildNode(node);
    }
    if (input.QuoteCharacter != null) {
      const node = xml_builder_1.XmlNode.of("QuoteCharacter", input.QuoteCharacter).withName("QuoteCharacter");
      bodyNode.addChildNode(node);
    }
    if (input.AllowQuotedRecordDelimiter != null) {
      const node = xml_builder_1.XmlNode.of("AllowQuotedRecordDelimiter", String(input.AllowQuotedRecordDelimiter)).withName("AllowQuotedRecordDelimiter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_CSVOutput = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CSVOutput");
    if (input.QuoteFields != null) {
      const node = xml_builder_1.XmlNode.of("QuoteFields", input.QuoteFields).withName("QuoteFields");
      bodyNode.addChildNode(node);
    }
    if (input.QuoteEscapeCharacter != null) {
      const node = xml_builder_1.XmlNode.of("QuoteEscapeCharacter", input.QuoteEscapeCharacter).withName("QuoteEscapeCharacter");
      bodyNode.addChildNode(node);
    }
    if (input.RecordDelimiter != null) {
      const node = xml_builder_1.XmlNode.of("RecordDelimiter", input.RecordDelimiter).withName("RecordDelimiter");
      bodyNode.addChildNode(node);
    }
    if (input.FieldDelimiter != null) {
      const node = xml_builder_1.XmlNode.of("FieldDelimiter", input.FieldDelimiter).withName("FieldDelimiter");
      bodyNode.addChildNode(node);
    }
    if (input.QuoteCharacter != null) {
      const node = xml_builder_1.XmlNode.of("QuoteCharacter", input.QuoteCharacter).withName("QuoteCharacter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_DefaultRetention = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("DefaultRetention");
    if (input.Mode != null) {
      const node = xml_builder_1.XmlNode.of("ObjectLockRetentionMode", input.Mode).withName("Mode");
      bodyNode.addChildNode(node);
    }
    if (input.Days != null) {
      const node = xml_builder_1.XmlNode.of("Days", String(input.Days)).withName("Days");
      bodyNode.addChildNode(node);
    }
    if (input.Years != null) {
      const node = xml_builder_1.XmlNode.of("Years", String(input.Years)).withName("Years");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Delete = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Delete");
    if (input.Objects != null) {
      const nodes = se_ObjectIdentifierList(input.Objects, context);
      nodes.map((node) => {
        node = node.withName("Object");
        bodyNode.addChildNode(node);
      });
    }
    if (input.Quiet != null) {
      const node = xml_builder_1.XmlNode.of("Quiet", String(input.Quiet)).withName("Quiet");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_DeleteMarkerReplication = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("DeleteMarkerReplication");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("DeleteMarkerReplicationStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Destination = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Destination");
    if (input.Bucket != null) {
      const node = xml_builder_1.XmlNode.of("BucketName", input.Bucket).withName("Bucket");
      bodyNode.addChildNode(node);
    }
    if (input.Account != null) {
      const node = xml_builder_1.XmlNode.of("AccountId", input.Account).withName("Account");
      bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
      const node = xml_builder_1.XmlNode.of("StorageClass", input.StorageClass).withName("StorageClass");
      bodyNode.addChildNode(node);
    }
    if (input.AccessControlTranslation != null) {
      const node = se_AccessControlTranslation(input.AccessControlTranslation, context).withName("AccessControlTranslation");
      bodyNode.addChildNode(node);
    }
    if (input.EncryptionConfiguration != null) {
      const node = se_EncryptionConfiguration(input.EncryptionConfiguration, context).withName("EncryptionConfiguration");
      bodyNode.addChildNode(node);
    }
    if (input.ReplicationTime != null) {
      const node = se_ReplicationTime(input.ReplicationTime, context).withName("ReplicationTime");
      bodyNode.addChildNode(node);
    }
    if (input.Metrics != null) {
      const node = se_Metrics(input.Metrics, context).withName("Metrics");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Encryption = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Encryption");
    if (input.EncryptionType != null) {
      const node = xml_builder_1.XmlNode.of("ServerSideEncryption", input.EncryptionType).withName("EncryptionType");
      bodyNode.addChildNode(node);
    }
    if (input.KMSKeyId != null) {
      const node = xml_builder_1.XmlNode.of("SSEKMSKeyId", input.KMSKeyId).withName("KMSKeyId");
      bodyNode.addChildNode(node);
    }
    if (input.KMSContext != null) {
      const node = xml_builder_1.XmlNode.of("KMSContext", input.KMSContext).withName("KMSContext");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_EncryptionConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("EncryptionConfiguration");
    if (input.ReplicaKmsKeyID != null) {
      const node = xml_builder_1.XmlNode.of("ReplicaKmsKeyID", input.ReplicaKmsKeyID).withName("ReplicaKmsKeyID");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ErrorDocument = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ErrorDocument");
    if (input.Key != null) {
      const node = xml_builder_1.XmlNode.of("ObjectKey", input.Key).withName("Key");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_EventBridgeConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("EventBridgeConfiguration");
    return bodyNode;
  };
  var se_EventList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = xml_builder_1.XmlNode.of("Event", entry);
      return node.withName("member");
    });
  };
  var se_ExistingObjectReplication = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ExistingObjectReplication");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("ExistingObjectReplicationStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ExposeHeaders = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = xml_builder_1.XmlNode.of("ExposeHeader", entry);
      return node.withName("member");
    });
  };
  var se_FilterRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FilterRule");
    if (input.Name != null) {
      const node = xml_builder_1.XmlNode.of("FilterRuleName", input.Name).withName("Name");
      bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
      const node = xml_builder_1.XmlNode.of("FilterRuleValue", input.Value).withName("Value");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_FilterRuleList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_FilterRule(entry, context);
      return node.withName("member");
    });
  };
  var se_GlacierJobParameters = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("GlacierJobParameters");
    if (input.Tier != null) {
      const node = xml_builder_1.XmlNode.of("Tier", input.Tier).withName("Tier");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Grant = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Grant");
    if (input.Grantee != null) {
      const node = se_Grantee(input.Grantee, context).withName("Grantee");
      node.addAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
      bodyNode.addChildNode(node);
    }
    if (input.Permission != null) {
      const node = xml_builder_1.XmlNode.of("Permission", input.Permission).withName("Permission");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Grantee = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Grantee");
    if (input.DisplayName != null) {
      const node = xml_builder_1.XmlNode.of("DisplayName", input.DisplayName).withName("DisplayName");
      bodyNode.addChildNode(node);
    }
    if (input.EmailAddress != null) {
      const node = xml_builder_1.XmlNode.of("EmailAddress", input.EmailAddress).withName("EmailAddress");
      bodyNode.addChildNode(node);
    }
    if (input.ID != null) {
      const node = xml_builder_1.XmlNode.of("ID", input.ID).withName("ID");
      bodyNode.addChildNode(node);
    }
    if (input.URI != null) {
      const node = xml_builder_1.XmlNode.of("URI", input.URI).withName("URI");
      bodyNode.addChildNode(node);
    }
    if (input.Type != null) {
      bodyNode.addAttribute("xsi:type", input.Type);
    }
    return bodyNode;
  };
  var se_Grants = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_Grant(entry, context);
      return node.withName("Grant");
    });
  };
  var se_IndexDocument = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("IndexDocument");
    if (input.Suffix != null) {
      const node = xml_builder_1.XmlNode.of("Suffix", input.Suffix).withName("Suffix");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InputSerialization = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InputSerialization");
    if (input.CSV != null) {
      const node = se_CSVInput(input.CSV, context).withName("CSV");
      bodyNode.addChildNode(node);
    }
    if (input.CompressionType != null) {
      const node = xml_builder_1.XmlNode.of("CompressionType", input.CompressionType).withName("CompressionType");
      bodyNode.addChildNode(node);
    }
    if (input.JSON != null) {
      const node = se_JSONInput(input.JSON, context).withName("JSON");
      bodyNode.addChildNode(node);
    }
    if (input.Parquet != null) {
      const node = se_ParquetInput(input.Parquet, context).withName("Parquet");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_IntelligentTieringAndOperator = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("IntelligentTieringAndOperator");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
      const nodes = se_TagSet(input.Tags, context);
      nodes.map((node) => {
        node = node.withName("Tag");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_IntelligentTieringConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("IntelligentTieringConfiguration");
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("IntelligentTieringId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
      const node = se_IntelligentTieringFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("IntelligentTieringStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    if (input.Tierings != null) {
      const nodes = se_TieringList(input.Tierings, context);
      nodes.map((node) => {
        node = node.withName("Tiering");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_IntelligentTieringFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("IntelligentTieringFilter");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Tag != null) {
      const node = se_Tag(input.Tag, context).withName("Tag");
      bodyNode.addChildNode(node);
    }
    if (input.And != null) {
      const node = se_IntelligentTieringAndOperator(input.And, context).withName("And");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InventoryConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InventoryConfiguration");
    if (input.Destination != null) {
      const node = se_InventoryDestination(input.Destination, context).withName("Destination");
      bodyNode.addChildNode(node);
    }
    if (input.IsEnabled != null) {
      const node = xml_builder_1.XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
      bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
      const node = se_InventoryFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("InventoryId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.IncludedObjectVersions != null) {
      const node = xml_builder_1.XmlNode.of("InventoryIncludedObjectVersions", input.IncludedObjectVersions).withName("IncludedObjectVersions");
      bodyNode.addChildNode(node);
    }
    if (input.OptionalFields != null) {
      const nodes = se_InventoryOptionalFields(input.OptionalFields, context);
      const containerNode = new xml_builder_1.XmlNode("OptionalFields");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    if (input.Schedule != null) {
      const node = se_InventorySchedule(input.Schedule, context).withName("Schedule");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InventoryDestination = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InventoryDestination");
    if (input.S3BucketDestination != null) {
      const node = se_InventoryS3BucketDestination(input.S3BucketDestination, context).withName("S3BucketDestination");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InventoryEncryption = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InventoryEncryption");
    if (input.SSES3 != null) {
      const node = se_SSES3(input.SSES3, context).withName("SSE-S3");
      bodyNode.addChildNode(node);
    }
    if (input.SSEKMS != null) {
      const node = se_SSEKMS(input.SSEKMS, context).withName("SSE-KMS");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InventoryFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InventoryFilter");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InventoryOptionalFields = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = xml_builder_1.XmlNode.of("InventoryOptionalField", entry);
      return node.withName("Field");
    });
  };
  var se_InventoryS3BucketDestination = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InventoryS3BucketDestination");
    if (input.AccountId != null) {
      const node = xml_builder_1.XmlNode.of("AccountId", input.AccountId).withName("AccountId");
      bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
      const node = xml_builder_1.XmlNode.of("BucketName", input.Bucket).withName("Bucket");
      bodyNode.addChildNode(node);
    }
    if (input.Format != null) {
      const node = xml_builder_1.XmlNode.of("InventoryFormat", input.Format).withName("Format");
      bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Encryption != null) {
      const node = se_InventoryEncryption(input.Encryption, context).withName("Encryption");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_InventorySchedule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InventorySchedule");
    if (input.Frequency != null) {
      const node = xml_builder_1.XmlNode.of("InventoryFrequency", input.Frequency).withName("Frequency");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_JSONInput = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("JSONInput");
    if (input.Type != null) {
      const node = xml_builder_1.XmlNode.of("JSONType", input.Type).withName("Type");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_JSONOutput = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("JSONOutput");
    if (input.RecordDelimiter != null) {
      const node = xml_builder_1.XmlNode.of("RecordDelimiter", input.RecordDelimiter).withName("RecordDelimiter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_LambdaFunctionConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LambdaFunctionConfiguration");
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("NotificationId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.LambdaFunctionArn != null) {
      const node = xml_builder_1.XmlNode.of("LambdaFunctionArn", input.LambdaFunctionArn).withName("CloudFunction");
      bodyNode.addChildNode(node);
    }
    if (input.Events != null) {
      const nodes = se_EventList(input.Events, context);
      nodes.map((node) => {
        node = node.withName("Event");
        bodyNode.addChildNode(node);
      });
    }
    if (input.Filter != null) {
      const node = se_NotificationConfigurationFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_LambdaFunctionConfigurationList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_LambdaFunctionConfiguration(entry, context);
      return node.withName("member");
    });
  };
  var se_LifecycleExpiration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LifecycleExpiration");
    if (input.Date != null) {
      const node = xml_builder_1.XmlNode.of("Date", (input.Date.toISOString().split(".")[0] + "Z").toString()).withName("Date");
      bodyNode.addChildNode(node);
    }
    if (input.Days != null) {
      const node = xml_builder_1.XmlNode.of("Days", String(input.Days)).withName("Days");
      bodyNode.addChildNode(node);
    }
    if (input.ExpiredObjectDeleteMarker != null) {
      const node = xml_builder_1.XmlNode.of("ExpiredObjectDeleteMarker", String(input.ExpiredObjectDeleteMarker)).withName("ExpiredObjectDeleteMarker");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_LifecycleRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LifecycleRule");
    if (input.Expiration != null) {
      const node = se_LifecycleExpiration(input.Expiration, context).withName("Expiration");
      bodyNode.addChildNode(node);
    }
    if (input.ID != null) {
      const node = xml_builder_1.XmlNode.of("ID", input.ID).withName("ID");
      bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
      const node = se_LifecycleRuleFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("ExpirationStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    if (input.Transitions != null) {
      const nodes = se_TransitionList(input.Transitions, context);
      nodes.map((node) => {
        node = node.withName("Transition");
        bodyNode.addChildNode(node);
      });
    }
    if (input.NoncurrentVersionTransitions != null) {
      const nodes = se_NoncurrentVersionTransitionList(input.NoncurrentVersionTransitions, context);
      nodes.map((node) => {
        node = node.withName("NoncurrentVersionTransition");
        bodyNode.addChildNode(node);
      });
    }
    if (input.NoncurrentVersionExpiration != null) {
      const node = se_NoncurrentVersionExpiration(input.NoncurrentVersionExpiration, context).withName("NoncurrentVersionExpiration");
      bodyNode.addChildNode(node);
    }
    if (input.AbortIncompleteMultipartUpload != null) {
      const node = se_AbortIncompleteMultipartUpload(input.AbortIncompleteMultipartUpload, context).withName("AbortIncompleteMultipartUpload");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_LifecycleRuleAndOperator = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LifecycleRuleAndOperator");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
      const nodes = se_TagSet(input.Tags, context);
      nodes.map((node) => {
        node = node.withName("Tag");
        bodyNode.addChildNode(node);
      });
    }
    if (input.ObjectSizeGreaterThan != null) {
      const node = xml_builder_1.XmlNode.of("ObjectSizeGreaterThanBytes", String(input.ObjectSizeGreaterThan)).withName("ObjectSizeGreaterThan");
      bodyNode.addChildNode(node);
    }
    if (input.ObjectSizeLessThan != null) {
      const node = xml_builder_1.XmlNode.of("ObjectSizeLessThanBytes", String(input.ObjectSizeLessThan)).withName("ObjectSizeLessThan");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_LifecycleRuleFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LifecycleRuleFilter");
    models_0_1.LifecycleRuleFilter.visit(input, {
      Prefix: (value) => {
        const node = xml_builder_1.XmlNode.of("Prefix", value).withName("Prefix");
        bodyNode.addChildNode(node);
      },
      Tag: (value) => {
        const node = se_Tag(value, context).withName("Tag");
        bodyNode.addChildNode(node);
      },
      ObjectSizeGreaterThan: (value) => {
        const node = xml_builder_1.XmlNode.of("ObjectSizeGreaterThanBytes", String(value)).withName("ObjectSizeGreaterThan");
        bodyNode.addChildNode(node);
      },
      ObjectSizeLessThan: (value) => {
        const node = xml_builder_1.XmlNode.of("ObjectSizeLessThanBytes", String(value)).withName("ObjectSizeLessThan");
        bodyNode.addChildNode(node);
      },
      And: (value) => {
        const node = se_LifecycleRuleAndOperator(value, context).withName("And");
        bodyNode.addChildNode(node);
      },
      _: (name, value) => {
        if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
          throw new Error("Unable to serialize unknown union members in XML.");
        }
        bodyNode.addChildNode(new xml_builder_1.XmlNode(name).addChildNode(value));
      }
    });
    return bodyNode;
  };
  var se_LifecycleRules = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_LifecycleRule(entry, context);
      return node.withName("member");
    });
  };
  var se_LoggingEnabled = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LoggingEnabled");
    if (input.TargetBucket != null) {
      const node = xml_builder_1.XmlNode.of("TargetBucket", input.TargetBucket).withName("TargetBucket");
      bodyNode.addChildNode(node);
    }
    if (input.TargetGrants != null) {
      const nodes = se_TargetGrants(input.TargetGrants, context);
      const containerNode = new xml_builder_1.XmlNode("TargetGrants");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    if (input.TargetPrefix != null) {
      const node = xml_builder_1.XmlNode.of("TargetPrefix", input.TargetPrefix).withName("TargetPrefix");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_MetadataEntry = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("MetadataEntry");
    if (input.Name != null) {
      const node = xml_builder_1.XmlNode.of("MetadataKey", input.Name).withName("Name");
      bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
      const node = xml_builder_1.XmlNode.of("MetadataValue", input.Value).withName("Value");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Metrics = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Metrics");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("MetricsStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    if (input.EventThreshold != null) {
      const node = se_ReplicationTimeValue(input.EventThreshold, context).withName("EventThreshold");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_MetricsAndOperator = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("MetricsAndOperator");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
      const nodes = se_TagSet(input.Tags, context);
      nodes.map((node) => {
        node = node.withName("Tag");
        bodyNode.addChildNode(node);
      });
    }
    if (input.AccessPointArn != null) {
      const node = xml_builder_1.XmlNode.of("AccessPointArn", input.AccessPointArn).withName("AccessPointArn");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_MetricsConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("MetricsConfiguration");
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("MetricsId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
      const node = se_MetricsFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_MetricsFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("MetricsFilter");
    models_0_1.MetricsFilter.visit(input, {
      Prefix: (value) => {
        const node = xml_builder_1.XmlNode.of("Prefix", value).withName("Prefix");
        bodyNode.addChildNode(node);
      },
      Tag: (value) => {
        const node = se_Tag(value, context).withName("Tag");
        bodyNode.addChildNode(node);
      },
      AccessPointArn: (value) => {
        const node = xml_builder_1.XmlNode.of("AccessPointArn", value).withName("AccessPointArn");
        bodyNode.addChildNode(node);
      },
      And: (value) => {
        const node = se_MetricsAndOperator(value, context).withName("And");
        bodyNode.addChildNode(node);
      },
      _: (name, value) => {
        if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
          throw new Error("Unable to serialize unknown union members in XML.");
        }
        bodyNode.addChildNode(new xml_builder_1.XmlNode(name).addChildNode(value));
      }
    });
    return bodyNode;
  };
  var se_NoncurrentVersionExpiration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("NoncurrentVersionExpiration");
    if (input.NoncurrentDays != null) {
      const node = xml_builder_1.XmlNode.of("Days", String(input.NoncurrentDays)).withName("NoncurrentDays");
      bodyNode.addChildNode(node);
    }
    if (input.NewerNoncurrentVersions != null) {
      const node = xml_builder_1.XmlNode.of("VersionCount", String(input.NewerNoncurrentVersions)).withName("NewerNoncurrentVersions");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_NoncurrentVersionTransition = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("NoncurrentVersionTransition");
    if (input.NoncurrentDays != null) {
      const node = xml_builder_1.XmlNode.of("Days", String(input.NoncurrentDays)).withName("NoncurrentDays");
      bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
      const node = xml_builder_1.XmlNode.of("TransitionStorageClass", input.StorageClass).withName("StorageClass");
      bodyNode.addChildNode(node);
    }
    if (input.NewerNoncurrentVersions != null) {
      const node = xml_builder_1.XmlNode.of("VersionCount", String(input.NewerNoncurrentVersions)).withName("NewerNoncurrentVersions");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_NoncurrentVersionTransitionList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_NoncurrentVersionTransition(entry, context);
      return node.withName("member");
    });
  };
  var se_NotificationConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("NotificationConfiguration");
    if (input.TopicConfigurations != null) {
      const nodes = se_TopicConfigurationList(input.TopicConfigurations, context);
      nodes.map((node) => {
        node = node.withName("TopicConfiguration");
        bodyNode.addChildNode(node);
      });
    }
    if (input.QueueConfigurations != null) {
      const nodes = se_QueueConfigurationList(input.QueueConfigurations, context);
      nodes.map((node) => {
        node = node.withName("QueueConfiguration");
        bodyNode.addChildNode(node);
      });
    }
    if (input.LambdaFunctionConfigurations != null) {
      const nodes = se_LambdaFunctionConfigurationList(input.LambdaFunctionConfigurations, context);
      nodes.map((node) => {
        node = node.withName("CloudFunctionConfiguration");
        bodyNode.addChildNode(node);
      });
    }
    if (input.EventBridgeConfiguration != null) {
      const node = se_EventBridgeConfiguration(input.EventBridgeConfiguration, context).withName("EventBridgeConfiguration");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_NotificationConfigurationFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("NotificationConfigurationFilter");
    if (input.Key != null) {
      const node = se_S3KeyFilter(input.Key, context).withName("S3Key");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ObjectIdentifier = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ObjectIdentifier");
    if (input.Key != null) {
      const node = xml_builder_1.XmlNode.of("ObjectKey", input.Key).withName("Key");
      bodyNode.addChildNode(node);
    }
    if (input.VersionId != null) {
      const node = xml_builder_1.XmlNode.of("ObjectVersionId", input.VersionId).withName("VersionId");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ObjectIdentifierList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_ObjectIdentifier(entry, context);
      return node.withName("member");
    });
  };
  var se_ObjectLockConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ObjectLockConfiguration");
    if (input.ObjectLockEnabled != null) {
      const node = xml_builder_1.XmlNode.of("ObjectLockEnabled", input.ObjectLockEnabled).withName("ObjectLockEnabled");
      bodyNode.addChildNode(node);
    }
    if (input.Rule != null) {
      const node = se_ObjectLockRule(input.Rule, context).withName("Rule");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ObjectLockLegalHold = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ObjectLockLegalHold");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("ObjectLockLegalHoldStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ObjectLockRetention = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ObjectLockRetention");
    if (input.Mode != null) {
      const node = xml_builder_1.XmlNode.of("ObjectLockRetentionMode", input.Mode).withName("Mode");
      bodyNode.addChildNode(node);
    }
    if (input.RetainUntilDate != null) {
      const node = xml_builder_1.XmlNode.of("Date", (input.RetainUntilDate.toISOString().split(".")[0] + "Z").toString()).withName("RetainUntilDate");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ObjectLockRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ObjectLockRule");
    if (input.DefaultRetention != null) {
      const node = se_DefaultRetention(input.DefaultRetention, context).withName("DefaultRetention");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_OutputLocation = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OutputLocation");
    if (input.S3 != null) {
      const node = se_S3Location(input.S3, context).withName("S3");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_OutputSerialization = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OutputSerialization");
    if (input.CSV != null) {
      const node = se_CSVOutput(input.CSV, context).withName("CSV");
      bodyNode.addChildNode(node);
    }
    if (input.JSON != null) {
      const node = se_JSONOutput(input.JSON, context).withName("JSON");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Owner = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Owner");
    if (input.DisplayName != null) {
      const node = xml_builder_1.XmlNode.of("DisplayName", input.DisplayName).withName("DisplayName");
      bodyNode.addChildNode(node);
    }
    if (input.ID != null) {
      const node = xml_builder_1.XmlNode.of("ID", input.ID).withName("ID");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_OwnershipControls = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OwnershipControls");
    if (input.Rules != null) {
      const nodes = se_OwnershipControlsRules(input.Rules, context);
      nodes.map((node) => {
        node = node.withName("Rule");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_OwnershipControlsRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OwnershipControlsRule");
    if (input.ObjectOwnership != null) {
      const node = xml_builder_1.XmlNode.of("ObjectOwnership", input.ObjectOwnership).withName("ObjectOwnership");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_OwnershipControlsRules = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_OwnershipControlsRule(entry, context);
      return node.withName("member");
    });
  };
  var se_ParquetInput = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ParquetInput");
    return bodyNode;
  };
  var se_PublicAccessBlockConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("PublicAccessBlockConfiguration");
    if (input.BlockPublicAcls != null) {
      const node = xml_builder_1.XmlNode.of("Setting", String(input.BlockPublicAcls)).withName("BlockPublicAcls");
      bodyNode.addChildNode(node);
    }
    if (input.IgnorePublicAcls != null) {
      const node = xml_builder_1.XmlNode.of("Setting", String(input.IgnorePublicAcls)).withName("IgnorePublicAcls");
      bodyNode.addChildNode(node);
    }
    if (input.BlockPublicPolicy != null) {
      const node = xml_builder_1.XmlNode.of("Setting", String(input.BlockPublicPolicy)).withName("BlockPublicPolicy");
      bodyNode.addChildNode(node);
    }
    if (input.RestrictPublicBuckets != null) {
      const node = xml_builder_1.XmlNode.of("Setting", String(input.RestrictPublicBuckets)).withName("RestrictPublicBuckets");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_QueueConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("QueueConfiguration");
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("NotificationId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.QueueArn != null) {
      const node = xml_builder_1.XmlNode.of("QueueArn", input.QueueArn).withName("Queue");
      bodyNode.addChildNode(node);
    }
    if (input.Events != null) {
      const nodes = se_EventList(input.Events, context);
      nodes.map((node) => {
        node = node.withName("Event");
        bodyNode.addChildNode(node);
      });
    }
    if (input.Filter != null) {
      const node = se_NotificationConfigurationFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_QueueConfigurationList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_QueueConfiguration(entry, context);
      return node.withName("member");
    });
  };
  var se_Redirect = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Redirect");
    if (input.HostName != null) {
      const node = xml_builder_1.XmlNode.of("HostName", input.HostName).withName("HostName");
      bodyNode.addChildNode(node);
    }
    if (input.HttpRedirectCode != null) {
      const node = xml_builder_1.XmlNode.of("HttpRedirectCode", input.HttpRedirectCode).withName("HttpRedirectCode");
      bodyNode.addChildNode(node);
    }
    if (input.Protocol != null) {
      const node = xml_builder_1.XmlNode.of("Protocol", input.Protocol).withName("Protocol");
      bodyNode.addChildNode(node);
    }
    if (input.ReplaceKeyPrefixWith != null) {
      const node = xml_builder_1.XmlNode.of("ReplaceKeyPrefixWith", input.ReplaceKeyPrefixWith).withName("ReplaceKeyPrefixWith");
      bodyNode.addChildNode(node);
    }
    if (input.ReplaceKeyWith != null) {
      const node = xml_builder_1.XmlNode.of("ReplaceKeyWith", input.ReplaceKeyWith).withName("ReplaceKeyWith");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_RedirectAllRequestsTo = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("RedirectAllRequestsTo");
    if (input.HostName != null) {
      const node = xml_builder_1.XmlNode.of("HostName", input.HostName).withName("HostName");
      bodyNode.addChildNode(node);
    }
    if (input.Protocol != null) {
      const node = xml_builder_1.XmlNode.of("Protocol", input.Protocol).withName("Protocol");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ReplicaModifications = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicaModifications");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("ReplicaModificationsStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ReplicationConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicationConfiguration");
    if (input.Role != null) {
      const node = xml_builder_1.XmlNode.of("Role", input.Role).withName("Role");
      bodyNode.addChildNode(node);
    }
    if (input.Rules != null) {
      const nodes = se_ReplicationRules(input.Rules, context);
      nodes.map((node) => {
        node = node.withName("Rule");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_ReplicationRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicationRule");
    if (input.ID != null) {
      const node = xml_builder_1.XmlNode.of("ID", input.ID).withName("ID");
      bodyNode.addChildNode(node);
    }
    if (input.Priority != null) {
      const node = xml_builder_1.XmlNode.of("Priority", String(input.Priority)).withName("Priority");
      bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
      const node = se_ReplicationRuleFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("ReplicationRuleStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    if (input.SourceSelectionCriteria != null) {
      const node = se_SourceSelectionCriteria(input.SourceSelectionCriteria, context).withName("SourceSelectionCriteria");
      bodyNode.addChildNode(node);
    }
    if (input.ExistingObjectReplication != null) {
      const node = se_ExistingObjectReplication(input.ExistingObjectReplication, context).withName("ExistingObjectReplication");
      bodyNode.addChildNode(node);
    }
    if (input.Destination != null) {
      const node = se_Destination(input.Destination, context).withName("Destination");
      bodyNode.addChildNode(node);
    }
    if (input.DeleteMarkerReplication != null) {
      const node = se_DeleteMarkerReplication(input.DeleteMarkerReplication, context).withName("DeleteMarkerReplication");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ReplicationRuleAndOperator = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicationRuleAndOperator");
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("Prefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
      const nodes = se_TagSet(input.Tags, context);
      nodes.map((node) => {
        node = node.withName("Tag");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_ReplicationRuleFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicationRuleFilter");
    models_0_1.ReplicationRuleFilter.visit(input, {
      Prefix: (value) => {
        const node = xml_builder_1.XmlNode.of("Prefix", value).withName("Prefix");
        bodyNode.addChildNode(node);
      },
      Tag: (value) => {
        const node = se_Tag(value, context).withName("Tag");
        bodyNode.addChildNode(node);
      },
      And: (value) => {
        const node = se_ReplicationRuleAndOperator(value, context).withName("And");
        bodyNode.addChildNode(node);
      },
      _: (name, value) => {
        if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
          throw new Error("Unable to serialize unknown union members in XML.");
        }
        bodyNode.addChildNode(new xml_builder_1.XmlNode(name).addChildNode(value));
      }
    });
    return bodyNode;
  };
  var se_ReplicationRules = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_ReplicationRule(entry, context);
      return node.withName("member");
    });
  };
  var se_ReplicationTime = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicationTime");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("ReplicationTimeStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    if (input.Time != null) {
      const node = se_ReplicationTimeValue(input.Time, context).withName("Time");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ReplicationTimeValue = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ReplicationTimeValue");
    if (input.Minutes != null) {
      const node = xml_builder_1.XmlNode.of("Minutes", String(input.Minutes)).withName("Minutes");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_RequestPaymentConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("RequestPaymentConfiguration");
    if (input.Payer != null) {
      const node = xml_builder_1.XmlNode.of("Payer", input.Payer).withName("Payer");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_RequestProgress = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("RequestProgress");
    if (input.Enabled != null) {
      const node = xml_builder_1.XmlNode.of("EnableRequestProgress", String(input.Enabled)).withName("Enabled");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_RestoreRequest = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("RestoreRequest");
    if (input.Days != null) {
      const node = xml_builder_1.XmlNode.of("Days", String(input.Days)).withName("Days");
      bodyNode.addChildNode(node);
    }
    if (input.GlacierJobParameters != null) {
      const node = se_GlacierJobParameters(input.GlacierJobParameters, context).withName("GlacierJobParameters");
      bodyNode.addChildNode(node);
    }
    if (input.Type != null) {
      const node = xml_builder_1.XmlNode.of("RestoreRequestType", input.Type).withName("Type");
      bodyNode.addChildNode(node);
    }
    if (input.Tier != null) {
      const node = xml_builder_1.XmlNode.of("Tier", input.Tier).withName("Tier");
      bodyNode.addChildNode(node);
    }
    if (input.Description != null) {
      const node = xml_builder_1.XmlNode.of("Description", input.Description).withName("Description");
      bodyNode.addChildNode(node);
    }
    if (input.SelectParameters != null) {
      const node = se_SelectParameters(input.SelectParameters, context).withName("SelectParameters");
      bodyNode.addChildNode(node);
    }
    if (input.OutputLocation != null) {
      const node = se_OutputLocation(input.OutputLocation, context).withName("OutputLocation");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_RoutingRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("RoutingRule");
    if (input.Condition != null) {
      const node = se_Condition(input.Condition, context).withName("Condition");
      bodyNode.addChildNode(node);
    }
    if (input.Redirect != null) {
      const node = se_Redirect(input.Redirect, context).withName("Redirect");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_RoutingRules = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_RoutingRule(entry, context);
      return node.withName("RoutingRule");
    });
  };
  var se_S3KeyFilter = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("S3KeyFilter");
    if (input.FilterRules != null) {
      const nodes = se_FilterRuleList(input.FilterRules, context);
      nodes.map((node) => {
        node = node.withName("FilterRule");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_S3Location = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("S3Location");
    if (input.BucketName != null) {
      const node = xml_builder_1.XmlNode.of("BucketName", input.BucketName).withName("BucketName");
      bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
      const node = xml_builder_1.XmlNode.of("LocationPrefix", input.Prefix).withName("Prefix");
      bodyNode.addChildNode(node);
    }
    if (input.Encryption != null) {
      const node = se_Encryption(input.Encryption, context).withName("Encryption");
      bodyNode.addChildNode(node);
    }
    if (input.CannedACL != null) {
      const node = xml_builder_1.XmlNode.of("ObjectCannedACL", input.CannedACL).withName("CannedACL");
      bodyNode.addChildNode(node);
    }
    if (input.AccessControlList != null) {
      const nodes = se_Grants(input.AccessControlList, context);
      const containerNode = new xml_builder_1.XmlNode("AccessControlList");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    if (input.Tagging != null) {
      const node = se_Tagging(input.Tagging, context).withName("Tagging");
      bodyNode.addChildNode(node);
    }
    if (input.UserMetadata != null) {
      const nodes = se_UserMetadata(input.UserMetadata, context);
      const containerNode = new xml_builder_1.XmlNode("UserMetadata");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    if (input.StorageClass != null) {
      const node = xml_builder_1.XmlNode.of("StorageClass", input.StorageClass).withName("StorageClass");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ScanRange = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ScanRange");
    if (input.Start != null) {
      const node = xml_builder_1.XmlNode.of("Start", String(input.Start)).withName("Start");
      bodyNode.addChildNode(node);
    }
    if (input.End != null) {
      const node = xml_builder_1.XmlNode.of("End", String(input.End)).withName("End");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_SelectParameters = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("SelectParameters");
    if (input.InputSerialization != null) {
      const node = se_InputSerialization(input.InputSerialization, context).withName("InputSerialization");
      bodyNode.addChildNode(node);
    }
    if (input.ExpressionType != null) {
      const node = xml_builder_1.XmlNode.of("ExpressionType", input.ExpressionType).withName("ExpressionType");
      bodyNode.addChildNode(node);
    }
    if (input.Expression != null) {
      const node = xml_builder_1.XmlNode.of("Expression", input.Expression).withName("Expression");
      bodyNode.addChildNode(node);
    }
    if (input.OutputSerialization != null) {
      const node = se_OutputSerialization(input.OutputSerialization, context).withName("OutputSerialization");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ServerSideEncryptionByDefault = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ServerSideEncryptionByDefault");
    if (input.SSEAlgorithm != null) {
      const node = xml_builder_1.XmlNode.of("ServerSideEncryption", input.SSEAlgorithm).withName("SSEAlgorithm");
      bodyNode.addChildNode(node);
    }
    if (input.KMSMasterKeyID != null) {
      const node = xml_builder_1.XmlNode.of("SSEKMSKeyId", input.KMSMasterKeyID).withName("KMSMasterKeyID");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ServerSideEncryptionConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ServerSideEncryptionConfiguration");
    if (input.Rules != null) {
      const nodes = se_ServerSideEncryptionRules(input.Rules, context);
      nodes.map((node) => {
        node = node.withName("Rule");
        bodyNode.addChildNode(node);
      });
    }
    return bodyNode;
  };
  var se_ServerSideEncryptionRule = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ServerSideEncryptionRule");
    if (input.ApplyServerSideEncryptionByDefault != null) {
      const node = se_ServerSideEncryptionByDefault(input.ApplyServerSideEncryptionByDefault, context).withName("ApplyServerSideEncryptionByDefault");
      bodyNode.addChildNode(node);
    }
    if (input.BucketKeyEnabled != null) {
      const node = xml_builder_1.XmlNode.of("BucketKeyEnabled", String(input.BucketKeyEnabled)).withName("BucketKeyEnabled");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_ServerSideEncryptionRules = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_ServerSideEncryptionRule(entry, context);
      return node.withName("member");
    });
  };
  var se_SourceSelectionCriteria = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("SourceSelectionCriteria");
    if (input.SseKmsEncryptedObjects != null) {
      const node = se_SseKmsEncryptedObjects(input.SseKmsEncryptedObjects, context).withName("SseKmsEncryptedObjects");
      bodyNode.addChildNode(node);
    }
    if (input.ReplicaModifications != null) {
      const node = se_ReplicaModifications(input.ReplicaModifications, context).withName("ReplicaModifications");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_SSEKMS = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("SSE-KMS");
    if (input.KeyId != null) {
      const node = xml_builder_1.XmlNode.of("SSEKMSKeyId", input.KeyId).withName("KeyId");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_SseKmsEncryptedObjects = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("SseKmsEncryptedObjects");
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("SseKmsEncryptedObjectsStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_SSES3 = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("SSE-S3");
    return bodyNode;
  };
  var se_StorageClassAnalysis = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StorageClassAnalysis");
    if (input.DataExport != null) {
      const node = se_StorageClassAnalysisDataExport(input.DataExport, context).withName("DataExport");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_StorageClassAnalysisDataExport = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StorageClassAnalysisDataExport");
    if (input.OutputSchemaVersion != null) {
      const node = xml_builder_1.XmlNode.of("StorageClassAnalysisSchemaVersion", input.OutputSchemaVersion).withName("OutputSchemaVersion");
      bodyNode.addChildNode(node);
    }
    if (input.Destination != null) {
      const node = se_AnalyticsExportDestination(input.Destination, context).withName("Destination");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Tag = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Tag");
    if (input.Key != null) {
      const node = xml_builder_1.XmlNode.of("ObjectKey", input.Key).withName("Key");
      bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
      const node = xml_builder_1.XmlNode.of("Value", input.Value).withName("Value");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_Tagging = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Tagging");
    if (input.TagSet != null) {
      const nodes = se_TagSet(input.TagSet, context);
      const containerNode = new xml_builder_1.XmlNode("TagSet");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
  };
  var se_TagSet = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_Tag(entry, context);
      return node.withName("Tag");
    });
  };
  var se_TargetGrant = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("TargetGrant");
    if (input.Grantee != null) {
      const node = se_Grantee(input.Grantee, context).withName("Grantee");
      node.addAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
      bodyNode.addChildNode(node);
    }
    if (input.Permission != null) {
      const node = xml_builder_1.XmlNode.of("BucketLogsPermission", input.Permission).withName("Permission");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_TargetGrants = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_TargetGrant(entry, context);
      return node.withName("Grant");
    });
  };
  var se_Tiering = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Tiering");
    if (input.Days != null) {
      const node = xml_builder_1.XmlNode.of("IntelligentTieringDays", String(input.Days)).withName("Days");
      bodyNode.addChildNode(node);
    }
    if (input.AccessTier != null) {
      const node = xml_builder_1.XmlNode.of("IntelligentTieringAccessTier", input.AccessTier).withName("AccessTier");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_TieringList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_Tiering(entry, context);
      return node.withName("member");
    });
  };
  var se_TopicConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("TopicConfiguration");
    if (input.Id != null) {
      const node = xml_builder_1.XmlNode.of("NotificationId", input.Id).withName("Id");
      bodyNode.addChildNode(node);
    }
    if (input.TopicArn != null) {
      const node = xml_builder_1.XmlNode.of("TopicArn", input.TopicArn).withName("Topic");
      bodyNode.addChildNode(node);
    }
    if (input.Events != null) {
      const nodes = se_EventList(input.Events, context);
      nodes.map((node) => {
        node = node.withName("Event");
        bodyNode.addChildNode(node);
      });
    }
    if (input.Filter != null) {
      const node = se_NotificationConfigurationFilter(input.Filter, context).withName("Filter");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_TopicConfigurationList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_TopicConfiguration(entry, context);
      return node.withName("member");
    });
  };
  var se_Transition = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Transition");
    if (input.Date != null) {
      const node = xml_builder_1.XmlNode.of("Date", (input.Date.toISOString().split(".")[0] + "Z").toString()).withName("Date");
      bodyNode.addChildNode(node);
    }
    if (input.Days != null) {
      const node = xml_builder_1.XmlNode.of("Days", String(input.Days)).withName("Days");
      bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
      const node = xml_builder_1.XmlNode.of("TransitionStorageClass", input.StorageClass).withName("StorageClass");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_TransitionList = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_Transition(entry, context);
      return node.withName("member");
    });
  };
  var se_UserMetadata = (input, context) => {
    return input.filter((e) => e != null).map((entry) => {
      const node = se_MetadataEntry(entry, context);
      return node.withName("MetadataEntry");
    });
  };
  var se_VersioningConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("VersioningConfiguration");
    if (input.MFADelete != null) {
      const node = xml_builder_1.XmlNode.of("MFADelete", input.MFADelete).withName("MfaDelete");
      bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
      const node = xml_builder_1.XmlNode.of("BucketVersioningStatus", input.Status).withName("Status");
      bodyNode.addChildNode(node);
    }
    return bodyNode;
  };
  var se_WebsiteConfiguration = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("WebsiteConfiguration");
    if (input.ErrorDocument != null) {
      const node = se_ErrorDocument(input.ErrorDocument, context).withName("ErrorDocument");
      bodyNode.addChildNode(node);
    }
    if (input.IndexDocument != null) {
      const node = se_IndexDocument(input.IndexDocument, context).withName("IndexDocument");
      bodyNode.addChildNode(node);
    }
    if (input.RedirectAllRequestsTo != null) {
      const node = se_RedirectAllRequestsTo(input.RedirectAllRequestsTo, context).withName("RedirectAllRequestsTo");
      bodyNode.addChildNode(node);
    }
    if (input.RoutingRules != null) {
      const nodes = se_RoutingRules(input.RoutingRules, context);
      const containerNode = new xml_builder_1.XmlNode("RoutingRules");
      nodes.map((node) => {
        containerNode.addChildNode(node);
      });
      bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
  };
  var de_AbortIncompleteMultipartUpload = (output, context) => {
    const contents = {};
    if (output["DaysAfterInitiation"] !== undefined) {
      contents.DaysAfterInitiation = (0, smithy_client_1.strictParseInt32)(output["DaysAfterInitiation"]);
    }
    return contents;
  };
  var de_AccessControlTranslation = (output, context) => {
    const contents = {};
    if (output["Owner"] !== undefined) {
      contents.Owner = (0, smithy_client_1.expectString)(output["Owner"]);
    }
    return contents;
  };
  var de_AllowedHeaders = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_AllowedMethods = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_AllowedOrigins = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_AnalyticsAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Tag === "") {
      contents.Tags = [];
    } else if (output["Tag"] !== undefined) {
      contents.Tags = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output["Tag"]), context);
    }
    return contents;
  };
  var de_AnalyticsConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output.Filter === "") {
    } else if (output["Filter"] !== undefined) {
      contents.Filter = de_AnalyticsFilter((0, smithy_client_1.expectUnion)(output["Filter"]), context);
    }
    if (output["StorageClassAnalysis"] !== undefined) {
      contents.StorageClassAnalysis = de_StorageClassAnalysis(output["StorageClassAnalysis"], context);
    }
    return contents;
  };
  var de_AnalyticsConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_AnalyticsConfiguration(entry, context);
    });
  };
  var de_AnalyticsExportDestination = (output, context) => {
    const contents = {};
    if (output["S3BucketDestination"] !== undefined) {
      contents.S3BucketDestination = de_AnalyticsS3BucketDestination(output["S3BucketDestination"], context);
    }
    return contents;
  };
  var de_AnalyticsFilter = (output, context) => {
    if (output["Prefix"] !== undefined) {
      return {
        Prefix: (0, smithy_client_1.expectString)(output["Prefix"])
      };
    }
    if (output["Tag"] !== undefined) {
      return {
        Tag: de_Tag(output["Tag"], context)
      };
    }
    if (output["And"] !== undefined) {
      return {
        And: de_AnalyticsAndOperator(output["And"], context)
      };
    }
    return { $unknown: Object.entries(output)[0] };
  };
  var de_AnalyticsS3BucketDestination = (output, context) => {
    const contents = {};
    if (output["Format"] !== undefined) {
      contents.Format = (0, smithy_client_1.expectString)(output["Format"]);
    }
    if (output["BucketAccountId"] !== undefined) {
      contents.BucketAccountId = (0, smithy_client_1.expectString)(output["BucketAccountId"]);
    }
    if (output["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(output["Bucket"]);
    }
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    return contents;
  };
  var de_Bucket = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
      contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["CreationDate"] !== undefined) {
      contents.CreationDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreationDate"]));
    }
    return contents;
  };
  var de_Buckets = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_Bucket(entry, context);
    });
  };
  var de_Checksum = (output, context) => {
    const contents = {};
    if (output["ChecksumCRC32"] !== undefined) {
      contents.ChecksumCRC32 = (0, smithy_client_1.expectString)(output["ChecksumCRC32"]);
    }
    if (output["ChecksumCRC32C"] !== undefined) {
      contents.ChecksumCRC32C = (0, smithy_client_1.expectString)(output["ChecksumCRC32C"]);
    }
    if (output["ChecksumSHA1"] !== undefined) {
      contents.ChecksumSHA1 = (0, smithy_client_1.expectString)(output["ChecksumSHA1"]);
    }
    if (output["ChecksumSHA256"] !== undefined) {
      contents.ChecksumSHA256 = (0, smithy_client_1.expectString)(output["ChecksumSHA256"]);
    }
    return contents;
  };
  var de_ChecksumAlgorithmList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_CommonPrefix = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    return contents;
  };
  var de_CommonPrefixList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_CommonPrefix(entry, context);
    });
  };
  var de_Condition = (output, context) => {
    const contents = {};
    if (output["HttpErrorCodeReturnedEquals"] !== undefined) {
      contents.HttpErrorCodeReturnedEquals = (0, smithy_client_1.expectString)(output["HttpErrorCodeReturnedEquals"]);
    }
    if (output["KeyPrefixEquals"] !== undefined) {
      contents.KeyPrefixEquals = (0, smithy_client_1.expectString)(output["KeyPrefixEquals"]);
    }
    return contents;
  };
  var de_ContinuationEvent = (output, context) => {
    const contents = {};
    return contents;
  };
  var de_CopyObjectResult = (output, context) => {
    const contents = {};
    if (output["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(output["ETag"]);
    }
    if (output["LastModified"] !== undefined) {
      contents.LastModified = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastModified"]));
    }
    if (output["ChecksumCRC32"] !== undefined) {
      contents.ChecksumCRC32 = (0, smithy_client_1.expectString)(output["ChecksumCRC32"]);
    }
    if (output["ChecksumCRC32C"] !== undefined) {
      contents.ChecksumCRC32C = (0, smithy_client_1.expectString)(output["ChecksumCRC32C"]);
    }
    if (output["ChecksumSHA1"] !== undefined) {
      contents.ChecksumSHA1 = (0, smithy_client_1.expectString)(output["ChecksumSHA1"]);
    }
    if (output["ChecksumSHA256"] !== undefined) {
      contents.ChecksumSHA256 = (0, smithy_client_1.expectString)(output["ChecksumSHA256"]);
    }
    return contents;
  };
  var de_CopyPartResult = (output, context) => {
    const contents = {};
    if (output["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(output["ETag"]);
    }
    if (output["LastModified"] !== undefined) {
      contents.LastModified = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastModified"]));
    }
    if (output["ChecksumCRC32"] !== undefined) {
      contents.ChecksumCRC32 = (0, smithy_client_1.expectString)(output["ChecksumCRC32"]);
    }
    if (output["ChecksumCRC32C"] !== undefined) {
      contents.ChecksumCRC32C = (0, smithy_client_1.expectString)(output["ChecksumCRC32C"]);
    }
    if (output["ChecksumSHA1"] !== undefined) {
      contents.ChecksumSHA1 = (0, smithy_client_1.expectString)(output["ChecksumSHA1"]);
    }
    if (output["ChecksumSHA256"] !== undefined) {
      contents.ChecksumSHA256 = (0, smithy_client_1.expectString)(output["ChecksumSHA256"]);
    }
    return contents;
  };
  var de_CORSRule = (output, context) => {
    const contents = {};
    if (output["ID"] !== undefined) {
      contents.ID = (0, smithy_client_1.expectString)(output["ID"]);
    }
    if (output.AllowedHeader === "") {
      contents.AllowedHeaders = [];
    } else if (output["AllowedHeader"] !== undefined) {
      contents.AllowedHeaders = de_AllowedHeaders((0, smithy_client_1.getArrayIfSingleItem)(output["AllowedHeader"]), context);
    }
    if (output.AllowedMethod === "") {
      contents.AllowedMethods = [];
    } else if (output["AllowedMethod"] !== undefined) {
      contents.AllowedMethods = de_AllowedMethods((0, smithy_client_1.getArrayIfSingleItem)(output["AllowedMethod"]), context);
    }
    if (output.AllowedOrigin === "") {
      contents.AllowedOrigins = [];
    } else if (output["AllowedOrigin"] !== undefined) {
      contents.AllowedOrigins = de_AllowedOrigins((0, smithy_client_1.getArrayIfSingleItem)(output["AllowedOrigin"]), context);
    }
    if (output.ExposeHeader === "") {
      contents.ExposeHeaders = [];
    } else if (output["ExposeHeader"] !== undefined) {
      contents.ExposeHeaders = de_ExposeHeaders((0, smithy_client_1.getArrayIfSingleItem)(output["ExposeHeader"]), context);
    }
    if (output["MaxAgeSeconds"] !== undefined) {
      contents.MaxAgeSeconds = (0, smithy_client_1.strictParseInt32)(output["MaxAgeSeconds"]);
    }
    return contents;
  };
  var de_CORSRules = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_CORSRule(entry, context);
    });
  };
  var de_DefaultRetention = (output, context) => {
    const contents = {};
    if (output["Mode"] !== undefined) {
      contents.Mode = (0, smithy_client_1.expectString)(output["Mode"]);
    }
    if (output["Days"] !== undefined) {
      contents.Days = (0, smithy_client_1.strictParseInt32)(output["Days"]);
    }
    if (output["Years"] !== undefined) {
      contents.Years = (0, smithy_client_1.strictParseInt32)(output["Years"]);
    }
    return contents;
  };
  var de_DeletedObject = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["VersionId"] !== undefined) {
      contents.VersionId = (0, smithy_client_1.expectString)(output["VersionId"]);
    }
    if (output["DeleteMarker"] !== undefined) {
      contents.DeleteMarker = (0, smithy_client_1.parseBoolean)(output["DeleteMarker"]);
    }
    if (output["DeleteMarkerVersionId"] !== undefined) {
      contents.DeleteMarkerVersionId = (0, smithy_client_1.expectString)(output["DeleteMarkerVersionId"]);
    }
    return contents;
  };
  var de_DeletedObjects = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_DeletedObject(entry, context);
    });
  };
  var de_DeleteMarkerEntry = (output, context) => {
    const contents = {};
    if (output["Owner"] !== undefined) {
      contents.Owner = de_Owner(output["Owner"], context);
    }
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["VersionId"] !== undefined) {
      contents.VersionId = (0, smithy_client_1.expectString)(output["VersionId"]);
    }
    if (output["IsLatest"] !== undefined) {
      contents.IsLatest = (0, smithy_client_1.parseBoolean)(output["IsLatest"]);
    }
    if (output["LastModified"] !== undefined) {
      contents.LastModified = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastModified"]));
    }
    return contents;
  };
  var de_DeleteMarkerReplication = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
  };
  var de_DeleteMarkers = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_DeleteMarkerEntry(entry, context);
    });
  };
  var de_Destination = (output, context) => {
    const contents = {};
    if (output["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(output["Bucket"]);
    }
    if (output["Account"] !== undefined) {
      contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    if (output["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(output["StorageClass"]);
    }
    if (output["AccessControlTranslation"] !== undefined) {
      contents.AccessControlTranslation = de_AccessControlTranslation(output["AccessControlTranslation"], context);
    }
    if (output["EncryptionConfiguration"] !== undefined) {
      contents.EncryptionConfiguration = de_EncryptionConfiguration(output["EncryptionConfiguration"], context);
    }
    if (output["ReplicationTime"] !== undefined) {
      contents.ReplicationTime = de_ReplicationTime(output["ReplicationTime"], context);
    }
    if (output["Metrics"] !== undefined) {
      contents.Metrics = de_Metrics(output["Metrics"], context);
    }
    return contents;
  };
  var de_EncryptionConfiguration = (output, context) => {
    const contents = {};
    if (output["ReplicaKmsKeyID"] !== undefined) {
      contents.ReplicaKmsKeyID = (0, smithy_client_1.expectString)(output["ReplicaKmsKeyID"]);
    }
    return contents;
  };
  var de_EndEvent = (output, context) => {
    const contents = {};
    return contents;
  };
  var de__Error = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["VersionId"] !== undefined) {
      contents.VersionId = (0, smithy_client_1.expectString)(output["VersionId"]);
    }
    if (output["Code"] !== undefined) {
      contents.Code = (0, smithy_client_1.expectString)(output["Code"]);
    }
    if (output["Message"] !== undefined) {
      contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
  };
  var de_ErrorDocument = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    return contents;
  };
  var de_Errors = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de__Error(entry, context);
    });
  };
  var de_EventBridgeConfiguration = (output, context) => {
    const contents = {};
    return contents;
  };
  var de_EventList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_ExistingObjectReplication = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
  };
  var de_ExposeHeaders = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_FilterRule = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
      contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["Value"] !== undefined) {
      contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
  };
  var de_FilterRuleList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_FilterRule(entry, context);
    });
  };
  var de_GetObjectAttributesParts = (output, context) => {
    const contents = {};
    if (output["PartsCount"] !== undefined) {
      contents.TotalPartsCount = (0, smithy_client_1.strictParseInt32)(output["PartsCount"]);
    }
    if (output["PartNumberMarker"] !== undefined) {
      contents.PartNumberMarker = (0, smithy_client_1.expectString)(output["PartNumberMarker"]);
    }
    if (output["NextPartNumberMarker"] !== undefined) {
      contents.NextPartNumberMarker = (0, smithy_client_1.expectString)(output["NextPartNumberMarker"]);
    }
    if (output["MaxParts"] !== undefined) {
      contents.MaxParts = (0, smithy_client_1.strictParseInt32)(output["MaxParts"]);
    }
    if (output["IsTruncated"] !== undefined) {
      contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output.Part === "") {
      contents.Parts = [];
    } else if (output["Part"] !== undefined) {
      contents.Parts = de_PartsList((0, smithy_client_1.getArrayIfSingleItem)(output["Part"]), context);
    }
    return contents;
  };
  var de_Grant = (output, context) => {
    const contents = {};
    if (output["Grantee"] !== undefined) {
      contents.Grantee = de_Grantee(output["Grantee"], context);
    }
    if (output["Permission"] !== undefined) {
      contents.Permission = (0, smithy_client_1.expectString)(output["Permission"]);
    }
    return contents;
  };
  var de_Grantee = (output, context) => {
    const contents = {};
    if (output["DisplayName"] !== undefined) {
      contents.DisplayName = (0, smithy_client_1.expectString)(output["DisplayName"]);
    }
    if (output["EmailAddress"] !== undefined) {
      contents.EmailAddress = (0, smithy_client_1.expectString)(output["EmailAddress"]);
    }
    if (output["ID"] !== undefined) {
      contents.ID = (0, smithy_client_1.expectString)(output["ID"]);
    }
    if (output["URI"] !== undefined) {
      contents.URI = (0, smithy_client_1.expectString)(output["URI"]);
    }
    if (output["xsi:type"] !== undefined) {
      contents.Type = (0, smithy_client_1.expectString)(output["xsi:type"]);
    }
    return contents;
  };
  var de_Grants = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_Grant(entry, context);
    });
  };
  var de_IndexDocument = (output, context) => {
    const contents = {};
    if (output["Suffix"] !== undefined) {
      contents.Suffix = (0, smithy_client_1.expectString)(output["Suffix"]);
    }
    return contents;
  };
  var de_Initiator = (output, context) => {
    const contents = {};
    if (output["ID"] !== undefined) {
      contents.ID = (0, smithy_client_1.expectString)(output["ID"]);
    }
    if (output["DisplayName"] !== undefined) {
      contents.DisplayName = (0, smithy_client_1.expectString)(output["DisplayName"]);
    }
    return contents;
  };
  var de_IntelligentTieringAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Tag === "") {
      contents.Tags = [];
    } else if (output["Tag"] !== undefined) {
      contents.Tags = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output["Tag"]), context);
    }
    return contents;
  };
  var de_IntelligentTieringConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Filter"] !== undefined) {
      contents.Filter = de_IntelligentTieringFilter(output["Filter"], context);
    }
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output.Tiering === "") {
      contents.Tierings = [];
    } else if (output["Tiering"] !== undefined) {
      contents.Tierings = de_TieringList((0, smithy_client_1.getArrayIfSingleItem)(output["Tiering"]), context);
    }
    return contents;
  };
  var de_IntelligentTieringConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_IntelligentTieringConfiguration(entry, context);
    });
  };
  var de_IntelligentTieringFilter = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output["Tag"] !== undefined) {
      contents.Tag = de_Tag(output["Tag"], context);
    }
    if (output["And"] !== undefined) {
      contents.And = de_IntelligentTieringAndOperator(output["And"], context);
    }
    return contents;
  };
  var de_InventoryConfiguration = (output, context) => {
    const contents = {};
    if (output["Destination"] !== undefined) {
      contents.Destination = de_InventoryDestination(output["Destination"], context);
    }
    if (output["IsEnabled"] !== undefined) {
      contents.IsEnabled = (0, smithy_client_1.parseBoolean)(output["IsEnabled"]);
    }
    if (output["Filter"] !== undefined) {
      contents.Filter = de_InventoryFilter(output["Filter"], context);
    }
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["IncludedObjectVersions"] !== undefined) {
      contents.IncludedObjectVersions = (0, smithy_client_1.expectString)(output["IncludedObjectVersions"]);
    }
    if (output.OptionalFields === "") {
      contents.OptionalFields = [];
    } else if (output["OptionalFields"] !== undefined && output["OptionalFields"]["Field"] !== undefined) {
      contents.OptionalFields = de_InventoryOptionalFields((0, smithy_client_1.getArrayIfSingleItem)(output["OptionalFields"]["Field"]), context);
    }
    if (output["Schedule"] !== undefined) {
      contents.Schedule = de_InventorySchedule(output["Schedule"], context);
    }
    return contents;
  };
  var de_InventoryConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_InventoryConfiguration(entry, context);
    });
  };
  var de_InventoryDestination = (output, context) => {
    const contents = {};
    if (output["S3BucketDestination"] !== undefined) {
      contents.S3BucketDestination = de_InventoryS3BucketDestination(output["S3BucketDestination"], context);
    }
    return contents;
  };
  var de_InventoryEncryption = (output, context) => {
    const contents = {};
    if (output["SSE-S3"] !== undefined) {
      contents.SSES3 = de_SSES3(output["SSE-S3"], context);
    }
    if (output["SSE-KMS"] !== undefined) {
      contents.SSEKMS = de_SSEKMS(output["SSE-KMS"], context);
    }
    return contents;
  };
  var de_InventoryFilter = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    return contents;
  };
  var de_InventoryOptionalFields = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return (0, smithy_client_1.expectString)(entry);
    });
  };
  var de_InventoryS3BucketDestination = (output, context) => {
    const contents = {};
    if (output["AccountId"] !== undefined) {
      contents.AccountId = (0, smithy_client_1.expectString)(output["AccountId"]);
    }
    if (output["Bucket"] !== undefined) {
      contents.Bucket = (0, smithy_client_1.expectString)(output["Bucket"]);
    }
    if (output["Format"] !== undefined) {
      contents.Format = (0, smithy_client_1.expectString)(output["Format"]);
    }
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output["Encryption"] !== undefined) {
      contents.Encryption = de_InventoryEncryption(output["Encryption"], context);
    }
    return contents;
  };
  var de_InventorySchedule = (output, context) => {
    const contents = {};
    if (output["Frequency"] !== undefined) {
      contents.Frequency = (0, smithy_client_1.expectString)(output["Frequency"]);
    }
    return contents;
  };
  var de_LambdaFunctionConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["CloudFunction"] !== undefined) {
      contents.LambdaFunctionArn = (0, smithy_client_1.expectString)(output["CloudFunction"]);
    }
    if (output.Event === "") {
      contents.Events = [];
    } else if (output["Event"] !== undefined) {
      contents.Events = de_EventList((0, smithy_client_1.getArrayIfSingleItem)(output["Event"]), context);
    }
    if (output["Filter"] !== undefined) {
      contents.Filter = de_NotificationConfigurationFilter(output["Filter"], context);
    }
    return contents;
  };
  var de_LambdaFunctionConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_LambdaFunctionConfiguration(entry, context);
    });
  };
  var de_LifecycleExpiration = (output, context) => {
    const contents = {};
    if (output["Date"] !== undefined) {
      contents.Date = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Date"]));
    }
    if (output["Days"] !== undefined) {
      contents.Days = (0, smithy_client_1.strictParseInt32)(output["Days"]);
    }
    if (output["ExpiredObjectDeleteMarker"] !== undefined) {
      contents.ExpiredObjectDeleteMarker = (0, smithy_client_1.parseBoolean)(output["ExpiredObjectDeleteMarker"]);
    }
    return contents;
  };
  var de_LifecycleRule = (output, context) => {
    const contents = {};
    if (output["Expiration"] !== undefined) {
      contents.Expiration = de_LifecycleExpiration(output["Expiration"], context);
    }
    if (output["ID"] !== undefined) {
      contents.ID = (0, smithy_client_1.expectString)(output["ID"]);
    }
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Filter === "") {
    } else if (output["Filter"] !== undefined) {
      contents.Filter = de_LifecycleRuleFilter((0, smithy_client_1.expectUnion)(output["Filter"]), context);
    }
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output.Transition === "") {
      contents.Transitions = [];
    } else if (output["Transition"] !== undefined) {
      contents.Transitions = de_TransitionList((0, smithy_client_1.getArrayIfSingleItem)(output["Transition"]), context);
    }
    if (output.NoncurrentVersionTransition === "") {
      contents.NoncurrentVersionTransitions = [];
    } else if (output["NoncurrentVersionTransition"] !== undefined) {
      contents.NoncurrentVersionTransitions = de_NoncurrentVersionTransitionList((0, smithy_client_1.getArrayIfSingleItem)(output["NoncurrentVersionTransition"]), context);
    }
    if (output["NoncurrentVersionExpiration"] !== undefined) {
      contents.NoncurrentVersionExpiration = de_NoncurrentVersionExpiration(output["NoncurrentVersionExpiration"], context);
    }
    if (output["AbortIncompleteMultipartUpload"] !== undefined) {
      contents.AbortIncompleteMultipartUpload = de_AbortIncompleteMultipartUpload(output["AbortIncompleteMultipartUpload"], context);
    }
    return contents;
  };
  var de_LifecycleRuleAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Tag === "") {
      contents.Tags = [];
    } else if (output["Tag"] !== undefined) {
      contents.Tags = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output["Tag"]), context);
    }
    if (output["ObjectSizeGreaterThan"] !== undefined) {
      contents.ObjectSizeGreaterThan = (0, smithy_client_1.strictParseLong)(output["ObjectSizeGreaterThan"]);
    }
    if (output["ObjectSizeLessThan"] !== undefined) {
      contents.ObjectSizeLessThan = (0, smithy_client_1.strictParseLong)(output["ObjectSizeLessThan"]);
    }
    return contents;
  };
  var de_LifecycleRuleFilter = (output, context) => {
    if (output["Prefix"] !== undefined) {
      return {
        Prefix: (0, smithy_client_1.expectString)(output["Prefix"])
      };
    }
    if (output["Tag"] !== undefined) {
      return {
        Tag: de_Tag(output["Tag"], context)
      };
    }
    if (output["ObjectSizeGreaterThan"] !== undefined) {
      return {
        ObjectSizeGreaterThan: (0, smithy_client_1.strictParseLong)(output["ObjectSizeGreaterThan"])
      };
    }
    if (output["ObjectSizeLessThan"] !== undefined) {
      return {
        ObjectSizeLessThan: (0, smithy_client_1.strictParseLong)(output["ObjectSizeLessThan"])
      };
    }
    if (output["And"] !== undefined) {
      return {
        And: de_LifecycleRuleAndOperator(output["And"], context)
      };
    }
    return { $unknown: Object.entries(output)[0] };
  };
  var de_LifecycleRules = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_LifecycleRule(entry, context);
    });
  };
  var de_LoggingEnabled = (output, context) => {
    const contents = {};
    if (output["TargetBucket"] !== undefined) {
      contents.TargetBucket = (0, smithy_client_1.expectString)(output["TargetBucket"]);
    }
    if (output.TargetGrants === "") {
      contents.TargetGrants = [];
    } else if (output["TargetGrants"] !== undefined && output["TargetGrants"]["Grant"] !== undefined) {
      contents.TargetGrants = de_TargetGrants((0, smithy_client_1.getArrayIfSingleItem)(output["TargetGrants"]["Grant"]), context);
    }
    if (output["TargetPrefix"] !== undefined) {
      contents.TargetPrefix = (0, smithy_client_1.expectString)(output["TargetPrefix"]);
    }
    return contents;
  };
  var de_Metrics = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["EventThreshold"] !== undefined) {
      contents.EventThreshold = de_ReplicationTimeValue(output["EventThreshold"], context);
    }
    return contents;
  };
  var de_MetricsAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Tag === "") {
      contents.Tags = [];
    } else if (output["Tag"] !== undefined) {
      contents.Tags = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output["Tag"]), context);
    }
    if (output["AccessPointArn"] !== undefined) {
      contents.AccessPointArn = (0, smithy_client_1.expectString)(output["AccessPointArn"]);
    }
    return contents;
  };
  var de_MetricsConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output.Filter === "") {
    } else if (output["Filter"] !== undefined) {
      contents.Filter = de_MetricsFilter((0, smithy_client_1.expectUnion)(output["Filter"]), context);
    }
    return contents;
  };
  var de_MetricsConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_MetricsConfiguration(entry, context);
    });
  };
  var de_MetricsFilter = (output, context) => {
    if (output["Prefix"] !== undefined) {
      return {
        Prefix: (0, smithy_client_1.expectString)(output["Prefix"])
      };
    }
    if (output["Tag"] !== undefined) {
      return {
        Tag: de_Tag(output["Tag"], context)
      };
    }
    if (output["AccessPointArn"] !== undefined) {
      return {
        AccessPointArn: (0, smithy_client_1.expectString)(output["AccessPointArn"])
      };
    }
    if (output["And"] !== undefined) {
      return {
        And: de_MetricsAndOperator(output["And"], context)
      };
    }
    return { $unknown: Object.entries(output)[0] };
  };
  var de_MultipartUpload = (output, context) => {
    const contents = {};
    if (output["UploadId"] !== undefined) {
      contents.UploadId = (0, smithy_client_1.expectString)(output["UploadId"]);
    }
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Initiated"] !== undefined) {
      contents.Initiated = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Initiated"]));
    }
    if (output["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(output["StorageClass"]);
    }
    if (output["Owner"] !== undefined) {
      contents.Owner = de_Owner(output["Owner"], context);
    }
    if (output["Initiator"] !== undefined) {
      contents.Initiator = de_Initiator(output["Initiator"], context);
    }
    if (output["ChecksumAlgorithm"] !== undefined) {
      contents.ChecksumAlgorithm = (0, smithy_client_1.expectString)(output["ChecksumAlgorithm"]);
    }
    return contents;
  };
  var de_MultipartUploadList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_MultipartUpload(entry, context);
    });
  };
  var de_NoncurrentVersionExpiration = (output, context) => {
    const contents = {};
    if (output["NoncurrentDays"] !== undefined) {
      contents.NoncurrentDays = (0, smithy_client_1.strictParseInt32)(output["NoncurrentDays"]);
    }
    if (output["NewerNoncurrentVersions"] !== undefined) {
      contents.NewerNoncurrentVersions = (0, smithy_client_1.strictParseInt32)(output["NewerNoncurrentVersions"]);
    }
    return contents;
  };
  var de_NoncurrentVersionTransition = (output, context) => {
    const contents = {};
    if (output["NoncurrentDays"] !== undefined) {
      contents.NoncurrentDays = (0, smithy_client_1.strictParseInt32)(output["NoncurrentDays"]);
    }
    if (output["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(output["StorageClass"]);
    }
    if (output["NewerNoncurrentVersions"] !== undefined) {
      contents.NewerNoncurrentVersions = (0, smithy_client_1.strictParseInt32)(output["NewerNoncurrentVersions"]);
    }
    return contents;
  };
  var de_NoncurrentVersionTransitionList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_NoncurrentVersionTransition(entry, context);
    });
  };
  var de_NotificationConfigurationFilter = (output, context) => {
    const contents = {};
    if (output["S3Key"] !== undefined) {
      contents.Key = de_S3KeyFilter(output["S3Key"], context);
    }
    return contents;
  };
  var de__Object = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["LastModified"] !== undefined) {
      contents.LastModified = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastModified"]));
    }
    if (output["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(output["ETag"]);
    }
    if (output.ChecksumAlgorithm === "") {
      contents.ChecksumAlgorithm = [];
    } else if (output["ChecksumAlgorithm"] !== undefined) {
      contents.ChecksumAlgorithm = de_ChecksumAlgorithmList((0, smithy_client_1.getArrayIfSingleItem)(output["ChecksumAlgorithm"]), context);
    }
    if (output["Size"] !== undefined) {
      contents.Size = (0, smithy_client_1.strictParseLong)(output["Size"]);
    }
    if (output["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(output["StorageClass"]);
    }
    if (output["Owner"] !== undefined) {
      contents.Owner = de_Owner(output["Owner"], context);
    }
    if (output["RestoreStatus"] !== undefined) {
      contents.RestoreStatus = de_RestoreStatus(output["RestoreStatus"], context);
    }
    return contents;
  };
  var de_ObjectList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de__Object(entry, context);
    });
  };
  var de_ObjectLockConfiguration = (output, context) => {
    const contents = {};
    if (output["ObjectLockEnabled"] !== undefined) {
      contents.ObjectLockEnabled = (0, smithy_client_1.expectString)(output["ObjectLockEnabled"]);
    }
    if (output["Rule"] !== undefined) {
      contents.Rule = de_ObjectLockRule(output["Rule"], context);
    }
    return contents;
  };
  var de_ObjectLockLegalHold = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
  };
  var de_ObjectLockRetention = (output, context) => {
    const contents = {};
    if (output["Mode"] !== undefined) {
      contents.Mode = (0, smithy_client_1.expectString)(output["Mode"]);
    }
    if (output["RetainUntilDate"] !== undefined) {
      contents.RetainUntilDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["RetainUntilDate"]));
    }
    return contents;
  };
  var de_ObjectLockRule = (output, context) => {
    const contents = {};
    if (output["DefaultRetention"] !== undefined) {
      contents.DefaultRetention = de_DefaultRetention(output["DefaultRetention"], context);
    }
    return contents;
  };
  var de_ObjectPart = (output, context) => {
    const contents = {};
    if (output["PartNumber"] !== undefined) {
      contents.PartNumber = (0, smithy_client_1.strictParseInt32)(output["PartNumber"]);
    }
    if (output["Size"] !== undefined) {
      contents.Size = (0, smithy_client_1.strictParseLong)(output["Size"]);
    }
    if (output["ChecksumCRC32"] !== undefined) {
      contents.ChecksumCRC32 = (0, smithy_client_1.expectString)(output["ChecksumCRC32"]);
    }
    if (output["ChecksumCRC32C"] !== undefined) {
      contents.ChecksumCRC32C = (0, smithy_client_1.expectString)(output["ChecksumCRC32C"]);
    }
    if (output["ChecksumSHA1"] !== undefined) {
      contents.ChecksumSHA1 = (0, smithy_client_1.expectString)(output["ChecksumSHA1"]);
    }
    if (output["ChecksumSHA256"] !== undefined) {
      contents.ChecksumSHA256 = (0, smithy_client_1.expectString)(output["ChecksumSHA256"]);
    }
    return contents;
  };
  var de_ObjectVersion = (output, context) => {
    const contents = {};
    if (output["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(output["ETag"]);
    }
    if (output.ChecksumAlgorithm === "") {
      contents.ChecksumAlgorithm = [];
    } else if (output["ChecksumAlgorithm"] !== undefined) {
      contents.ChecksumAlgorithm = de_ChecksumAlgorithmList((0, smithy_client_1.getArrayIfSingleItem)(output["ChecksumAlgorithm"]), context);
    }
    if (output["Size"] !== undefined) {
      contents.Size = (0, smithy_client_1.strictParseLong)(output["Size"]);
    }
    if (output["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(output["StorageClass"]);
    }
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["VersionId"] !== undefined) {
      contents.VersionId = (0, smithy_client_1.expectString)(output["VersionId"]);
    }
    if (output["IsLatest"] !== undefined) {
      contents.IsLatest = (0, smithy_client_1.parseBoolean)(output["IsLatest"]);
    }
    if (output["LastModified"] !== undefined) {
      contents.LastModified = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastModified"]));
    }
    if (output["Owner"] !== undefined) {
      contents.Owner = de_Owner(output["Owner"], context);
    }
    if (output["RestoreStatus"] !== undefined) {
      contents.RestoreStatus = de_RestoreStatus(output["RestoreStatus"], context);
    }
    return contents;
  };
  var de_ObjectVersionList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_ObjectVersion(entry, context);
    });
  };
  var de_Owner = (output, context) => {
    const contents = {};
    if (output["DisplayName"] !== undefined) {
      contents.DisplayName = (0, smithy_client_1.expectString)(output["DisplayName"]);
    }
    if (output["ID"] !== undefined) {
      contents.ID = (0, smithy_client_1.expectString)(output["ID"]);
    }
    return contents;
  };
  var de_OwnershipControls = (output, context) => {
    const contents = {};
    if (output.Rule === "") {
      contents.Rules = [];
    } else if (output["Rule"] !== undefined) {
      contents.Rules = de_OwnershipControlsRules((0, smithy_client_1.getArrayIfSingleItem)(output["Rule"]), context);
    }
    return contents;
  };
  var de_OwnershipControlsRule = (output, context) => {
    const contents = {};
    if (output["ObjectOwnership"] !== undefined) {
      contents.ObjectOwnership = (0, smithy_client_1.expectString)(output["ObjectOwnership"]);
    }
    return contents;
  };
  var de_OwnershipControlsRules = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_OwnershipControlsRule(entry, context);
    });
  };
  var de_Part = (output, context) => {
    const contents = {};
    if (output["PartNumber"] !== undefined) {
      contents.PartNumber = (0, smithy_client_1.strictParseInt32)(output["PartNumber"]);
    }
    if (output["LastModified"] !== undefined) {
      contents.LastModified = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastModified"]));
    }
    if (output["ETag"] !== undefined) {
      contents.ETag = (0, smithy_client_1.expectString)(output["ETag"]);
    }
    if (output["Size"] !== undefined) {
      contents.Size = (0, smithy_client_1.strictParseLong)(output["Size"]);
    }
    if (output["ChecksumCRC32"] !== undefined) {
      contents.ChecksumCRC32 = (0, smithy_client_1.expectString)(output["ChecksumCRC32"]);
    }
    if (output["ChecksumCRC32C"] !== undefined) {
      contents.ChecksumCRC32C = (0, smithy_client_1.expectString)(output["ChecksumCRC32C"]);
    }
    if (output["ChecksumSHA1"] !== undefined) {
      contents.ChecksumSHA1 = (0, smithy_client_1.expectString)(output["ChecksumSHA1"]);
    }
    if (output["ChecksumSHA256"] !== undefined) {
      contents.ChecksumSHA256 = (0, smithy_client_1.expectString)(output["ChecksumSHA256"]);
    }
    return contents;
  };
  var de_Parts = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_Part(entry, context);
    });
  };
  var de_PartsList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_ObjectPart(entry, context);
    });
  };
  var de_PolicyStatus = (output, context) => {
    const contents = {};
    if (output["IsPublic"] !== undefined) {
      contents.IsPublic = (0, smithy_client_1.parseBoolean)(output["IsPublic"]);
    }
    return contents;
  };
  var de_Progress = (output, context) => {
    const contents = {};
    if (output["BytesScanned"] !== undefined) {
      contents.BytesScanned = (0, smithy_client_1.strictParseLong)(output["BytesScanned"]);
    }
    if (output["BytesProcessed"] !== undefined) {
      contents.BytesProcessed = (0, smithy_client_1.strictParseLong)(output["BytesProcessed"]);
    }
    if (output["BytesReturned"] !== undefined) {
      contents.BytesReturned = (0, smithy_client_1.strictParseLong)(output["BytesReturned"]);
    }
    return contents;
  };
  var de_PublicAccessBlockConfiguration = (output, context) => {
    const contents = {};
    if (output["BlockPublicAcls"] !== undefined) {
      contents.BlockPublicAcls = (0, smithy_client_1.parseBoolean)(output["BlockPublicAcls"]);
    }
    if (output["IgnorePublicAcls"] !== undefined) {
      contents.IgnorePublicAcls = (0, smithy_client_1.parseBoolean)(output["IgnorePublicAcls"]);
    }
    if (output["BlockPublicPolicy"] !== undefined) {
      contents.BlockPublicPolicy = (0, smithy_client_1.parseBoolean)(output["BlockPublicPolicy"]);
    }
    if (output["RestrictPublicBuckets"] !== undefined) {
      contents.RestrictPublicBuckets = (0, smithy_client_1.parseBoolean)(output["RestrictPublicBuckets"]);
    }
    return contents;
  };
  var de_QueueConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Queue"] !== undefined) {
      contents.QueueArn = (0, smithy_client_1.expectString)(output["Queue"]);
    }
    if (output.Event === "") {
      contents.Events = [];
    } else if (output["Event"] !== undefined) {
      contents.Events = de_EventList((0, smithy_client_1.getArrayIfSingleItem)(output["Event"]), context);
    }
    if (output["Filter"] !== undefined) {
      contents.Filter = de_NotificationConfigurationFilter(output["Filter"], context);
    }
    return contents;
  };
  var de_QueueConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_QueueConfiguration(entry, context);
    });
  };
  var de_Redirect = (output, context) => {
    const contents = {};
    if (output["HostName"] !== undefined) {
      contents.HostName = (0, smithy_client_1.expectString)(output["HostName"]);
    }
    if (output["HttpRedirectCode"] !== undefined) {
      contents.HttpRedirectCode = (0, smithy_client_1.expectString)(output["HttpRedirectCode"]);
    }
    if (output["Protocol"] !== undefined) {
      contents.Protocol = (0, smithy_client_1.expectString)(output["Protocol"]);
    }
    if (output["ReplaceKeyPrefixWith"] !== undefined) {
      contents.ReplaceKeyPrefixWith = (0, smithy_client_1.expectString)(output["ReplaceKeyPrefixWith"]);
    }
    if (output["ReplaceKeyWith"] !== undefined) {
      contents.ReplaceKeyWith = (0, smithy_client_1.expectString)(output["ReplaceKeyWith"]);
    }
    return contents;
  };
  var de_RedirectAllRequestsTo = (output, context) => {
    const contents = {};
    if (output["HostName"] !== undefined) {
      contents.HostName = (0, smithy_client_1.expectString)(output["HostName"]);
    }
    if (output["Protocol"] !== undefined) {
      contents.Protocol = (0, smithy_client_1.expectString)(output["Protocol"]);
    }
    return contents;
  };
  var de_ReplicaModifications = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
  };
  var de_ReplicationConfiguration = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
      contents.Role = (0, smithy_client_1.expectString)(output["Role"]);
    }
    if (output.Rule === "") {
      contents.Rules = [];
    } else if (output["Rule"] !== undefined) {
      contents.Rules = de_ReplicationRules((0, smithy_client_1.getArrayIfSingleItem)(output["Rule"]), context);
    }
    return contents;
  };
  var de_ReplicationRule = (output, context) => {
    const contents = {};
    if (output["ID"] !== undefined) {
      contents.ID = (0, smithy_client_1.expectString)(output["ID"]);
    }
    if (output["Priority"] !== undefined) {
      contents.Priority = (0, smithy_client_1.strictParseInt32)(output["Priority"]);
    }
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Filter === "") {
    } else if (output["Filter"] !== undefined) {
      contents.Filter = de_ReplicationRuleFilter((0, smithy_client_1.expectUnion)(output["Filter"]), context);
    }
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["SourceSelectionCriteria"] !== undefined) {
      contents.SourceSelectionCriteria = de_SourceSelectionCriteria(output["SourceSelectionCriteria"], context);
    }
    if (output["ExistingObjectReplication"] !== undefined) {
      contents.ExistingObjectReplication = de_ExistingObjectReplication(output["ExistingObjectReplication"], context);
    }
    if (output["Destination"] !== undefined) {
      contents.Destination = de_Destination(output["Destination"], context);
    }
    if (output["DeleteMarkerReplication"] !== undefined) {
      contents.DeleteMarkerReplication = de_DeleteMarkerReplication(output["DeleteMarkerReplication"], context);
    }
    return contents;
  };
  var de_ReplicationRuleAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
      contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    if (output.Tag === "") {
      contents.Tags = [];
    } else if (output["Tag"] !== undefined) {
      contents.Tags = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output["Tag"]), context);
    }
    return contents;
  };
  var de_ReplicationRuleFilter = (output, context) => {
    if (output["Prefix"] !== undefined) {
      return {
        Prefix: (0, smithy_client_1.expectString)(output["Prefix"])
      };
    }
    if (output["Tag"] !== undefined) {
      return {
        Tag: de_Tag(output["Tag"], context)
      };
    }
    if (output["And"] !== undefined) {
      return {
        And: de_ReplicationRuleAndOperator(output["And"], context)
      };
    }
    return { $unknown: Object.entries(output)[0] };
  };
  var de_ReplicationRules = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_ReplicationRule(entry, context);
    });
  };
  var de_ReplicationTime = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["Time"] !== undefined) {
      contents.Time = de_ReplicationTimeValue(output["Time"], context);
    }
    return contents;
  };
  var de_ReplicationTimeValue = (output, context) => {
    const contents = {};
    if (output["Minutes"] !== undefined) {
      contents.Minutes = (0, smithy_client_1.strictParseInt32)(output["Minutes"]);
    }
    return contents;
  };
  var de_RestoreStatus = (output, context) => {
    const contents = {};
    if (output["IsRestoreInProgress"] !== undefined) {
      contents.IsRestoreInProgress = (0, smithy_client_1.parseBoolean)(output["IsRestoreInProgress"]);
    }
    if (output["RestoreExpiryDate"] !== undefined) {
      contents.RestoreExpiryDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["RestoreExpiryDate"]));
    }
    return contents;
  };
  var de_RoutingRule = (output, context) => {
    const contents = {};
    if (output["Condition"] !== undefined) {
      contents.Condition = de_Condition(output["Condition"], context);
    }
    if (output["Redirect"] !== undefined) {
      contents.Redirect = de_Redirect(output["Redirect"], context);
    }
    return contents;
  };
  var de_RoutingRules = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_RoutingRule(entry, context);
    });
  };
  var de_S3KeyFilter = (output, context) => {
    const contents = {};
    if (output.FilterRule === "") {
      contents.FilterRules = [];
    } else if (output["FilterRule"] !== undefined) {
      contents.FilterRules = de_FilterRuleList((0, smithy_client_1.getArrayIfSingleItem)(output["FilterRule"]), context);
    }
    return contents;
  };
  var de_ServerSideEncryptionByDefault = (output, context) => {
    const contents = {};
    if (output["SSEAlgorithm"] !== undefined) {
      contents.SSEAlgorithm = (0, smithy_client_1.expectString)(output["SSEAlgorithm"]);
    }
    if (output["KMSMasterKeyID"] !== undefined) {
      contents.KMSMasterKeyID = (0, smithy_client_1.expectString)(output["KMSMasterKeyID"]);
    }
    return contents;
  };
  var de_ServerSideEncryptionConfiguration = (output, context) => {
    const contents = {};
    if (output.Rule === "") {
      contents.Rules = [];
    } else if (output["Rule"] !== undefined) {
      contents.Rules = de_ServerSideEncryptionRules((0, smithy_client_1.getArrayIfSingleItem)(output["Rule"]), context);
    }
    return contents;
  };
  var de_ServerSideEncryptionRule = (output, context) => {
    const contents = {};
    if (output["ApplyServerSideEncryptionByDefault"] !== undefined) {
      contents.ApplyServerSideEncryptionByDefault = de_ServerSideEncryptionByDefault(output["ApplyServerSideEncryptionByDefault"], context);
    }
    if (output["BucketKeyEnabled"] !== undefined) {
      contents.BucketKeyEnabled = (0, smithy_client_1.parseBoolean)(output["BucketKeyEnabled"]);
    }
    return contents;
  };
  var de_ServerSideEncryptionRules = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_ServerSideEncryptionRule(entry, context);
    });
  };
  var de_SourceSelectionCriteria = (output, context) => {
    const contents = {};
    if (output["SseKmsEncryptedObjects"] !== undefined) {
      contents.SseKmsEncryptedObjects = de_SseKmsEncryptedObjects(output["SseKmsEncryptedObjects"], context);
    }
    if (output["ReplicaModifications"] !== undefined) {
      contents.ReplicaModifications = de_ReplicaModifications(output["ReplicaModifications"], context);
    }
    return contents;
  };
  var de_SSEKMS = (output, context) => {
    const contents = {};
    if (output["KeyId"] !== undefined) {
      contents.KeyId = (0, smithy_client_1.expectString)(output["KeyId"]);
    }
    return contents;
  };
  var de_SseKmsEncryptedObjects = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
      contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
  };
  var de_SSES3 = (output, context) => {
    const contents = {};
    return contents;
  };
  var de_Stats = (output, context) => {
    const contents = {};
    if (output["BytesScanned"] !== undefined) {
      contents.BytesScanned = (0, smithy_client_1.strictParseLong)(output["BytesScanned"]);
    }
    if (output["BytesProcessed"] !== undefined) {
      contents.BytesProcessed = (0, smithy_client_1.strictParseLong)(output["BytesProcessed"]);
    }
    if (output["BytesReturned"] !== undefined) {
      contents.BytesReturned = (0, smithy_client_1.strictParseLong)(output["BytesReturned"]);
    }
    return contents;
  };
  var de_StorageClassAnalysis = (output, context) => {
    const contents = {};
    if (output["DataExport"] !== undefined) {
      contents.DataExport = de_StorageClassAnalysisDataExport(output["DataExport"], context);
    }
    return contents;
  };
  var de_StorageClassAnalysisDataExport = (output, context) => {
    const contents = {};
    if (output["OutputSchemaVersion"] !== undefined) {
      contents.OutputSchemaVersion = (0, smithy_client_1.expectString)(output["OutputSchemaVersion"]);
    }
    if (output["Destination"] !== undefined) {
      contents.Destination = de_AnalyticsExportDestination(output["Destination"], context);
    }
    return contents;
  };
  var de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
      contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
      contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
  };
  var de_TagSet = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_Tag(entry, context);
    });
  };
  var de_TargetGrant = (output, context) => {
    const contents = {};
    if (output["Grantee"] !== undefined) {
      contents.Grantee = de_Grantee(output["Grantee"], context);
    }
    if (output["Permission"] !== undefined) {
      contents.Permission = (0, smithy_client_1.expectString)(output["Permission"]);
    }
    return contents;
  };
  var de_TargetGrants = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_TargetGrant(entry, context);
    });
  };
  var de_Tiering = (output, context) => {
    const contents = {};
    if (output["Days"] !== undefined) {
      contents.Days = (0, smithy_client_1.strictParseInt32)(output["Days"]);
    }
    if (output["AccessTier"] !== undefined) {
      contents.AccessTier = (0, smithy_client_1.expectString)(output["AccessTier"]);
    }
    return contents;
  };
  var de_TieringList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_Tiering(entry, context);
    });
  };
  var de_TopicConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
      contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Topic"] !== undefined) {
      contents.TopicArn = (0, smithy_client_1.expectString)(output["Topic"]);
    }
    if (output.Event === "") {
      contents.Events = [];
    } else if (output["Event"] !== undefined) {
      contents.Events = de_EventList((0, smithy_client_1.getArrayIfSingleItem)(output["Event"]), context);
    }
    if (output["Filter"] !== undefined) {
      contents.Filter = de_NotificationConfigurationFilter(output["Filter"], context);
    }
    return contents;
  };
  var de_TopicConfigurationList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_TopicConfiguration(entry, context);
    });
  };
  var de_Transition = (output, context) => {
    const contents = {};
    if (output["Date"] !== undefined) {
      contents.Date = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Date"]));
    }
    if (output["Days"] !== undefined) {
      contents.Days = (0, smithy_client_1.strictParseInt32)(output["Days"]);
    }
    if (output["StorageClass"] !== undefined) {
      contents.StorageClass = (0, smithy_client_1.expectString)(output["StorageClass"]);
    }
    return contents;
  };
  var de_TransitionList = (output, context) => {
    return (output || []).filter((e) => e != null).map((entry) => {
      return de_Transition(entry, context);
    });
  };
  var deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
  var isSerializableHeaderValue = (value) => value !== undefined && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
  var parseBody2 = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      const parser = new fast_xml_parser_1.XMLParser({
        attributeNamePrefix: "",
        htmlEntities: true,
        ignoreAttributes: false,
        ignoreDeclaration: true,
        parseTagValue: false,
        trimValues: false,
        tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : undefined
      });
      parser.addEntity("#xD", "\r");
      parser.addEntity("#10", "\n");
      const parsedObj = parser.parse(encoded);
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
  });
  var parseErrorBody = async (errorBody, context) => {
    const value = await parseBody2(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  };
  var loadRestXmlErrorCode = (output, data) => {
    if (data?.Code !== undefined) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/AbortMultipartUploadCommand.js
var require_AbortMultipartUploadCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortMultipartUploadCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class AbortMultipartUploadCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AbortMultipartUploadCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "AbortMultipartUploadCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "AbortMultipartUpload"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_AbortMultipartUploadCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_AbortMultipartUploadCommand)(output, context);
    }
  }
  exports.AbortMultipartUploadCommand = AbortMultipartUploadCommand;
});

// node_modules/@aws-sdk/middleware-ssec/dist-cjs/index.js
var require_dist_cjs65 = __commonJS((exports) => {
  var ssecMiddleware = function(options5) {
    return (next) => async (args) => {
      let input = { ...args.input };
      const properties = [
        {
          target: "SSECustomerKey",
          hash: "SSECustomerKeyMD5"
        },
        {
          target: "CopySourceSSECustomerKey",
          hash: "CopySourceSSECustomerKeyMD5"
        }
      ];
      for (const prop of properties) {
        const value = input[prop.target];
        if (value) {
          const valueView = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : typeof value === "string" ? options5.utf8Decoder(value) : new Uint8Array(value);
          const encoded = options5.base64Encoder(valueView);
          const hash = new options5.md5;
          hash.update(valueView);
          input = {
            ...input,
            [prop.target]: encoded,
            [prop.hash]: options5.base64Encoder(await hash.digest())
          };
        }
      }
      return next({
        ...args,
        input
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSsecPlugin = exports.ssecMiddlewareOptions = exports.ssecMiddleware = undefined;
  exports.ssecMiddleware = ssecMiddleware;
  exports.ssecMiddlewareOptions = {
    name: "ssecMiddleware",
    step: "initialize",
    tags: ["SSE"],
    override: true
  };
  var getSsecPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(ssecMiddleware(config), exports.ssecMiddlewareOptions);
    }
  });
  exports.getSsecPlugin = getSsecPlugin;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/CompleteMultipartUploadCommand.js
var require_CompleteMultipartUploadCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompleteMultipartUploadCommand = exports.$Command = undefined;
  var middleware_sdk_s3_1 = require_dist_cjs18();
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class CompleteMultipartUploadCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CompleteMultipartUploadCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_sdk_s3_1.getThrow200ExceptionsPlugin)(configuration));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "CompleteMultipartUploadCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.CompleteMultipartUploadRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.CompleteMultipartUploadOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "CompleteMultipartUpload"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_CompleteMultipartUploadCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_CompleteMultipartUploadCommand)(output, context);
    }
  }
  exports.CompleteMultipartUploadCommand = CompleteMultipartUploadCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/CopyObjectCommand.js
var require_CopyObjectCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CopyObjectCommand = exports.$Command = undefined;
  var middleware_sdk_s3_1 = require_dist_cjs18();
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class CopyObjectCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CopyObjectCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_sdk_s3_1.getThrow200ExceptionsPlugin)(configuration));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "CopyObjectCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.CopyObjectRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.CopyObjectOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "CopyObject"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_CopyObjectCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_CopyObjectCommand)(output, context);
    }
  }
  exports.CopyObjectCommand = CopyObjectCommand;
});

// node_modules/@aws-sdk/middleware-location-constraint/dist-cjs/index.js
var require_dist_cjs66 = __commonJS((exports) => {
  var locationConstraintMiddleware = function(options5) {
    return (next) => async (args) => {
      const { CreateBucketConfiguration } = args.input;
      const region = await options5.region();
      if (!CreateBucketConfiguration || !CreateBucketConfiguration.LocationConstraint) {
        args = {
          ...args,
          input: {
            ...args.input,
            CreateBucketConfiguration: region === "us-east-1" ? undefined : { LocationConstraint: region }
          }
        };
      }
      return next(args);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getLocationConstraintPlugin = exports.locationConstraintMiddlewareOptions = exports.locationConstraintMiddleware = undefined;
  exports.locationConstraintMiddleware = locationConstraintMiddleware;
  exports.locationConstraintMiddlewareOptions = {
    step: "initialize",
    tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
    name: "locationConstraintMiddleware",
    override: true
  };
  var getLocationConstraintPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(locationConstraintMiddleware(config), exports.locationConstraintMiddlewareOptions);
    }
  });
  exports.getLocationConstraintPlugin = getLocationConstraintPlugin;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/CreateBucketCommand.js
var require_CreateBucketCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateBucketCommand = exports.$Command = undefined;
  var middleware_location_constraint_1 = require_dist_cjs66();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class CreateBucketCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        DisableAccessPoints: { type: "staticContextParams", value: true },
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateBucketCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_location_constraint_1.getLocationConstraintPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "CreateBucketCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "CreateBucket"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_CreateBucketCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_CreateBucketCommand)(output, context);
    }
  }
  exports.CreateBucketCommand = CreateBucketCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/CreateMultipartUploadCommand.js
var require_CreateMultipartUploadCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateMultipartUploadCommand = exports.$Command = undefined;
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class CreateMultipartUploadCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateMultipartUploadCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "CreateMultipartUploadCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.CreateMultipartUploadRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.CreateMultipartUploadOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "CreateMultipartUpload"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_CreateMultipartUploadCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_CreateMultipartUploadCommand)(output, context);
    }
  }
  exports.CreateMultipartUploadCommand = CreateMultipartUploadCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketAnalyticsConfigurationCommand.js
var require_DeleteBucketAnalyticsConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketAnalyticsConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketAnalyticsConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketAnalyticsConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketAnalyticsConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketAnalyticsConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketAnalyticsConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketAnalyticsConfigurationCommand)(output, context);
    }
  }
  exports.DeleteBucketAnalyticsConfigurationCommand = DeleteBucketAnalyticsConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketCommand.js
var require_DeleteBucketCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucket"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketCommand)(output, context);
    }
  }
  exports.DeleteBucketCommand = DeleteBucketCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketCorsCommand.js
var require_DeleteBucketCorsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketCorsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketCorsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketCorsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketCorsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketCors"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketCorsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketCorsCommand)(output, context);
    }
  }
  exports.DeleteBucketCorsCommand = DeleteBucketCorsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketEncryptionCommand.js
var require_DeleteBucketEncryptionCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketEncryptionCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketEncryptionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketEncryptionCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketEncryptionCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketEncryption"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketEncryptionCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketEncryptionCommand)(output, context);
    }
  }
  exports.DeleteBucketEncryptionCommand = DeleteBucketEncryptionCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketIntelligentTieringConfigurationCommand.js
var require_DeleteBucketIntelligentTieringConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketIntelligentTieringConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketIntelligentTieringConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketIntelligentTieringConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketIntelligentTieringConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketIntelligentTieringConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketIntelligentTieringConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketIntelligentTieringConfigurationCommand)(output, context);
    }
  }
  exports.DeleteBucketIntelligentTieringConfigurationCommand = DeleteBucketIntelligentTieringConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketInventoryConfigurationCommand.js
var require_DeleteBucketInventoryConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketInventoryConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketInventoryConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketInventoryConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketInventoryConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketInventoryConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketInventoryConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketInventoryConfigurationCommand)(output, context);
    }
  }
  exports.DeleteBucketInventoryConfigurationCommand = DeleteBucketInventoryConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketLifecycleCommand.js
var require_DeleteBucketLifecycleCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketLifecycleCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketLifecycleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketLifecycleCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketLifecycleCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketLifecycle"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketLifecycleCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketLifecycleCommand)(output, context);
    }
  }
  exports.DeleteBucketLifecycleCommand = DeleteBucketLifecycleCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketMetricsConfigurationCommand.js
var require_DeleteBucketMetricsConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketMetricsConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketMetricsConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketMetricsConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketMetricsConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketMetricsConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketMetricsConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketMetricsConfigurationCommand)(output, context);
    }
  }
  exports.DeleteBucketMetricsConfigurationCommand = DeleteBucketMetricsConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketOwnershipControlsCommand.js
var require_DeleteBucketOwnershipControlsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketOwnershipControlsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketOwnershipControlsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketOwnershipControlsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketOwnershipControlsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketOwnershipControls"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketOwnershipControlsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketOwnershipControlsCommand)(output, context);
    }
  }
  exports.DeleteBucketOwnershipControlsCommand = DeleteBucketOwnershipControlsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketPolicyCommand.js
var require_DeleteBucketPolicyCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketPolicyCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketPolicyCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketPolicyCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketPolicy"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketPolicyCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketPolicyCommand)(output, context);
    }
  }
  exports.DeleteBucketPolicyCommand = DeleteBucketPolicyCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketReplicationCommand.js
var require_DeleteBucketReplicationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketReplicationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketReplicationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketReplicationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketReplicationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketReplication"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketReplicationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketReplicationCommand)(output, context);
    }
  }
  exports.DeleteBucketReplicationCommand = DeleteBucketReplicationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketTaggingCommand.js
var require_DeleteBucketTaggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketTaggingCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketTaggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketTaggingCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketTaggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketTagging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketTaggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketTaggingCommand)(output, context);
    }
  }
  exports.DeleteBucketTaggingCommand = DeleteBucketTaggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteBucketWebsiteCommand.js
var require_DeleteBucketWebsiteCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteBucketWebsiteCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteBucketWebsiteCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteBucketWebsiteCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteBucketWebsiteCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteBucketWebsite"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteBucketWebsiteCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteBucketWebsiteCommand)(output, context);
    }
  }
  exports.DeleteBucketWebsiteCommand = DeleteBucketWebsiteCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteObjectCommand.js
var require_DeleteObjectCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteObjectCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteObjectCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteObjectCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteObjectCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteObject"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteObjectCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteObjectCommand)(output, context);
    }
  }
  exports.DeleteObjectCommand = DeleteObjectCommand;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/constants.js
var require_constants11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumLocation = exports.ChecksumAlgorithm = undefined;
  var ChecksumAlgorithm;
  (function(ChecksumAlgorithm2) {
    ChecksumAlgorithm2["MD5"] = "MD5";
    ChecksumAlgorithm2["CRC32"] = "CRC32";
    ChecksumAlgorithm2["CRC32C"] = "CRC32C";
    ChecksumAlgorithm2["SHA1"] = "SHA1";
    ChecksumAlgorithm2["SHA256"] = "SHA256";
  })(ChecksumAlgorithm = exports.ChecksumAlgorithm || (exports.ChecksumAlgorithm = {}));
  var ChecksumLocation;
  (function(ChecksumLocation2) {
    ChecksumLocation2["HEADER"] = "header";
    ChecksumLocation2["TRAILER"] = "trailer";
  })(ChecksumLocation = exports.ChecksumLocation || (exports.ChecksumLocation = {}));
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/types.js
var require_types10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PRIORITY_ORDER_ALGORITHMS = exports.CLIENT_SUPPORTED_ALGORITHMS = undefined;
  var constants_1 = require_constants11();
  exports.CLIENT_SUPPORTED_ALGORITHMS = [
    constants_1.ChecksumAlgorithm.CRC32,
    constants_1.ChecksumAlgorithm.CRC32C,
    constants_1.ChecksumAlgorithm.SHA1,
    constants_1.ChecksumAlgorithm.SHA256
  ];
  exports.PRIORITY_ORDER_ALGORITHMS = [
    constants_1.ChecksumAlgorithm.CRC32,
    constants_1.ChecksumAlgorithm.CRC32C,
    constants_1.ChecksumAlgorithm.SHA1,
    constants_1.ChecksumAlgorithm.SHA256
  ];
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getChecksumAlgorithmForRequest.js
var require_getChecksumAlgorithmForRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChecksumAlgorithmForRequest = undefined;
  var constants_1 = require_constants11();
  var types_1 = require_types10();
  var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }) => {
    if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
      return requestChecksumRequired ? constants_1.ChecksumAlgorithm.MD5 : undefined;
    }
    const checksumAlgorithm = input[requestAlgorithmMember];
    if (!types_1.CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
      throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client.` + ` Select one of ${types_1.CLIENT_SUPPORTED_ALGORITHMS}.`);
    }
    return checksumAlgorithm;
  };
  exports.getChecksumAlgorithmForRequest = getChecksumAlgorithmForRequest;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getChecksumLocationName.js
var require_getChecksumLocationName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChecksumLocationName = undefined;
  var constants_1 = require_constants11();
  var getChecksumLocationName = (algorithm) => algorithm === constants_1.ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;
  exports.getChecksumLocationName = getChecksumLocationName;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/hasHeader.js
var require_hasHeader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasHeader = undefined;
  var hasHeader = (header, headers) => {
    const soughtHeader = header.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  };
  exports.hasHeader = hasHeader;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/isStreaming.js
var require_isStreaming = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isStreaming = undefined;
  var is_array_buffer_1 = require_dist_cjs8();
  var isStreaming = (body) => body !== undefined && typeof body !== "string" && !ArrayBuffer.isView(body) && !(0, is_array_buffer_1.isArrayBuffer)(body);
  exports.isStreaming = isStreaming;
});

// node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS((exports, module) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __createBinding;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i2 = 1, n = arguments.length;i2 < n; i2++) {
        s = arguments[i2];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
          if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
            t[p[i2]] = s[p[i2]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d = decorators[i2])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __createBinding = function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __exportStar = function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = undefined;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k = 0, i2 = 0;i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n) {
        if (g[n])
          i2[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i2, p;
      return i2 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n, f) {
        i2[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i2;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet2 = function(receiver2, privateMap) {
      if (!privateMap.has(receiver2)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver2);
    };
    __classPrivateFieldSet2 = function(receiver2, privateMap, value) {
      if (!privateMap.has(receiver2)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver2, value);
      return value;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
  });
});

// node_modules/@aws-crypto/crc32c/build/aws_crc32c.js
var require_aws_crc32c = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32c = undefined;
  var tslib_1 = require_tslib3();
  var util_1 = require_build();
  var index_1 = require_build3();
  var AwsCrc32c = function() {
    function AwsCrc32c2() {
      this.crc32c = new index_1.Crc32c;
    }
    AwsCrc32c2.prototype.update = function(toHash) {
      if ((0, util_1.isEmptyData)(toHash))
        return;
      this.crc32c.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc32c2.prototype.digest = function() {
      return tslib_1.__awaiter(this, undefined, undefined, function() {
        return tslib_1.__generator(this, function(_a) {
          return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
        });
      });
    };
    AwsCrc32c2.prototype.reset = function() {
      this.crc32c = new index_1.Crc32c;
    };
    return AwsCrc32c2;
  }();
  exports.AwsCrc32c = AwsCrc32c;
});

// node_modules/@aws-crypto/crc32c/build/index.js
var require_build3 = __commonJS((exports) => {
  var crc32c = function(data) {
    return new Crc32c().update(data).digest();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32c = exports.Crc32c = exports.crc32c = undefined;
  var tslib_1 = require_tslib3();
  var util_1 = require_build();
  exports.crc32c = crc32c;
  var Crc32c = function() {
    function Crc32c2() {
      this.checksum = 4294967295;
    }
    Crc32c2.prototype.update = function(data) {
      var e_1, _a;
      try {
        for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
          var byte = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a = data_1.return))
            _a.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc32c2.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc32c2;
  }();
  exports.Crc32c = Crc32c;
  var a_lookupTable = [
    0,
    4067132163,
    3778769143,
    324072436,
    3348797215,
    904991772,
    648144872,
    3570033899,
    2329499855,
    2024987596,
    1809983544,
    2575936315,
    1296289744,
    3207089363,
    2893594407,
    1578318884,
    274646895,
    3795141740,
    4049975192,
    51262619,
    3619967088,
    632279923,
    922689671,
    3298075524,
    2592579488,
    1760304291,
    2075979607,
    2312596564,
    1562183871,
    2943781820,
    3156637768,
    1313733451,
    549293790,
    3537243613,
    3246849577,
    871202090,
    3878099393,
    357341890,
    102525238,
    4101499445,
    2858735121,
    1477399826,
    1264559846,
    3107202533,
    1845379342,
    2677391885,
    2361733625,
    2125378298,
    820201905,
    3263744690,
    3520608582,
    598981189,
    4151959214,
    85089709,
    373468761,
    3827903834,
    3124367742,
    1213305469,
    1526817161,
    2842354314,
    2107672161,
    2412447074,
    2627466902,
    1861252501,
    1098587580,
    3004210879,
    2688576843,
    1378610760,
    2262928035,
    1955203488,
    1742404180,
    2511436119,
    3416409459,
    969524848,
    714683780,
    3639785095,
    205050476,
    4266873199,
    3976438427,
    526918040,
    1361435347,
    2739821008,
    2954799652,
    1114974503,
    2529119692,
    1691668175,
    2005155131,
    2247081528,
    3690758684,
    697762079,
    986182379,
    3366744552,
    476452099,
    3993867776,
    4250756596,
    255256311,
    1640403810,
    2477592673,
    2164122517,
    1922457750,
    2791048317,
    1412925310,
    1197962378,
    3037525897,
    3944729517,
    427051182,
    170179418,
    4165941337,
    746937522,
    3740196785,
    3451792453,
    1070968646,
    1905808397,
    2213795598,
    2426610938,
    1657317369,
    3053634322,
    1147748369,
    1463399397,
    2773627110,
    4215344322,
    153784257,
    444234805,
    3893493558,
    1021025245,
    3467647198,
    3722505002,
    797665321,
    2197175160,
    1889384571,
    1674398607,
    2443626636,
    1164749927,
    3070701412,
    2757221520,
    1446797203,
    137323447,
    4198817972,
    3910406976,
    461344835,
    3484808360,
    1037989803,
    781091935,
    3705997148,
    2460548119,
    1623424788,
    1939049696,
    2180517859,
    1429367560,
    2807687179,
    3020495871,
    1180866812,
    410100952,
    3927582683,
    4182430767,
    186734380,
    3756733383,
    763408580,
    1053836080,
    3434856499,
    2722870694,
    1344288421,
    1131464017,
    2971354706,
    1708204729,
    2545590714,
    2229949006,
    1988219213,
    680717673,
    3673779818,
    3383336350,
    1002577565,
    4010310262,
    493091189,
    238226049,
    4233660802,
    2987750089,
    1082061258,
    1395524158,
    2705686845,
    1972364758,
    2279892693,
    2494862625,
    1725896226,
    952904198,
    3399985413,
    3656866545,
    731699698,
    4283874585,
    222117402,
    510512622,
    3959836397,
    3280807620,
    837199303,
    582374963,
    3504198960,
    68661723,
    4135334616,
    3844915500,
    390545967,
    1230274059,
    3141532936,
    2825850620,
    1510247935,
    2395924756,
    2091215383,
    1878366691,
    2644384480,
    3553878443,
    565732008,
    854102364,
    3229815391,
    340358836,
    3861050807,
    4117890627,
    119113024,
    1493875044,
    2875275879,
    3090270611,
    1247431312,
    2660249211,
    1828433272,
    2141937292,
    2378227087,
    3811616794,
    291187481,
    34330861,
    4032846830,
    615137029,
    3603020806,
    3314634738,
    939183345,
    1776939221,
    2609017814,
    2295496738,
    2058945313,
    2926798794,
    1545135305,
    1330124605,
    3173225534,
    4084100981,
    17165430,
    307568514,
    3762199681,
    888469610,
    3332340585,
    3587147933,
    665062302,
    2042050490,
    2346497209,
    2559330125,
    1793573966,
    3190661285,
    1279665062,
    1595330642,
    2910671697
  ];
  var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
  var aws_crc32c_1 = require_aws_crc32c();
  Object.defineProperty(exports, "AwsCrc32c", { enumerable: true, get: function() {
    return aws_crc32c_1.AwsCrc32c;
  } });
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/selectChecksumAlgorithmFunction.js
var require_selectChecksumAlgorithmFunction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.selectChecksumAlgorithmFunction = undefined;
  var crc32_1 = require_build2();
  var crc32c_1 = require_build3();
  var constants_1 = require_constants11();
  var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => ({
    [constants_1.ChecksumAlgorithm.MD5]: config.md5,
    [constants_1.ChecksumAlgorithm.CRC32]: crc32_1.AwsCrc32,
    [constants_1.ChecksumAlgorithm.CRC32C]: crc32c_1.AwsCrc32c,
    [constants_1.ChecksumAlgorithm.SHA1]: config.sha1,
    [constants_1.ChecksumAlgorithm.SHA256]: config.sha256
  })[checksumAlgorithm];
  exports.selectChecksumAlgorithmFunction = selectChecksumAlgorithmFunction;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/stringHasher.js
var require_stringHasher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringHasher = undefined;
  var util_utf8_1 = require_dist_cjs11();
  var stringHasher = (checksumAlgorithmFn, body) => {
    const hash = new checksumAlgorithmFn;
    hash.update((0, util_utf8_1.toUint8Array)(body || ""));
    return hash.digest();
  };
  exports.stringHasher = stringHasher;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/flexibleChecksumsMiddleware.js
var require_flexibleChecksumsMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flexibleChecksumsMiddleware = exports.flexibleChecksumsMiddlewareOptions = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var getChecksumAlgorithmForRequest_1 = require_getChecksumAlgorithmForRequest();
  var getChecksumLocationName_1 = require_getChecksumLocationName();
  var hasHeader_1 = require_hasHeader();
  var isStreaming_1 = require_isStreaming();
  var selectChecksumAlgorithmFunction_1 = require_selectChecksumAlgorithmFunction();
  var stringHasher_1 = require_stringHasher();
  exports.flexibleChecksumsMiddlewareOptions = {
    name: "flexibleChecksumsMiddleware",
    step: "build",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const { request } = args;
    const { body: requestBody, headers } = request;
    const { base64Encoder, streamHasher } = config;
    const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
    const checksumAlgorithm = (0, getChecksumAlgorithmForRequest_1.getChecksumAlgorithmForRequest)(input, {
      requestChecksumRequired,
      requestAlgorithmMember
    });
    let updatedBody = requestBody;
    let updatedHeaders = headers;
    if (checksumAlgorithm) {
      const checksumLocationName = (0, getChecksumLocationName_1.getChecksumLocationName)(checksumAlgorithm);
      const checksumAlgorithmFn = (0, selectChecksumAlgorithmFunction_1.selectChecksumAlgorithmFunction)(checksumAlgorithm, config);
      if ((0, isStreaming_1.isStreaming)(requestBody)) {
        const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;
        updatedBody = getAwsChunkedEncodingStream(requestBody, {
          base64Encoder,
          bodyLengthChecker,
          checksumLocationName,
          checksumAlgorithmFn,
          streamHasher
        });
        updatedHeaders = {
          ...headers,
          "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
          "transfer-encoding": "chunked",
          "x-amz-decoded-content-length": headers["content-length"],
          "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
          "x-amz-trailer": checksumLocationName
        };
        delete updatedHeaders["content-length"];
      } else if (!(0, hasHeader_1.hasHeader)(checksumLocationName, headers)) {
        const rawChecksum = await (0, stringHasher_1.stringHasher)(checksumAlgorithmFn, requestBody);
        updatedHeaders = {
          ...headers,
          [checksumLocationName]: base64Encoder(rawChecksum)
        };
      }
    }
    const result = await next({
      ...args,
      request: {
        ...request,
        headers: updatedHeaders,
        body: updatedBody
      }
    });
    return result;
  };
  exports.flexibleChecksumsMiddleware = flexibleChecksumsMiddleware;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getChecksumAlgorithmListForResponse.js
var require_getChecksumAlgorithmListForResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChecksumAlgorithmListForResponse = undefined;
  var types_1 = require_types10();
  var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
    const validChecksumAlgorithms = [];
    for (const algorithm of types_1.PRIORITY_ORDER_ALGORITHMS) {
      if (!responseAlgorithms.includes(algorithm) || !types_1.CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
        continue;
      }
      validChecksumAlgorithms.push(algorithm);
    }
    return validChecksumAlgorithms;
  };
  exports.getChecksumAlgorithmListForResponse = getChecksumAlgorithmListForResponse;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/isChecksumWithPartNumber.js
var require_isChecksumWithPartNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isChecksumWithPartNumber = undefined;
  var isChecksumWithPartNumber = (checksum) => {
    const lastHyphenIndex = checksum.lastIndexOf("-");
    if (lastHyphenIndex !== -1) {
      const numberPart = checksum.slice(lastHyphenIndex + 1);
      if (!numberPart.startsWith("0")) {
        const number = parseInt(numberPart, 10);
        if (!isNaN(number) && number >= 1 && number <= 1e4) {
          return true;
        }
      }
    }
    return false;
  };
  exports.isChecksumWithPartNumber = isChecksumWithPartNumber;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/streams/create-read-stream-on-buffer.js
var require_create_read_stream_on_buffer = __commonJS((exports) => {
  var createReadStreamOnBuffer = function(buffer) {
    const stream3 = new stream_1.Transform;
    stream3.push(buffer);
    stream3.push(null);
    return stream3;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createReadStreamOnBuffer = undefined;
  var stream_1 = __require("stream");
  exports.createReadStreamOnBuffer = createReadStreamOnBuffer;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getChecksum.js
var require_getChecksum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChecksum = undefined;
  var isStreaming_1 = require_isStreaming();
  var stringHasher_1 = require_stringHasher();
  var getChecksum = async (body, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
    const digest = (0, isStreaming_1.isStreaming)(body) ? streamHasher(checksumAlgorithmFn, body) : (0, stringHasher_1.stringHasher)(checksumAlgorithmFn, body);
    return base64Encoder(await digest);
  };
  exports.getChecksum = getChecksum;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/validateChecksumFromResponse.js
var require_validateChecksumFromResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateChecksumFromResponse = undefined;
  var getChecksum_1 = require_getChecksum();
  var getChecksumAlgorithmListForResponse_1 = require_getChecksumAlgorithmListForResponse();
  var getChecksumLocationName_1 = require_getChecksumLocationName();
  var selectChecksumAlgorithmFunction_1 = require_selectChecksumAlgorithmFunction();
  var validateChecksumFromResponse = async (response4, { config, responseAlgorithms }) => {
    const checksumAlgorithms = (0, getChecksumAlgorithmListForResponse_1.getChecksumAlgorithmListForResponse)(responseAlgorithms);
    const { body: responseBody, headers: responseHeaders } = response4;
    for (const algorithm of checksumAlgorithms) {
      const responseHeader = (0, getChecksumLocationName_1.getChecksumLocationName)(algorithm);
      const checksumFromResponse = responseHeaders[responseHeader];
      if (checksumFromResponse) {
        const checksumAlgorithmFn = (0, selectChecksumAlgorithmFunction_1.selectChecksumAlgorithmFunction)(algorithm, config);
        const { streamHasher, base64Encoder } = config;
        const checksum = await (0, getChecksum_1.getChecksum)(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
        if (checksum === checksumFromResponse) {
          break;
        }
        throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}"` + ` in response header "${responseHeader}".`);
      }
    }
  };
  exports.validateChecksumFromResponse = validateChecksumFromResponse;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/flexibleChecksumsResponseMiddleware.js
var require_flexibleChecksumsResponseMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flexibleChecksumsResponseMiddleware = exports.flexibleChecksumsResponseMiddlewareOptions = undefined;
  var protocol_http_1 = require_dist_cjs2();
  var getChecksumAlgorithmListForResponse_1 = require_getChecksumAlgorithmListForResponse();
  var getChecksumLocationName_1 = require_getChecksumLocationName();
  var isChecksumWithPartNumber_1 = require_isChecksumWithPartNumber();
  var isStreaming_1 = require_isStreaming();
  var create_read_stream_on_buffer_1 = require_create_read_stream_on_buffer();
  var validateChecksumFromResponse_1 = require_validateChecksumFromResponse();
  exports.flexibleChecksumsResponseMiddlewareOptions = {
    name: "flexibleChecksumsResponseMiddleware",
    toMiddleware: "deserializerMiddleware",
    relation: "after",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const input = args.input;
    const result = await next(args);
    const response4 = result.response;
    let collectedStream = undefined;
    const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
    if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
      const { clientName, commandName } = context;
      const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && (0, getChecksumAlgorithmListForResponse_1.getChecksumAlgorithmListForResponse)(responseAlgorithms).every((algorithm) => {
        const responseHeader = (0, getChecksumLocationName_1.getChecksumLocationName)(algorithm);
        const checksumFromResponse = response4.headers[responseHeader];
        return !checksumFromResponse || (0, isChecksumWithPartNumber_1.isChecksumWithPartNumber)(checksumFromResponse);
      });
      if (isS3WholeObjectMultipartGetResponseChecksum) {
        return result;
      }
      const isStreamingBody = (0, isStreaming_1.isStreaming)(response4.body);
      if (isStreamingBody) {
        collectedStream = await config.streamCollector(response4.body);
        response4.body = (0, create_read_stream_on_buffer_1.createReadStreamOnBuffer)(collectedStream);
      }
      await (0, validateChecksumFromResponse_1.validateChecksumFromResponse)(result.response, {
        config,
        responseAlgorithms
      });
      if (isStreamingBody && collectedStream) {
        response4.body = (0, create_read_stream_on_buffer_1.createReadStreamOnBuffer)(collectedStream);
      }
    }
    return result;
  };
  exports.flexibleChecksumsResponseMiddleware = flexibleChecksumsResponseMiddleware;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getFlexibleChecksumsPlugin.js
var require_getFlexibleChecksumsPlugin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFlexibleChecksumsPlugin = undefined;
  var flexibleChecksumsMiddleware_1 = require_flexibleChecksumsMiddleware();
  var flexibleChecksumsResponseMiddleware_1 = require_flexibleChecksumsResponseMiddleware();
  var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add((0, flexibleChecksumsMiddleware_1.flexibleChecksumsMiddleware)(config, middlewareConfig), flexibleChecksumsMiddleware_1.flexibleChecksumsMiddlewareOptions);
      clientStack.addRelativeTo((0, flexibleChecksumsResponseMiddleware_1.flexibleChecksumsResponseMiddleware)(config, middlewareConfig), flexibleChecksumsResponseMiddleware_1.flexibleChecksumsResponseMiddlewareOptions);
    }
  });
  exports.getFlexibleChecksumsPlugin = getFlexibleChecksumsPlugin;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/index.js
var require_dist_cjs67 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_constants11(), exports);
  tslib_1.__exportStar(require_flexibleChecksumsMiddleware(), exports);
  tslib_1.__exportStar(require_getFlexibleChecksumsPlugin(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteObjectsCommand.js
var require_DeleteObjectsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteObjectsCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteObjectsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteObjectsCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteObjectsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteObjects"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteObjectsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteObjectsCommand)(output, context);
    }
  }
  exports.DeleteObjectsCommand = DeleteObjectsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeleteObjectTaggingCommand.js
var require_DeleteObjectTaggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteObjectTaggingCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeleteObjectTaggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteObjectTaggingCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeleteObjectTaggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeleteObjectTagging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeleteObjectTaggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeleteObjectTaggingCommand)(output, context);
    }
  }
  exports.DeleteObjectTaggingCommand = DeleteObjectTaggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/DeletePublicAccessBlockCommand.js
var require_DeletePublicAccessBlockCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeletePublicAccessBlockCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class DeletePublicAccessBlockCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeletePublicAccessBlockCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "DeletePublicAccessBlockCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "DeletePublicAccessBlock"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_DeletePublicAccessBlockCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_DeletePublicAccessBlockCommand)(output, context);
    }
  }
  exports.DeletePublicAccessBlockCommand = DeletePublicAccessBlockCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketAccelerateConfigurationCommand.js
var require_GetBucketAccelerateConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketAccelerateConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketAccelerateConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketAccelerateConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketAccelerateConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketAccelerateConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketAccelerateConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketAccelerateConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketAccelerateConfigurationCommand = GetBucketAccelerateConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketAclCommand.js
var require_GetBucketAclCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketAclCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketAclCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketAclCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketAclCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketAcl"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketAclCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketAclCommand)(output, context);
    }
  }
  exports.GetBucketAclCommand = GetBucketAclCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketAnalyticsConfigurationCommand.js
var require_GetBucketAnalyticsConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketAnalyticsConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketAnalyticsConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketAnalyticsConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketAnalyticsConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketAnalyticsConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketAnalyticsConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketAnalyticsConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketAnalyticsConfigurationCommand = GetBucketAnalyticsConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketCorsCommand.js
var require_GetBucketCorsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketCorsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketCorsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketCorsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketCorsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketCors"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketCorsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketCorsCommand)(output, context);
    }
  }
  exports.GetBucketCorsCommand = GetBucketCorsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketEncryptionCommand.js
var require_GetBucketEncryptionCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketEncryptionCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketEncryptionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketEncryptionCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketEncryptionCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.GetBucketEncryptionOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketEncryption"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketEncryptionCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketEncryptionCommand)(output, context);
    }
  }
  exports.GetBucketEncryptionCommand = GetBucketEncryptionCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketIntelligentTieringConfigurationCommand.js
var require_GetBucketIntelligentTieringConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketIntelligentTieringConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketIntelligentTieringConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketIntelligentTieringConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketIntelligentTieringConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketIntelligentTieringConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketIntelligentTieringConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketIntelligentTieringConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketIntelligentTieringConfigurationCommand = GetBucketIntelligentTieringConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketInventoryConfigurationCommand.js
var require_GetBucketInventoryConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketInventoryConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketInventoryConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketInventoryConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketInventoryConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.GetBucketInventoryConfigurationOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketInventoryConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketInventoryConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketInventoryConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketInventoryConfigurationCommand = GetBucketInventoryConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketLifecycleConfigurationCommand.js
var require_GetBucketLifecycleConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketLifecycleConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketLifecycleConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketLifecycleConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketLifecycleConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketLifecycleConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketLifecycleConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketLifecycleConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketLifecycleConfigurationCommand = GetBucketLifecycleConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketLocationCommand.js
var require_GetBucketLocationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketLocationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketLocationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketLocationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketLocationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketLocation"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketLocationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketLocationCommand)(output, context);
    }
  }
  exports.GetBucketLocationCommand = GetBucketLocationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketLoggingCommand.js
var require_GetBucketLoggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketLoggingCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketLoggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketLoggingCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketLoggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketLogging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketLoggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketLoggingCommand)(output, context);
    }
  }
  exports.GetBucketLoggingCommand = GetBucketLoggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketMetricsConfigurationCommand.js
var require_GetBucketMetricsConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketMetricsConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketMetricsConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketMetricsConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketMetricsConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketMetricsConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketMetricsConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketMetricsConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketMetricsConfigurationCommand = GetBucketMetricsConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketNotificationConfigurationCommand.js
var require_GetBucketNotificationConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketNotificationConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketNotificationConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketNotificationConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketNotificationConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketNotificationConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketNotificationConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketNotificationConfigurationCommand)(output, context);
    }
  }
  exports.GetBucketNotificationConfigurationCommand = GetBucketNotificationConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketOwnershipControlsCommand.js
var require_GetBucketOwnershipControlsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketOwnershipControlsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketOwnershipControlsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketOwnershipControlsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketOwnershipControlsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketOwnershipControls"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketOwnershipControlsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketOwnershipControlsCommand)(output, context);
    }
  }
  exports.GetBucketOwnershipControlsCommand = GetBucketOwnershipControlsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketPolicyCommand.js
var require_GetBucketPolicyCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketPolicyCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketPolicyCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketPolicyCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketPolicy"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketPolicyCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketPolicyCommand)(output, context);
    }
  }
  exports.GetBucketPolicyCommand = GetBucketPolicyCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketPolicyStatusCommand.js
var require_GetBucketPolicyStatusCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketPolicyStatusCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketPolicyStatusCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketPolicyStatusCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketPolicyStatusCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketPolicyStatus"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketPolicyStatusCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketPolicyStatusCommand)(output, context);
    }
  }
  exports.GetBucketPolicyStatusCommand = GetBucketPolicyStatusCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketReplicationCommand.js
var require_GetBucketReplicationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketReplicationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketReplicationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketReplicationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketReplicationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketReplication"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketReplicationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketReplicationCommand)(output, context);
    }
  }
  exports.GetBucketReplicationCommand = GetBucketReplicationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketRequestPaymentCommand.js
var require_GetBucketRequestPaymentCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketRequestPaymentCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketRequestPaymentCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketRequestPaymentCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketRequestPaymentCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketRequestPayment"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketRequestPaymentCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketRequestPaymentCommand)(output, context);
    }
  }
  exports.GetBucketRequestPaymentCommand = GetBucketRequestPaymentCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketTaggingCommand.js
var require_GetBucketTaggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketTaggingCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketTaggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketTaggingCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketTaggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketTagging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketTaggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketTaggingCommand)(output, context);
    }
  }
  exports.GetBucketTaggingCommand = GetBucketTaggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketVersioningCommand.js
var require_GetBucketVersioningCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketVersioningCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketVersioningCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketVersioningCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketVersioningCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketVersioning"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketVersioningCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketVersioningCommand)(output, context);
    }
  }
  exports.GetBucketVersioningCommand = GetBucketVersioningCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetBucketWebsiteCommand.js
var require_GetBucketWebsiteCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetBucketWebsiteCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetBucketWebsiteCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetBucketWebsiteCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetBucketWebsiteCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetBucketWebsite"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetBucketWebsiteCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetBucketWebsiteCommand)(output, context);
    }
  }
  exports.GetBucketWebsiteCommand = GetBucketWebsiteCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectAclCommand.js
var require_GetObjectAclCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectAclCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectAclCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectAclCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectAclCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectAcl"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectAclCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectAclCommand)(output, context);
    }
  }
  exports.GetObjectAclCommand = GetObjectAclCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectAttributesCommand.js
var require_GetObjectAttributesCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectAttributesCommand = exports.$Command = undefined;
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectAttributesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectAttributesCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectAttributesCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.GetObjectAttributesRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectAttributes"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectAttributesCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectAttributesCommand)(output, context);
    }
  }
  exports.GetObjectAttributesCommand = GetObjectAttributesCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectCommand.js
var require_GetObjectCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestChecksumRequired: false,
        requestValidationModeMember: "ChecksumMode",
        responseAlgorithms: ["CRC32", "CRC32C", "SHA256", "SHA1"]
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.GetObjectRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.GetObjectOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObject"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectCommand)(output, context);
    }
  }
  exports.GetObjectCommand = GetObjectCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectLegalHoldCommand.js
var require_GetObjectLegalHoldCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectLegalHoldCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectLegalHoldCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectLegalHoldCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectLegalHoldCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectLegalHold"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectLegalHoldCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectLegalHoldCommand)(output, context);
    }
  }
  exports.GetObjectLegalHoldCommand = GetObjectLegalHoldCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectLockConfigurationCommand.js
var require_GetObjectLockConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectLockConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectLockConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectLockConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectLockConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectLockConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectLockConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectLockConfigurationCommand)(output, context);
    }
  }
  exports.GetObjectLockConfigurationCommand = GetObjectLockConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectRetentionCommand.js
var require_GetObjectRetentionCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectRetentionCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectRetentionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectRetentionCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectRetentionCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectRetention"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectRetentionCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectRetentionCommand)(output, context);
    }
  }
  exports.GetObjectRetentionCommand = GetObjectRetentionCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectTaggingCommand.js
var require_GetObjectTaggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectTaggingCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectTaggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectTaggingCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectTaggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectTagging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectTaggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectTaggingCommand)(output, context);
    }
  }
  exports.GetObjectTaggingCommand = GetObjectTaggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetObjectTorrentCommand.js
var require_GetObjectTorrentCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetObjectTorrentCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetObjectTorrentCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetObjectTorrentCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetObjectTorrentCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.GetObjectTorrentOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetObjectTorrent"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetObjectTorrentCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetObjectTorrentCommand)(output, context);
    }
  }
  exports.GetObjectTorrentCommand = GetObjectTorrentCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/GetPublicAccessBlockCommand.js
var require_GetPublicAccessBlockCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetPublicAccessBlockCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class GetPublicAccessBlockCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetPublicAccessBlockCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "GetPublicAccessBlockCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "GetPublicAccessBlock"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_GetPublicAccessBlockCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_GetPublicAccessBlockCommand)(output, context);
    }
  }
  exports.GetPublicAccessBlockCommand = GetPublicAccessBlockCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/HeadBucketCommand.js
var require_HeadBucketCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HeadBucketCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class HeadBucketCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, HeadBucketCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "HeadBucketCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "HeadBucket"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_HeadBucketCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_HeadBucketCommand)(output, context);
    }
  }
  exports.HeadBucketCommand = HeadBucketCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/HeadObjectCommand.js
var require_HeadObjectCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HeadObjectCommand = exports.$Command = undefined;
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class HeadObjectCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, HeadObjectCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "HeadObjectCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.HeadObjectRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.HeadObjectOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "HeadObject"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_HeadObjectCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_HeadObjectCommand)(output, context);
    }
  }
  exports.HeadObjectCommand = HeadObjectCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListBucketAnalyticsConfigurationsCommand.js
var require_ListBucketAnalyticsConfigurationsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListBucketAnalyticsConfigurationsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListBucketAnalyticsConfigurationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListBucketAnalyticsConfigurationsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListBucketAnalyticsConfigurationsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListBucketAnalyticsConfigurations"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListBucketAnalyticsConfigurationsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListBucketAnalyticsConfigurationsCommand)(output, context);
    }
  }
  exports.ListBucketAnalyticsConfigurationsCommand = ListBucketAnalyticsConfigurationsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListBucketIntelligentTieringConfigurationsCommand.js
var require_ListBucketIntelligentTieringConfigurationsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListBucketIntelligentTieringConfigurationsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListBucketIntelligentTieringConfigurationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListBucketIntelligentTieringConfigurationsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListBucketIntelligentTieringConfigurationsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListBucketIntelligentTieringConfigurations"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListBucketIntelligentTieringConfigurationsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListBucketIntelligentTieringConfigurationsCommand)(output, context);
    }
  }
  exports.ListBucketIntelligentTieringConfigurationsCommand = ListBucketIntelligentTieringConfigurationsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListBucketInventoryConfigurationsCommand.js
var require_ListBucketInventoryConfigurationsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListBucketInventoryConfigurationsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListBucketInventoryConfigurationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListBucketInventoryConfigurationsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListBucketInventoryConfigurationsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: models_0_1.ListBucketInventoryConfigurationsOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListBucketInventoryConfigurations"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListBucketInventoryConfigurationsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListBucketInventoryConfigurationsCommand)(output, context);
    }
  }
  exports.ListBucketInventoryConfigurationsCommand = ListBucketInventoryConfigurationsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListBucketMetricsConfigurationsCommand.js
var require_ListBucketMetricsConfigurationsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListBucketMetricsConfigurationsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListBucketMetricsConfigurationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListBucketMetricsConfigurationsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListBucketMetricsConfigurationsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListBucketMetricsConfigurations"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListBucketMetricsConfigurationsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListBucketMetricsConfigurationsCommand)(output, context);
    }
  }
  exports.ListBucketMetricsConfigurationsCommand = ListBucketMetricsConfigurationsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListBucketsCommand.js
var require_ListBucketsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListBucketsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListBucketsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListBucketsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListBucketsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListBuckets"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListBucketsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListBucketsCommand)(output, context);
    }
  }
  exports.ListBucketsCommand = ListBucketsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListMultipartUploadsCommand.js
var require_ListMultipartUploadsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListMultipartUploadsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListMultipartUploadsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListMultipartUploadsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListMultipartUploadsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListMultipartUploads"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListMultipartUploadsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListMultipartUploadsCommand)(output, context);
    }
  }
  exports.ListMultipartUploadsCommand = ListMultipartUploadsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListObjectsCommand.js
var require_ListObjectsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListObjectsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListObjectsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListObjectsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListObjectsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListObjects"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListObjectsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListObjectsCommand)(output, context);
    }
  }
  exports.ListObjectsCommand = ListObjectsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListObjectsV2Command.js
var require_ListObjectsV2Command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListObjectsV2Command = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListObjectsV2Command extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListObjectsV2Command.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListObjectsV2Command";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListObjectsV2"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListObjectsV2Command)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListObjectsV2Command)(output, context);
    }
  }
  exports.ListObjectsV2Command = ListObjectsV2Command;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListObjectVersionsCommand.js
var require_ListObjectVersionsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListObjectVersionsCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListObjectVersionsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListObjectVersionsCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListObjectVersionsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListObjectVersions"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListObjectVersionsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListObjectVersionsCommand)(output, context);
    }
  }
  exports.ListObjectVersionsCommand = ListObjectVersionsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/ListPartsCommand.js
var require_ListPartsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListPartsCommand = exports.$Command = undefined;
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class ListPartsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListPartsCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "ListPartsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.ListPartsRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "ListParts"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_ListPartsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_ListPartsCommand)(output, context);
    }
  }
  exports.ListPartsCommand = ListPartsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketAccelerateConfigurationCommand.js
var require_PutBucketAccelerateConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketAccelerateConfigurationCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketAccelerateConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketAccelerateConfigurationCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: false
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketAccelerateConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketAccelerateConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketAccelerateConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketAccelerateConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketAccelerateConfigurationCommand = PutBucketAccelerateConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketAclCommand.js
var require_PutBucketAclCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketAclCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketAclCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketAclCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketAclCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketAcl"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketAclCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketAclCommand)(output, context);
    }
  }
  exports.PutBucketAclCommand = PutBucketAclCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketAnalyticsConfigurationCommand.js
var require_PutBucketAnalyticsConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketAnalyticsConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketAnalyticsConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketAnalyticsConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketAnalyticsConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketAnalyticsConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketAnalyticsConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketAnalyticsConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketAnalyticsConfigurationCommand = PutBucketAnalyticsConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketCorsCommand.js
var require_PutBucketCorsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketCorsCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketCorsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketCorsCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketCorsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketCors"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketCorsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketCorsCommand)(output, context);
    }
  }
  exports.PutBucketCorsCommand = PutBucketCorsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketEncryptionCommand.js
var require_PutBucketEncryptionCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketEncryptionCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketEncryptionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketEncryptionCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketEncryptionCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.PutBucketEncryptionRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketEncryption"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketEncryptionCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketEncryptionCommand)(output, context);
    }
  }
  exports.PutBucketEncryptionCommand = PutBucketEncryptionCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketIntelligentTieringConfigurationCommand.js
var require_PutBucketIntelligentTieringConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketIntelligentTieringConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketIntelligentTieringConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketIntelligentTieringConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketIntelligentTieringConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketIntelligentTieringConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketIntelligentTieringConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketIntelligentTieringConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketIntelligentTieringConfigurationCommand = PutBucketIntelligentTieringConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketInventoryConfigurationCommand.js
var require_PutBucketInventoryConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketInventoryConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketInventoryConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketInventoryConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketInventoryConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.PutBucketInventoryConfigurationRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketInventoryConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketInventoryConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketInventoryConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketInventoryConfigurationCommand = PutBucketInventoryConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketLifecycleConfigurationCommand.js
var require_PutBucketLifecycleConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketLifecycleConfigurationCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketLifecycleConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketLifecycleConfigurationCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketLifecycleConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketLifecycleConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketLifecycleConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketLifecycleConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketLifecycleConfigurationCommand = PutBucketLifecycleConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketLoggingCommand.js
var require_PutBucketLoggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketLoggingCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketLoggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketLoggingCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketLoggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketLogging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketLoggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketLoggingCommand)(output, context);
    }
  }
  exports.PutBucketLoggingCommand = PutBucketLoggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketMetricsConfigurationCommand.js
var require_PutBucketMetricsConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketMetricsConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketMetricsConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketMetricsConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketMetricsConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketMetricsConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketMetricsConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketMetricsConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketMetricsConfigurationCommand = PutBucketMetricsConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketNotificationConfigurationCommand.js
var require_PutBucketNotificationConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketNotificationConfigurationCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketNotificationConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketNotificationConfigurationCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketNotificationConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketNotificationConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketNotificationConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketNotificationConfigurationCommand)(output, context);
    }
  }
  exports.PutBucketNotificationConfigurationCommand = PutBucketNotificationConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketOwnershipControlsCommand.js
var require_PutBucketOwnershipControlsCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketOwnershipControlsCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketOwnershipControlsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketOwnershipControlsCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, { input: this.input, requestChecksumRequired: true }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketOwnershipControlsCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketOwnershipControls"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketOwnershipControlsCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketOwnershipControlsCommand)(output, context);
    }
  }
  exports.PutBucketOwnershipControlsCommand = PutBucketOwnershipControlsCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketPolicyCommand.js
var require_PutBucketPolicyCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketPolicyCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketPolicyCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketPolicyCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketPolicy"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketPolicyCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketPolicyCommand)(output, context);
    }
  }
  exports.PutBucketPolicyCommand = PutBucketPolicyCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketReplicationCommand.js
var require_PutBucketReplicationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketReplicationCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketReplicationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketReplicationCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketReplicationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketReplication"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketReplicationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketReplicationCommand)(output, context);
    }
  }
  exports.PutBucketReplicationCommand = PutBucketReplicationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketRequestPaymentCommand.js
var require_PutBucketRequestPaymentCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketRequestPaymentCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketRequestPaymentCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketRequestPaymentCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketRequestPaymentCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketRequestPayment"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketRequestPaymentCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketRequestPaymentCommand)(output, context);
    }
  }
  exports.PutBucketRequestPaymentCommand = PutBucketRequestPaymentCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketTaggingCommand.js
var require_PutBucketTaggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketTaggingCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketTaggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketTaggingCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketTaggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketTagging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketTaggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketTaggingCommand)(output, context);
    }
  }
  exports.PutBucketTaggingCommand = PutBucketTaggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketVersioningCommand.js
var require_PutBucketVersioningCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketVersioningCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketVersioningCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketVersioningCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketVersioningCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketVersioning"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketVersioningCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketVersioningCommand)(output, context);
    }
  }
  exports.PutBucketVersioningCommand = PutBucketVersioningCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutBucketWebsiteCommand.js
var require_PutBucketWebsiteCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutBucketWebsiteCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutBucketWebsiteCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutBucketWebsiteCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutBucketWebsiteCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutBucketWebsite"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutBucketWebsiteCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutBucketWebsiteCommand)(output, context);
    }
  }
  exports.PutBucketWebsiteCommand = PutBucketWebsiteCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutObjectAclCommand.js
var require_PutObjectAclCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutObjectAclCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutObjectAclCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutObjectAclCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutObjectAclCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutObjectAcl"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutObjectAclCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutObjectAclCommand)(output, context);
    }
  }
  exports.PutObjectAclCommand = PutObjectAclCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutObjectCommand.js
var require_PutObjectCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutObjectCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_sdk_s3_1 = require_dist_cjs18();
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_0_1 = require_models_03();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutObjectCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutObjectCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_sdk_s3_1.getCheckContentLengthHeaderPlugin)(configuration));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: false
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutObjectCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_0_1.PutObjectRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_0_1.PutObjectOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutObject"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutObjectCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutObjectCommand)(output, context);
    }
  }
  exports.PutObjectCommand = PutObjectCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutObjectLegalHoldCommand.js
var require_PutObjectLegalHoldCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutObjectLegalHoldCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutObjectLegalHoldCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutObjectLegalHoldCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutObjectLegalHoldCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutObjectLegalHold"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutObjectLegalHoldCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutObjectLegalHoldCommand)(output, context);
    }
  }
  exports.PutObjectLegalHoldCommand = PutObjectLegalHoldCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutObjectLockConfigurationCommand.js
var require_PutObjectLockConfigurationCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutObjectLockConfigurationCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutObjectLockConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutObjectLockConfigurationCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutObjectLockConfigurationCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutObjectLockConfiguration"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutObjectLockConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutObjectLockConfigurationCommand)(output, context);
    }
  }
  exports.PutObjectLockConfigurationCommand = PutObjectLockConfigurationCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutObjectRetentionCommand.js
var require_PutObjectRetentionCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutObjectRetentionCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutObjectRetentionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutObjectRetentionCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutObjectRetentionCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutObjectRetention"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutObjectRetentionCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutObjectRetentionCommand)(output, context);
    }
  }
  exports.PutObjectRetentionCommand = PutObjectRetentionCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutObjectTaggingCommand.js
var require_PutObjectTaggingCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutObjectTaggingCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutObjectTaggingCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutObjectTaggingCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutObjectTaggingCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutObjectTagging"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutObjectTaggingCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutObjectTaggingCommand)(output, context);
    }
  }
  exports.PutObjectTaggingCommand = PutObjectTaggingCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/PutPublicAccessBlockCommand.js
var require_PutPublicAccessBlockCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PutPublicAccessBlockCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var Aws_restXml_1 = require_Aws_restXml();

  class PutPublicAccessBlockCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutPublicAccessBlockCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: true
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "PutPublicAccessBlockCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: (_) => _,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "PutPublicAccessBlock"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_PutPublicAccessBlockCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_PutPublicAccessBlockCommand)(output, context);
    }
  }
  exports.PutPublicAccessBlockCommand = PutPublicAccessBlockCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/RestoreObjectCommand.js
var require_RestoreObjectCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestoreObjectCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_1_1 = require_models_1();
  var Aws_restXml_1 = require_Aws_restXml();

  class RestoreObjectCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RestoreObjectCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: false
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "RestoreObjectCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_1_1.RestoreObjectRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "RestoreObject"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_RestoreObjectCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_RestoreObjectCommand)(output, context);
    }
  }
  exports.RestoreObjectCommand = RestoreObjectCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/SelectObjectContentCommand.js
var require_SelectObjectContentCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SelectObjectContentCommand = exports.$Command = undefined;
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_1_1 = require_models_1();
  var Aws_restXml_1 = require_Aws_restXml();

  class SelectObjectContentCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SelectObjectContentCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "SelectObjectContentCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_1_1.SelectObjectContentRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_1_1.SelectObjectContentOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "SelectObjectContent"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_SelectObjectContentCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_SelectObjectContentCommand)(output, context);
    }
  }
  exports.SelectObjectContentCommand = SelectObjectContentCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/UploadPartCommand.js
var require_UploadPartCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UploadPartCommand = exports.$Command = undefined;
  var middleware_flexible_checksums_1 = require_dist_cjs67();
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_1_1 = require_models_1();
  var Aws_restXml_1 = require_Aws_restXml();

  class UploadPartCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UploadPartCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      this.middlewareStack.use((0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(configuration, {
        input: this.input,
        requestAlgorithmMember: "ChecksumAlgorithm",
        requestChecksumRequired: false
      }));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "UploadPartCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_1_1.UploadPartRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_1_1.UploadPartOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "UploadPart"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_UploadPartCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_UploadPartCommand)(output, context);
    }
  }
  exports.UploadPartCommand = UploadPartCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/UploadPartCopyCommand.js
var require_UploadPartCopyCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UploadPartCopyCommand = exports.$Command = undefined;
  var middleware_sdk_s3_1 = require_dist_cjs18();
  var middleware_ssec_1 = require_dist_cjs65();
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_1_1 = require_models_1();
  var Aws_restXml_1 = require_Aws_restXml();

  class UploadPartCopyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        Bucket: { type: "contextParams", name: "Bucket" },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UploadPartCopyCommand.getEndpointParameterInstructions()));
      this.middlewareStack.use((0, middleware_sdk_s3_1.getThrow200ExceptionsPlugin)(configuration));
      this.middlewareStack.use((0, middleware_ssec_1.getSsecPlugin)(configuration));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "UploadPartCopyCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_1_1.UploadPartCopyRequestFilterSensitiveLog,
        outputFilterSensitiveLog: models_1_1.UploadPartCopyOutputFilterSensitiveLog,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "UploadPartCopy"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_UploadPartCopyCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_UploadPartCopyCommand)(output, context);
    }
  }
  exports.UploadPartCopyCommand = UploadPartCopyCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/WriteGetObjectResponseCommand.js
var require_WriteGetObjectResponseCommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteGetObjectResponseCommand = exports.$Command = undefined;
  var middleware_endpoint_1 = require_dist_cjs38();
  var middleware_serde_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs16();
  Object.defineProperty(exports, "$Command", { enumerable: true, get: function() {
    return smithy_client_1.Command;
  } });
  var types_1 = require_dist_cjs();
  var models_1_1 = require_models_1();
  var Aws_restXml_1 = require_Aws_restXml();

  class WriteGetObjectResponseCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
      return {
        UseObjectLambdaEndpoint: { type: "staticContextParams", value: true },
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
        Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
      };
    }
    constructor(input) {
      super();
      this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options5) {
      this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
      this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, WriteGetObjectResponseCommand.getEndpointParameterInstructions()));
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const clientName = "S3Client";
      const commandName = "WriteGetObjectResponseCommand";
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog: models_1_1.WriteGetObjectResponseRequestFilterSensitiveLog,
        outputFilterSensitiveLog: (_) => _,
        [types_1.SMITHY_CONTEXT_KEY]: {
          service: "AmazonS3",
          operation: "WriteGetObjectResponse"
        }
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options5 || {}), handlerExecutionContext);
    }
    serialize(input, context) {
      return (0, Aws_restXml_1.se_WriteGetObjectResponseCommand)(input, context);
    }
    deserialize(output, context) {
      return (0, Aws_restXml_1.de_WriteGetObjectResponseCommand)(output, context);
    }
  }
  exports.WriteGetObjectResponseCommand = WriteGetObjectResponseCommand;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/S3.js
var require_S3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3 = undefined;
  var smithy_client_1 = require_dist_cjs16();
  var AbortMultipartUploadCommand_1 = require_AbortMultipartUploadCommand();
  var CompleteMultipartUploadCommand_1 = require_CompleteMultipartUploadCommand();
  var CopyObjectCommand_1 = require_CopyObjectCommand();
  var CreateBucketCommand_1 = require_CreateBucketCommand();
  var CreateMultipartUploadCommand_1 = require_CreateMultipartUploadCommand();
  var DeleteBucketAnalyticsConfigurationCommand_1 = require_DeleteBucketAnalyticsConfigurationCommand();
  var DeleteBucketCommand_1 = require_DeleteBucketCommand();
  var DeleteBucketCorsCommand_1 = require_DeleteBucketCorsCommand();
  var DeleteBucketEncryptionCommand_1 = require_DeleteBucketEncryptionCommand();
  var DeleteBucketIntelligentTieringConfigurationCommand_1 = require_DeleteBucketIntelligentTieringConfigurationCommand();
  var DeleteBucketInventoryConfigurationCommand_1 = require_DeleteBucketInventoryConfigurationCommand();
  var DeleteBucketLifecycleCommand_1 = require_DeleteBucketLifecycleCommand();
  var DeleteBucketMetricsConfigurationCommand_1 = require_DeleteBucketMetricsConfigurationCommand();
  var DeleteBucketOwnershipControlsCommand_1 = require_DeleteBucketOwnershipControlsCommand();
  var DeleteBucketPolicyCommand_1 = require_DeleteBucketPolicyCommand();
  var DeleteBucketReplicationCommand_1 = require_DeleteBucketReplicationCommand();
  var DeleteBucketTaggingCommand_1 = require_DeleteBucketTaggingCommand();
  var DeleteBucketWebsiteCommand_1 = require_DeleteBucketWebsiteCommand();
  var DeleteObjectCommand_1 = require_DeleteObjectCommand();
  var DeleteObjectsCommand_1 = require_DeleteObjectsCommand();
  var DeleteObjectTaggingCommand_1 = require_DeleteObjectTaggingCommand();
  var DeletePublicAccessBlockCommand_1 = require_DeletePublicAccessBlockCommand();
  var GetBucketAccelerateConfigurationCommand_1 = require_GetBucketAccelerateConfigurationCommand();
  var GetBucketAclCommand_1 = require_GetBucketAclCommand();
  var GetBucketAnalyticsConfigurationCommand_1 = require_GetBucketAnalyticsConfigurationCommand();
  var GetBucketCorsCommand_1 = require_GetBucketCorsCommand();
  var GetBucketEncryptionCommand_1 = require_GetBucketEncryptionCommand();
  var GetBucketIntelligentTieringConfigurationCommand_1 = require_GetBucketIntelligentTieringConfigurationCommand();
  var GetBucketInventoryConfigurationCommand_1 = require_GetBucketInventoryConfigurationCommand();
  var GetBucketLifecycleConfigurationCommand_1 = require_GetBucketLifecycleConfigurationCommand();
  var GetBucketLocationCommand_1 = require_GetBucketLocationCommand();
  var GetBucketLoggingCommand_1 = require_GetBucketLoggingCommand();
  var GetBucketMetricsConfigurationCommand_1 = require_GetBucketMetricsConfigurationCommand();
  var GetBucketNotificationConfigurationCommand_1 = require_GetBucketNotificationConfigurationCommand();
  var GetBucketOwnershipControlsCommand_1 = require_GetBucketOwnershipControlsCommand();
  var GetBucketPolicyCommand_1 = require_GetBucketPolicyCommand();
  var GetBucketPolicyStatusCommand_1 = require_GetBucketPolicyStatusCommand();
  var GetBucketReplicationCommand_1 = require_GetBucketReplicationCommand();
  var GetBucketRequestPaymentCommand_1 = require_GetBucketRequestPaymentCommand();
  var GetBucketTaggingCommand_1 = require_GetBucketTaggingCommand();
  var GetBucketVersioningCommand_1 = require_GetBucketVersioningCommand();
  var GetBucketWebsiteCommand_1 = require_GetBucketWebsiteCommand();
  var GetObjectAclCommand_1 = require_GetObjectAclCommand();
  var GetObjectAttributesCommand_1 = require_GetObjectAttributesCommand();
  var GetObjectCommand_1 = require_GetObjectCommand();
  var GetObjectLegalHoldCommand_1 = require_GetObjectLegalHoldCommand();
  var GetObjectLockConfigurationCommand_1 = require_GetObjectLockConfigurationCommand();
  var GetObjectRetentionCommand_1 = require_GetObjectRetentionCommand();
  var GetObjectTaggingCommand_1 = require_GetObjectTaggingCommand();
  var GetObjectTorrentCommand_1 = require_GetObjectTorrentCommand();
  var GetPublicAccessBlockCommand_1 = require_GetPublicAccessBlockCommand();
  var HeadBucketCommand_1 = require_HeadBucketCommand();
  var HeadObjectCommand_1 = require_HeadObjectCommand();
  var ListBucketAnalyticsConfigurationsCommand_1 = require_ListBucketAnalyticsConfigurationsCommand();
  var ListBucketIntelligentTieringConfigurationsCommand_1 = require_ListBucketIntelligentTieringConfigurationsCommand();
  var ListBucketInventoryConfigurationsCommand_1 = require_ListBucketInventoryConfigurationsCommand();
  var ListBucketMetricsConfigurationsCommand_1 = require_ListBucketMetricsConfigurationsCommand();
  var ListBucketsCommand_1 = require_ListBucketsCommand();
  var ListMultipartUploadsCommand_1 = require_ListMultipartUploadsCommand();
  var ListObjectsCommand_1 = require_ListObjectsCommand();
  var ListObjectsV2Command_1 = require_ListObjectsV2Command();
  var ListObjectVersionsCommand_1 = require_ListObjectVersionsCommand();
  var ListPartsCommand_1 = require_ListPartsCommand();
  var PutBucketAccelerateConfigurationCommand_1 = require_PutBucketAccelerateConfigurationCommand();
  var PutBucketAclCommand_1 = require_PutBucketAclCommand();
  var PutBucketAnalyticsConfigurationCommand_1 = require_PutBucketAnalyticsConfigurationCommand();
  var PutBucketCorsCommand_1 = require_PutBucketCorsCommand();
  var PutBucketEncryptionCommand_1 = require_PutBucketEncryptionCommand();
  var PutBucketIntelligentTieringConfigurationCommand_1 = require_PutBucketIntelligentTieringConfigurationCommand();
  var PutBucketInventoryConfigurationCommand_1 = require_PutBucketInventoryConfigurationCommand();
  var PutBucketLifecycleConfigurationCommand_1 = require_PutBucketLifecycleConfigurationCommand();
  var PutBucketLoggingCommand_1 = require_PutBucketLoggingCommand();
  var PutBucketMetricsConfigurationCommand_1 = require_PutBucketMetricsConfigurationCommand();
  var PutBucketNotificationConfigurationCommand_1 = require_PutBucketNotificationConfigurationCommand();
  var PutBucketOwnershipControlsCommand_1 = require_PutBucketOwnershipControlsCommand();
  var PutBucketPolicyCommand_1 = require_PutBucketPolicyCommand();
  var PutBucketReplicationCommand_1 = require_PutBucketReplicationCommand();
  var PutBucketRequestPaymentCommand_1 = require_PutBucketRequestPaymentCommand();
  var PutBucketTaggingCommand_1 = require_PutBucketTaggingCommand();
  var PutBucketVersioningCommand_1 = require_PutBucketVersioningCommand();
  var PutBucketWebsiteCommand_1 = require_PutBucketWebsiteCommand();
  var PutObjectAclCommand_1 = require_PutObjectAclCommand();
  var PutObjectCommand_1 = require_PutObjectCommand();
  var PutObjectLegalHoldCommand_1 = require_PutObjectLegalHoldCommand();
  var PutObjectLockConfigurationCommand_1 = require_PutObjectLockConfigurationCommand();
  var PutObjectRetentionCommand_1 = require_PutObjectRetentionCommand();
  var PutObjectTaggingCommand_1 = require_PutObjectTaggingCommand();
  var PutPublicAccessBlockCommand_1 = require_PutPublicAccessBlockCommand();
  var RestoreObjectCommand_1 = require_RestoreObjectCommand();
  var SelectObjectContentCommand_1 = require_SelectObjectContentCommand();
  var UploadPartCommand_1 = require_UploadPartCommand();
  var UploadPartCopyCommand_1 = require_UploadPartCopyCommand();
  var WriteGetObjectResponseCommand_1 = require_WriteGetObjectResponseCommand();
  var S3Client_1 = require_S3Client();
  var commands = {
    AbortMultipartUploadCommand: AbortMultipartUploadCommand_1.AbortMultipartUploadCommand,
    CompleteMultipartUploadCommand: CompleteMultipartUploadCommand_1.CompleteMultipartUploadCommand,
    CopyObjectCommand: CopyObjectCommand_1.CopyObjectCommand,
    CreateBucketCommand: CreateBucketCommand_1.CreateBucketCommand,
    CreateMultipartUploadCommand: CreateMultipartUploadCommand_1.CreateMultipartUploadCommand,
    DeleteBucketCommand: DeleteBucketCommand_1.DeleteBucketCommand,
    DeleteBucketAnalyticsConfigurationCommand: DeleteBucketAnalyticsConfigurationCommand_1.DeleteBucketAnalyticsConfigurationCommand,
    DeleteBucketCorsCommand: DeleteBucketCorsCommand_1.DeleteBucketCorsCommand,
    DeleteBucketEncryptionCommand: DeleteBucketEncryptionCommand_1.DeleteBucketEncryptionCommand,
    DeleteBucketIntelligentTieringConfigurationCommand: DeleteBucketIntelligentTieringConfigurationCommand_1.DeleteBucketIntelligentTieringConfigurationCommand,
    DeleteBucketInventoryConfigurationCommand: DeleteBucketInventoryConfigurationCommand_1.DeleteBucketInventoryConfigurationCommand,
    DeleteBucketLifecycleCommand: DeleteBucketLifecycleCommand_1.DeleteBucketLifecycleCommand,
    DeleteBucketMetricsConfigurationCommand: DeleteBucketMetricsConfigurationCommand_1.DeleteBucketMetricsConfigurationCommand,
    DeleteBucketOwnershipControlsCommand: DeleteBucketOwnershipControlsCommand_1.DeleteBucketOwnershipControlsCommand,
    DeleteBucketPolicyCommand: DeleteBucketPolicyCommand_1.DeleteBucketPolicyCommand,
    DeleteBucketReplicationCommand: DeleteBucketReplicationCommand_1.DeleteBucketReplicationCommand,
    DeleteBucketTaggingCommand: DeleteBucketTaggingCommand_1.DeleteBucketTaggingCommand,
    DeleteBucketWebsiteCommand: DeleteBucketWebsiteCommand_1.DeleteBucketWebsiteCommand,
    DeleteObjectCommand: DeleteObjectCommand_1.DeleteObjectCommand,
    DeleteObjectsCommand: DeleteObjectsCommand_1.DeleteObjectsCommand,
    DeleteObjectTaggingCommand: DeleteObjectTaggingCommand_1.DeleteObjectTaggingCommand,
    DeletePublicAccessBlockCommand: DeletePublicAccessBlockCommand_1.DeletePublicAccessBlockCommand,
    GetBucketAccelerateConfigurationCommand: GetBucketAccelerateConfigurationCommand_1.GetBucketAccelerateConfigurationCommand,
    GetBucketAclCommand: GetBucketAclCommand_1.GetBucketAclCommand,
    GetBucketAnalyticsConfigurationCommand: GetBucketAnalyticsConfigurationCommand_1.GetBucketAnalyticsConfigurationCommand,
    GetBucketCorsCommand: GetBucketCorsCommand_1.GetBucketCorsCommand,
    GetBucketEncryptionCommand: GetBucketEncryptionCommand_1.GetBucketEncryptionCommand,
    GetBucketIntelligentTieringConfigurationCommand: GetBucketIntelligentTieringConfigurationCommand_1.GetBucketIntelligentTieringConfigurationCommand,
    GetBucketInventoryConfigurationCommand: GetBucketInventoryConfigurationCommand_1.GetBucketInventoryConfigurationCommand,
    GetBucketLifecycleConfigurationCommand: GetBucketLifecycleConfigurationCommand_1.GetBucketLifecycleConfigurationCommand,
    GetBucketLocationCommand: GetBucketLocationCommand_1.GetBucketLocationCommand,
    GetBucketLoggingCommand: GetBucketLoggingCommand_1.GetBucketLoggingCommand,
    GetBucketMetricsConfigurationCommand: GetBucketMetricsConfigurationCommand_1.GetBucketMetricsConfigurationCommand,
    GetBucketNotificationConfigurationCommand: GetBucketNotificationConfigurationCommand_1.GetBucketNotificationConfigurationCommand,
    GetBucketOwnershipControlsCommand: GetBucketOwnershipControlsCommand_1.GetBucketOwnershipControlsCommand,
    GetBucketPolicyCommand: GetBucketPolicyCommand_1.GetBucketPolicyCommand,
    GetBucketPolicyStatusCommand: GetBucketPolicyStatusCommand_1.GetBucketPolicyStatusCommand,
    GetBucketReplicationCommand: GetBucketReplicationCommand_1.GetBucketReplicationCommand,
    GetBucketRequestPaymentCommand: GetBucketRequestPaymentCommand_1.GetBucketRequestPaymentCommand,
    GetBucketTaggingCommand: GetBucketTaggingCommand_1.GetBucketTaggingCommand,
    GetBucketVersioningCommand: GetBucketVersioningCommand_1.GetBucketVersioningCommand,
    GetBucketWebsiteCommand: GetBucketWebsiteCommand_1.GetBucketWebsiteCommand,
    GetObjectCommand: GetObjectCommand_1.GetObjectCommand,
    GetObjectAclCommand: GetObjectAclCommand_1.GetObjectAclCommand,
    GetObjectAttributesCommand: GetObjectAttributesCommand_1.GetObjectAttributesCommand,
    GetObjectLegalHoldCommand: GetObjectLegalHoldCommand_1.GetObjectLegalHoldCommand,
    GetObjectLockConfigurationCommand: GetObjectLockConfigurationCommand_1.GetObjectLockConfigurationCommand,
    GetObjectRetentionCommand: GetObjectRetentionCommand_1.GetObjectRetentionCommand,
    GetObjectTaggingCommand: GetObjectTaggingCommand_1.GetObjectTaggingCommand,
    GetObjectTorrentCommand: GetObjectTorrentCommand_1.GetObjectTorrentCommand,
    GetPublicAccessBlockCommand: GetPublicAccessBlockCommand_1.GetPublicAccessBlockCommand,
    HeadBucketCommand: HeadBucketCommand_1.HeadBucketCommand,
    HeadObjectCommand: HeadObjectCommand_1.HeadObjectCommand,
    ListBucketAnalyticsConfigurationsCommand: ListBucketAnalyticsConfigurationsCommand_1.ListBucketAnalyticsConfigurationsCommand,
    ListBucketIntelligentTieringConfigurationsCommand: ListBucketIntelligentTieringConfigurationsCommand_1.ListBucketIntelligentTieringConfigurationsCommand,
    ListBucketInventoryConfigurationsCommand: ListBucketInventoryConfigurationsCommand_1.ListBucketInventoryConfigurationsCommand,
    ListBucketMetricsConfigurationsCommand: ListBucketMetricsConfigurationsCommand_1.ListBucketMetricsConfigurationsCommand,
    ListBucketsCommand: ListBucketsCommand_1.ListBucketsCommand,
    ListMultipartUploadsCommand: ListMultipartUploadsCommand_1.ListMultipartUploadsCommand,
    ListObjectsCommand: ListObjectsCommand_1.ListObjectsCommand,
    ListObjectsV2Command: ListObjectsV2Command_1.ListObjectsV2Command,
    ListObjectVersionsCommand: ListObjectVersionsCommand_1.ListObjectVersionsCommand,
    ListPartsCommand: ListPartsCommand_1.ListPartsCommand,
    PutBucketAccelerateConfigurationCommand: PutBucketAccelerateConfigurationCommand_1.PutBucketAccelerateConfigurationCommand,
    PutBucketAclCommand: PutBucketAclCommand_1.PutBucketAclCommand,
    PutBucketAnalyticsConfigurationCommand: PutBucketAnalyticsConfigurationCommand_1.PutBucketAnalyticsConfigurationCommand,
    PutBucketCorsCommand: PutBucketCorsCommand_1.PutBucketCorsCommand,
    PutBucketEncryptionCommand: PutBucketEncryptionCommand_1.PutBucketEncryptionCommand,
    PutBucketIntelligentTieringConfigurationCommand: PutBucketIntelligentTieringConfigurationCommand_1.PutBucketIntelligentTieringConfigurationCommand,
    PutBucketInventoryConfigurationCommand: PutBucketInventoryConfigurationCommand_1.PutBucketInventoryConfigurationCommand,
    PutBucketLifecycleConfigurationCommand: PutBucketLifecycleConfigurationCommand_1.PutBucketLifecycleConfigurationCommand,
    PutBucketLoggingCommand: PutBucketLoggingCommand_1.PutBucketLoggingCommand,
    PutBucketMetricsConfigurationCommand: PutBucketMetricsConfigurationCommand_1.PutBucketMetricsConfigurationCommand,
    PutBucketNotificationConfigurationCommand: PutBucketNotificationConfigurationCommand_1.PutBucketNotificationConfigurationCommand,
    PutBucketOwnershipControlsCommand: PutBucketOwnershipControlsCommand_1.PutBucketOwnershipControlsCommand,
    PutBucketPolicyCommand: PutBucketPolicyCommand_1.PutBucketPolicyCommand,
    PutBucketReplicationCommand: PutBucketReplicationCommand_1.PutBucketReplicationCommand,
    PutBucketRequestPaymentCommand: PutBucketRequestPaymentCommand_1.PutBucketRequestPaymentCommand,
    PutBucketTaggingCommand: PutBucketTaggingCommand_1.PutBucketTaggingCommand,
    PutBucketVersioningCommand: PutBucketVersioningCommand_1.PutBucketVersioningCommand,
    PutBucketWebsiteCommand: PutBucketWebsiteCommand_1.PutBucketWebsiteCommand,
    PutObjectCommand: PutObjectCommand_1.PutObjectCommand,
    PutObjectAclCommand: PutObjectAclCommand_1.PutObjectAclCommand,
    PutObjectLegalHoldCommand: PutObjectLegalHoldCommand_1.PutObjectLegalHoldCommand,
    PutObjectLockConfigurationCommand: PutObjectLockConfigurationCommand_1.PutObjectLockConfigurationCommand,
    PutObjectRetentionCommand: PutObjectRetentionCommand_1.PutObjectRetentionCommand,
    PutObjectTaggingCommand: PutObjectTaggingCommand_1.PutObjectTaggingCommand,
    PutPublicAccessBlockCommand: PutPublicAccessBlockCommand_1.PutPublicAccessBlockCommand,
    RestoreObjectCommand: RestoreObjectCommand_1.RestoreObjectCommand,
    SelectObjectContentCommand: SelectObjectContentCommand_1.SelectObjectContentCommand,
    UploadPartCommand: UploadPartCommand_1.UploadPartCommand,
    UploadPartCopyCommand: UploadPartCopyCommand_1.UploadPartCopyCommand,
    WriteGetObjectResponseCommand: WriteGetObjectResponseCommand_1.WriteGetObjectResponseCommand
  };

  class S3 extends S3Client_1.S3Client {
  }
  exports.S3 = S3;
  (0, smithy_client_1.createAggregatedClient)(commands, S3);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/commands/index.js
var require_commands3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_AbortMultipartUploadCommand(), exports);
  tslib_1.__exportStar(require_CompleteMultipartUploadCommand(), exports);
  tslib_1.__exportStar(require_CopyObjectCommand(), exports);
  tslib_1.__exportStar(require_CreateBucketCommand(), exports);
  tslib_1.__exportStar(require_CreateMultipartUploadCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketAnalyticsConfigurationCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketCorsCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketEncryptionCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketIntelligentTieringConfigurationCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketInventoryConfigurationCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketLifecycleCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketMetricsConfigurationCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketOwnershipControlsCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketPolicyCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketReplicationCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketTaggingCommand(), exports);
  tslib_1.__exportStar(require_DeleteBucketWebsiteCommand(), exports);
  tslib_1.__exportStar(require_DeleteObjectCommand(), exports);
  tslib_1.__exportStar(require_DeleteObjectTaggingCommand(), exports);
  tslib_1.__exportStar(require_DeleteObjectsCommand(), exports);
  tslib_1.__exportStar(require_DeletePublicAccessBlockCommand(), exports);
  tslib_1.__exportStar(require_GetBucketAccelerateConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketAclCommand(), exports);
  tslib_1.__exportStar(require_GetBucketAnalyticsConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketCorsCommand(), exports);
  tslib_1.__exportStar(require_GetBucketEncryptionCommand(), exports);
  tslib_1.__exportStar(require_GetBucketIntelligentTieringConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketInventoryConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketLifecycleConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketLocationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketLoggingCommand(), exports);
  tslib_1.__exportStar(require_GetBucketMetricsConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketNotificationConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketOwnershipControlsCommand(), exports);
  tslib_1.__exportStar(require_GetBucketPolicyCommand(), exports);
  tslib_1.__exportStar(require_GetBucketPolicyStatusCommand(), exports);
  tslib_1.__exportStar(require_GetBucketReplicationCommand(), exports);
  tslib_1.__exportStar(require_GetBucketRequestPaymentCommand(), exports);
  tslib_1.__exportStar(require_GetBucketTaggingCommand(), exports);
  tslib_1.__exportStar(require_GetBucketVersioningCommand(), exports);
  tslib_1.__exportStar(require_GetBucketWebsiteCommand(), exports);
  tslib_1.__exportStar(require_GetObjectAclCommand(), exports);
  tslib_1.__exportStar(require_GetObjectAttributesCommand(), exports);
  tslib_1.__exportStar(require_GetObjectCommand(), exports);
  tslib_1.__exportStar(require_GetObjectLegalHoldCommand(), exports);
  tslib_1.__exportStar(require_GetObjectLockConfigurationCommand(), exports);
  tslib_1.__exportStar(require_GetObjectRetentionCommand(), exports);
  tslib_1.__exportStar(require_GetObjectTaggingCommand(), exports);
  tslib_1.__exportStar(require_GetObjectTorrentCommand(), exports);
  tslib_1.__exportStar(require_GetPublicAccessBlockCommand(), exports);
  tslib_1.__exportStar(require_HeadBucketCommand(), exports);
  tslib_1.__exportStar(require_HeadObjectCommand(), exports);
  tslib_1.__exportStar(require_ListBucketAnalyticsConfigurationsCommand(), exports);
  tslib_1.__exportStar(require_ListBucketIntelligentTieringConfigurationsCommand(), exports);
  tslib_1.__exportStar(require_ListBucketInventoryConfigurationsCommand(), exports);
  tslib_1.__exportStar(require_ListBucketMetricsConfigurationsCommand(), exports);
  tslib_1.__exportStar(require_ListBucketsCommand(), exports);
  tslib_1.__exportStar(require_ListMultipartUploadsCommand(), exports);
  tslib_1.__exportStar(require_ListObjectVersionsCommand(), exports);
  tslib_1.__exportStar(require_ListObjectsCommand(), exports);
  tslib_1.__exportStar(require_ListObjectsV2Command(), exports);
  tslib_1.__exportStar(require_ListPartsCommand(), exports);
  tslib_1.__exportStar(require_PutBucketAccelerateConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketAclCommand(), exports);
  tslib_1.__exportStar(require_PutBucketAnalyticsConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketCorsCommand(), exports);
  tslib_1.__exportStar(require_PutBucketEncryptionCommand(), exports);
  tslib_1.__exportStar(require_PutBucketIntelligentTieringConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketInventoryConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketLifecycleConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketLoggingCommand(), exports);
  tslib_1.__exportStar(require_PutBucketMetricsConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketNotificationConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketOwnershipControlsCommand(), exports);
  tslib_1.__exportStar(require_PutBucketPolicyCommand(), exports);
  tslib_1.__exportStar(require_PutBucketReplicationCommand(), exports);
  tslib_1.__exportStar(require_PutBucketRequestPaymentCommand(), exports);
  tslib_1.__exportStar(require_PutBucketTaggingCommand(), exports);
  tslib_1.__exportStar(require_PutBucketVersioningCommand(), exports);
  tslib_1.__exportStar(require_PutBucketWebsiteCommand(), exports);
  tslib_1.__exportStar(require_PutObjectAclCommand(), exports);
  tslib_1.__exportStar(require_PutObjectCommand(), exports);
  tslib_1.__exportStar(require_PutObjectLegalHoldCommand(), exports);
  tslib_1.__exportStar(require_PutObjectLockConfigurationCommand(), exports);
  tslib_1.__exportStar(require_PutObjectRetentionCommand(), exports);
  tslib_1.__exportStar(require_PutObjectTaggingCommand(), exports);
  tslib_1.__exportStar(require_PutPublicAccessBlockCommand(), exports);
  tslib_1.__exportStar(require_RestoreObjectCommand(), exports);
  tslib_1.__exportStar(require_SelectObjectContentCommand(), exports);
  tslib_1.__exportStar(require_UploadPartCommand(), exports);
  tslib_1.__exportStar(require_UploadPartCopyCommand(), exports);
  tslib_1.__exportStar(require_WriteGetObjectResponseCommand(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/pagination/Interfaces.js
var require_Interfaces2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@aws-sdk/client-s3/dist-cjs/pagination/ListObjectsV2Paginator.js
var require_ListObjectsV2Paginator = __commonJS((exports) => {
  async function* paginateListObjectsV2(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
      input.ContinuationToken = token;
      input["MaxKeys"] = config.pageSize;
      if (config.client instanceof S3Client_1.S3Client) {
        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
      } else {
        throw new Error("Invalid client, expected S3 | S3Client");
      }
      yield page;
      const prevToken = token;
      token = page.NextContinuationToken;
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.paginateListObjectsV2 = undefined;
  var ListObjectsV2Command_1 = require_ListObjectsV2Command();
  var S3Client_1 = require_S3Client();
  var makePagedClientRequest = async (client2, input, ...args) => {
    return await client2.send(new ListObjectsV2Command_1.ListObjectsV2Command(input), ...args);
  };
  exports.paginateListObjectsV2 = paginateListObjectsV2;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/pagination/ListPartsPaginator.js
var require_ListPartsPaginator = __commonJS((exports) => {
  async function* paginateListParts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
      input.PartNumberMarker = token;
      input["MaxParts"] = config.pageSize;
      if (config.client instanceof S3Client_1.S3Client) {
        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
      } else {
        throw new Error("Invalid client, expected S3 | S3Client");
      }
      yield page;
      const prevToken = token;
      token = page.NextPartNumberMarker;
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.paginateListParts = undefined;
  var ListPartsCommand_1 = require_ListPartsCommand();
  var S3Client_1 = require_S3Client();
  var makePagedClientRequest = async (client2, input, ...args) => {
    return await client2.send(new ListPartsCommand_1.ListPartsCommand(input), ...args);
  };
  exports.paginateListParts = paginateListParts;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/pagination/index.js
var require_pagination3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_Interfaces2(), exports);
  tslib_1.__exportStar(require_ListObjectsV2Paginator(), exports);
  tslib_1.__exportStar(require_ListPartsPaginator(), exports);
});

// node_modules/@smithy/util-waiter/dist-cjs/utils/sleep.js
var require_sleep = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sleep = undefined;
  var sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
  };
  exports.sleep = sleep;
});

// node_modules/@smithy/util-waiter/dist-cjs/waiter.js
var require_waiter2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkExceptions = exports.WaiterState = exports.waiterServiceDefaults = undefined;
  exports.waiterServiceDefaults = {
    minDelay: 2,
    maxDelay: 120
  };
  var WaiterState;
  (function(WaiterState2) {
    WaiterState2["ABORTED"] = "ABORTED";
    WaiterState2["FAILURE"] = "FAILURE";
    WaiterState2["SUCCESS"] = "SUCCESS";
    WaiterState2["RETRY"] = "RETRY";
    WaiterState2["TIMEOUT"] = "TIMEOUT";
  })(WaiterState = exports.WaiterState || (exports.WaiterState = {}));
  var checkExceptions = (result) => {
    if (result.state === WaiterState.ABORTED) {
      const abortError = new Error(`${JSON.stringify({
        ...result,
        reason: "Request was aborted"
      })}`);
      abortError.name = "AbortError";
      throw abortError;
    } else if (result.state === WaiterState.TIMEOUT) {
      const timeoutError = new Error(`${JSON.stringify({
        ...result,
        reason: "Waiter has timed out"
      })}`);
      timeoutError.name = "TimeoutError";
      throw timeoutError;
    } else if (result.state !== WaiterState.SUCCESS) {
      throw new Error(`${JSON.stringify({ result })}`);
    }
    return result;
  };
  exports.checkExceptions = checkExceptions;
});

// node_modules/@smithy/util-waiter/dist-cjs/poller.js
var require_poller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.runPolling = undefined;
  var sleep_1 = require_sleep();
  var waiter_1 = require_waiter2();
  var exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
    if (attempt > attemptCeiling)
      return maxDelay;
    const delay2 = minDelay * 2 ** (attempt - 1);
    return randomInRange(minDelay, delay2);
  };
  var randomInRange = (min, max) => min + Math.random() * (max - min);
  var runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client: client2, abortSignal }, input, acceptorChecks) => {
    var _a;
    const { state, reason } = await acceptorChecks(client2, input);
    if (state !== waiter_1.WaiterState.RETRY) {
      return { state, reason };
    }
    let currentAttempt = 1;
    const waitUntil = Date.now() + maxWaitTime * 1000;
    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
    while (true) {
      if (((_a = abortController === null || abortController === undefined ? undefined : abortController.signal) === null || _a === undefined ? undefined : _a.aborted) || (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted)) {
        return { state: waiter_1.WaiterState.ABORTED };
      }
      const delay2 = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
      if (Date.now() + delay2 * 1000 > waitUntil) {
        return { state: waiter_1.WaiterState.TIMEOUT };
      }
      await (0, sleep_1.sleep)(delay2);
      const { state: state2, reason: reason2 } = await acceptorChecks(client2, input);
      if (state2 !== waiter_1.WaiterState.RETRY) {
        return { state: state2, reason: reason2 };
      }
      currentAttempt += 1;
    }
  };
  exports.runPolling = runPolling;
});

// node_modules/@smithy/util-waiter/dist-cjs/utils/validate.js
var require_validate2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateWaiterOptions = undefined;
  var validateWaiterOptions = (options5) => {
    if (options5.maxWaitTime < 1) {
      throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
    } else if (options5.minDelay < 1) {
      throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
    } else if (options5.maxDelay < 1) {
      throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
    } else if (options5.maxWaitTime <= options5.minDelay) {
      throw new Error(`WaiterConfiguration.maxWaitTime [${options5.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options5.minDelay}] for this waiter`);
    } else if (options5.maxDelay < options5.minDelay) {
      throw new Error(`WaiterConfiguration.maxDelay [${options5.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options5.minDelay}] for this waiter`);
    }
  };
  exports.validateWaiterOptions = validateWaiterOptions;
});

// node_modules/@smithy/util-waiter/dist-cjs/utils/index.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_sleep(), exports);
  tslib_1.__exportStar(require_validate2(), exports);
});

// node_modules/@smithy/util-waiter/dist-cjs/createWaiter.js
var require_createWaiter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createWaiter = undefined;
  var poller_1 = require_poller();
  var utils_1 = require_utils4();
  var waiter_1 = require_waiter2();
  var abortTimeout = async (abortSignal) => {
    return new Promise((resolve) => {
      abortSignal.onabort = () => resolve({ state: waiter_1.WaiterState.ABORTED });
    });
  };
  var createWaiter = async (options5, input, acceptorChecks) => {
    const params = {
      ...waiter_1.waiterServiceDefaults,
      ...options5
    };
    (0, utils_1.validateWaiterOptions)(params);
    const exitConditions = [(0, poller_1.runPolling)(params, input, acceptorChecks)];
    if (options5.abortController) {
      exitConditions.push(abortTimeout(options5.abortController.signal));
    }
    if (options5.abortSignal) {
      exitConditions.push(abortTimeout(options5.abortSignal));
    }
    return Promise.race(exitConditions);
  };
  exports.createWaiter = createWaiter;
});

// node_modules/@smithy/util-waiter/dist-cjs/index.js
var require_dist_cjs68 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_createWaiter(), exports);
  tslib_1.__exportStar(require_waiter2(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/waiters/waitForBucketExists.js
var require_waitForBucketExists = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.waitUntilBucketExists = exports.waitForBucketExists = undefined;
  var util_waiter_1 = require_dist_cjs68();
  var HeadBucketCommand_1 = require_HeadBucketCommand();
  var checkState = async (client2, input) => {
    let reason;
    try {
      const result = await client2.send(new HeadBucketCommand_1.HeadBucketCommand(input));
      reason = result;
      return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: util_waiter_1.WaiterState.RETRY, reason };
      }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
  };
  var waitForBucketExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
  };
  exports.waitForBucketExists = waitForBucketExists;
  var waitUntilBucketExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
  };
  exports.waitUntilBucketExists = waitUntilBucketExists;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/waiters/waitForBucketNotExists.js
var require_waitForBucketNotExists = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.waitUntilBucketNotExists = exports.waitForBucketNotExists = undefined;
  var util_waiter_1 = require_dist_cjs68();
  var HeadBucketCommand_1 = require_HeadBucketCommand();
  var checkState = async (client2, input) => {
    let reason;
    try {
      const result = await client2.send(new HeadBucketCommand_1.HeadBucketCommand(input));
      reason = result;
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
      }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
  };
  var waitForBucketNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
  };
  exports.waitForBucketNotExists = waitForBucketNotExists;
  var waitUntilBucketNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
  };
  exports.waitUntilBucketNotExists = waitUntilBucketNotExists;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/waiters/waitForObjectExists.js
var require_waitForObjectExists = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.waitUntilObjectExists = exports.waitForObjectExists = undefined;
  var util_waiter_1 = require_dist_cjs68();
  var HeadObjectCommand_1 = require_HeadObjectCommand();
  var checkState = async (client2, input) => {
    let reason;
    try {
      const result = await client2.send(new HeadObjectCommand_1.HeadObjectCommand(input));
      reason = result;
      return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: util_waiter_1.WaiterState.RETRY, reason };
      }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
  };
  var waitForObjectExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
  };
  exports.waitForObjectExists = waitForObjectExists;
  var waitUntilObjectExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
  };
  exports.waitUntilObjectExists = waitUntilObjectExists;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/waiters/waitForObjectNotExists.js
var require_waitForObjectNotExists = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.waitUntilObjectNotExists = exports.waitForObjectNotExists = undefined;
  var util_waiter_1 = require_dist_cjs68();
  var HeadObjectCommand_1 = require_HeadObjectCommand();
  var checkState = async (client2, input) => {
    let reason;
    try {
      const result = await client2.send(new HeadObjectCommand_1.HeadObjectCommand(input));
      reason = result;
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
      }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
  };
  var waitForObjectNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
  };
  exports.waitForObjectNotExists = waitForObjectNotExists;
  var waitUntilObjectNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
  };
  exports.waitUntilObjectNotExists = waitUntilObjectNotExists;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/waiters/index.js
var require_waiters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_waitForBucketExists(), exports);
  tslib_1.__exportStar(require_waitForBucketNotExists(), exports);
  tslib_1.__exportStar(require_waitForObjectExists(), exports);
  tslib_1.__exportStar(require_waitForObjectNotExists(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/models/index.js
var require_models3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_models_03(), exports);
  tslib_1.__exportStar(require_models_1(), exports);
});

// node_modules/@aws-sdk/client-s3/dist-cjs/index.js
var require_dist_cjs69 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3ServiceException = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_S3Client(), exports);
  tslib_1.__exportStar(require_S3(), exports);
  tslib_1.__exportStar(require_commands3(), exports);
  tslib_1.__exportStar(require_pagination3(), exports);
  tslib_1.__exportStar(require_waiters(), exports);
  tslib_1.__exportStar(require_models3(), exports);
  require_dist_cjs27();
  var S3ServiceException_1 = require_S3ServiceException();
  Object.defineProperty(exports, "S3ServiceException", { enumerable: true, get: function() {
    return S3ServiceException_1.S3ServiceException;
  } });
});

// node_modules/dotenv/package.json
var require_package6 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.3.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://github.com/motdotla/dotenv?sponsor=1",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var parse4 = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  };
  var _parseVault = function(options5) {
    const vaultPath = _vaultPath(options5);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    }
    const keys = _dotenvKey(options5).split(",");
    const length2 = keys.length;
    let decrypted;
    for (let i2 = 0;i2 < length2; i2++) {
      try {
        const key = keys[i2].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i2 + 1 >= length2) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options5) {
    if (options5 && options5.DOTENV_KEY && options5.DOTENV_KEY.length > 0) {
      return options5.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        throw new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      throw new Error("INVALID_DOTENV_KEY: Missing key part");
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      throw new Error("INVALID_DOTENV_KEY: Missing environment part");
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options5) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    if (options5 && options5.path && options5.path.length > 0) {
      dotenvPath = options5.path;
    }
    return dotenvPath.endsWith(".vault") ? dotenvPath : `${dotenvPath}.vault`;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os2.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options5) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options5);
    let processEnv = process.env;
    if (options5 && options5.processEnv != null) {
      processEnv = options5.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options5);
    return { parsed };
  };
  var configDotenv = function(options5) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug15 = Boolean(options5 && options5.debug);
    if (options5) {
      if (options5.path != null) {
        dotenvPath = _resolveHome(options5.path);
      }
      if (options5.encoding != null) {
        encoding = options5.encoding;
      }
    }
    try {
      const parsed = DotenvModule.parse(fs3.readFileSync(dotenvPath, { encoding }));
      let processEnv = process.env;
      if (options5 && options5.processEnv != null) {
        processEnv = options5.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options5);
      return { parsed };
    } catch (e) {
      if (debug15) {
        _debug(`Failed to load ${dotenvPath} ${e.message}`);
      }
      return { error: e };
    }
  };
  var config = function(options5) {
    const vaultPath = _vaultPath(options5);
    if (_dotenvKey(options5).length === 0) {
      return DotenvModule.configDotenv(options5);
    }
    if (!fs3.existsSync(vaultPath)) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options5);
    }
    return DotenvModule._configVault(options5);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.slice(0, 12);
    const authTag = ciphertext.slice(-16);
    ciphertext = ciphertext.slice(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const msg = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
        throw new Error(msg);
      } else if (decryptionFailed) {
        const msg = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
        throw new Error(msg);
      } else {
        console.error("Error: ", error.code);
        console.error("Error: ", error.message);
        throw error;
      }
    }
  };
  var populate = function(processEnv, parsed, options5 = {}) {
    const debug15 = Boolean(options5 && options5.debug);
    const override = Boolean(options5 && options5.override);
    if (typeof parsed !== "object") {
      throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug15) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs3 = __require("fs");
  var path = __require("path");
  var os2 = __require("os");
  var crypto2 = __require("crypto");
  var packageJson = require_package6();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse4,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/@aws-sdk/util-format-url/dist-cjs/index.js
var require_dist_cjs70 = __commonJS((exports) => {
  var formatUrl = function(request) {
    var _a, _b;
    const { port, query } = request;
    let { protocol: protocol4, path, hostname } = request;
    if (protocol4 && protocol4.slice(-1) !== ":") {
      protocol4 += ":";
    }
    if (port) {
      hostname += `:${port}`;
    }
    if (path && path.charAt(0) !== "/") {
      path = `/${path}`;
    }
    let queryString = query ? (0, querystring_builder_1.buildQueryString)(query) : "";
    if (queryString && queryString[0] !== "?") {
      queryString = `?${queryString}`;
    }
    let auth = "";
    if (request.username != null || request.password != null) {
      const username = (_a = request.username) !== null && _a !== undefined ? _a : "";
      const password = (_b = request.password) !== null && _b !== undefined ? _b : "";
      auth = `${username}:${password}@`;
    }
    let fragment = "";
    if (request.fragment) {
      fragment = `#${request.fragment}`;
    }
    return `${protocol4}//${auth}${hostname}${path}${queryString}${fragment}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatUrl = undefined;
  var querystring_builder_1 = require_dist_cjs13();
  exports.formatUrl = formatUrl;
});

// node_modules/@aws-sdk/s3-request-presigner/dist-cjs/constants.js
var require_constants12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ALGORITHM_IDENTIFIER = exports.HOST_HEADER = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = exports.SHA256_HEADER = exports.UNSIGNED_PAYLOAD = undefined;
  exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  exports.SHA256_HEADER = "X-Amz-Content-Sha256";
  exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  exports.HOST_HEADER = "host";
  exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
});

// node_modules/@aws-sdk/s3-request-presigner/dist-cjs/presigner.js
var require_presigner = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3RequestPresigner = undefined;
  var signature_v4_multi_region_1 = require_dist_cjs63();
  var constants_1 = require_constants12();

  class S3RequestPresigner {
    constructor(options5) {
      const resolvedOptions = {
        service: options5.signingName || options5.service || "s3",
        uriEscapePath: options5.uriEscapePath || false,
        applyChecksum: options5.applyChecksum || false,
        ...options5
      };
      this.signer = new signature_v4_multi_region_1.SignatureV4MultiRegion(resolvedOptions);
    }
    presign(requestToSign, { unsignableHeaders = new Set, unhoistableHeaders = new Set, ...options5 } = {}) {
      unsignableHeaders.add("content-type");
      Object.keys(requestToSign.headers).map((header) => header.toLowerCase()).filter((header) => header.startsWith("x-amz-server-side-encryption")).forEach((header) => {
        unhoistableHeaders.add(header);
      });
      requestToSign.headers[constants_1.SHA256_HEADER] = constants_1.UNSIGNED_PAYLOAD;
      const currentHostHeader = requestToSign.headers.host;
      const port = requestToSign.port;
      const expectedHostHeader = `${requestToSign.hostname}${requestToSign.port != null ? ":" + port : ""}`;
      if (!currentHostHeader || currentHostHeader === requestToSign.hostname && requestToSign.port != null) {
        requestToSign.headers.host = expectedHostHeader;
      }
      return this.signer.presign(requestToSign, {
        expiresIn: 900,
        unsignableHeaders,
        unhoistableHeaders,
        ...options5
      });
    }
  }
  exports.S3RequestPresigner = S3RequestPresigner;
});

// node_modules/@aws-sdk/s3-request-presigner/dist-cjs/getSignedUrl.js
var require_getSignedUrl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSignedUrl = undefined;
  var util_format_url_1 = require_dist_cjs70();
  var middleware_endpoint_1 = require_dist_cjs38();
  var protocol_http_1 = require_dist_cjs2();
  var presigner_1 = require_presigner();
  var getSignedUrl = async (client2, command, options5 = {}) => {
    var _a, _b;
    let s3Presigner;
    if (typeof client2.config.endpointProvider === "function") {
      const endpointV2 = await (0, middleware_endpoint_1.getEndpointFromInstructions)(command.input, command.constructor, client2.config);
      const authScheme = (_b = (_a = endpointV2.properties) === null || _a === undefined ? undefined : _a.authSchemes) === null || _b === undefined ? undefined : _b[0];
      s3Presigner = new presigner_1.S3RequestPresigner({
        ...client2.config,
        signingName: authScheme === null || authScheme === undefined ? undefined : authScheme.signingName,
        region: async () => authScheme === null || authScheme === undefined ? undefined : authScheme.signingRegion
      });
    } else {
      s3Presigner = new presigner_1.S3RequestPresigner(client2.config);
    }
    const presignInterceptMiddleware = (next, context) => async (args) => {
      var _a2, _b2;
      const { request } = args;
      if (!protocol_http_1.HttpRequest.isInstance(request)) {
        throw new Error("Request to be presigned is not an valid HTTP request.");
      }
      delete request.headers["amz-sdk-invocation-id"];
      delete request.headers["amz-sdk-request"];
      delete request.headers["x-amz-user-agent"];
      const presigned2 = await s3Presigner.presign(request, {
        ...options5,
        signingRegion: (_a2 = options5.signingRegion) !== null && _a2 !== undefined ? _a2 : context["signing_region"],
        signingService: (_b2 = options5.signingService) !== null && _b2 !== undefined ? _b2 : context["signing_service"]
      });
      return {
        response: {},
        output: {
          $metadata: { httpStatusCode: 200 },
          presigned: presigned2
        }
      };
    };
    const middlewareName = "presignInterceptMiddleware";
    const clientStack = client2.middlewareStack.clone();
    clientStack.addRelativeTo(presignInterceptMiddleware, {
      name: middlewareName,
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: true
    });
    const handler = command.resolveMiddleware(clientStack, client2.config, {});
    const { output } = await handler({ input: command.input });
    const { presigned } = output;
    return (0, util_format_url_1.formatUrl)(presigned);
  };
  exports.getSignedUrl = getSignedUrl;
});

// node_modules/@aws-sdk/s3-request-presigner/dist-cjs/index.js
var require_dist_cjs71 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_getSignedUrl(), exports);
  tslib_1.__exportStar(require_presigner(), exports);
});

// node_modules/commander/esm.mjs
var import_ = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import_.default;

// src/index.ts
var import_debug23 = __toESM(require_src(), 1);
import {isMainThread as isMainThread2} from "node:worker_threads";

// src/create-token.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
import {readFileSync} from "node:fs";

// src/payload.ts
var import_joi = __toESM(require_lib4(), 1);
var CloudflareBucketLocationConstraint = {
  wnam: "wnam",
  enam: "enam",
  weur: "weur",
  eeur: "eeur",
  apac: "apac"
};
var nameSchema = import_joi.default.string().alphanum().case("lower");
var payloadSchema = import_joi.default.object({
  type: import_joi.default.string().valid("download", "upload").required(),
  name: nameSchema.required(),
  loc: import_joi.default.string().valid(...Object.keys(CloudflareBucketLocationConstraint))
});

// src/errors.ts
class ValidationError extends Error {
  constructor(message) {
    super(message);
  }
}

class UnauthorizedError extends Error {
  constructor(message) {
    super(message);
  }
}

// src/validate.ts
var validate = (schema, value) => {
  const { error, value: validated } = schema.validate(value);
  if (error !== undefined) {
    let message = error.message;
    const details = error.details.map((d) => d.message).join(", ");
    if (details !== undefined) {
      message = `${message}: ${details}`;
    }
    throw new ValidationError(message);
  }
  return validated;
};

// src/create-token.ts
var makeCreateTokenCommand = () => {
  const command = new Command;
  command.name(`create-token`).showHelpAfterError().requiredOption("--name <value>", "Where the server is located").requiredOption("--type <value>", "Token to authenticate with the server").option("--loc <value>", "Location hint for the cloud provider").requiredOption("--private-key-file <path>", "Path to the private key file generated with `openssl ecparam -name prime256v1 -genkey`").action(() => {
    const options = command.opts();
    const name = options.name;
    const type = options.type;
    const loc = options.loc;
    const payload2 = { name, type, loc };
    const privateKeyFile = options.privateKeyFile;
    if (typeof privateKeyFile !== "string") {
      throw new Error("privateKeyFile must be a string");
    }
    const privateKey = readFileSync(privateKeyFile, "utf8");
    const token = createToken(payload2, privateKey);
    process.stdout.write(token);
    process.stdout.write("\n");
  });
  return command;
};
var createToken = (payload2, privateKey) => {
  payload2 = validate(payloadSchema, payload2);
  const token = import_jsonwebtoken.default.sign(payload2, privateKey, { algorithm: "ES256" });
  return token;
};

// src/download-client.ts
var import_debug14 = __toESM(require_src(), 1);
var import_fastq2 = __toESM(require_queue(), 1);
var import_joi7 = __toESM(require_lib4(), 1);
var import_jsonwebtoken2 = __toESM(require_jsonwebtoken(), 1);
import {createHash as createHash2} from "node:crypto";
import {open as open3} from "node:fs/promises";
import {pipeline as pipeline2} from "node:stream/promises";
import {join} from "path";

// src/download-info.ts
var import_debug = __toESM(require_src(), 1);
import {open as open2} from "node:fs/promises";

// src/fs.ts
import {createHash} from "node:crypto";
import {
mkdir,
open
} from "node:fs/promises";
import {parse} from "node:path";
import {pipeline} from "node:stream/promises";
var calculateChecksum = async (path, algorithm, range) => {
  const options = {};
  if (range) {
    options.start = range.start;
    options.end = range.end;
  }
  const sha256 = createHash(algorithm);
  let fileHandle;
  try {
    fileHandle = await open(path);
    const readStream = fileHandle.createReadStream(options);
    await pipeline(readStream, sha256);
  } finally {
    await fileHandle?.close();
  }
  return sha256.digest("hex");
};
var touch = async (path) => {
  const { dir } = parse(path);
  await mkdir(dir, { recursive: true });
  let fileHandle;
  try {
    fileHandle = await open(path, "a");
  } finally {
    await fileHandle?.close();
  }
};

// src/info.ts
var import_fastq = __toESM(require_queue(), 1);
var import_joi4 = __toESM(require_lib4(), 1);

// src/part.ts
var import_joi3 = __toESM(require_lib4(), 1);

// src/range.ts
var import_joi2 = __toESM(require_lib4(), 1);

class Range {
  start;
  end;
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  size() {
    return this.end - this.start + 1;
  }
  equals(that) {
    return this.start === that.start && this.end === that.end;
  }
  touches(that) {
    return this.end + 1 >= that.start && this.start - 1 <= that.end;
  }
  toString() {
    return `${this.start}-${this.end}`;
  }
}
var byStart = (a, b) => a.start - b.start;
var reduceRanges = (ranges) => ranges.sort(byStart).reduce((array, range) => {
  if (array.length === 0) {
    array.push(range);
    return array;
  }
  const { start, end } = range;
  const previous = array[array.length - 1];
  if (previous.touches(range)) {
    previous.start = Math.min(previous.start, start);
    previous.end = Math.max(previous.end, end);
  } else {
    array.push(range);
  }
  return array;
}, new Array);
var rangeSchema = import_joi2.default.object().keys({
  start: import_joi2.default.number().required(),
  end: import_joi2.default.number().required()
});

// src/part.ts
var partSchema = import_joi3.default.object().keys({
  range: rangeSchema.required(),
  checksumMD5: import_joi3.default.string().required()
});
var parseRange = (value) => {
  const { start, end } = value.range;
  value.range = new Range(start, end);
};

// src/info.ts
var infoDataSchema = import_joi4.default.object({
  parts: import_joi4.default.array().items(partSchema.keys({
    complete: import_joi4.default.boolean().required()
  })),
  size: import_joi4.default.number(),
  checksumSHA256: import_joi4.default.string(),
  verified: import_joi4.default.boolean().required()
}).required();
var isInfoData = (data) => {
  const { error } = infoDataSchema.validate(data);
  return error === undefined;
};

class Info {
  path;
  queue;
  data;
  constructor(path) {
    this.path = path;
    this.queue = import_fastq.default.promise(this, this.run, 1);
  }
  get defaultData() {
    return { parts: [], verified: false };
  }
  async isVerified() {
    const data = await this.load();
    return data.verified;
  }
  findUploadPart(query, data) {
    const parts = data.parts.filter((part3) => part3.range.equals(query.range));
    if (parts.length !== 1) {
      return;
    }
    const [part2] = parts;
    return part2;
  }
  runAddFilePart(filePart, data) {
    const part2 = this.findUploadPart(filePart, data);
    if (part2 !== undefined) {
      return !part2.complete;
    }
    const { range: range2, checksumMD5, size } = filePart;
    data.parts.push({ range: range2, checksumMD5, complete: false });
    if (data.size === undefined) {
      data.size = size;
    } else if (data.size !== size) {
      throw new Error(`Mismatched size for ${this.toString()}: ${data.size} !== ${size}`);
    }
    return true;
  }
  runCompletePart(query, data) {
    const part2 = this.findUploadPart(query, data);
    if (part2 === undefined) {
      const rangeString = query.range.toString();
      throw new Error(`Part not found for ${this.toString()}: ${rangeString}`);
    }
    if (part2.checksumMD5 !== query.checksumMD5) {
      throw new Error(`Mismatched checksum for ${this.toString()}: ` + `${part2.checksumMD5} !== ${query.checksumMD5}`);
    }
    part2.complete = true;
    return true;
  }
  parse(body) {
    let data;
    try {
      data = JSON.parse(body);
    } catch (error) {
      return this.defaultData;
    }
    if (typeof data !== "object" || data === null) {
      return this.defaultData;
    }
    if (!isInfoData(data)) {
      throw new Error(`Invalid download info data for ${this.path}: ${body}`);
    }
    data.parts.map((part2) => parseRange(part2));
    return data;
  }
}

// src/download-info.ts
var debug = import_debug.default("download-client");

class DownloadInfo extends Info {
  constructor(path) {
    super(path);
  }
  get key() {
    return `${this.path}.download-info.json`;
  }
  toString() {
    return `${this.path}`;
  }
  async load() {
    if (this.data !== undefined) {
      return this.data;
    }
    await touch(this.key);
    let fileHandle, buffer;
    try {
      fileHandle = await open2(this.key, "r");
      buffer = await fileHandle.readFile("utf8");
    } finally {
      await fileHandle?.close();
    }
    const data = this.parse(buffer.toString());
    this.data = data;
    return data;
  }
  async run(job) {
    const data = await this.load();
    let result = undefined;
    switch (job.type) {
      case "set-checksum-sha256":
        data.checksumSHA256 = job.checksumSHA256;
        break;
      case "add-download-job":
        result = this.runAddFilePart(job.downloadJob, data);
        break;
      case "complete-part":
        this.runCompletePart(job.part, data);
        break;
    }
    if (result === undefined) {
      if (!data.verified) {
        if (this.complete(data)) {
          data.verified = await this.verified(data);
        }
      }
      result = data.verified;
    }
    await this.save();
    return result;
  }
  async setChecksumSHA256(checksumSHA256) {
    return await this.queue.push({
      type: "set-checksum-sha256",
      checksumSHA256
    });
  }
  async addDownloadJob(downloadJob) {
    return await this.queue.push({ type: "add-download-job", downloadJob });
  }
  async completePart(part2) {
    return await this.queue.push({ type: "complete-part", part: part2 });
  }
  async verified(data) {
    if (data.verified) {
      return true;
    }
    const checksumSHA256 = await calculateChecksum(this.path, "sha256");
    if (checksumSHA256 === data.checksumSHA256) {
      debug("verified checksum for %s", this.path);
      return true;
    }
    throw new Error(`invalid checksum for ${this.path}`);
  }
  complete(data) {
    if (data.size === undefined || data.checksumSHA256 === undefined) {
      return false;
    }
    const ranges = reduceRanges(data.parts.filter(({ complete: complete2 }) => complete2).map(({ range: range4 }) => new Range(range4.start, range4.end)));
    if (ranges.length !== 1) {
      return false;
    }
    const [range3] = ranges;
    const { start } = range3;
    const complete = start == 0 && range3.size() == data.size;
    return complete;
  }
  async save() {
    const dataString = JSON.stringify(this.data, null, 2);
    let fileHandle;
    try {
      fileHandle = await open2(this.key, "w");
      await fileHandle.writeFile(dataString, "utf8");
    } finally {
      await fileHandle?.close();
    }
  }
}

// src/http-client.ts
var import_debug2 = __toESM(require_src(), 1);

// node_modules/@sindresorhus/is/dist/index.js
var isTypedArrayName = function(name) {
  return typedArrayTypeNames.includes(name);
};
var isObjectTypeName = function(name) {
  return objectTypeNames.includes(name);
};
var isPrimitiveTypeName = function(name) {
  return primitiveTypeNames.includes(name);
};
var isOfType = function(type) {
  return (value) => typeof value === type;
};
var is = function(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "undefined": {
      return "undefined";
    }
    case "string": {
      return "string";
    }
    case "number": {
      return Number.isNaN(value) ? "NaN" : "number";
    }
    case "boolean": {
      return "boolean";
    }
    case "function": {
      return "Function";
    }
    case "bigint": {
      return "bigint";
    }
    case "symbol": {
      return "symbol";
    }
    default:
  }
  if (is.observable(value)) {
    return "Observable";
  }
  if (is.array(value)) {
    return "Array";
  }
  if (is.buffer(value)) {
    return "Buffer";
  }
  const tagType = getObjectType(value);
  if (tagType) {
    return tagType;
  }
  if (value instanceof String || value instanceof Boolean || value instanceof Number) {
    throw new TypeError("Please don\'t use object wrappers for primitive types");
  }
  return "Object";
};
var typedArrayTypeNames = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Blob",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "WeakRef",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "FormData",
  "URLSearchParams",
  "HTMLElement",
  "NaN",
  ...typedArrayTypeNames
];
var primitiveTypeNames = [
  "null",
  "undefined",
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol"
];
var { toString } = Object.prototype;
var getObjectType = (value) => {
  const objectTypeName = toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
    return "HTMLElement";
  }
  if (isObjectTypeName(objectTypeName)) {
    return objectTypeName;
  }
  return;
};
var isObjectOfType = (type) => (value) => getObjectType(value) === type;
is.undefined = isOfType("undefined");
is.string = isOfType("string");
var isNumberType = isOfType("number");
is.number = (value) => isNumberType(value) && !is.nan(value);
is.positiveNumber = (value) => is.number(value) && value > 0;
is.negativeNumber = (value) => is.number(value) && value < 0;
is.bigint = isOfType("bigint");
is.function_ = isOfType("function");
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType("symbol");
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => {
  if (!Array.isArray(value)) {
    return false;
  }
  if (!is.function_(assertion)) {
    return true;
  }
  return value.every((element) => assertion(element));
};
is.buffer = (value) => value?.constructor?.isBuffer?.(value) ?? false;
is.blob = (value) => isObjectOfType("Blob")(value);
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
is.iterable = (value) => is.function_(value?.[Symbol.iterator]);
is.asyncIterable = (value) => is.function_(value?.[Symbol.asyncIterator]);
is.generator = (value) => is.iterable(value) && is.function_(value?.next) && is.function_(value?.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType("Promise")(value);
var hasPromiseApi = (value) => is.function_(value?.then) && is.function_(value?.catch);
is.promise = (value) => is.nativePromise(value) || hasPromiseApi(value);
is.generatorFunction = isObjectOfType("GeneratorFunction");
is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
is.regExp = isObjectOfType("RegExp");
is.date = isObjectOfType("Date");
is.error = isObjectOfType("Error");
is.map = (value) => isObjectOfType("Map")(value);
is.set = (value) => isObjectOfType("Set")(value);
is.weakMap = (value) => isObjectOfType("WeakMap")(value);
is.weakSet = (value) => isObjectOfType("WeakSet")(value);
is.weakRef = (value) => isObjectOfType("WeakRef")(value);
is.int8Array = isObjectOfType("Int8Array");
is.uint8Array = isObjectOfType("Uint8Array");
is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
is.int16Array = isObjectOfType("Int16Array");
is.uint16Array = isObjectOfType("Uint16Array");
is.int32Array = isObjectOfType("Int32Array");
is.uint32Array = isObjectOfType("Uint32Array");
is.float32Array = isObjectOfType("Float32Array");
is.float64Array = isObjectOfType("Float64Array");
is.bigInt64Array = isObjectOfType("BigInt64Array");
is.bigUint64Array = isObjectOfType("BigUint64Array");
is.arrayBuffer = isObjectOfType("ArrayBuffer");
is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
is.dataView = isObjectOfType("DataView");
is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType("URL")(value);
is.urlString = (value) => {
  if (!is.string(value)) {
    return false;
  }
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
};
is.truthy = (value) => Boolean(value);
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
var isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.tupleLike = (value, guards) => {
  if (is.array(guards) && is.array(value) && guards.length === value.length) {
    return guards.every((guard, index) => guard(value[index]));
  }
  return false;
};
is.inRange = (value, range3) => {
  if (is.number(range3)) {
    return value >= Math.min(0, range3) && value <= Math.max(range3, 0);
  }
  if (is.array(range3) && range3.length === 2) {
    return value >= Math.min(...range3) && value <= Math.max(...range3);
  }
  throw new TypeError(`Invalid range: ${JSON.stringify(range3)}`);
};
var NODE_TYPE_ELEMENT = 1;
var DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => (property in value));
is.observable = (value) => {
  if (!value) {
    return false;
  }
  if (value === value[Symbol.observable]?.()) {
    return true;
  }
  if (value === value["@@observable"]?.()) {
    return true;
  }
  return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
is.formData = (value) => isObjectOfType("FormData")(value);
is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
var predicateOnArray = (method, predicate, values) => {
  if (!is.function_(predicate)) {
    throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
  }
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
  const predicates = is.array(predicate) ? predicate : [predicate];
  return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
var assertType = (condition, description, value, options = {}) => {
  if (!condition) {
    const { multipleValues } = options;
    const valuesMessage = multipleValues ? `received values of types ${[
      ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
    ].join(", ")}` : `received value of type \`${is(value)}\``;
    throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
  }
};
var assert = {
  undefined: (value) => assertType(is.undefined(value), "undefined", value),
  string: (value) => assertType(is.string(value), "string", value),
  number: (value) => assertType(is.number(value), "number", value),
  positiveNumber: (value) => assertType(is.positiveNumber(value), "positive number", value),
  negativeNumber: (value) => assertType(is.negativeNumber(value), "negative number", value),
  bigint: (value) => assertType(is.bigint(value), "bigint", value),
  function_: (value) => assertType(is.function_(value), "Function", value),
  null_: (value) => assertType(is.null_(value), "null", value),
  class_: (value) => assertType(is.class_(value), "Class", value),
  boolean: (value) => assertType(is.boolean(value), "boolean", value),
  symbol: (value) => assertType(is.symbol(value), "symbol", value),
  numericString: (value) => assertType(is.numericString(value), "string with a number", value),
  array: (value, assertion) => {
    const assert2 = assertType;
    assert2(is.array(value), "Array", value);
    if (assertion) {
      value.forEach(assertion);
    }
  },
  buffer: (value) => assertType(is.buffer(value), "Buffer", value),
  blob: (value) => assertType(is.blob(value), "Blob", value),
  nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
  object: (value) => assertType(is.object(value), "Object", value),
  iterable: (value) => assertType(is.iterable(value), "Iterable", value),
  asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
  generator: (value) => assertType(is.generator(value), "Generator", value),
  asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
  nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
  promise: (value) => assertType(is.promise(value), "Promise", value),
  generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
  asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
  asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
  boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
  regExp: (value) => assertType(is.regExp(value), "RegExp", value),
  date: (value) => assertType(is.date(value), "Date", value),
  error: (value) => assertType(is.error(value), "Error", value),
  map: (value) => assertType(is.map(value), "Map", value),
  set: (value) => assertType(is.set(value), "Set", value),
  weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
  weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
  weakRef: (value) => assertType(is.weakRef(value), "WeakRef", value),
  int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
  uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
  uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
  int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
  uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
  int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
  uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
  float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
  float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
  bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
  bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
  arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
  sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
  dataView: (value) => assertType(is.dataView(value), "DataView", value),
  enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), "EnumCase", value),
  urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
  urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
  truthy: (value) => assertType(is.truthy(value), "truthy", value),
  falsy: (value) => assertType(is.falsy(value), "falsy", value),
  nan: (value) => assertType(is.nan(value), "NaN", value),
  primitive: (value) => assertType(is.primitive(value), "primitive", value),
  integer: (value) => assertType(is.integer(value), "integer", value),
  safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
  plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
  typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
  arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
  tupleLike: (value, guards) => assertType(is.tupleLike(value, guards), "tuple-like", value),
  domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
  observable: (value) => assertType(is.observable(value), "Observable", value),
  nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
  infinite: (value) => assertType(is.infinite(value), "infinite number", value),
  emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
  nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
  emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
  emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
  nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
  nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
  emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
  nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
  emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
  nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
  emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
  nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
  propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
  formData: (value) => assertType(is.formData(value), "FormData", value),
  urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
  evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
  oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
  directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
  inRange: (value, range3) => assertType(is.inRange(value, range3), "in range", value),
  any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true }),
  all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
};
Object.defineProperties(is, {
  class: {
    value: is.class_
  },
  function: {
    value: is.function_
  },
  null: {
    value: is.null_
  }
});
Object.defineProperties(assert, {
  class: {
    value: assert.class_
  },
  function: {
    value: assert.function_
  },
  null: {
    value: assert.null_
  }
});
var dist_default = is;

// node_modules/got/dist/source/as-promise/index.js
import {EventEmitter as EventEmitter2} from "node:events";

// node_modules/p-cancelable/index.js
class CancelError extends Error {
  constructor(reason) {
    super(reason || "Promise was canceled");
    this.name = "CancelError";
  }
  get isCanceled() {
    return true;
  }
}

class PCancelable {
  static fn(userFunction) {
    return (...arguments_) => {
      return new PCancelable((resolve, reject, onCancel) => {
        arguments_.push(onCancel);
        userFunction(...arguments_).then(resolve, reject);
      });
    };
  }
  constructor(executor) {
    this._cancelHandlers = [];
    this._isPending = true;
    this._isCanceled = false;
    this._rejectOnCancel = true;
    this._promise = new Promise((resolve, reject) => {
      this._reject = reject;
      const onResolve = (value) => {
        if (!this._isCanceled || !onCancel.shouldReject) {
          this._isPending = false;
          resolve(value);
        }
      };
      const onReject = (error) => {
        this._isPending = false;
        reject(error);
      };
      const onCancel = (handler) => {
        if (!this._isPending) {
          throw new Error("The `onCancel` handler was attached after the promise settled.");
        }
        this._cancelHandlers.push(handler);
      };
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: () => this._rejectOnCancel,
          set: (boolean) => {
            this._rejectOnCancel = boolean;
          }
        }
      });
      executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel(reason) {
    if (!this._isPending || this._isCanceled) {
      return;
    }
    this._isCanceled = true;
    if (this._cancelHandlers.length > 0) {
      try {
        for (const handler of this._cancelHandlers) {
          handler();
        }
      } catch (error) {
        this._reject(error);
        return;
      }
    }
    if (this._rejectOnCancel) {
      this._reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this._isCanceled;
  }
}
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

// node_modules/got/dist/source/core/errors.js
var isRequest = function(x) {
  return dist_default.object(x) && ("_onResponse" in x);
};

class RequestError extends Error {
  constructor(message, error, self2) {
    super(message);
    Object.defineProperty(this, "input", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "stack", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "timings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Error.captureStackTrace(this, this.constructor);
    this.name = "RequestError";
    this.code = error.code ?? "ERR_GOT_REQUEST_ERROR";
    this.input = error.input;
    if (isRequest(self2)) {
      Object.defineProperty(this, "request", {
        enumerable: false,
        value: self2
      });
      Object.defineProperty(this, "response", {
        enumerable: false,
        value: self2.response
      });
      this.options = self2.options;
    } else {
      this.options = self2;
    }
    this.timings = this.request?.timings;
    if (dist_default.string(error.stack) && dist_default.string(this.stack)) {
      const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
      const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
      const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
      while (errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]) {
        thisStackTrace.shift();
      }
      this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
    }
  }
}

class MaxRedirectsError extends RequestError {
  constructor(request) {
    super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
    this.name = "MaxRedirectsError";
    this.code = "ERR_TOO_MANY_REDIRECTS";
  }
}

class HTTPError extends RequestError {
  constructor(response) {
    super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
    this.name = "HTTPError";
    this.code = "ERR_NON_2XX_3XX_RESPONSE";
  }
}

class CacheError extends RequestError {
  constructor(error, request) {
    super(error.message, error, request);
    this.name = "CacheError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
  }
}

class UploadError extends RequestError {
  constructor(error, request) {
    super(error.message, error, request);
    this.name = "UploadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
  }
}

class TimeoutError extends RequestError {
  constructor(error, timings, request) {
    super(error.message, error, request);
    Object.defineProperty(this, "timings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.name = "TimeoutError";
    this.event = error.event;
    this.timings = timings;
  }
}

class ReadError extends RequestError {
  constructor(error, request) {
    super(error.message, error, request);
    this.name = "ReadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
  }
}

class RetryError extends RequestError {
  constructor(request) {
    super("Retrying", {}, request);
    this.name = "RetryError";
    this.code = "ERR_RETRYING";
  }
}

class AbortError extends RequestError {
  constructor(request) {
    super("This operation was aborted.", {}, request);
    this.code = "ERR_ABORTED";
    this.name = "AbortError";
  }
}

// node_modules/got/dist/source/core/index.js
import process3 from "node:process";
import {Buffer as Buffer3} from "node:buffer";
import {Duplex} from "node:stream";
import http2, {ServerResponse} from "node:http";

// node_modules/@szmarczak/http-timer/dist/source/index.js
var import_defer_to_connect = __toESM(require_source(), 1);
import {errorMonitor} from "events";
import {types} from "util";
var timer = (request) => {
  if (request.timings) {
    return request.timings;
  }
  const timings = {
    start: Date.now(),
    socket: undefined,
    lookup: undefined,
    connect: undefined,
    secureConnect: undefined,
    upload: undefined,
    response: undefined,
    end: undefined,
    error: undefined,
    abort: undefined,
    phases: {
      wait: undefined,
      dns: undefined,
      tcp: undefined,
      tls: undefined,
      request: undefined,
      firstByte: undefined,
      download: undefined,
      total: undefined
    }
  };
  request.timings = timings;
  const handleError = (origin) => {
    origin.once(errorMonitor, () => {
      timings.error = Date.now();
      timings.phases.total = timings.error - timings.start;
    });
  };
  handleError(request);
  const onAbort = () => {
    timings.abort = Date.now();
    timings.phases.total = timings.abort - timings.start;
  };
  request.prependOnceListener("abort", onAbort);
  const onSocket = (socket) => {
    timings.socket = Date.now();
    timings.phases.wait = timings.socket - timings.start;
    if (types.isProxy(socket)) {
      return;
    }
    const lookupListener = () => {
      timings.lookup = Date.now();
      timings.phases.dns = timings.lookup - timings.socket;
    };
    socket.prependOnceListener("lookup", lookupListener);
    import_defer_to_connect.default(socket, {
      connect: () => {
        timings.connect = Date.now();
        if (timings.lookup === undefined) {
          socket.removeListener("lookup", lookupListener);
          timings.lookup = timings.connect;
          timings.phases.dns = timings.lookup - timings.socket;
        }
        timings.phases.tcp = timings.connect - timings.lookup;
      },
      secureConnect: () => {
        timings.secureConnect = Date.now();
        timings.phases.tls = timings.secureConnect - timings.connect;
      }
    });
  };
  if (request.socket) {
    onSocket(request.socket);
  } else {
    request.prependOnceListener("socket", onSocket);
  }
  const onUpload = () => {
    timings.upload = Date.now();
    timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
  };
  if (request.writableFinished) {
    onUpload();
  } else {
    request.prependOnceListener("finish", onUpload);
  }
  request.prependOnceListener("response", (response) => {
    timings.response = Date.now();
    timings.phases.firstByte = timings.response - timings.upload;
    response.timings = timings;
    handleError(response);
    response.prependOnceListener("end", () => {
      request.off("abort", onAbort);
      response.off("aborted", onAbort);
      if (timings.phases.total) {
        return;
      }
      timings.end = Date.now();
      timings.phases.download = timings.end - timings.response;
      timings.phases.total = timings.end - timings.start;
    });
    response.prependOnceListener("aborted", onAbort);
  });
  return timings;
};
var source_default = timer;

// node_modules/cacheable-request/dist/index.js
import EventEmitter from "node:events";
import urlLib from "node:url";
import crypto from "node:crypto";
import stream, {PassThrough as PassThroughStream} from "node:stream";

// node_modules/normalize-url/index.js
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
var supportedProtocols = new Set([
  "https:",
  "http:",
  "file:"
]);
var hasCustomProtocol = (urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !supportedProtocols.has(protocol);
  } catch {
    return false;
  }
};
var normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  let { type, data, hash } = match.groups;
  const mediaType = type.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [
    ...attributes
  ];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (;; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname);
    } catch {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1);
      urlObject.pathname = pathComponents.slice(1).join("/") + "/";
    }
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}

// node_modules/cacheable-request/dist/index.js
var import_get_stream = __toESM(require_get_stream(), 1);
var import_http_cache_semantics = __toESM(require_http_cache_semantics(), 1);

// node_modules/responselike/index.js
import {Readable as ReadableStream} from "node:stream";

// node_modules/lowercase-keys/index.js
function lowercaseKeys(object) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}

// node_modules/responselike/index.js
class Response extends ReadableStream {
  statusCode;
  headers;
  body;
  url;
  constructor({ statusCode, headers, body, url }) {
    if (typeof statusCode !== "number") {
      throw new TypeError("Argument `statusCode` should be a number");
    }
    if (typeof headers !== "object") {
      throw new TypeError("Argument `headers` should be an object");
    }
    if (!(body instanceof Uint8Array)) {
      throw new TypeError("Argument `body` should be a buffer");
    }
    if (typeof url !== "string") {
      throw new TypeError("Argument `url` should be a string");
    }
    super({
      read() {
        this.push(body);
        this.push(null);
      }
    });
    this.statusCode = statusCode;
    this.headers = lowercaseKeys(headers);
    this.body = body;
    this.url = url;
  }
}

// node_modules/cacheable-request/dist/index.js
var import_keyv = __toESM(require_src2(), 1);

// node_modules/mimic-response/index.js
var knownProperties = [
  "aborted",
  "complete",
  "headers",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "method",
  "rawHeaders",
  "rawTrailers",
  "setTimeout",
  "socket",
  "statusCode",
  "statusMessage",
  "trailers",
  "url"
];
function mimicResponse(fromStream, toStream) {
  if (toStream._readableState.autoDestroy) {
    throw new Error("The second stream must have the `autoDestroy` option set to `false`");
  }
  const fromProperties = new Set([...Object.keys(fromStream), ...knownProperties]);
  const properties = {};
  for (const property of fromProperties) {
    if (property in toStream) {
      continue;
    }
    properties[property] = {
      get() {
        const value = fromStream[property];
        const isFunction = typeof value === "function";
        return isFunction ? value.bind(fromStream) : value;
      },
      set(value) {
        fromStream[property] = value;
      },
      enumerable: true,
      configurable: false
    };
  }
  Object.defineProperties(toStream, properties);
  fromStream.once("aborted", () => {
    toStream.destroy();
    toStream.emit("aborted");
  });
  fromStream.once("close", () => {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once("end", () => {
          toStream.emit("close");
        });
      } else {
        toStream.emit("close");
      }
    } else {
      toStream.emit("close");
    }
  });
  return toStream;
}

// node_modules/cacheable-request/dist/types.js
class RequestError2 extends Error {
  constructor(error) {
    super(error.message);
    Object.assign(this, error);
  }
}

class CacheError2 extends Error {
  constructor(error) {
    super(error.message);
    Object.assign(this, error);
  }
}

// node_modules/cacheable-request/dist/index.js
class CacheableRequest {
  constructor(cacheRequest, cacheAdapter) {
    this.hooks = new Map;
    this.request = () => (options, cb) => {
      let url;
      if (typeof options === "string") {
        url = normalizeUrlObject(urlLib.parse(options));
        options = {};
      } else if (options instanceof urlLib.URL) {
        url = normalizeUrlObject(urlLib.parse(options.toString()));
        options = {};
      } else {
        const [pathname, ...searchParts] = (options.path ?? "").split("?");
        const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
        url = normalizeUrlObject({ ...options, pathname, search });
      }
      options = {
        headers: {},
        method: "GET",
        cache: true,
        strictTtl: false,
        automaticFailover: false,
        ...options,
        ...urlObjectToRequestOptions(url)
      };
      options.headers = Object.fromEntries(entries(options.headers).map(([key2, value]) => [key2.toLowerCase(), value]));
      const ee = new EventEmitter;
      const normalizedUrlString = normalizeUrl(urlLib.format(url), {
        stripWWW: false,
        removeTrailingSlash: false,
        stripAuthentication: false
      });
      let key = `${options.method}:${normalizedUrlString}`;
      if (options.body && options.method !== undefined && ["POST", "PATCH", "PUT"].includes(options.method)) {
        if (options.body instanceof stream.Readable) {
          options.cache = false;
        } else {
          key += `:${crypto.createHash("md5").update(options.body).digest("hex")}`;
        }
      }
      let revalidate = false;
      let madeRequest = false;
      const makeRequest = (options_) => {
        madeRequest = true;
        let requestErrored = false;
        let requestErrorCallback = () => {
        };
        const requestErrorPromise = new Promise((resolve) => {
          requestErrorCallback = () => {
            if (!requestErrored) {
              requestErrored = true;
              resolve();
            }
          };
        });
        const handler = async (response) => {
          if (revalidate) {
            response.status = response.statusCode;
            const revalidatedPolicy = import_http_cache_semantics.default.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
            if (!revalidatedPolicy.modified) {
              response.resume();
              await new Promise((resolve) => {
                response.once("end", resolve);
              });
              const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());
              response = new Response({ statusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url });
              response.cachePolicy = revalidatedPolicy.policy;
              response.fromCache = true;
            }
          }
          if (!response.fromCache) {
            response.cachePolicy = new import_http_cache_semantics.default(options_, response, options_);
            response.fromCache = false;
          }
          let clonedResponse;
          if (options_.cache && response.cachePolicy.storable()) {
            clonedResponse = cloneResponse(response);
            (async () => {
              try {
                const bodyPromise = import_get_stream.default.buffer(response);
                await Promise.race([
                  requestErrorPromise,
                  new Promise((resolve) => response.once("end", resolve)),
                  new Promise((resolve) => response.once("close", resolve))
                ]);
                const body = await bodyPromise;
                let value = {
                  url: response.url,
                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                  body,
                  cachePolicy: response.cachePolicy.toObject()
                };
                let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;
                if (options_.maxTtl) {
                  ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;
                }
                if (this.hooks.size > 0) {
                  for (const key_ of this.hooks.keys()) {
                    value = await this.runHook(key_, value, response);
                  }
                }
                await this.cache.set(key, value, ttl);
              } catch (error) {
                ee.emit("error", new CacheError2(error));
              }
            })();
          } else if (options_.cache && revalidate) {
            (async () => {
              try {
                await this.cache.delete(key);
              } catch (error) {
                ee.emit("error", new CacheError2(error));
              }
            })();
          }
          ee.emit("response", clonedResponse ?? response);
          if (typeof cb === "function") {
            cb(clonedResponse ?? response);
          }
        };
        try {
          const request_ = this.cacheRequest(options_, handler);
          request_.once("error", requestErrorCallback);
          request_.once("abort", requestErrorCallback);
          request_.once("destroy", requestErrorCallback);
          ee.emit("request", request_);
        } catch (error) {
          ee.emit("error", new RequestError2(error));
        }
      };
      (async () => {
        const get = async (options_) => {
          await Promise.resolve();
          const cacheEntry = options_.cache ? await this.cache.get(key) : undefined;
          if (cacheEntry === undefined && !options_.forceRefresh) {
            makeRequest(options_);
            return;
          }
          const policy = import_http_cache_semantics.default.fromObject(cacheEntry.cachePolicy);
          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
            const headers = convertHeaders(policy.responseHeaders());
            const response = new Response({ statusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url });
            response.cachePolicy = policy;
            response.fromCache = true;
            ee.emit("response", response);
            if (typeof cb === "function") {
              cb(response);
            }
          } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {
            await this.cache.delete(key);
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          } else {
            revalidate = cacheEntry;
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          }
        };
        const errorHandler = (error) => ee.emit("error", new CacheError2(error));
        if (this.cache instanceof import_keyv.default) {
          const cachek = this.cache;
          cachek.once("error", errorHandler);
          ee.on("error", () => cachek.removeListener("error", errorHandler));
          ee.on("response", () => cachek.removeListener("error", errorHandler));
        }
        try {
          await get(options);
        } catch (error) {
          if (options.automaticFailover && !madeRequest) {
            makeRequest(options);
          }
          ee.emit("error", new CacheError2(error));
        }
      })();
      return ee;
    };
    this.addHook = (name, fn) => {
      if (!this.hooks.has(name)) {
        this.hooks.set(name, fn);
      }
    };
    this.removeHook = (name) => this.hooks.delete(name);
    this.getHook = (name) => this.hooks.get(name);
    this.runHook = async (name, ...args) => this.hooks.get(name)?.(...args);
    if (cacheAdapter instanceof import_keyv.default) {
      this.cache = cacheAdapter;
    } else if (typeof cacheAdapter === "string") {
      this.cache = new import_keyv.default({
        uri: cacheAdapter,
        namespace: "cacheable-request"
      });
    } else {
      this.cache = new import_keyv.default({
        store: cacheAdapter,
        namespace: "cacheable-request"
      });
    }
    this.request = this.request.bind(this);
    this.cacheRequest = cacheRequest;
  }
}
var entries = Object.entries;
var cloneResponse = (response) => {
  const clone = new PassThroughStream({ autoDestroy: false });
  mimicResponse(response, clone);
  return response.pipe(clone);
};
var urlObjectToRequestOptions = (url) => {
  const options = { ...url };
  options.path = `${url.pathname || "/"}${url.search || ""}`;
  delete options.pathname;
  delete options.search;
  return options;
};
var normalizeUrlObject = (url) => ({
  protocol: url.protocol,
  auth: url.auth,
  hostname: url.hostname || url.host || "localhost",
  port: url.port,
  pathname: url.pathname,
  search: url.search
});
var convertHeaders = (headers) => {
  const result = [];
  for (const name of Object.keys(headers)) {
    result[name.toLowerCase()] = headers[name];
  }
  return result;
};
var dist_default2 = CacheableRequest;

// node_modules/got/dist/source/core/index.js
var import_decompress_response = __toESM(require_decompress_response(), 1);
var import_get_stream2 = __toESM(require_get_stream(), 1);

// node_modules/form-data-encoder/lib/util/isFunction.js
var isFunction = (value) => typeof value === "function";

// node_modules/form-data-encoder/lib/util/getStreamIterator.js
async function* readStream(readable) {
  const reader = readable.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    yield value;
  }
}
var isAsyncIterable = (value) => isFunction(value[Symbol.asyncIterator]);
var getStreamIterator = (source) => {
  if (isAsyncIterable(source)) {
    return source;
  }
  if (isFunction(source.getReader)) {
    return readStream(source);
  }
  throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
};

// node_modules/form-data-encoder/lib/util/createBoundary.js
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";

// node_modules/form-data-encoder/lib/util/normalizeValue.js
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i, str) => {
  if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
    return "\r\n";
  }
  return match;
});

// node_modules/form-data-encoder/lib/util/isPlainObject.js
function isPlainObject(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === undefined) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();

// node_modules/form-data-encoder/lib/util/proxyHeaders.js
var getProperty = function(target, prop) {
  if (typeof prop === "string") {
    for (const [name, value] of Object.entries(target)) {
      if (prop.toLowerCase() === name.toLowerCase()) {
        return value;
      }
    }
  }
  return;
};
var proxyHeaders = (object) => new Proxy(object, {
  get: (target, prop) => getProperty(target, prop),
  has: (target, prop) => getProperty(target, prop) !== undefined
});

// node_modules/form-data-encoder/lib/util/isFormData.js
var isFormData = (value) => Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator]));

// node_modules/form-data-encoder/lib/util/escapeName.js
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");

// node_modules/form-data-encoder/lib/util/isFile.js
var isFile = (value) => Boolean(value && typeof value === "object" && isFunction(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction(value.stream) && value.name != null);

// node_modules/form-data-encoder/lib/FormDataEncoder.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormDataEncoder_instances;
var _FormDataEncoder_CRLF;
var _FormDataEncoder_CRLF_BYTES;
var _FormDataEncoder_CRLF_BYTES_LENGTH;
var _FormDataEncoder_DASHES;
var _FormDataEncoder_encoder;
var _FormDataEncoder_footer;
var _FormDataEncoder_form;
var _FormDataEncoder_options;
var _FormDataEncoder_getFieldHeader;
var _FormDataEncoder_getContentLength;
var defaultOptions = {
  enableAdditionalHeaders: false
};
var readonlyProp = { writable: false, configurable: false };

class FormDataEncoder {
  constructor(form, boundaryOrOptions, options) {
    _FormDataEncoder_instances.add(this);
    _FormDataEncoder_CRLF.set(this, "\r\n");
    _FormDataEncoder_CRLF_BYTES.set(this, undefined);
    _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, undefined);
    _FormDataEncoder_DASHES.set(this, "-".repeat(2));
    _FormDataEncoder_encoder.set(this, new TextEncoder);
    _FormDataEncoder_footer.set(this, undefined);
    _FormDataEncoder_form.set(this, undefined);
    _FormDataEncoder_options.set(this, undefined);
    if (!isFormData(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = createBoundary();
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __classPrivateFieldSet(this, _FormDataEncoder_form, Array.from(form.entries()), "f");
    __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
    __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
    __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
    this.boundary = `form-data-boundary-${boundary}`;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    const headers = {
      "Content-Type": this.contentType
    };
    const contentLength = __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getContentLength).call(this);
    if (contentLength) {
      this.contentLength = contentLength;
      headers["Content-Length"] = contentLength;
    }
    this.headers = proxyHeaders(Object.freeze(headers));
    Object.defineProperties(this, {
      boundary: readonlyProp,
      contentType: readonlyProp,
      contentLength: readonlyProp,
      headers: readonlyProp
    });
  }
  getContentLength() {
    return this.contentLength == null ? undefined : Number(this.contentLength);
  }
  *values() {
    for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
      const value = isFile(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(normalizeValue(raw));
      yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
      yield value;
      yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
  }
  async* encode() {
    for (const part2 of this.values()) {
      if (isFile(part2)) {
        yield* getStreamIterator(part2.stream());
      } else {
        yield part2;
      }
    }
  }
  [(_FormDataEncoder_CRLF = new WeakMap, _FormDataEncoder_CRLF_BYTES = new WeakMap, _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap, _FormDataEncoder_DASHES = new WeakMap, _FormDataEncoder_encoder = new WeakMap, _FormDataEncoder_footer = new WeakMap, _FormDataEncoder_form = new WeakMap, _FormDataEncoder_options = new WeakMap, _FormDataEncoder_instances = new WeakSet, _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
    header += `Content-Disposition: form-data; name="${escapeName(name)}"`;
    if (isFile(value)) {
      header += `; filename="${escapeName(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
      header += `Content-Type: ${value.type || "application/octet-stream"}`;
    }
    const size = isFile(value) ? value.size : value.byteLength;
    if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true && size != null && !isNaN(size)) {
      header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFile(value) ? value.size : value.byteLength}`;
    }
    return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, _FormDataEncoder_getContentLength = function _FormDataEncoder_getContentLength() {
    let length = 0;
    for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
      const value = isFile(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(normalizeValue(raw));
      const size = isFile(value) ? value.size : value.byteLength;
      if (size == null || isNaN(size)) {
        return;
      }
      length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
      length += size;
      length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return String(length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
}

// node_modules/got/dist/source/core/utils/get-body-size.js
import {Buffer as Buffer2} from "node:buffer";
import {promisify} from "node:util";

// node_modules/got/dist/source/core/utils/is-form-data.js
function isFormData3(body) {
  return dist_default.nodeStream(body) && dist_default.function_(body.getBoundary);
}

// node_modules/got/dist/source/core/utils/get-body-size.js
async function getBodySize(body, headers) {
  if (headers && ("content-length" in headers)) {
    return Number(headers["content-length"]);
  }
  if (!body) {
    return 0;
  }
  if (dist_default.string(body)) {
    return Buffer2.byteLength(body);
  }
  if (dist_default.buffer(body)) {
    return body.length;
  }
  if (isFormData3(body)) {
    return promisify(body.getLength.bind(body))();
  }
  return;
}

// node_modules/got/dist/source/core/utils/proxy-events.js
function proxyEvents(from, to, events) {
  const eventFunctions = {};
  for (const event of events) {
    const eventFunction = (...args) => {
      to.emit(event, ...args);
    };
    eventFunctions[event] = eventFunction;
    from.on(event, eventFunction);
  }
  return () => {
    for (const [event, eventFunction] of Object.entries(eventFunctions)) {
      from.off(event, eventFunction);
    }
  };
}

// node_modules/got/dist/source/core/timed-out.js
import net from "node:net";

// node_modules/got/dist/source/core/utils/unhandle.js
function unhandle() {
  const handlers = [];
  return {
    once(origin, event, fn) {
      origin.once(event, fn);
      handlers.push({ origin, event, fn });
    },
    unhandleAll() {
      for (const handler of handlers) {
        const { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
}

// node_modules/got/dist/source/core/timed-out.js
var reentry = Symbol("reentry");
var noop = () => {
};

class TimeoutError2 extends Error {
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`);
    Object.defineProperty(this, "event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: event
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.name = "TimeoutError";
    this.code = "ETIMEDOUT";
  }
}
function timedOut(request, delays, options) {
  if (reentry in request) {
    return noop;
  }
  request[reentry] = true;
  const cancelers = [];
  const { once, unhandleAll } = unhandle();
  const addTimeout = (delay, callback, event) => {
    const timeout = setTimeout(callback, delay, delay, event);
    timeout.unref?.();
    const cancel = () => {
      clearTimeout(timeout);
    };
    cancelers.push(cancel);
    return cancel;
  };
  const { host, hostname } = options;
  const timeoutHandler = (delay, event) => {
    request.destroy(new TimeoutError2(delay, event));
  };
  const cancelTimeouts = () => {
    for (const cancel of cancelers) {
      cancel();
    }
    unhandleAll();
  };
  request.once("error", (error) => {
    cancelTimeouts();
    if (request.listenerCount("error") === 0) {
      throw error;
    }
  });
  if (delays.request !== undefined) {
    const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
    once(request, "response", (response) => {
      once(response, "end", cancelTimeout);
    });
  }
  if (delays.socket !== undefined) {
    const { socket } = delays;
    const socketTimeoutHandler = () => {
      timeoutHandler(socket, "socket");
    };
    request.setTimeout(socket, socketTimeoutHandler);
    cancelers.push(() => {
      request.removeListener("timeout", socketTimeoutHandler);
    });
  }
  const hasLookup = delays.lookup !== undefined;
  const hasConnect = delays.connect !== undefined;
  const hasSecureConnect = delays.secureConnect !== undefined;
  const hasSend = delays.send !== undefined;
  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
    once(request, "socket", (socket) => {
      const { socketPath } = request;
      if (socket.connecting) {
        const hasPath = Boolean(socketPath ?? net.isIP(hostname ?? host ?? "") !== 0);
        if (hasLookup && !hasPath && socket.address().address === undefined) {
          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
          once(socket, "lookup", cancelTimeout);
        }
        if (hasConnect) {
          const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
          if (hasPath) {
            once(socket, "connect", timeConnect());
          } else {
            once(socket, "lookup", (error) => {
              if (error === null) {
                once(socket, "connect", timeConnect());
              }
            });
          }
        }
        if (hasSecureConnect && options.protocol === "https:") {
          once(socket, "connect", () => {
            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
            once(socket, "secureConnect", cancelTimeout);
          });
        }
      }
      if (hasSend) {
        const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
        if (socket.connecting) {
          once(socket, "connect", () => {
            once(request, "upload-complete", timeRequest());
          });
        } else {
          once(request, "upload-complete", timeRequest());
        }
      }
    });
  }
  if (delays.response !== undefined) {
    once(request, "upload-complete", () => {
      const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
      once(request, "response", cancelTimeout);
    });
  }
  if (delays.read !== undefined) {
    once(request, "response", (response) => {
      const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
      once(response, "end", cancelTimeout);
    });
  }
  return cancelTimeouts;
}

// node_modules/got/dist/source/core/utils/url-to-options.js
function urlToOptions(url) {
  url = url;
  const options = {
    protocol: url.protocol,
    hostname: dist_default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: `${url.pathname || ""}${url.search || ""}`
  };
  if (dist_default.string(url.port) && url.port.length > 0) {
    options.port = Number(url.port);
  }
  if (url.username || url.password) {
    options.auth = `${url.username || ""}:${url.password || ""}`;
  }
  return options;
}

// node_modules/got/dist/source/core/utils/weakable-map.js
class WeakableMap {
  constructor() {
    Object.defineProperty(this, "weakMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "map", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.weakMap = new WeakMap;
    this.map = new Map;
  }
  set(key, value) {
    if (typeof key === "object") {
      this.weakMap.set(key, value);
    } else {
      this.map.set(key, value);
    }
  }
  get(key) {
    if (typeof key === "object") {
      return this.weakMap.get(key);
    }
    return this.map.get(key);
  }
  has(key) {
    if (typeof key === "object") {
      return this.weakMap.has(key);
    }
    return this.map.has(key);
  }
}

// node_modules/got/dist/source/core/calculate-retry-delay.js
var calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter, computedValue }) => {
  if (error.name === "RetryError") {
    return 1;
  }
  if (attemptCount > retryOptions.limit) {
    return 0;
  }
  const hasMethod = retryOptions.methods.includes(error.options.method);
  const hasErrorCode = retryOptions.errorCodes.includes(error.code);
  const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode) {
    return 0;
  }
  if (error.response) {
    if (retryAfter) {
      if (retryAfter > computedValue) {
        return 0;
      }
      return retryAfter;
    }
    if (error.response.statusCode === 413) {
      return 0;
    }
  }
  const noise = Math.random() * retryOptions.noise;
  return Math.min(2 ** (attemptCount - 1) * 1000, retryOptions.backoffLimit) + noise;
};
var calculate_retry_delay_default = calculateRetryDelay;

// node_modules/got/dist/source/core/options.js
import process2 from "node:process";
import {promisify as promisify3, inspect} from "node:util";
import {checkServerIdentity} from "node:tls";
import http from "node:http";
import https from "node:https";

// node_modules/cacheable-lookup/source/index.js
import {
V4MAPPED,
ADDRCONFIG,
ALL,
promises as dnsPromises,
lookup as dnsLookup
} from "node:dns";
import {promisify as promisify2} from "node:util";
import os from "node:os";
var { Resolver: AsyncResolver } = dnsPromises;
var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
var kExpires = Symbol("expires");
var supportsALL = typeof ALL === "number";
var verifyAgent = (agent) => {
  if (!(agent && typeof agent.createConnection === "function")) {
    throw new Error("Expected an Agent instance as the first argument");
  }
};
var map4to6 = (entries2) => {
  for (const entry of entries2) {
    if (entry.family === 6) {
      continue;
    }
    entry.address = `::ffff:${entry.address}`;
    entry.family = 6;
  }
};
var getIfaceInfo = () => {
  let has4 = false;
  let has6 = false;
  for (const device of Object.values(os.networkInterfaces())) {
    for (const iface of device) {
      if (iface.internal) {
        continue;
      }
      if (iface.family === "IPv6") {
        has6 = true;
      } else {
        has4 = true;
      }
      if (has4 && has6) {
        return { has4, has6 };
      }
    }
  }
  return { has4, has6 };
};
var isIterable = (map) => {
  return Symbol.iterator in map;
};
var ignoreNoResultErrors = (dnsPromise) => {
  return dnsPromise.catch((error) => {
    if (error.code === "ENODATA" || error.code === "ENOTFOUND" || error.code === "ENOENT") {
      return [];
    }
    throw error;
  });
};
var ttl = { ttl: true };
var all = { all: true };
var all4 = { all: true, family: 4 };
var all6 = { all: true, family: 6 };

class CacheableLookup {
  constructor({
    cache = new Map,
    maxTtl = Infinity,
    fallbackDuration = 3600,
    errorTtl = 0.15,
    resolver = new AsyncResolver,
    lookup = dnsLookup
  } = {}) {
    this.maxTtl = maxTtl;
    this.errorTtl = errorTtl;
    this._cache = cache;
    this._resolver = resolver;
    this._dnsLookup = lookup && promisify2(lookup);
    this.stats = {
      cache: 0,
      query: 0
    };
    if (this._resolver instanceof AsyncResolver) {
      this._resolve4 = this._resolver.resolve4.bind(this._resolver);
      this._resolve6 = this._resolver.resolve6.bind(this._resolver);
    } else {
      this._resolve4 = promisify2(this._resolver.resolve4.bind(this._resolver));
      this._resolve6 = promisify2(this._resolver.resolve6.bind(this._resolver));
    }
    this._iface = getIfaceInfo();
    this._pending = {};
    this._nextRemovalTime = false;
    this._hostnamesToFallback = new Set;
    this.fallbackDuration = fallbackDuration;
    if (fallbackDuration > 0) {
      const interval = setInterval(() => {
        this._hostnamesToFallback.clear();
      }, fallbackDuration * 1000);
      if (interval.unref) {
        interval.unref();
      }
      this._fallbackInterval = interval;
    }
    this.lookup = this.lookup.bind(this);
    this.lookupAsync = this.lookupAsync.bind(this);
  }
  set servers(servers) {
    this.clear();
    this._resolver.setServers(servers);
  }
  get servers() {
    return this._resolver.getServers();
  }
  lookup(hostname, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (typeof options === "number") {
      options = {
        family: options
      };
    }
    if (!callback) {
      throw new Error("Callback must be a function.");
    }
    this.lookupAsync(hostname, options).then((result) => {
      if (options.all) {
        callback(null, result);
      } else {
        callback(null, result.address, result.family, result.expires, result.ttl, result.source);
      }
    }, callback);
  }
  async lookupAsync(hostname, options = {}) {
    if (typeof options === "number") {
      options = {
        family: options
      };
    }
    let cached = await this.query(hostname);
    if (options.family === 6) {
      const filtered = cached.filter((entry) => entry.family === 6);
      if (options.hints & V4MAPPED) {
        if (supportsALL && options.hints & ALL || filtered.length === 0) {
          map4to6(cached);
        } else {
          cached = filtered;
        }
      } else {
        cached = filtered;
      }
    } else if (options.family === 4) {
      cached = cached.filter((entry) => entry.family === 4);
    }
    if (options.hints & ADDRCONFIG) {
      const { _iface } = this;
      cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
    }
    if (cached.length === 0) {
      const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
      error.code = "ENOTFOUND";
      error.hostname = hostname;
      throw error;
    }
    if (options.all) {
      return cached;
    }
    return cached[0];
  }
  async query(hostname) {
    let source = "cache";
    let cached = await this._cache.get(hostname);
    if (cached) {
      this.stats.cache++;
    }
    if (!cached) {
      const pending = this._pending[hostname];
      if (pending) {
        this.stats.cache++;
        cached = await pending;
      } else {
        source = "query";
        const newPromise = this.queryAndCache(hostname);
        this._pending[hostname] = newPromise;
        this.stats.query++;
        try {
          cached = await newPromise;
        } finally {
          delete this._pending[hostname];
        }
      }
    }
    cached = cached.map((entry) => {
      return { ...entry, source };
    });
    return cached;
  }
  async _resolve(hostname) {
    const [A, AAAA] = await Promise.all([
      ignoreNoResultErrors(this._resolve4(hostname, ttl)),
      ignoreNoResultErrors(this._resolve6(hostname, ttl))
    ]);
    let aTtl = 0;
    let aaaaTtl = 0;
    let cacheTtl = 0;
    const now = Date.now();
    for (const entry of A) {
      entry.family = 4;
      entry.expires = now + entry.ttl * 1000;
      aTtl = Math.max(aTtl, entry.ttl);
    }
    for (const entry of AAAA) {
      entry.family = 6;
      entry.expires = now + entry.ttl * 1000;
      aaaaTtl = Math.max(aaaaTtl, entry.ttl);
    }
    if (A.length > 0) {
      if (AAAA.length > 0) {
        cacheTtl = Math.min(aTtl, aaaaTtl);
      } else {
        cacheTtl = aTtl;
      }
    } else {
      cacheTtl = aaaaTtl;
    }
    return {
      entries: [
        ...A,
        ...AAAA
      ],
      cacheTtl
    };
  }
  async _lookup(hostname) {
    try {
      const [A, AAAA] = await Promise.all([
        ignoreNoResultErrors(this._dnsLookup(hostname, all4)),
        ignoreNoResultErrors(this._dnsLookup(hostname, all6))
      ]);
      return {
        entries: [
          ...A,
          ...AAAA
        ],
        cacheTtl: 0
      };
    } catch {
      return {
        entries: [],
        cacheTtl: 0
      };
    }
  }
  async _set(hostname, data, cacheTtl) {
    if (this.maxTtl > 0 && cacheTtl > 0) {
      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
      data[kExpires] = Date.now() + cacheTtl;
      try {
        await this._cache.set(hostname, data, cacheTtl);
      } catch (error) {
        this.lookupAsync = async () => {
          const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
          cacheError.cause = error;
          throw cacheError;
        };
      }
      if (isIterable(this._cache)) {
        this._tick(cacheTtl);
      }
    }
  }
  async queryAndCache(hostname) {
    if (this._hostnamesToFallback.has(hostname)) {
      return this._dnsLookup(hostname, all);
    }
    let query = await this._resolve(hostname);
    if (query.entries.length === 0 && this._dnsLookup) {
      query = await this._lookup(hostname);
      if (query.entries.length !== 0 && this.fallbackDuration > 0) {
        this._hostnamesToFallback.add(hostname);
      }
    }
    const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
    await this._set(hostname, query.entries, cacheTtl);
    return query.entries;
  }
  _tick(ms) {
    const nextRemovalTime = this._nextRemovalTime;
    if (!nextRemovalTime || ms < nextRemovalTime) {
      clearTimeout(this._removalTimeout);
      this._nextRemovalTime = ms;
      this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = false;
        let nextExpiry = Infinity;
        const now = Date.now();
        for (const [hostname, entries2] of this._cache) {
          const expires = entries2[kExpires];
          if (now >= expires) {
            this._cache.delete(hostname);
          } else if (expires < nextExpiry) {
            nextExpiry = expires;
          }
        }
        if (nextExpiry !== Infinity) {
          this._tick(nextExpiry - now);
        }
      }, ms);
      if (this._removalTimeout.unref) {
        this._removalTimeout.unref();
      }
    }
  }
  install(agent) {
    verifyAgent(agent);
    if (kCacheableLookupCreateConnection in agent) {
      throw new Error("CacheableLookup has been already installed");
    }
    agent[kCacheableLookupCreateConnection] = agent.createConnection;
    agent[kCacheableLookupInstance] = this;
    agent.createConnection = (options, callback) => {
      if (!("lookup" in options)) {
        options.lookup = this.lookup;
      }
      return agent[kCacheableLookupCreateConnection](options, callback);
    };
  }
  uninstall(agent) {
    verifyAgent(agent);
    if (agent[kCacheableLookupCreateConnection]) {
      if (agent[kCacheableLookupInstance] !== this) {
        throw new Error("The agent is not owned by this CacheableLookup instance");
      }
      agent.createConnection = agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupInstance];
    }
  }
  updateInterfaceInfo() {
    const { _iface } = this;
    this._iface = getIfaceInfo();
    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
      this._cache.clear();
    }
  }
  clear(hostname) {
    if (hostname) {
      this._cache.delete(hostname);
      return;
    }
    this._cache.clear();
  }
}

// node_modules/got/dist/source/core/options.js
var import_http2_wrapper = __toESM(require_source2(), 1);

// node_modules/got/dist/source/core/parse-link-header.js
function parseLinkHeader(link) {
  const parsed = [];
  const items = link.split(",");
  for (const item of items) {
    const [rawUriReference, ...rawLinkParameters] = item.split(";");
    const trimmedUriReference = rawUriReference.trim();
    if (trimmedUriReference[0] !== "<" || trimmedUriReference[trimmedUriReference.length - 1] !== ">") {
      throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
    }
    const reference = trimmedUriReference.slice(1, -1);
    const parameters = {};
    if (rawLinkParameters.length === 0) {
      throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
    }
    for (const rawParameter of rawLinkParameters) {
      const trimmedRawParameter = rawParameter.trim();
      const center = trimmedRawParameter.indexOf("=");
      if (center === -1) {
        throw new Error(`Failed to parse Link header: ${link}`);
      }
      const name = trimmedRawParameter.slice(0, center).trim();
      const value = trimmedRawParameter.slice(center + 1).trim();
      parameters[name] = value;
    }
    parsed.push({
      reference,
      parameters
    });
  }
  return parsed;
}

// node_modules/got/dist/source/core/options.js
var validateSearchParameters = function(searchParameters) {
  for (const key in searchParameters) {
    const value = searchParameters[key];
    assert.any([dist_default.string, dist_default.number, dist_default.boolean, dist_default.null_, dist_default.undefined], value);
  }
};
var [major, minor] = process2.versions.node.split(".").map(Number);
var globalCache = new Map;
var globalDnsCache;
var getGlobalDnsCache = () => {
  if (globalDnsCache) {
    return globalDnsCache;
  }
  globalDnsCache = new CacheableLookup;
  return globalDnsCache;
};
var defaultInternals = {
  request: undefined,
  agent: {
    http: undefined,
    https: undefined,
    http2: undefined
  },
  h2session: undefined,
  decompress: true,
  timeout: {
    connect: undefined,
    lookup: undefined,
    read: undefined,
    request: undefined,
    response: undefined,
    secureConnect: undefined,
    send: undefined,
    socket: undefined
  },
  prefixUrl: "",
  body: undefined,
  form: undefined,
  json: undefined,
  cookieJar: undefined,
  ignoreInvalidCookies: false,
  searchParams: undefined,
  dnsLookup: undefined,
  dnsCache: undefined,
  context: {},
  hooks: {
    init: [],
    beforeRequest: [],
    beforeError: [],
    beforeRedirect: [],
    beforeRetry: [],
    afterResponse: []
  },
  followRedirect: true,
  maxRedirects: 10,
  cache: undefined,
  throwHttpErrors: true,
  username: "",
  password: "",
  http2: false,
  allowGetBody: false,
  headers: {
    "user-agent": "got (https://github.com/sindresorhus/got)"
  },
  methodRewriting: false,
  dnsLookupIpVersion: undefined,
  parseJson: JSON.parse,
  stringifyJson: JSON.stringify,
  retry: {
    limit: 2,
    methods: [
      "GET",
      "PUT",
      "HEAD",
      "DELETE",
      "OPTIONS",
      "TRACE"
    ],
    statusCodes: [
      408,
      413,
      429,
      500,
      502,
      503,
      504,
      521,
      522,
      524
    ],
    errorCodes: [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN"
    ],
    maxRetryAfter: undefined,
    calculateDelay: ({ computedValue }) => computedValue,
    backoffLimit: Number.POSITIVE_INFINITY,
    noise: 100
  },
  localAddress: undefined,
  method: "GET",
  createConnection: undefined,
  cacheOptions: {
    shared: undefined,
    cacheHeuristic: undefined,
    immutableMinTimeToLive: undefined,
    ignoreCargoCult: undefined
  },
  https: {
    alpnProtocols: undefined,
    rejectUnauthorized: undefined,
    checkServerIdentity: undefined,
    certificateAuthority: undefined,
    key: undefined,
    certificate: undefined,
    passphrase: undefined,
    pfx: undefined,
    ciphers: undefined,
    honorCipherOrder: undefined,
    minVersion: undefined,
    maxVersion: undefined,
    signatureAlgorithms: undefined,
    tlsSessionLifetime: undefined,
    dhparam: undefined,
    ecdhCurve: undefined,
    certificateRevocationLists: undefined
  },
  encoding: undefined,
  resolveBodyOnly: false,
  isStream: false,
  responseType: "text",
  url: undefined,
  pagination: {
    transform(response) {
      if (response.request.options.responseType === "json") {
        return response.body;
      }
      return JSON.parse(response.body);
    },
    paginate({ response }) {
      const rawLinkHeader = response.headers.link;
      if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") {
        return false;
      }
      const parsed = parseLinkHeader(rawLinkHeader);
      const next = parsed.find((entry) => entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
      if (next) {
        return {
          url: new URL(next.reference, response.url)
        };
      }
      return false;
    },
    filter: () => true,
    shouldContinue: () => true,
    countLimit: Number.POSITIVE_INFINITY,
    backoff: 0,
    requestLimit: 1e4,
    stackAllItems: false
  },
  setHost: true,
  maxHeaderSize: undefined,
  signal: undefined,
  enableUnixSockets: false
};
var cloneInternals = (internals) => {
  const { hooks, retry } = internals;
  const result = {
    ...internals,
    context: { ...internals.context },
    cacheOptions: { ...internals.cacheOptions },
    https: { ...internals.https },
    agent: { ...internals.agent },
    headers: { ...internals.headers },
    retry: {
      ...retry,
      errorCodes: [...retry.errorCodes],
      methods: [...retry.methods],
      statusCodes: [...retry.statusCodes]
    },
    timeout: { ...internals.timeout },
    hooks: {
      init: [...hooks.init],
      beforeRequest: [...hooks.beforeRequest],
      beforeError: [...hooks.beforeError],
      beforeRedirect: [...hooks.beforeRedirect],
      beforeRetry: [...hooks.beforeRetry],
      afterResponse: [...hooks.afterResponse]
    },
    searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : undefined,
    pagination: { ...internals.pagination }
  };
  if (result.url !== undefined) {
    result.prefixUrl = "";
  }
  return result;
};
var cloneRaw = (raw) => {
  const { hooks, retry } = raw;
  const result = { ...raw };
  if (dist_default.object(raw.context)) {
    result.context = { ...raw.context };
  }
  if (dist_default.object(raw.cacheOptions)) {
    result.cacheOptions = { ...raw.cacheOptions };
  }
  if (dist_default.object(raw.https)) {
    result.https = { ...raw.https };
  }
  if (dist_default.object(raw.cacheOptions)) {
    result.cacheOptions = { ...result.cacheOptions };
  }
  if (dist_default.object(raw.agent)) {
    result.agent = { ...raw.agent };
  }
  if (dist_default.object(raw.headers)) {
    result.headers = { ...raw.headers };
  }
  if (dist_default.object(retry)) {
    result.retry = { ...retry };
    if (dist_default.array(retry.errorCodes)) {
      result.retry.errorCodes = [...retry.errorCodes];
    }
    if (dist_default.array(retry.methods)) {
      result.retry.methods = [...retry.methods];
    }
    if (dist_default.array(retry.statusCodes)) {
      result.retry.statusCodes = [...retry.statusCodes];
    }
  }
  if (dist_default.object(raw.timeout)) {
    result.timeout = { ...raw.timeout };
  }
  if (dist_default.object(hooks)) {
    result.hooks = {
      ...hooks
    };
    if (dist_default.array(hooks.init)) {
      result.hooks.init = [...hooks.init];
    }
    if (dist_default.array(hooks.beforeRequest)) {
      result.hooks.beforeRequest = [...hooks.beforeRequest];
    }
    if (dist_default.array(hooks.beforeError)) {
      result.hooks.beforeError = [...hooks.beforeError];
    }
    if (dist_default.array(hooks.beforeRedirect)) {
      result.hooks.beforeRedirect = [...hooks.beforeRedirect];
    }
    if (dist_default.array(hooks.beforeRetry)) {
      result.hooks.beforeRetry = [...hooks.beforeRetry];
    }
    if (dist_default.array(hooks.afterResponse)) {
      result.hooks.afterResponse = [...hooks.afterResponse];
    }
  }
  if (dist_default.object(raw.pagination)) {
    result.pagination = { ...raw.pagination };
  }
  return result;
};
var getHttp2TimeoutOption = (internals) => {
  const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter((delay) => typeof delay === "number");
  if (delays.length > 0) {
    return Math.min(...delays);
  }
  return;
};
var init = (options, withOptions, self2) => {
  const initHooks = options.hooks?.init;
  if (initHooks) {
    for (const hook of initHooks) {
      hook(withOptions, self2);
    }
  }
};

class Options {
  constructor(input, options, defaults) {
    Object.defineProperty(this, "_unixOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_internals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_merging", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_init", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    assert.any([dist_default.string, dist_default.urlInstance, dist_default.object, dist_default.undefined], input);
    assert.any([dist_default.object, dist_default.undefined], options);
    assert.any([dist_default.object, dist_default.undefined], defaults);
    if (input instanceof Options || options instanceof Options) {
      throw new TypeError("The defaults must be passed as the third argument");
    }
    this._internals = cloneInternals(defaults?._internals ?? defaults ?? defaultInternals);
    this._init = [...defaults?._init ?? []];
    this._merging = false;
    this._unixOptions = undefined;
    try {
      if (dist_default.plainObject(input)) {
        try {
          this.merge(input);
          this.merge(options);
        } finally {
          this.url = input.url;
        }
      } else {
        try {
          this.merge(options);
        } finally {
          if (options?.url !== undefined) {
            if (input === undefined) {
              this.url = options.url;
            } else {
              throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            }
          } else if (input !== undefined) {
            this.url = input;
          }
        }
      }
    } catch (error) {
      error.options = this;
      throw error;
    }
  }
  merge(options) {
    if (!options) {
      return;
    }
    if (options instanceof Options) {
      for (const init2 of options._init) {
        this.merge(init2);
      }
      return;
    }
    options = cloneRaw(options);
    init(this, options, this);
    init(options, options, this);
    this._merging = true;
    if ("isStream" in options) {
      this.isStream = options.isStream;
    }
    try {
      let push = false;
      for (const key in options) {
        if (key === "mutableDefaults" || key === "handlers") {
          continue;
        }
        if (key === "url") {
          continue;
        }
        if (!(key in this)) {
          throw new Error(`Unexpected option: ${key}`);
        }
        const value = options[key];
        if (value === undefined) {
          continue;
        }
        this[key] = value;
        push = true;
      }
      if (push) {
        this._init.push(options);
      }
    } finally {
      this._merging = false;
    }
  }
  get request() {
    return this._internals.request;
  }
  set request(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.request = value;
  }
  get agent() {
    return this._internals.agent;
  }
  set agent(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.agent)) {
        throw new TypeError(`Unexpected agent option: ${key}`);
      }
      assert.any([dist_default.object, dist_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.agent, value);
    } else {
      this._internals.agent = { ...value };
    }
  }
  get h2session() {
    return this._internals.h2session;
  }
  set h2session(value) {
    this._internals.h2session = value;
  }
  get decompress() {
    return this._internals.decompress;
  }
  set decompress(value) {
    assert.boolean(value);
    this._internals.decompress = value;
  }
  get timeout() {
    return this._internals.timeout;
  }
  set timeout(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.timeout)) {
        throw new Error(`Unexpected timeout option: ${key}`);
      }
      assert.any([dist_default.number, dist_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.timeout, value);
    } else {
      this._internals.timeout = { ...value };
    }
  }
  get prefixUrl() {
    return this._internals.prefixUrl;
  }
  set prefixUrl(value) {
    assert.any([dist_default.string, dist_default.urlInstance], value);
    if (value === "") {
      this._internals.prefixUrl = "";
      return;
    }
    value = value.toString();
    if (!value.endsWith("/")) {
      value += "/";
    }
    if (this._internals.prefixUrl && this._internals.url) {
      const { href } = this._internals.url;
      this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
    }
    this._internals.prefixUrl = value;
  }
  get body() {
    return this._internals.body;
  }
  set body(value) {
    assert.any([dist_default.string, dist_default.buffer, dist_default.nodeStream, dist_default.generator, dist_default.asyncGenerator, isFormData, dist_default.undefined], value);
    if (dist_default.nodeStream(value)) {
      assert.truthy(value.readable);
    }
    if (value !== undefined) {
      assert.undefined(this._internals.form);
      assert.undefined(this._internals.json);
    }
    this._internals.body = value;
  }
  get form() {
    return this._internals.form;
  }
  set form(value) {
    assert.any([dist_default.plainObject, dist_default.undefined], value);
    if (value !== undefined) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.json);
    }
    this._internals.form = value;
  }
  get json() {
    return this._internals.json;
  }
  set json(value) {
    if (value !== undefined) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.form);
    }
    this._internals.json = value;
  }
  get url() {
    return this._internals.url;
  }
  set url(value) {
    assert.any([dist_default.string, dist_default.urlInstance, dist_default.undefined], value);
    if (value === undefined) {
      this._internals.url = undefined;
      return;
    }
    if (dist_default.string(value) && value.startsWith("/")) {
      throw new Error("`url` must not start with a slash");
    }
    const urlString = `${this.prefixUrl}${value.toString()}`;
    const url = new URL(urlString);
    this._internals.url = url;
    if (url.protocol === "unix:") {
      url.href = `http://unix${url.pathname}${url.search}`;
    }
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      const error = new Error(`Unsupported protocol: ${url.protocol}`);
      error.code = "ERR_UNSUPPORTED_PROTOCOL";
      throw error;
    }
    if (this._internals.username) {
      url.username = this._internals.username;
      this._internals.username = "";
    }
    if (this._internals.password) {
      url.password = this._internals.password;
      this._internals.password = "";
    }
    if (this._internals.searchParams) {
      url.search = this._internals.searchParams.toString();
      this._internals.searchParams = undefined;
    }
    if (url.hostname === "unix") {
      if (!this._internals.enableUnixSockets) {
        throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
      }
      const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
      if (matches?.groups) {
        const { socketPath, path } = matches.groups;
        this._unixOptions = {
          socketPath,
          path,
          host: ""
        };
      } else {
        this._unixOptions = undefined;
      }
      return;
    }
    this._unixOptions = undefined;
  }
  get cookieJar() {
    return this._internals.cookieJar;
  }
  set cookieJar(value) {
    assert.any([dist_default.object, dist_default.undefined], value);
    if (value === undefined) {
      this._internals.cookieJar = undefined;
      return;
    }
    let { setCookie, getCookieString } = value;
    assert.function_(setCookie);
    assert.function_(getCookieString);
    if (setCookie.length === 4 && getCookieString.length === 0) {
      setCookie = promisify3(setCookie.bind(value));
      getCookieString = promisify3(getCookieString.bind(value));
      this._internals.cookieJar = {
        setCookie,
        getCookieString
      };
    } else {
      this._internals.cookieJar = value;
    }
  }
  get signal() {
    return this._internals.signal;
  }
  set signal(value) {
    assert.object(value);
    this._internals.signal = value;
  }
  get ignoreInvalidCookies() {
    return this._internals.ignoreInvalidCookies;
  }
  set ignoreInvalidCookies(value) {
    assert.boolean(value);
    this._internals.ignoreInvalidCookies = value;
  }
  get searchParams() {
    if (this._internals.url) {
      return this._internals.url.searchParams;
    }
    if (this._internals.searchParams === undefined) {
      this._internals.searchParams = new URLSearchParams;
    }
    return this._internals.searchParams;
  }
  set searchParams(value) {
    assert.any([dist_default.string, dist_default.object, dist_default.undefined], value);
    const url = this._internals.url;
    if (value === undefined) {
      this._internals.searchParams = undefined;
      if (url) {
        url.search = "";
      }
      return;
    }
    const searchParameters = this.searchParams;
    let updated;
    if (dist_default.string(value)) {
      updated = new URLSearchParams(value);
    } else if (value instanceof URLSearchParams) {
      updated = value;
    } else {
      validateSearchParameters(value);
      updated = new URLSearchParams;
      for (const key in value) {
        const entry = value[key];
        if (entry === null) {
          updated.append(key, "");
        } else if (entry === undefined) {
          searchParameters.delete(key);
        } else {
          updated.append(key, entry);
        }
      }
    }
    if (this._merging) {
      for (const key of updated.keys()) {
        searchParameters.delete(key);
      }
      for (const [key, value2] of updated) {
        searchParameters.append(key, value2);
      }
    } else if (url) {
      url.search = searchParameters.toString();
    } else {
      this._internals.searchParams = searchParameters;
    }
  }
  get searchParameters() {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  set searchParameters(_value) {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  get dnsLookup() {
    return this._internals.dnsLookup;
  }
  set dnsLookup(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.dnsLookup = value;
  }
  get dnsCache() {
    return this._internals.dnsCache;
  }
  set dnsCache(value) {
    assert.any([dist_default.object, dist_default.boolean, dist_default.undefined], value);
    if (value === true) {
      this._internals.dnsCache = getGlobalDnsCache();
    } else if (value === false) {
      this._internals.dnsCache = undefined;
    } else {
      this._internals.dnsCache = value;
    }
  }
  get context() {
    return this._internals.context;
  }
  set context(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.context, value);
    } else {
      this._internals.context = { ...value };
    }
  }
  get hooks() {
    return this._internals.hooks;
  }
  set hooks(value) {
    assert.object(value);
    for (const knownHookEvent in value) {
      if (!(knownHookEvent in this._internals.hooks)) {
        throw new Error(`Unexpected hook event: ${knownHookEvent}`);
      }
      const typedKnownHookEvent = knownHookEvent;
      const hooks = value[typedKnownHookEvent];
      assert.any([dist_default.array, dist_default.undefined], hooks);
      if (hooks) {
        for (const hook of hooks) {
          assert.function_(hook);
        }
      }
      if (this._merging) {
        if (hooks) {
          this._internals.hooks[typedKnownHookEvent].push(...hooks);
        }
      } else {
        if (!hooks) {
          throw new Error(`Missing hook event: ${knownHookEvent}`);
        }
        this._internals.hooks[knownHookEvent] = [...hooks];
      }
    }
  }
  get followRedirect() {
    return this._internals.followRedirect;
  }
  set followRedirect(value) {
    assert.boolean(value);
    this._internals.followRedirect = value;
  }
  get followRedirects() {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  set followRedirects(_value) {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  get maxRedirects() {
    return this._internals.maxRedirects;
  }
  set maxRedirects(value) {
    assert.number(value);
    this._internals.maxRedirects = value;
  }
  get cache() {
    return this._internals.cache;
  }
  set cache(value) {
    assert.any([dist_default.object, dist_default.string, dist_default.boolean, dist_default.undefined], value);
    if (value === true) {
      this._internals.cache = globalCache;
    } else if (value === false) {
      this._internals.cache = undefined;
    } else {
      this._internals.cache = value;
    }
  }
  get throwHttpErrors() {
    return this._internals.throwHttpErrors;
  }
  set throwHttpErrors(value) {
    assert.boolean(value);
    this._internals.throwHttpErrors = value;
  }
  get username() {
    const url = this._internals.url;
    const value = url ? url.username : this._internals.username;
    return decodeURIComponent(value);
  }
  set username(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.username = fixedValue;
    } else {
      this._internals.username = fixedValue;
    }
  }
  get password() {
    const url = this._internals.url;
    const value = url ? url.password : this._internals.password;
    return decodeURIComponent(value);
  }
  set password(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.password = fixedValue;
    } else {
      this._internals.password = fixedValue;
    }
  }
  get http2() {
    return this._internals.http2;
  }
  set http2(value) {
    assert.boolean(value);
    this._internals.http2 = value;
  }
  get allowGetBody() {
    return this._internals.allowGetBody;
  }
  set allowGetBody(value) {
    assert.boolean(value);
    this._internals.allowGetBody = value;
  }
  get headers() {
    return this._internals.headers;
  }
  set headers(value) {
    assert.plainObject(value);
    if (this._merging) {
      Object.assign(this._internals.headers, lowercaseKeys(value));
    } else {
      this._internals.headers = lowercaseKeys(value);
    }
  }
  get methodRewriting() {
    return this._internals.methodRewriting;
  }
  set methodRewriting(value) {
    assert.boolean(value);
    this._internals.methodRewriting = value;
  }
  get dnsLookupIpVersion() {
    return this._internals.dnsLookupIpVersion;
  }
  set dnsLookupIpVersion(value) {
    if (value !== undefined && value !== 4 && value !== 6) {
      throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
    }
    this._internals.dnsLookupIpVersion = value;
  }
  get parseJson() {
    return this._internals.parseJson;
  }
  set parseJson(value) {
    assert.function_(value);
    this._internals.parseJson = value;
  }
  get stringifyJson() {
    return this._internals.stringifyJson;
  }
  set stringifyJson(value) {
    assert.function_(value);
    this._internals.stringifyJson = value;
  }
  get retry() {
    return this._internals.retry;
  }
  set retry(value) {
    assert.plainObject(value);
    assert.any([dist_default.function_, dist_default.undefined], value.calculateDelay);
    assert.any([dist_default.number, dist_default.undefined], value.maxRetryAfter);
    assert.any([dist_default.number, dist_default.undefined], value.limit);
    assert.any([dist_default.array, dist_default.undefined], value.methods);
    assert.any([dist_default.array, dist_default.undefined], value.statusCodes);
    assert.any([dist_default.array, dist_default.undefined], value.errorCodes);
    assert.any([dist_default.number, dist_default.undefined], value.noise);
    if (value.noise && Math.abs(value.noise) > 100) {
      throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
    }
    for (const key in value) {
      if (!(key in this._internals.retry)) {
        throw new Error(`Unexpected retry option: ${key}`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.retry, value);
    } else {
      this._internals.retry = { ...value };
    }
    const { retry } = this._internals;
    retry.methods = [...new Set(retry.methods.map((method) => method.toUpperCase()))];
    retry.statusCodes = [...new Set(retry.statusCodes)];
    retry.errorCodes = [...new Set(retry.errorCodes)];
  }
  get localAddress() {
    return this._internals.localAddress;
  }
  set localAddress(value) {
    assert.any([dist_default.string, dist_default.undefined], value);
    this._internals.localAddress = value;
  }
  get method() {
    return this._internals.method;
  }
  set method(value) {
    assert.string(value);
    this._internals.method = value.toUpperCase();
  }
  get createConnection() {
    return this._internals.createConnection;
  }
  set createConnection(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.createConnection = value;
  }
  get cacheOptions() {
    return this._internals.cacheOptions;
  }
  set cacheOptions(value) {
    assert.plainObject(value);
    assert.any([dist_default.boolean, dist_default.undefined], value.shared);
    assert.any([dist_default.number, dist_default.undefined], value.cacheHeuristic);
    assert.any([dist_default.number, dist_default.undefined], value.immutableMinTimeToLive);
    assert.any([dist_default.boolean, dist_default.undefined], value.ignoreCargoCult);
    for (const key in value) {
      if (!(key in this._internals.cacheOptions)) {
        throw new Error(`Cache option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.cacheOptions, value);
    } else {
      this._internals.cacheOptions = { ...value };
    }
  }
  get https() {
    return this._internals.https;
  }
  set https(value) {
    assert.plainObject(value);
    assert.any([dist_default.boolean, dist_default.undefined], value.rejectUnauthorized);
    assert.any([dist_default.function_, dist_default.undefined], value.checkServerIdentity);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.certificateAuthority);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.key);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.certificate);
    assert.any([dist_default.string, dist_default.undefined], value.passphrase);
    assert.any([dist_default.string, dist_default.buffer, dist_default.array, dist_default.undefined], value.pfx);
    assert.any([dist_default.array, dist_default.undefined], value.alpnProtocols);
    assert.any([dist_default.string, dist_default.undefined], value.ciphers);
    assert.any([dist_default.string, dist_default.buffer, dist_default.undefined], value.dhparam);
    assert.any([dist_default.string, dist_default.undefined], value.signatureAlgorithms);
    assert.any([dist_default.string, dist_default.undefined], value.minVersion);
    assert.any([dist_default.string, dist_default.undefined], value.maxVersion);
    assert.any([dist_default.boolean, dist_default.undefined], value.honorCipherOrder);
    assert.any([dist_default.number, dist_default.undefined], value.tlsSessionLifetime);
    assert.any([dist_default.string, dist_default.undefined], value.ecdhCurve);
    assert.any([dist_default.string, dist_default.buffer, dist_default.array, dist_default.undefined], value.certificateRevocationLists);
    for (const key in value) {
      if (!(key in this._internals.https)) {
        throw new Error(`HTTPS option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.https, value);
    } else {
      this._internals.https = { ...value };
    }
  }
  get encoding() {
    return this._internals.encoding;
  }
  set encoding(value) {
    if (value === null) {
      throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
    }
    assert.any([dist_default.string, dist_default.undefined], value);
    this._internals.encoding = value;
  }
  get resolveBodyOnly() {
    return this._internals.resolveBodyOnly;
  }
  set resolveBodyOnly(value) {
    assert.boolean(value);
    this._internals.resolveBodyOnly = value;
  }
  get isStream() {
    return this._internals.isStream;
  }
  set isStream(value) {
    assert.boolean(value);
    this._internals.isStream = value;
  }
  get responseType() {
    return this._internals.responseType;
  }
  set responseType(value) {
    if (value === undefined) {
      this._internals.responseType = "text";
      return;
    }
    if (value !== "text" && value !== "buffer" && value !== "json") {
      throw new Error(`Invalid \`responseType\` option: ${value}`);
    }
    this._internals.responseType = value;
  }
  get pagination() {
    return this._internals.pagination;
  }
  set pagination(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.pagination, value);
    } else {
      this._internals.pagination = value;
    }
  }
  get auth() {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  set auth(_value) {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  get setHost() {
    return this._internals.setHost;
  }
  set setHost(value) {
    assert.boolean(value);
    this._internals.setHost = value;
  }
  get maxHeaderSize() {
    return this._internals.maxHeaderSize;
  }
  set maxHeaderSize(value) {
    assert.any([dist_default.number, dist_default.undefined], value);
    this._internals.maxHeaderSize = value;
  }
  get enableUnixSockets() {
    return this._internals.enableUnixSockets;
  }
  set enableUnixSockets(value) {
    assert.boolean(value);
    this._internals.enableUnixSockets = value;
  }
  toJSON() {
    return { ...this._internals };
  }
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    return inspect(this._internals, options);
  }
  createNativeRequestOptions() {
    const internals = this._internals;
    const url = internals.url;
    let agent;
    if (url.protocol === "https:") {
      agent = internals.http2 ? internals.agent : internals.agent.https;
    } else {
      agent = internals.agent.http;
    }
    const { https: https2 } = internals;
    let { pfx } = https2;
    if (dist_default.array(pfx) && dist_default.plainObject(pfx[0])) {
      pfx = pfx.map((object) => ({
        buf: object.buffer,
        passphrase: object.passphrase
      }));
    }
    return {
      ...internals.cacheOptions,
      ...this._unixOptions,
      ALPNProtocols: https2.alpnProtocols,
      ca: https2.certificateAuthority,
      cert: https2.certificate,
      key: https2.key,
      passphrase: https2.passphrase,
      pfx: https2.pfx,
      rejectUnauthorized: https2.rejectUnauthorized,
      checkServerIdentity: https2.checkServerIdentity ?? checkServerIdentity,
      ciphers: https2.ciphers,
      honorCipherOrder: https2.honorCipherOrder,
      minVersion: https2.minVersion,
      maxVersion: https2.maxVersion,
      sigalgs: https2.signatureAlgorithms,
      sessionTimeout: https2.tlsSessionLifetime,
      dhparam: https2.dhparam,
      ecdhCurve: https2.ecdhCurve,
      crl: https2.certificateRevocationLists,
      lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
      family: internals.dnsLookupIpVersion,
      agent,
      setHost: internals.setHost,
      method: internals.method,
      maxHeaderSize: internals.maxHeaderSize,
      localAddress: internals.localAddress,
      headers: internals.headers,
      createConnection: internals.createConnection,
      timeout: internals.http2 ? getHttp2TimeoutOption(internals) : undefined,
      h2session: internals.h2session
    };
  }
  getRequestFunction() {
    const url = this._internals.url;
    const { request } = this._internals;
    if (!request && url) {
      return this.getFallbackRequestFunction();
    }
    return request;
  }
  getFallbackRequestFunction() {
    const url = this._internals.url;
    if (!url) {
      return;
    }
    if (url.protocol === "https:") {
      if (this._internals.http2) {
        if (major < 15 || major === 15 && minor < 10) {
          const error = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
          error.code = "EUNSUPPORTED";
          throw error;
        }
        return import_http2_wrapper.default.auto;
      }
      return https.request;
    }
    return http.request;
  }
  freeze() {
    const options = this._internals;
    Object.freeze(options);
    Object.freeze(options.hooks);
    Object.freeze(options.hooks.afterResponse);
    Object.freeze(options.hooks.beforeError);
    Object.freeze(options.hooks.beforeRedirect);
    Object.freeze(options.hooks.beforeRequest);
    Object.freeze(options.hooks.beforeRetry);
    Object.freeze(options.hooks.init);
    Object.freeze(options.https);
    Object.freeze(options.cacheOptions);
    Object.freeze(options.agent);
    Object.freeze(options.headers);
    Object.freeze(options.timeout);
    Object.freeze(options.retry);
    Object.freeze(options.retry.errorCodes);
    Object.freeze(options.retry.methods);
    Object.freeze(options.retry.statusCodes);
  }
}

// node_modules/got/dist/source/core/response.js
var isResponseOk = (response) => {
  const { statusCode } = response;
  const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};

class ParseError extends RequestError {
  constructor(error, response) {
    const { options } = response.request;
    super(`${error.message} in "${options.url.toString()}"`, error, response.request);
    this.name = "ParseError";
    this.code = "ERR_BODY_PARSE_FAILURE";
  }
}
var parseBody = (response, responseType, parseJson, encoding) => {
  const { rawBody } = response;
  try {
    if (responseType === "text") {
      return rawBody.toString(encoding);
    }
    if (responseType === "json") {
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
    }
    if (responseType === "buffer") {
      return rawBody;
    }
  } catch (error) {
    throw new ParseError(error, response);
  }
  throw new ParseError({
    message: `Unknown body type '${responseType}'`,
    name: "Error"
  }, response);
};

// node_modules/got/dist/source/core/utils/is-client-request.js
var isClientRequest = function(clientRequest) {
  return clientRequest.writable && !clientRequest.writableEnded;
};
var is_client_request_default = isClientRequest;

// node_modules/got/dist/source/core/utils/is-unix-socket-url.js
function isUnixSocketURL(url) {
  return url.protocol === "unix:" || url.hostname === "unix";
}

// node_modules/got/dist/source/core/index.js
var { buffer: getStreamAsBuffer } = import_get_stream2.default;
var supportsBrotli = dist_default.string(process3.versions.brotli);
var methodsWithoutBody = new Set(["GET", "HEAD"]);
var cacheableStore = new WeakableMap;
var redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
var proxiedRequestEvents = [
  "socket",
  "connect",
  "continue",
  "information",
  "upgrade"
];
var noop2 = () => {
};

class Request extends Duplex {
  constructor(url, options2, defaults) {
    super({
      autoDestroy: false,
      highWaterMark: 0
    });
    Object.defineProperty(this, "constructor", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_noPipe", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "requestUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "redirectUrls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "retryCount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_stopRetry", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_downloadedSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_uploadedSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_stopReading", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_pipedServerResponses", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_responseSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_bodySize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_unproxyEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_isFromCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_cannotHaveBody", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_triggerRead", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_cancelTimeouts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_removeListeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_nativeResponse", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_flushed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_aborted", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_requestInitialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this._downloadedSize = 0;
    this._uploadedSize = 0;
    this._stopReading = false;
    this._pipedServerResponses = new Set;
    this._cannotHaveBody = false;
    this._unproxyEvents = noop2;
    this._triggerRead = false;
    this._cancelTimeouts = noop2;
    this._removeListeners = noop2;
    this._jobs = [];
    this._flushed = false;
    this._requestInitialized = false;
    this._aborted = false;
    this.redirectUrls = [];
    this.retryCount = 0;
    this._stopRetry = noop2;
    this.on("pipe", (source) => {
      if (source?.headers) {
        Object.assign(this.options.headers, source.headers);
      }
    });
    this.on("newListener", (event) => {
      if (event === "retry" && this.listenerCount("retry") > 0) {
        throw new Error("A retry listener has been attached already.");
      }
    });
    try {
      this.options = new Options(url, options2, defaults);
      if (!this.options.url) {
        if (this.options.prefixUrl === "") {
          throw new TypeError("Missing `url` property");
        }
        this.options.url = "";
      }
      this.requestUrl = this.options.url;
    } catch (error) {
      const { options: options3 } = error;
      if (options3) {
        this.options = options3;
      }
      this.flush = async () => {
        this.flush = async () => {
        };
        this.destroy(error);
      };
      return;
    }
    const { body } = this.options;
    if (dist_default.nodeStream(body)) {
      body.once("error", (error) => {
        if (this._flushed) {
          this._beforeError(new UploadError(error, this));
        } else {
          this.flush = async () => {
            this.flush = async () => {
            };
            this._beforeError(new UploadError(error, this));
          };
        }
      });
    }
    if (this.options.signal) {
      const abort = () => {
        this.destroy(new AbortError(this));
      };
      if (this.options.signal.aborted) {
        abort();
      } else {
        this.options.signal.addEventListener("abort", abort);
        this._removeListeners = () => {
          this.options.signal?.removeEventListener("abort", abort);
        };
      }
    }
  }
  async flush() {
    if (this._flushed) {
      return;
    }
    this._flushed = true;
    try {
      await this._finalizeBody();
      if (this.destroyed) {
        return;
      }
      await this._makeRequest();
      if (this.destroyed) {
        this._request?.destroy();
        return;
      }
      for (const job of this._jobs) {
        job();
      }
      this._jobs.length = 0;
      this._requestInitialized = true;
    } catch (error) {
      this._beforeError(error);
    }
  }
  _beforeError(error) {
    if (this._stopReading) {
      return;
    }
    const { response: response2, options: options2 } = this;
    const attemptCount = this.retryCount + (error.name === "RetryError" ? 0 : 1);
    this._stopReading = true;
    if (!(error instanceof RequestError)) {
      error = new RequestError(error.message, error, this);
    }
    const typedError = error;
    (async () => {
      if (response2?.readable && !response2.rawBody && !this._request?.socket?.destroyed) {
        response2.setEncoding(this.readableEncoding);
        const success = await this._setRawBody(response2);
        if (success) {
          response2.body = response2.rawBody.toString();
        }
      }
      if (this.listenerCount("retry") !== 0) {
        let backoff;
        try {
          let retryAfter;
          if (response2 && ("retry-after" in response2.headers)) {
            retryAfter = Number(response2.headers["retry-after"]);
            if (Number.isNaN(retryAfter)) {
              retryAfter = Date.parse(response2.headers["retry-after"]) - Date.now();
              if (retryAfter <= 0) {
                retryAfter = 1;
              }
            } else {
              retryAfter *= 1000;
            }
          }
          const retryOptions = options2.retry;
          backoff = await retryOptions.calculateDelay({
            attemptCount,
            retryOptions,
            error: typedError,
            retryAfter,
            computedValue: calculate_retry_delay_default({
              attemptCount,
              retryOptions,
              error: typedError,
              retryAfter,
              computedValue: retryOptions.maxRetryAfter ?? options2.timeout.request ?? Number.POSITIVE_INFINITY
            })
          });
        } catch (error_) {
          this._error(new RequestError(error_.message, error_, this));
          return;
        }
        if (backoff) {
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, backoff);
            this._stopRetry = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
          if (this.destroyed) {
            return;
          }
          try {
            for (const hook of this.options.hooks.beforeRetry) {
              await hook(typedError, this.retryCount + 1);
            }
          } catch (error_) {
            this._error(new RequestError(error_.message, error, this));
            return;
          }
          if (this.destroyed) {
            return;
          }
          this.destroy();
          this.emit("retry", this.retryCount + 1, error, (updatedOptions) => {
            const request = new Request(options2.url, updatedOptions, options2);
            request.retryCount = this.retryCount + 1;
            process3.nextTick(() => {
              request.flush();
            });
            return request;
          });
          return;
        }
      }
      this._error(typedError);
    })();
  }
  _read() {
    this._triggerRead = true;
    const { response: response2 } = this;
    if (response2 && !this._stopReading) {
      if (response2.readableLength) {
        this._triggerRead = false;
      }
      let data;
      while ((data = response2.read()) !== null) {
        this._downloadedSize += data.length;
        const progress = this.downloadProgress;
        if (progress.percent < 1) {
          this.emit("downloadProgress", progress);
        }
        this.push(data);
      }
    }
  }
  _write(chunk, encoding, callback) {
    const write = () => {
      this._writeRequest(chunk, encoding, callback);
    };
    if (this._requestInitialized) {
      write();
    } else {
      this._jobs.push(write);
    }
  }
  _final(callback) {
    const endRequest = () => {
      if (!this._request || this._request.destroyed) {
        callback();
        return;
      }
      this._request.end((error) => {
        if (this._request._writableState?.errored) {
          return;
        }
        if (!error) {
          this._bodySize = this._uploadedSize;
          this.emit("uploadProgress", this.uploadProgress);
          this._request.emit("upload-complete");
        }
        callback(error);
      });
    };
    if (this._requestInitialized) {
      endRequest();
    } else {
      this._jobs.push(endRequest);
    }
  }
  _destroy(error, callback) {
    this._stopReading = true;
    this.flush = async () => {
    };
    this._stopRetry();
    this._cancelTimeouts();
    this._removeListeners();
    if (this.options) {
      const { body } = this.options;
      if (dist_default.nodeStream(body)) {
        body.destroy();
      }
    }
    if (this._request) {
      this._request.destroy();
    }
    if (error !== null && !dist_default.undefined(error) && !(error instanceof RequestError)) {
      error = new RequestError(error.message, error, this);
    }
    callback(error);
  }
  pipe(destination, options2) {
    if (destination instanceof ServerResponse) {
      this._pipedServerResponses.add(destination);
    }
    return super.pipe(destination, options2);
  }
  unpipe(destination) {
    if (destination instanceof ServerResponse) {
      this._pipedServerResponses.delete(destination);
    }
    super.unpipe(destination);
    return this;
  }
  async _finalizeBody() {
    const { options: options2 } = this;
    const { headers } = options2;
    const isForm = !dist_default.undefined(options2.form);
    const isJSON = !dist_default.undefined(options2.json);
    const isBody = !dist_default.undefined(options2.body);
    const cannotHaveBody = methodsWithoutBody.has(options2.method) && !(options2.method === "GET" && options2.allowGetBody);
    this._cannotHaveBody = cannotHaveBody;
    if (isForm || isJSON || isBody) {
      if (cannotHaveBody) {
        throw new TypeError(`The \`${options2.method}\` method cannot be used with a body`);
      }
      const noContentType = !dist_default.string(headers["content-type"]);
      if (isBody) {
        if (isFormData(options2.body)) {
          const encoder = new FormDataEncoder(options2.body);
          if (noContentType) {
            headers["content-type"] = encoder.headers["Content-Type"];
          }
          if ("Content-Length" in encoder.headers) {
            headers["content-length"] = encoder.headers["Content-Length"];
          }
          options2.body = encoder.encode();
        }
        if (isFormData3(options2.body) && noContentType) {
          headers["content-type"] = `multipart/form-data; boundary=${options2.body.getBoundary()}`;
        }
      } else if (isForm) {
        if (noContentType) {
          headers["content-type"] = "application/x-www-form-urlencoded";
        }
        const { form } = options2;
        options2.form = undefined;
        options2.body = new URLSearchParams(form).toString();
      } else {
        if (noContentType) {
          headers["content-type"] = "application/json";
        }
        const { json } = options2;
        options2.json = undefined;
        options2.body = options2.stringifyJson(json);
      }
      const uploadBodySize = await getBodySize(options2.body, options2.headers);
      if (dist_default.undefined(headers["content-length"]) && dist_default.undefined(headers["transfer-encoding"]) && !cannotHaveBody && !dist_default.undefined(uploadBodySize)) {
        headers["content-length"] = String(uploadBodySize);
      }
    }
    if (options2.responseType === "json" && !("accept" in options2.headers)) {
      options2.headers.accept = "application/json";
    }
    this._bodySize = Number(headers["content-length"]) || undefined;
  }
  async _onResponseBase(response2) {
    if (this.isAborted) {
      return;
    }
    const { options: options2 } = this;
    const { url } = options2;
    this._nativeResponse = response2;
    if (options2.decompress) {
      response2 = import_decompress_response.default(response2);
    }
    const statusCode = response2.statusCode;
    const typedResponse = response2;
    typedResponse.statusMessage = typedResponse.statusMessage ?? http2.STATUS_CODES[statusCode];
    typedResponse.url = options2.url.toString();
    typedResponse.requestUrl = this.requestUrl;
    typedResponse.redirectUrls = this.redirectUrls;
    typedResponse.request = this;
    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
    typedResponse.ip = this.ip;
    typedResponse.retryCount = this.retryCount;
    typedResponse.ok = isResponseOk(typedResponse);
    this._isFromCache = typedResponse.isFromCache;
    this._responseSize = Number(response2.headers["content-length"]) || undefined;
    this.response = typedResponse;
    response2.once("end", () => {
      this._responseSize = this._downloadedSize;
      this.emit("downloadProgress", this.downloadProgress);
    });
    response2.once("error", (error) => {
      this._aborted = true;
      response2.destroy();
      this._beforeError(new ReadError(error, this));
    });
    response2.once("aborted", () => {
      this._aborted = true;
      this._beforeError(new ReadError({
        name: "Error",
        message: "The server aborted pending request",
        code: "ECONNRESET"
      }, this));
    });
    this.emit("downloadProgress", this.downloadProgress);
    const rawCookies = response2.headers["set-cookie"];
    if (dist_default.object(options2.cookieJar) && rawCookies) {
      let promises4 = rawCookies.map(async (rawCookie) => options2.cookieJar.setCookie(rawCookie, url.toString()));
      if (options2.ignoreInvalidCookies) {
        promises4 = promises4.map(async (promise) => {
          try {
            await promise;
          } catch {
          }
        });
      }
      try {
        await Promise.all(promises4);
      } catch (error) {
        this._beforeError(error);
        return;
      }
    }
    if (this.isAborted) {
      return;
    }
    if (options2.followRedirect && response2.headers.location && redirectCodes.has(statusCode)) {
      response2.resume();
      this._cancelTimeouts();
      this._unproxyEvents();
      if (this.redirectUrls.length >= options2.maxRedirects) {
        this._beforeError(new MaxRedirectsError(this));
        return;
      }
      this._request = undefined;
      const updatedOptions = new Options(undefined, undefined, this.options);
      const serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
      const canRewrite = statusCode !== 307 && statusCode !== 308;
      const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
      if (serverRequestedGet || userRequestedGet) {
        updatedOptions.method = "GET";
        updatedOptions.body = undefined;
        updatedOptions.json = undefined;
        updatedOptions.form = undefined;
        delete updatedOptions.headers["content-length"];
      }
      try {
        const redirectBuffer = Buffer3.from(response2.headers.location, "binary").toString();
        const redirectUrl = new URL(redirectBuffer, url);
        if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
          this._beforeError(new RequestError("Cannot redirect to UNIX socket", {}, this));
          return;
        }
        if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
          if ("host" in updatedOptions.headers) {
            delete updatedOptions.headers.host;
          }
          if ("cookie" in updatedOptions.headers) {
            delete updatedOptions.headers.cookie;
          }
          if ("authorization" in updatedOptions.headers) {
            delete updatedOptions.headers.authorization;
          }
          if (updatedOptions.username || updatedOptions.password) {
            updatedOptions.username = "";
            updatedOptions.password = "";
          }
        } else {
          redirectUrl.username = updatedOptions.username;
          redirectUrl.password = updatedOptions.password;
        }
        this.redirectUrls.push(redirectUrl);
        updatedOptions.prefixUrl = "";
        updatedOptions.url = redirectUrl;
        for (const hook of updatedOptions.hooks.beforeRedirect) {
          await hook(updatedOptions, typedResponse);
        }
        this.emit("redirect", updatedOptions, typedResponse);
        this.options = updatedOptions;
        await this._makeRequest();
      } catch (error) {
        this._beforeError(error);
        return;
      }
      return;
    }
    if (options2.isStream && options2.throwHttpErrors && !isResponseOk(typedResponse)) {
      this._beforeError(new HTTPError(typedResponse));
      return;
    }
    response2.on("readable", () => {
      if (this._triggerRead) {
        this._read();
      }
    });
    this.on("resume", () => {
      response2.resume();
    });
    this.on("pause", () => {
      response2.pause();
    });
    response2.once("end", () => {
      this.push(null);
    });
    if (this._noPipe) {
      const success = await this._setRawBody();
      if (success) {
        this.emit("response", response2);
      }
      return;
    }
    this.emit("response", response2);
    for (const destination of this._pipedServerResponses) {
      if (destination.headersSent) {
        continue;
      }
      for (const key in response2.headers) {
        const isAllowed = options2.decompress ? key !== "content-encoding" : true;
        const value = response2.headers[key];
        if (isAllowed) {
          destination.setHeader(key, value);
        }
      }
      destination.statusCode = statusCode;
    }
  }
  async _setRawBody(from = this) {
    if (from.readableEnded) {
      return false;
    }
    try {
      const rawBody = await getStreamAsBuffer(from);
      if (!this.isAborted) {
        this.response.rawBody = rawBody;
        return true;
      }
    } catch {
    }
    return false;
  }
  async _onResponse(response2) {
    try {
      await this._onResponseBase(response2);
    } catch (error) {
      this._beforeError(error);
    }
  }
  _onRequest(request) {
    const { options: options2 } = this;
    const { timeout, url } = options2;
    source_default(request);
    if (this.options.http2) {
      request.setTimeout(0);
    }
    this._cancelTimeouts = timedOut(request, timeout, url);
    const responseEventName = options2.cache ? "cacheableResponse" : "response";
    request.once(responseEventName, (response2) => {
      this._onResponse(response2);
    });
    request.once("error", (error) => {
      this._aborted = true;
      request.destroy();
      error = error instanceof TimeoutError2 ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);
      this._beforeError(error);
    });
    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);
    this._request = request;
    this.emit("uploadProgress", this.uploadProgress);
    this._sendBody();
    this.emit("request", request);
  }
  async _asyncWrite(chunk) {
    return new Promise((resolve, reject) => {
      super.write(chunk, (error) => {
        if (error) {
          reject(error);
          return;
        }
        resolve();
      });
    });
  }
  _sendBody() {
    const { body } = this.options;
    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
    if (dist_default.nodeStream(body)) {
      body.pipe(currentRequest);
    } else if (dist_default.generator(body) || dist_default.asyncGenerator(body)) {
      (async () => {
        try {
          for await (const chunk of body) {
            await this._asyncWrite(chunk);
          }
          super.end();
        } catch (error) {
          this._beforeError(error);
        }
      })();
    } else if (!dist_default.undefined(body)) {
      this._writeRequest(body, undefined, () => {
      });
      currentRequest.end();
    } else if (this._cannotHaveBody || this._noPipe) {
      currentRequest.end();
    }
  }
  _prepareCache(cache) {
    if (!cacheableStore.has(cache)) {
      const cacheableRequest = new dist_default2((requestOptions, handler) => {
        const result = requestOptions._request(requestOptions, handler);
        if (dist_default.promise(result)) {
          result.once = (event, handler2) => {
            if (event === "error") {
              (async () => {
                try {
                  await result;
                } catch (error) {
                  handler2(error);
                }
              })();
            } else if (event === "abort") {
              (async () => {
                try {
                  const request = await result;
                  request.once("abort", handler2);
                } catch {
                }
              })();
            } else {
              throw new Error(`Unknown HTTP2 promise event: ${event}`);
            }
            return result;
          };
        }
        return result;
      }, cache);
      cacheableStore.set(cache, cacheableRequest.request());
    }
  }
  async _createCacheableRequest(url, options2) {
    return new Promise((resolve, reject) => {
      Object.assign(options2, urlToOptions(url));
      let request;
      const cacheRequest = cacheableStore.get(options2.cache)(options2, async (response2) => {
        response2._readableState.autoDestroy = false;
        if (request) {
          const fix = () => {
            if (response2.req) {
              response2.complete = response2.req.res.complete;
            }
          };
          response2.prependOnceListener("end", fix);
          fix();
          (await request).emit("cacheableResponse", response2);
        }
        resolve(response2);
      });
      cacheRequest.once("error", reject);
      cacheRequest.once("request", async (requestOrPromise) => {
        request = requestOrPromise;
        resolve(request);
      });
    });
  }
  async _makeRequest() {
    const { options: options2 } = this;
    const { headers, username, password } = options2;
    const cookieJar = options2.cookieJar;
    for (const key in headers) {
      if (dist_default.undefined(headers[key])) {
        delete headers[key];
      } else if (dist_default.null_(headers[key])) {
        throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
      }
    }
    if (options2.decompress && dist_default.undefined(headers["accept-encoding"])) {
      headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
    }
    if (username || password) {
      const credentials = Buffer3.from(`${username}:${password}`).toString("base64");
      headers.authorization = `Basic ${credentials}`;
    }
    if (cookieJar) {
      const cookieString = await cookieJar.getCookieString(options2.url.toString());
      if (dist_default.nonEmptyString(cookieString)) {
        headers.cookie = cookieString;
      }
    }
    options2.prefixUrl = "";
    let request;
    for (const hook of options2.hooks.beforeRequest) {
      const result = await hook(options2);
      if (!dist_default.undefined(result)) {
        request = () => result;
        break;
      }
    }
    if (!request) {
      request = options2.getRequestFunction();
    }
    const url = options2.url;
    this._requestOptions = options2.createNativeRequestOptions();
    if (options2.cache) {
      this._requestOptions._request = request;
      this._requestOptions.cache = options2.cache;
      this._requestOptions.body = options2.body;
      this._prepareCache(options2.cache);
    }
    const fn = options2.cache ? this._createCacheableRequest : request;
    try {
      let requestOrResponse = fn(url, this._requestOptions);
      if (dist_default.promise(requestOrResponse)) {
        requestOrResponse = await requestOrResponse;
      }
      if (dist_default.undefined(requestOrResponse)) {
        requestOrResponse = options2.getFallbackRequestFunction()(url, this._requestOptions);
        if (dist_default.promise(requestOrResponse)) {
          requestOrResponse = await requestOrResponse;
        }
      }
      if (is_client_request_default(requestOrResponse)) {
        this._onRequest(requestOrResponse);
      } else if (this.writable) {
        this.once("finish", () => {
          this._onResponse(requestOrResponse);
        });
        this._sendBody();
      } else {
        this._onResponse(requestOrResponse);
      }
    } catch (error) {
      if (error instanceof CacheError2) {
        throw new CacheError(error, this);
      }
      throw error;
    }
  }
  async _error(error) {
    try {
      if (error instanceof HTTPError && !this.options.throwHttpErrors) {
      } else {
        for (const hook of this.options.hooks.beforeError) {
          error = await hook(error);
        }
      }
    } catch (error_) {
      error = new RequestError(error_.message, error_, this);
    }
    this.destroy(error);
  }
  _writeRequest(chunk, encoding, callback) {
    if (!this._request || this._request.destroyed) {
      return;
    }
    this._request.write(chunk, encoding, (error) => {
      if (!error && !this._request.destroyed) {
        this._uploadedSize += Buffer3.byteLength(chunk, encoding);
        const progress = this.uploadProgress;
        if (progress.percent < 1) {
          this.emit("uploadProgress", progress);
        }
      }
      callback(error);
    });
  }
  get ip() {
    return this.socket?.remoteAddress;
  }
  get isAborted() {
    return this._aborted;
  }
  get socket() {
    return this._request?.socket ?? undefined;
  }
  get downloadProgress() {
    let percent;
    if (this._responseSize) {
      percent = this._downloadedSize / this._responseSize;
    } else if (this._responseSize === this._downloadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._downloadedSize,
      total: this._responseSize
    };
  }
  get uploadProgress() {
    let percent;
    if (this._bodySize) {
      percent = this._uploadedSize / this._bodySize;
    } else if (this._bodySize === this._uploadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._uploadedSize,
      total: this._bodySize
    };
  }
  get timings() {
    return this._request?.timings;
  }
  get isFromCache() {
    return this._isFromCache;
  }
  get reusedSocket() {
    return this._request?.reusedSocket;
  }
}

// node_modules/got/dist/source/as-promise/types.js
class CancelError2 extends RequestError {
  constructor(request) {
    super("Promise was canceled", {}, request);
    this.name = "CancelError";
    this.code = "ERR_CANCELED";
  }
  get isCanceled() {
    return true;
  }
}

// node_modules/got/dist/source/as-promise/index.js
var proxiedRequestEvents2 = [
  "request",
  "response",
  "redirect",
  "uploadProgress",
  "downloadProgress"
];
function asPromise(firstRequest) {
  let globalRequest;
  let globalResponse;
  let normalizedOptions;
  const emitter = new EventEmitter2;
  const promise = new PCancelable((resolve, reject, onCancel) => {
    onCancel(() => {
      globalRequest.destroy();
    });
    onCancel.shouldReject = false;
    onCancel(() => {
      reject(new CancelError2(globalRequest));
    });
    const makeRequest = (retryCount) => {
      onCancel(() => {
      });
      const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);
      request.retryCount = retryCount;
      request._noPipe = true;
      globalRequest = request;
      request.once("response", async (response3) => {
        const contentEncoding = (response3.headers["content-encoding"] ?? "").toLowerCase();
        const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br";
        const { options: options2 } = request;
        if (isCompressed && !options2.decompress) {
          response3.body = response3.rawBody;
        } else {
          try {
            response3.body = parseBody(response3, options2.responseType, options2.parseJson, options2.encoding);
          } catch (error) {
            response3.body = response3.rawBody.toString();
            if (isResponseOk(response3)) {
              request._beforeError(error);
              return;
            }
          }
        }
        try {
          const hooks = options2.hooks.afterResponse;
          for (const [index, hook] of hooks.entries()) {
            response3 = await hook(response3, async (updatedOptions) => {
              options2.merge(updatedOptions);
              options2.prefixUrl = "";
              if (updatedOptions.url) {
                options2.url = updatedOptions.url;
              }
              options2.hooks.afterResponse = options2.hooks.afterResponse.slice(0, index);
              throw new RetryError(request);
            });
            if (!(dist_default.object(response3) && dist_default.number(response3.statusCode) && !dist_default.nullOrUndefined(response3.body))) {
              throw new TypeError("The `afterResponse` hook returned an invalid value");
            }
          }
        } catch (error) {
          request._beforeError(error);
          return;
        }
        globalResponse = response3;
        if (!isResponseOk(response3)) {
          request._beforeError(new HTTPError(response3));
          return;
        }
        request.destroy();
        resolve(request.options.resolveBodyOnly ? response3.body : response3);
      });
      const onError = (error) => {
        if (promise.isCanceled) {
          return;
        }
        const { options: options2 } = request;
        if (error instanceof HTTPError && !options2.throwHttpErrors) {
          const { response: response3 } = error;
          request.destroy();
          resolve(request.options.resolveBodyOnly ? response3.body : response3);
          return;
        }
        reject(error);
      };
      request.once("error", onError);
      const previousBody = request.options?.body;
      request.once("retry", (newRetryCount, error) => {
        firstRequest = undefined;
        const newBody = request.options.body;
        if (previousBody === newBody && dist_default.nodeStream(newBody)) {
          error.message = "Cannot retry with consumed body stream";
          onError(error);
          return;
        }
        normalizedOptions = request.options;
        makeRequest(newRetryCount);
      });
      proxyEvents(request, emitter, proxiedRequestEvents2);
      if (dist_default.undefined(firstRequest)) {
        request.flush();
      }
    };
    makeRequest(0);
  });
  promise.on = (event, fn) => {
    emitter.on(event, fn);
    return promise;
  };
  promise.off = (event, fn) => {
    emitter.off(event, fn);
    return promise;
  };
  const shortcut = (responseType) => {
    const newPromise = (async () => {
      await promise;
      const { options: options2 } = globalResponse.request;
      return parseBody(globalResponse, responseType, options2.parseJson, options2.encoding);
    })();
    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
    return newPromise;
  };
  promise.json = () => {
    if (globalRequest.options) {
      const { headers } = globalRequest.options;
      if (!globalRequest.writableFinished && !("accept" in headers)) {
        headers.accept = "application/json";
      }
    }
    return shortcut("json");
  };
  promise.buffer = () => shortcut("buffer");
  promise.text = () => shortcut("text");
  return promise;
}

// node_modules/got/dist/source/create.js
var delay = async (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});
var isGotInstance = (value) => dist_default.function_(value);
var aliases = [
  "get",
  "post",
  "put",
  "patch",
  "head",
  "delete"
];
var create = (defaults) => {
  defaults = {
    options: new Options(undefined, undefined, defaults.options),
    handlers: [...defaults.handlers],
    mutableDefaults: defaults.mutableDefaults
  };
  Object.defineProperty(defaults, "mutableDefaults", {
    enumerable: true,
    configurable: false,
    writable: false
  });
  const got = (url, options3, defaultOptions2 = defaults.options) => {
    const request = new Request(url, options3, defaultOptions2);
    let promise;
    const lastHandler = (normalized) => {
      request.options = normalized;
      request._noPipe = !normalized.isStream;
      request.flush();
      if (normalized.isStream) {
        return request;
      }
      if (!promise) {
        promise = asPromise(request);
      }
      return promise;
    };
    let iteration = 0;
    const iterateHandlers = (newOptions) => {
      const handler = defaults.handlers[iteration++] ?? lastHandler;
      const result = handler(newOptions, iterateHandlers);
      if (dist_default.promise(result) && !request.options.isStream) {
        if (!promise) {
          promise = asPromise(request);
        }
        if (result !== promise) {
          const descriptors = Object.getOwnPropertyDescriptors(promise);
          for (const key in descriptors) {
            if (key in result) {
              delete descriptors[key];
            }
          }
          Object.defineProperties(result, descriptors);
          result.cancel = promise.cancel;
        }
      }
      return result;
    };
    return iterateHandlers(request.options);
  };
  got.extend = (...instancesOrOptions) => {
    const options3 = new Options(undefined, undefined, defaults.options);
    const handlers = [...defaults.handlers];
    let mutableDefaults;
    for (const value of instancesOrOptions) {
      if (isGotInstance(value)) {
        options3.merge(value.defaults.options);
        handlers.push(...value.defaults.handlers);
        mutableDefaults = value.defaults.mutableDefaults;
      } else {
        options3.merge(value);
        if (value.handlers) {
          handlers.push(...value.handlers);
        }
        mutableDefaults = value.mutableDefaults;
      }
    }
    return create({
      options: options3,
      handlers,
      mutableDefaults: Boolean(mutableDefaults)
    });
  };
  const paginateEach = async function* (url, options3) {
    let normalizedOptions = new Options(url, options3, defaults.options);
    normalizedOptions.resolveBodyOnly = false;
    const { pagination } = normalizedOptions;
    assert.function_(pagination.transform);
    assert.function_(pagination.shouldContinue);
    assert.function_(pagination.filter);
    assert.function_(pagination.paginate);
    assert.number(pagination.countLimit);
    assert.number(pagination.requestLimit);
    assert.number(pagination.backoff);
    const allItems = [];
    let { countLimit } = pagination;
    let numberOfRequests = 0;
    while (numberOfRequests < pagination.requestLimit) {
      if (numberOfRequests !== 0) {
        await delay(pagination.backoff);
      }
      const response3 = await got(undefined, undefined, normalizedOptions);
      const parsed = await pagination.transform(response3);
      const currentItems = [];
      assert.array(parsed);
      for (const item of parsed) {
        if (pagination.filter({ item, currentItems, allItems })) {
          if (!pagination.shouldContinue({ item, currentItems, allItems })) {
            return;
          }
          yield item;
          if (pagination.stackAllItems) {
            allItems.push(item);
          }
          currentItems.push(item);
          if (--countLimit <= 0) {
            return;
          }
        }
      }
      const optionsToMerge = pagination.paginate({
        response: response3,
        currentItems,
        allItems
      });
      if (optionsToMerge === false) {
        return;
      }
      if (optionsToMerge === response3.request.options) {
        normalizedOptions = response3.request.options;
      } else {
        normalizedOptions.merge(optionsToMerge);
        assert.any([dist_default.urlInstance, dist_default.undefined], optionsToMerge.url);
        if (optionsToMerge.url !== undefined) {
          normalizedOptions.prefixUrl = "";
          normalizedOptions.url = optionsToMerge.url;
        }
      }
      numberOfRequests++;
    }
  };
  got.paginate = paginateEach;
  got.paginate.all = async (url, options3) => {
    const results = [];
    for await (const item of paginateEach(url, options3)) {
      results.push(item);
    }
    return results;
  };
  got.paginate.each = paginateEach;
  got.stream = (url, options3) => got(url, { ...options3, isStream: true });
  for (const method of aliases) {
    got[method] = (url, options3) => got(url, { ...options3, method });
    got.stream[method] = (url, options3) => got(url, { ...options3, method, isStream: true });
  }
  if (!defaults.mutableDefaults) {
    Object.freeze(defaults.handlers);
    defaults.options.freeze();
  }
  Object.defineProperty(got, "defaults", {
    value: defaults,
    writable: false,
    configurable: false,
    enumerable: true
  });
  return got;
};
var create_default = create;
// node_modules/got/dist/source/index.js
var defaults = {
  options: new Options,
  handlers: [],
  mutableDefaults: false
};
var got = create_default(defaults);

// src/proxy.ts
var import_https_proxy_agent = __toESM(require_dist2(), 1);
var import_joi5 = __toESM(require_lib4(), 1);
var httpProxy = process.env.http_proxy || process.env.HTTP_PROXY || process.env.https_proxy || process.env.HTTPS_PROXY || process.env.all_proxy || process.env.ALL_PROXY;
var httpProxySchema = import_joi5.default.string().uri({
  scheme: ["http", "https"]
});
var getHttpsProxyAgent = () => {
  if (httpProxy) {
    import_joi5.default.assert(httpProxy, httpProxySchema);
    return new import_https_proxy_agent.HttpsProxyAgent(httpProxy);
  }
};

// src/http-client.ts
var debug2 = import_debug2.default("got");
var agent = getHttpsProxyAgent();
var client = got.extend({
  agent: {
    https: agent
  },
  hooks: {
    beforeRequest: [
      (options5) => {
        debug2(`${options5.method} ${options5.url}`);
      }
    ],
    afterResponse: [
      (response4, retryWithMergedOptions) => {
        debug2(`${response4.statusCode} ${response4.statusMessage}`);
        return response4;
      }
    ],
    beforeRetry: [
      (error, count) => {
        debug2(`${error?.response?.statusCode} retry number ${count}`);
      }
    ]
  }
});
var retryCount = 100;
var requestOptions = {
  retry: {
    limit: retryCount
  }
};

// src/progress.ts
var import_bytes = __toESM(require_bytes(), 1);
var import_format_duration = __toESM(require_format_duration(), 1);
var import_gauge = __toESM(require_lib5(), 1);

class Progress {
  gauge = new import_gauge.default;
  bytes = 0;
  total = 0;
  start = undefined;
  constructor() {
  }
  addPart(part2) {
    this.total += part2.range.size();
    this.update();
    if (this.start === undefined) {
      this.start = Date.now();
    }
  }
  completePart(part2) {
    this.bytes += part2.range.size();
    this.update();
  }
  update() {
    const { bytes, gauge, start, total } = this;
    let timeString = "";
    if (start !== undefined) {
      const elapsedMilliseconds = Date.now() - start;
      const elapsedString = import_format_duration.default(elapsedMilliseconds);
      timeString = elapsedString;
    }
    const proportionComplete = bytes / total;
    const percentCompleteString = `${Math.round(proportionComplete * 100)}%`;
    const sizeString = `${import_bytes.format(bytes)} / ${import_bytes.format(total)}`;
    gauge.show(`${percentCompleteString} ${sizeString} ${timeString}`, proportionComplete);
  }
}

// src/socket-client.ts
var import_debug13 = __toESM(require_src(), 1);
var import_joi6 = __toESM(require_lib4(), 1);

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.js
function encodePacketToBinary(packet, callback) {
  if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
    return callback(toBuffer(packet.data, false));
  }
  encodePacket(packet, true, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder;
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return callback(supportsBinary ? data : "b" + toBuffer(data, true).toString("base64"));
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var toBuffer = (data, forceBufferConversion) => {
  if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return Buffer.from(data);
  } else {
    return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  }
};
var TEXT_ENCODER;

// node_modules/engine.io-parser/build/esm/decodePacket.js
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    const buffer = Buffer.from(encodedPacket.substring(1), "base64");
    return {
      type: "message",
      data: mapBinary(buffer, binaryType)
    };
  }
  if (!PACKET_TYPES_REVERSE[type]) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "arraybuffer":
      if (data instanceof ArrayBuffer) {
        return data;
      } else if (Buffer.isBuffer(data)) {
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      } else {
        return data.buffer;
      }
    case "nodebuffer":
    default:
      if (Buffer.isBuffer(data)) {
        return data;
      } else {
        return Buffer.from(data);
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var totalLength = function(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
};
var concatChunks = function(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i = 0;i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
};
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder;
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0;i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
var TEXT_DECODER;
var protocol = 4;

// node_modules/engine.io-client/build/esm-debug/transport.js
var component_emitter = __toESM(require_component_emitter(), 1);

// node_modules/engine.io-client/build/esm-debug/globalThis.js
var globalThisShim = global;

// node_modules/engine.io-client/build/esm-debug/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
var utf8Length = function(str) {
  let c = 0, length = 0;
  for (let i = 0, l = str.length;i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length += 1;
    } else if (c < 2048) {
      length += 2;
    } else if (c < 55296 || c >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
};
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
var BASE64_OVERHEAD = 1.33;

// node_modules/engine.io-client/build/esm-debug/transport.js
var import_debug3 = __toESM(require_src(), 1);

// node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length;i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm-debug/transport.js
var debug3 = import_debug3.default("engine.io-client:transport");

class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}

class Transport extends component_emitter.Emitter {
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
      debug3("transport is not open, discarding packets");
    }
  }
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}

// node_modules/engine.io-client/build/esm-debug/transports/polling.js
var import_debug4 = __toESM(require_src(), 1);

// node_modules/engine.io-client/build/esm-debug/contrib/yeast.js
function encode2(num) {
  let encoded = "";
  do {
    encoded = alphabet2[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode2(+new Date);
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode2(seed++);
}
var alphabet2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var length = 64;
var map = {};
var seed = 0;
var i = 0;
var prev;
for (;i < length; i++)
  map[alphabet2[i]] = i;

// node_modules/engine.io-client/build/esm-debug/transports/xmlhttprequest.js
var XMLHttpRequestModule = __toESM(require_XMLHttpRequest(), 1);
function createCookieJar() {
  return new CookieJar;
}
function parse2(setCookieString) {
  const parts = setCookieString.split("; ");
  const i2 = parts[0].indexOf("=");
  if (i2 === -1) {
    return;
  }
  const name = parts[0].substring(0, i2).trim();
  if (!name.length) {
    return;
  }
  let value = parts[0].substring(i2 + 1).trim();
  if (value.charCodeAt(0) === 34) {
    value = value.slice(1, -1);
  }
  const cookie = {
    name,
    value
  };
  for (let j = 1;j < parts.length; j++) {
    const subParts = parts[j].split("=");
    if (subParts.length !== 2) {
      continue;
    }
    const key = subParts[0].trim();
    const value2 = subParts[1].trim();
    switch (key) {
      case "Expires":
        cookie.expires = new Date(value2);
        break;
      case "Max-Age":
        const expiration = new Date;
        expiration.setUTCSeconds(expiration.getUTCSeconds() + parseInt(value2, 10));
        cookie.expires = expiration;
        break;
      default:
    }
  }
  return cookie;
}
var XHR = XMLHttpRequestModule.default || XMLHttpRequestModule;

class CookieJar {
  constructor() {
    this.cookies = new Map;
  }
  parseCookies(xhr) {
    const values = xhr.getResponseHeader("set-cookie");
    if (!values) {
      return;
    }
    values.forEach((value) => {
      const parsed = parse2(value);
      if (parsed) {
        this.cookies.set(parsed.name, parsed);
      }
    });
  }
  addCookies(xhr) {
    const cookies = [];
    this.cookies.forEach((cookie, name) => {
      var _a;
      if (((_a = cookie.expires) === null || _a === undefined ? undefined : _a.getTime()) < Date.now()) {
        this.cookies.delete(name);
      } else {
        cookies.push(`${name}=${cookie.value}`);
      }
    });
    if (cookies.length) {
      xhr.setDisableHeaderCheck(true);
      xhr.setRequestHeader("cookie", cookies.join("; "));
    }
  }
}

// node_modules/engine.io-client/build/esm-debug/transports/polling.js
var component_emitter2 = __toESM(require_component_emitter(), 1);
var empty = function() {
};
var unloadHandler = function() {
  for (let i2 in Request2.requests) {
    if (Request2.requests.hasOwnProperty(i2)) {
      Request2.requests[i2].abort();
    }
  }
};
var debug4 = import_debug4.default("engine.io-client:polling");
var hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return xhr.responseType != null;
}();

class Polling extends Transport {
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = location.protocol === "https:";
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      debug4("paused");
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        debug4("we are currently polling - waiting to pause");
        total++;
        this.once("pollComplete", function() {
          debug4("pre-pause polling complete");
          --total || pause();
        });
      }
      if (!this.writable) {
        debug4("we are currently writing - waiting to pause");
        total++;
        this.once("drain", function() {
          debug4("pre-pause writing complete");
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  poll() {
    debug4("polling");
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  onData(data) {
    debug4("polling got data %s", data);
    const callback = (packet) => {
      if (this.readyState === "opening" && packet.type === "open") {
        this.onOpen();
      }
      if (packet.type === "close") {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if (this.readyState !== "closed") {
      this.polling = false;
      this.emitReserved("pollComplete");
      if (this.readyState === "open") {
        this.poll();
      } else {
        debug4('ignoring poll - transport state "%s"', this.readyState);
      }
    }
  }
  doClose() {
    const close = () => {
      debug4("writing close packet");
      this.write([{ type: "close" }]);
    };
    if (this.readyState === "open") {
      debug4("transport open - closing");
      close();
    } else {
      debug4("transport not open - deferring close");
      this.once("open", close);
    }
  }
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (this.opts.timestampRequests !== false) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request2(this.uri(), opts);
  }
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  doPoll() {
    debug4("xhr poll");
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}

class Request2 extends component_emitter2.Emitter {
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = opts.data !== undefined ? opts.data : null;
    this.create();
  }
  create() {
    var _a;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr = this.xhr = new XHR(opts);
    try {
      debug4("xhr open %s: %s", this.method, this.uri);
      xhr.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if (this.method === "POST") {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this.opts.cookieJar) === null || _a === undefined || _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this.opts.cookieJar) === null || _a2 === undefined || _a2.parseCookies(xhr);
        }
        if (xhr.readyState !== 4)
          return;
        if (xhr.status === 200 || xhr.status === 1223) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      debug4("xhr data %s", this.data);
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request2.requestsCount++;
      Request2.requests[this.index] = this;
    }
  }
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  cleanup(fromError) {
    if (typeof this.xhr === "undefined" || this.xhr === null) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request2.requests[this.index];
    }
    this.xhr = null;
  }
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  abort() {
    this.cleanup();
  }
}
Request2.requestsCount = 0;
Request2.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

// node_modules/ws/wrapper.mjs
var stream2 = __toESM(require_stream(), 1);
var receiver = __toESM(require_receiver(), 1);
var sender = __toESM(require_sender(), 1);
var websocket = __toESM(require_websocket(), 1);
var websocket_server = __toESM(require_websocket_server(), 1);
var wrapper_default = websocket.default;

// node_modules/engine.io-client/build/esm-debug/transports/websocket-constructor.js
var WebSocket2 = wrapper_default;
var usingBrowserWebSocket = false;
var defaultBinaryType = "nodebuffer";
var nextTick = process.nextTick;

// node_modules/engine.io-client/build/esm-debug/transports/websocket.js
var import_debug5 = __toESM(require_src(), 1);
var debug5 = import_debug5.default("engine.io-client:websocket");
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";

class WS extends Transport {
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket2(uri, protocols) : new WebSocket2(uri) : new WebSocket2(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0;i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        const opts = {};
        if (!usingBrowserWebSocket) {
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          if (this.opts.perMessageDeflate) {
            const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
            if (len < this.opts.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          } else {
            this.ws.send(data, opts);
          }
        } catch (e) {
          debug5("websocket closed before onclose event");
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  check() {
    return !!WebSocket2;
  }
}

// node_modules/engine.io-client/build/esm-debug/transports/webtransport.js
var import_debug6 = __toESM(require_src(), 1);
var debug6 = import_debug6.default("engine.io-client:webtransport");

class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      debug6("transport closed gracefully");
      this.onClose();
    }).catch((err) => {
      debug6("transport closed due to %s", err);
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream3) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream3.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream3.writable);
        this.writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value }) => {
            if (done) {
              debug6("session is closed");
              return;
            }
            debug6("received chunk: %o", value);
            this.onPacket(value);
            read();
          }).catch((err) => {
            debug6("an error occurred while reading: %s", err);
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0;i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this.transport) === null || _a === undefined || _a.close();
  }
}

// node_modules/engine.io-client/build/esm-debug/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};

// node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js
function parse3(str) {
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
var pathNames = function(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
};
var queryKey = function(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
};
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];

// node_modules/engine.io-client/build/esm-debug/socket.js
var import_debug7 = __toESM(require_src(), 1);
var component_emitter3 = __toESM(require_component_emitter(), 1);
var debug7 = import_debug7.default("engine.io-client:socket");

class Socket extends component_emitter3.Emitter {
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && typeof uri === "object") {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse3(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse3(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  createTransport(name) {
    debug7('creating transport "%s"', name);
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    debug7("options: %j", opts);
    return new transports[name](opts);
  }
  open() {
    let transport4;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport4 = "websocket";
    } else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport4 = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport4 = this.createTransport(transport4);
    } catch (e) {
      debug7("error while creating transport: %s", e);
      this.transports.shift();
      this.open();
      return;
    }
    transport4.open();
    this.setTransport(transport4);
  }
  setTransport(transport4) {
    debug7("setting transport %s", transport4.name);
    if (this.transport) {
      debug7("clearing existing transport %s", this.transport.name);
      this.transport.removeAllListeners();
    }
    this.transport = transport4;
    transport4.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  probe(name) {
    debug7('probing transport "%s"', name);
    let transport4 = this.createTransport(name);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      debug7('probe transport "%s" opened', name);
      transport4.send([{ type: "ping", data: "probe" }]);
      transport4.once("packet", (msg) => {
        if (failed)
          return;
        if (msg.type === "pong" && msg.data === "probe") {
          debug7('probe transport "%s" pong', name);
          this.upgrading = true;
          this.emitReserved("upgrading", transport4);
          if (!transport4)
            return;
          Socket.priorWebsocketSuccess = transport4.name === "websocket";
          debug7('pausing current transport "%s"', this.transport.name);
          this.transport.pause(() => {
            if (failed)
              return;
            if (this.readyState === "closed")
              return;
            debug7("changing transport and sending upgrade packet");
            cleanup();
            this.setTransport(transport4);
            transport4.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport4);
            transport4 = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          debug7('probe transport "%s" failed', name);
          const err = new Error("probe error");
          err.transport = transport4.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport4.close();
      transport4 = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport4.name;
      freezeTransport();
      debug7('probe transport "%s" failed because of error: %s', name, err);
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport4 && to.name !== transport4.name) {
        debug7('"%s" works - aborting "%s"', to.name, transport4.name);
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport4.removeListener("open", onTransportOpen);
      transport4.removeListener("error", onerror);
      transport4.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport4.once("open", onTransportOpen);
    transport4.once("error", onerror);
    transport4.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport4.open();
        }
      }, 200);
    } else {
      transport4.open();
    }
  }
  onOpen() {
    debug7("socket open");
    this.readyState = "open";
    Socket.priorWebsocketSuccess = this.transport.name === "websocket";
    this.emitReserved("open");
    this.flush();
    if (this.readyState === "open" && this.opts.upgrade) {
      debug7("starting upgrade probes");
      let i2 = 0;
      const l = this.upgrades.length;
      for (;i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  onPacket(packet) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      debug7('socket receive: type "%s", data "%s"', packet.type, packet.data);
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
      debug7('packet received with socket readyState "%s"', this.readyState);
    }
  }
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if (this.readyState === "closed")
      return;
    this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (this.writeBuffer.length === 0) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      debug7("flushing %d packets in socket", packets.length);
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0;i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        debug7("only send %d out of %d packets", i2, this.writeBuffer.length);
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    debug7("payload size is %d (max: %d)", payloadSize, this.maxPayload);
    return this.writeBuffer;
  }
  write(msg, options5, fn) {
    this.sendPacket("message", msg, options5, fn);
    return this;
  }
  send(msg, options5, fn) {
    this.sendPacket("message", msg, options5, fn);
    return this;
  }
  sendPacket(type, data, options5, fn) {
    if (typeof data === "function") {
      fn = data;
      data = undefined;
    }
    if (typeof options5 === "function") {
      fn = options5;
      options5 = null;
    }
    if (this.readyState === "closing" || this.readyState === "closed") {
      return;
    }
    options5 = options5 || {};
    options5.compress = options5.compress !== false;
    const packet = {
      type,
      data,
      options: options5
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  close() {
    const close = () => {
      this.onClose("forced close");
      debug7("socket closing - telling transport to close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if (this.readyState === "opening" || this.readyState === "open") {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  onError(err) {
    debug7("socket error %j", err);
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  onClose(reason, description) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      debug7('socket close with reason: "%s"', reason);
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j = upgrades.length;
    for (;i2 < j; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
}
Socket.protocol = protocol;
// node_modules/engine.io-client/build/esm-debug/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm-debug/url.js
var import_debug8 = __toESM(require_src(), 1);
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (uri == null)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if (uri.charAt(0) === "/") {
      if (uri.charAt(1) === "/") {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug8("protocol-less url %s", uri);
      if (typeof loc !== "undefined") {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    debug8("parse %s", uri);
    obj = parse3(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
var debug8 = import_debug8.default("socket.io-client:url");

// node_modules/socket.io-parser/build/esm-debug/index.js
var exports_esm_debug = {};
__export(exports_esm_debug, {
  protocol: () => {
    {
      return protocol3;
    }
  },
  PacketType: () => {
    {
      return PacketType;
    }
  },
  Encoder: () => {
    {
      return Encoder;
    }
  },
  Decoder: () => {
    {
      return Decoder;
    }
  }
});
var component_emitter4 = __toESM(require_component_emitter(), 1);

// node_modules/socket.io-parser/build/esm-debug/is-binary.js
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length;i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString2 = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString2.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString2.call(File) === "[object FileConstructor]";

// node_modules/socket.io-parser/build/esm-debug/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
var _deconstructPacket = function(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0;i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
};
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
var _reconstructPacket = function(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0;i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
};

// node_modules/socket.io-parser/build/esm-debug/index.js
var import_debug9 = __toESM(require_src(), 1);
var isObject = function(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
};
var debug9 = import_debug9.default("socket.io-parser");
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));

class Encoder {
  constructor(replacer) {
    this.replacer = replacer;
  }
  encode(obj) {
    debug9("encoding packet %j", obj);
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && obj.nsp !== "/") {
      str += obj.nsp + ",";
    }
    if (obj.id != null) {
      str += obj.id;
    }
    if (obj.data != null) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    debug9("encoded %j as %s", obj, str);
    return str;
  }
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}

class Decoder extends component_emitter4.Emitter {
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  decodeString(str) {
    let i2 = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === undefined) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if (str.charAt(i2 + 1) === "/") {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (c === ",")
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if (next !== "" && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (c == null || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload2 = this.tryParse(str.substr(i2));
      if (Decoder.isPayloadValid(p.type, payload2)) {
        p.data = payload2;
      } else {
        throw new Error("invalid payload");
      }
    }
    debug9("decoded %s as %j", str, p);
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload2) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload2);
      case PacketType.DISCONNECT:
        return payload2 === undefined;
      case PacketType.CONNECT_ERROR:
        return typeof payload2 === "string" || isObject(payload2);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload2) && (typeof payload2[0] === "number" || typeof payload2[0] === "string" && RESERVED_EVENTS.indexOf(payload2[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload2);
    }
  }
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}

class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}

// node_modules/socket.io-client/build/esm-debug/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

// node_modules/socket.io-client/build/esm-debug/socket.js
var component_emitter5 = __toESM(require_component_emitter(), 1);
var import_debug10 = __toESM(require_src(), 1);
var debug10 = import_debug10.default("socket.io-client:socket");
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});

class Socket2 extends component_emitter5.Emitter {
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if (this.io._readyState === "open")
      this.onopen();
    return this;
  }
  open() {
    return this.connect();
  }
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  emit(ev, ...args) {
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if (typeof args[args.length - 1] === "function") {
      const id = this.ids++;
      debug10("emitting packet with ack id %d", id);
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) {
      debug10("discard packet as the transport is not currently writable");
    } else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== undefined ? _a : this._opts.ackTimeout;
    if (timeout === undefined) {
      this.acks[id] = ack;
      return;
    }
    const timer2 = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0;i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          debug10("removing packet with ack id %d from the buffer", id);
          this.sendBuffer.splice(i2, 1);
        }
      }
      debug10("event with ack id %d has timed out after %d ms", id, timeout);
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer2);
      ack.apply(this, [null, ...args]);
    };
  }
  emitWithAck(ev, ...args) {
    const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;
    return new Promise((resolve, reject) => {
      args.push((arg1, arg2) => {
        if (withErr) {
          return arg1 ? reject(arg1) : resolve(arg2);
        } else {
          return resolve(arg1);
        }
      });
      this.emit(ev, ...args);
    });
  }
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          debug10("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        debug10("packet [%d] was successfully sent", packet.id);
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  _drainQueue(force = false) {
    debug10("draining queue");
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      debug10("packet [%d] has already been sent and is waiting for an ack", packet.id);
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    debug10("sending packet [%d] (try n\xB0%d)", packet.id, packet.tryCount);
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  onopen() {
    debug10("transport is open - connecting");
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  onclose(reason, description) {
    debug10("close (%s)", reason);
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  onevent(packet) {
    const args = packet.data || [];
    debug10("emitting event %j", args);
    if (packet.id != null) {
      debug10("attaching ack callback to event");
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      debug10("sending ack %j", args);
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack === "function") {
      debug10("calling ack %s with %j", packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug10("bad ack %s", packet.id);
    }
  }
  onconnect(id, pid) {
    debug10("socket connected with id %s", id);
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  ondisconnect() {
    debug10("server disconnect (%s)", this.nsp);
    this.destroy();
    this.onclose("io server disconnect");
  }
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = undefined;
    }
    this.io["_destroy"](this);
  }
  disconnect() {
    if (this.connected) {
      debug10("performing disconnect (%s)", this.nsp);
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  close() {
    return this.disconnect();
  }
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0;i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0;i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}

// node_modules/socket.io-client/build/esm-debug/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm-debug/manager.js
var component_emitter6 = __toESM(require_component_emitter(), 1);
var import_debug11 = __toESM(require_src(), 1);
var debug11 = import_debug11.default("socket.io-client:manager");

class Manager extends component_emitter6.Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && typeof uri === "object") {
      opts = uri;
      uri = undefined;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1000);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== undefined ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(opts.timeout == null ? 20000 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || exports_esm_debug;
    this.encoder = new _parser.Encoder;
    this.decoder = new _parser.Decoder;
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === undefined)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === undefined)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === undefined || _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === undefined)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === undefined || _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === undefined)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === undefined || _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  open(fn) {
    debug11("readyState %s", this._readyState);
    if (~this._readyState.indexOf("open"))
      return this;
    debug11("opening %s", this.uri);
    this.engine = new Socket(this.uri, this.opts);
    const socket3 = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket3, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      debug11("error");
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket3, "error", onError);
    if (this._timeout !== false) {
      const timeout = this._timeout;
      debug11("connect attempt will timeout after %d", timeout);
      const timer2 = this.setTimeoutFn(() => {
        debug11("connect attempt timed out after %d", timeout);
        openSubDestroy();
        onError(new Error("timeout"));
        socket3.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer2.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer2);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  connect(fn) {
    return this.open(fn);
  }
  onopen() {
    debug11("open");
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket3 = this.engine;
    this.subs.push(on(socket3, "ping", this.onping.bind(this)), on(socket3, "data", this.ondata.bind(this)), on(socket3, "error", this.onerror.bind(this)), on(socket3, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  onerror(err) {
    debug11("error", err);
    this.emitReserved("error", err);
  }
  socket(nsp, opts) {
    let socket3 = this.nsps[nsp];
    if (!socket3) {
      socket3 = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket3;
    } else if (this._autoConnect && !socket3.active) {
      socket3.connect();
    }
    return socket3;
  }
  _destroy(socket3) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket4 = this.nsps[nsp];
      if (socket4.active) {
        debug11("socket %s is still active, skipping close", nsp);
        return;
      }
    }
    this._close();
  }
  _packet(packet) {
    debug11("writing packet %j", packet);
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0;i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  cleanup() {
    debug11("cleanup");
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  _close() {
    debug11("disconnect");
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(reason, description) {
    debug11("closed due to %s", reason);
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      debug11("reconnect failed");
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay2 = this.backoff.duration();
      debug11("will wait %dms before reconnect attempt", delay2);
      this._reconnecting = true;
      const timer2 = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        debug11("attempting reconnect");
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            debug11("reconnect attempt error");
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            debug11("reconnect success");
            self2.onreconnect();
          }
        });
      }, delay2);
      if (this.opts.autoUnref) {
        timer2.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer2);
      });
    }
  }
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}

// node_modules/socket.io-client/build/esm-debug/index.js
var import_debug12 = __toESM(require_src(), 1);
var lookup = function(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && (path in cache[id]["nsps"]);
  const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
  let io;
  if (newConnection) {
    debug12("ignoring socket cache for %s", source);
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug12("new io instance for %s", source);
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
};
var debug12 = import_debug12.default("socket.io-client");
var cache = {};
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});

// src/socket-client.ts
var debug13 = import_debug13.default("socket-client");
var endpointSchema = import_joi6.default.string().uri({
  scheme: ["http", "https", "ws", "wss"]
});
var makeClient = (endpoint, token) => {
  const options5 = {
    auth: { token }
  };
  const agent2 = getHttpsProxyAgent();
  if (agent2 !== undefined) {
    options5.agent = agent2;
  }
  const socket4 = lookup(endpoint, options5);
  socket4.on("connect_error", (error) => {
    debug13(`Failed to connect to server: ${error.message}`);
  });
  return socket4;
};

// src/download-client.ts
var debug14 = import_debug14.default("download-client");
var makeDownloadCommand = () => {
  const command = new Command;
  command.name(`download`).showHelpAfterError().requiredOption("--endpoint <value>", "Where the server is located").requiredOption("--token <value>", "Token to authenticate with the server").option("--num-threads <count>", "Number of concurrent upload threads", "20").action(async () => {
    const options5 = command.opts();
    const endpoint = options5.endpoint;
    if (typeof endpoint !== "string") {
      throw new Error(`"endpoint" needs to be a string`);
    }
    import_joi7.default.assert(endpoint, endpointSchema);
    const token = options5.token;
    if (typeof token !== "string") {
      throw new Error(`"token" needs to be a string`);
    }
    const payload2 = import_jsonwebtoken2.default.decode(token);
    if (typeof payload2 !== "object" || payload2 === null) {
      throw new Error(`"token" does not have a payload`);
    }
    const { type } = payload2;
    if (type !== "download") {
      throw new Error(`"token" is not a download token`);
    }
    const numThreads = parseInt(options5.numThreads, 10);
    if (typeof numThreads !== "number") {
      throw new Error(`"numThreads" needs to be a number`);
    }
    const signal = new Promise((resolve) => {
      process.on("SIGINT", () => {
        resolve();
      });
    });
    const socket4 = makeClient(endpoint, token);
    const client2 = new DownloadClient(socket4, numThreads);
    try {
      client2.listen();
      await signal;
    } finally {
      socket4.disconnect();
      client2.queue.kill();
    }
  });
  return command;
};
var makePath = (job) => {
  return join(job.name, job.path);
};

class DownloadClient {
  socket;
  queue;
  progress = new Progress;
  downloadInfos = new Map;
  downloads = new Set;
  constructor(socket4, numThreads) {
    this.socket = socket4;
    this.queue = import_fastq2.default.promise(this, this.runDownloadJob, numThreads);
  }
  getDownloadInfo(path) {
    let downloadInfo = this.downloadInfos.get(path);
    if (downloadInfo === undefined) {
      downloadInfo = new DownloadInfo(path);
      this.downloadInfos.set(path, downloadInfo);
    }
    return downloadInfo;
  }
  listen() {
    this.socket.on("download:create", async (downloadJobs) => {
      const promises6 = [];
      for (const downloadJob of downloadJobs) {
        try {
          parseRange(downloadJob);
          const path = makePath(downloadJob);
          const downloadInfo = this.getDownloadInfo(path);
          const run = await downloadInfo.addDownloadJob(downloadJob);
          if (!run) {
            await this.socket.emitWithAck("download:complete", downloadJob);
            continue;
          }
          const key = `${downloadJob.path}:${downloadJob.range.toString()}`;
          if (this.downloads.has(key)) {
            continue;
          }
          this.downloads.add(key);
          this.progress.addPart(downloadJob);
          promises6.push(this.queue.push(downloadJob));
        } catch (error) {
          debug14("failed to process download job: %o", error);
        }
      }
      await Promise.all(promises6);
    });
    this.socket.on("download:checksum", async (checksumJob) => {
      try {
        const { checksumSHA256 } = checksumJob;
        const path = makePath(checksumJob);
        const downloadInfo = this.getDownloadInfo(path);
        await downloadInfo.setChecksumSHA256(checksumSHA256);
      } catch (error) {
        debug14("failed to process checksum job: %o", error);
      }
    });
  }
  async retryDownloadJob(readStream2, downloadJob) {
    const { progress: progress2 } = this;
    const { start, end } = downloadJob.range;
    const path = makePath(downloadJob);
    await touch(path);
    let fileHandle;
    const md5 = createHash2("md5");
    let size = 0;
    try {
      fileHandle = await open3(path, "r+");
      const writeStream = fileHandle.createWriteStream({ start });
      await pipeline2(readStream2, async function* (source) {
        for await (const chunk of source) {
          md5.update(chunk);
          size += chunk.length;
          progress2.gauge.pulse();
          yield chunk;
        }
      }, writeStream);
      writeStream.end();
    } finally {
      await fileHandle?.close();
    }
    if (end !== undefined) {
      if (size !== new Range(start, end).size()) {
        throw new Error(`Received invalid response from server: Content length does not match suffix`);
      }
    }
    const etag = JSON.parse(readStream2.response?.headers.etag ?? "");
    if (typeof etag !== "string") {
      throw new Error(`Received invalid response from server: "etag" needs to be a string`);
    }
    if (etag !== md5.digest("hex")) {
      throw new Error('Received invalid response from server: "etag" does not match MD5 checksum calculated from response body');
    }
    if (downloadJob.checksumMD5 !== etag) {
      throw new Error('Received invalid response from server: "etag" does not match MD5 checksum received from server');
    }
    return {
      ...downloadJob,
      size
    };
  }
  async finalizeDownloadJob(downloadJob) {
    this.progress.completePart(downloadJob);
    const { range: range4 } = downloadJob;
    debug14("completed partial download for %s in range %s", downloadJob.path, range4.toString());
    const path = makePath(downloadJob);
    const downloadInfo = this.getDownloadInfo(path);
    const verified = await downloadInfo.completePart(downloadJob);
    await this.socket.emitWithAck("download:complete", downloadJob);
    if (verified) {
      await this.socket.emitWithAck("download:verified", downloadJob);
    }
  }
  async runDownloadJob(downloadJob) {
    const { url: url3 } = downloadJob;
    const readStream2 = client.stream.get(url3, { ...requestOptions });
    return new Promise((resolve, reject) => {
      const fn = async (retryStream) => {
        try {
          retryStream.once("retry", (retryCount2, error, createRetryStream) => {
            fn(createRetryStream());
          });
          let completedDownloadJob = await this.retryDownloadJob(retryStream, downloadJob);
          await this.finalizeDownloadJob(completedDownloadJob);
          resolve();
        } catch (error) {
          debug14(error);
        }
      };
      fn(readStream2);
    });
  }
}

// src/serve.ts
var import_debug20 = __toESM(require_src(), 1);
var import_jsonwebtoken3 = __toESM(require_jsonwebtoken(), 1);
import {readFileSync as readFileSync2} from "node:fs";

// node_modules/socket.io/wrapper.mjs
var dist = __toESM(require_dist4(), 1);
var { Server, Namespace, Socket: Socket3 } = dist.default;

// src/download-server.ts
var import_debug17 = __toESM(require_src(), 1);

// src/upload-info.ts
var import_debug16 = __toESM(require_src(), 1);
var client_s32 = __toESM(require_dist_cjs69(), 1);

// src/config.ts
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.default.config();
var getS3Config = () => {
  if (typeof process.env.ENDPOINT !== "string") {
    throw new Error(`"process.env.ENDPOINT" needs to be a string`);
  }
  const endpoint = process.env.ENDPOINT;
  if (typeof process.env.ACCESS_KEY_ID !== "string") {
    throw new Error(`"process.env.ACCESS_KEY_ID" needs to be a string`);
  }
  const accessKeyId = process.env.ACCESS_KEY_ID;
  if (typeof process.env.SECRET_ACCESS_KEY !== "string") {
    throw new Error(`"process.env.SECRET_ACCESS_KEY" needs to be a string`);
  }
  const secretAccessKey = process.env.SECRET_ACCESS_KEY;
  return { endpoint, accessKeyId, secretAccessKey };
};
var signedUrlOptions = { expiresIn: 604800 };
var delimiter = "/";

// src/storage.ts
var import_debug15 = __toESM(require_src(), 1);
var client_s3 = __toESM(require_dist_cjs69(), 1);
async function* listObjectsInBucket(s3, bucket) {
  let isTruncated = false;
  const input = {
    Bucket: bucket
  };
  do {
    const output = await s3.send(new client_s3.ListObjectsCommand(input));
    isTruncated = output.IsTruncated ?? false;
    input.Marker = output.NextMarker;
    const objects = output.Contents;
    if (objects !== undefined) {
      yield* objects;
    }
  } while (isTruncated);
}
async function* listObjects(s3) {
  const result = await s3.send(new client_s3.ListBucketsCommand({}));
  const buckets = result.Buckets?.reduce((previousValue, bucket) => {
    if (bucket.Name?.startsWith(prefix)) {
      previousValue.push(bucket.Name);
    }
    return previousValue;
  }, new Array);
  if (buckets === undefined) {
    return;
  }
  debug15("listing %o buckets", buckets.length);
  for (const bucket of buckets) {
    for await (const object of listObjectsInBucket(s3, bucket)) {
      yield { ...object, Bucket: bucket };
    }
  }
}
var debug15 = import_debug15.default("storage");
var prefix = "upload-";
var makeS3Client = () => {
  const { endpoint, accessKeyId, secretAccessKey } = getS3Config();
  return new client_s3.S3Client({
    region: "auto",
    endpoint: `https://${endpoint}`,
    credentials: { accessKeyId, secretAccessKey }
  });
};
var getBucketName = (name) => `${prefix}${name}`;
var requireBucketName = async (s3, name, loc) => {
  const bucket = getBucketName(name);
  const bucketInput = { Bucket: bucket };
  try {
    await s3.send(new client_s3.HeadBucketCommand(bucketInput));
  } catch (error) {
    try {
      const input = { ...bucketInput };
      if (loc !== undefined) {
        input.CreateBucketConfiguration = {
          LocationConstraint: loc
        };
      }
      await s3.send(new client_s3.CreateBucketCommand(input));
    } catch (error2) {
      debug15(error2);
      throw new Error("Failed to create bucket");
    }
  }
  return bucket;
};

// src/download-parse.ts
var getBucketNameFromURL = (url3) => {
  let { hostname } = new URL(url3);
  const bucket = hostname.split(".")[0];
  if (!bucket.startsWith(prefix)) {
    throw new Error(`Invalid bucket name: ${bucket}`);
  }
  return bucket;
};
var getPathnameFromURL = (url3) => {
  let { pathname } = new URL(url3);
  if (pathname.startsWith(delimiter)) {
    pathname = pathname.slice(1);
  }
  return pathname;
};
var getNameFromBucket = (bucket) => {
  if (!bucket.startsWith(prefix)) {
    throw new Error(`Invalid bucket name: ${bucket}`);
  }
  const name = bucket.slice(prefix.length);
  validate(nameSchema, name);
  return name;
};
var getNameFromURL = (url3) => {
  const bucket = getBucketNameFromURL(url3);
  return getNameFromBucket(bucket);
};
var getRangeFromPathname = (pathname) => {
  const tokens = pathname.split(delimiter);
  const suffix = tokens.pop();
  if (suffix === undefined) {
    throw new Error(`Invalid path: ${pathname}`);
  }
  let [start, end] = suffix.split("-").map((n) => parseInt(n, 10));
  if (Number.isNaN(start) || start < 0) {
    throw new Error(`Invalid start: ${pathname}`);
  }
  if (Number.isNaN(end) || end < start || end < 0) {
    throw new Error(`Invalid end: ${pathname}`);
  }
  return new Range(start, end);
};
var getRangeFromURL = (url3) => {
  const pathname = getPathnameFromURL(url3);
  return getRangeFromPathname(pathname);
};
var getPathFromPathname = (pathname) => {
  const tokens = pathname.split(delimiter);
  tokens.pop();
  return tokens.join(delimiter);
};
var getPathFromURL = (url3) => {
  const pathname = getPathnameFromURL(url3);
  return getPathFromPathname(pathname);
};
var getInputFromURL = (url3) => {
  const bucket = getBucketNameFromURL(url3);
  return {
    Bucket: bucket,
    Key: getPathnameFromURL(url3)
  };
};

// src/upload-info.ts
var debug16 = import_debug16.default("serve");

class UploadInfo extends Info {
  s3;
  bucket;
  constructor(bucket, path, s3) {
    super(path);
    this.s3 = s3;
    this.bucket = bucket;
  }
  static get suffix() {
    return "upload-info.json";
  }
  get key() {
    return `${this.path}${delimiter}${UploadInfo.suffix}`;
  }
  get input() {
    return {
      Bucket: this.bucket,
      Key: this.key
    };
  }
  toString() {
    return `${this.bucket} ${this.path}`;
  }
  async load() {
    if (this.data !== undefined) {
      return this.data;
    }
    const command = new client_s32.GetObjectCommand(this.input);
    let response4;
    try {
      response4 = await this.s3.send(command);
    } catch (error) {
      if (error instanceof client_s32.NoSuchKey) {
        this.data = this.defaultData;
        return this.data;
      }
      throw error;
    }
    const body = await response4.Body?.transformToString();
    if (body === undefined) {
      throw new Error(`Invalid response from s3: "body" is undefined`);
    }
    const data = this.parse(body);
    this.data = data;
    return data;
  }
  async run(job) {
    const data = await this.load();
    let result = false;
    let save = false;
    switch (job.type) {
      case "set-checksum-sha256":
        data.checksumSHA256 = job.checksumSHA256;
        result = true;
        save = true;
        break;
      case "add-upload-request":
        result = this.runAddFilePart(job.uploadRequest, data);
        break;
      case "complete-part":
        result = this.runCompletePart(job.part, data);
        save = true;
        break;
      case "set-verified":
        data.verified = true;
        save = true;
        break;
    }
    if (this.queue.length() === 0 || save) {
      await this.save();
    }
    return result;
  }
  async getSize() {
    const { size } = await this.load();
    if (size === undefined) {
      throw new Error("Size not set");
    }
    return size;
  }
  async getChecksumJob() {
    const { checksumSHA256, size } = await this.load();
    if (checksumSHA256 === undefined) {
      throw new Error("Checksum not set");
    }
    if (size === undefined) {
      throw new Error("Size not set");
    }
    return {
      name: getNameFromBucket(this.bucket),
      path: this.path,
      checksumSHA256,
      size
    };
  }
  async setChecksumSHA256(checksumSHA256) {
    return await this.queue.push({
      type: "set-checksum-sha256",
      checksumSHA256
    });
  }
  async addUploadRequest(uploadRequest) {
    return await this.queue.push({ type: "add-upload-request", uploadRequest });
  }
  async completePart(part3) {
    await this.queue.push({ type: "complete-part", part: part3 });
  }
  async setVerified() {
    await this.queue.push({ type: "set-verified" });
  }
  async getPart(query) {
    const data = await this.load();
    const part3 = this.findUploadPart(query, data);
    if (part3 === undefined) {
      throw new Error("Part not found");
    }
    return part3;
  }
  async save() {
    if (this.data === undefined) {
      throw new Error(`Invalid state`);
    }
    const dataString = JSON.stringify(this.data, null, 2);
    const command = new client_s32.PutObjectCommand({ ...this.input, Body: dataString });
    await this.s3.send(command);
  }
}

// src/download-server.ts
var client_s33 = __toESM(require_dist_cjs69(), 1);
var s3_request_presigner = __toESM(require_dist_cjs71(), 1);
var debug17 = import_debug17.default("serve");

class DownloadServer {
  io;
  constructor(io2) {
    this.io = io2;
    const loop = this.loop.bind(this);
    setTimeout(loop, 1000);
  }
  listen(socket4) {
    const { uploadServer, s3 } = this.io;
    socket4.on("download:complete", async (downloadJob, callback) => {
      const input = getInputFromURL(downloadJob.url);
      await s3.send(new client_s33.DeleteObjectCommand(input));
      callback();
    });
    socket4.on("download:verified", async (downloadJob, callback) => {
      const input = getInputFromURL(downloadJob.url);
      if (input.Bucket === undefined) {
        throw new Error('"input.Bucket" is undefined');
      }
      const { path } = downloadJob;
      const pathFromURL = getPathFromURL(downloadJob.url);
      if (path !== pathFromURL) {
        throw new Error(`Mismatched path between job and upload URL: ` + `${path} != ${pathFromURL}`);
      }
      const uploadInfo = uploadServer.getUploadInfo(input.Bucket, path);
      await uploadInfo.setVerified();
      callback();
    });
  }
  async loop() {
    debug17("loop");
    const io2 = this.io;
    const { s3, uploadServer } = io2;
    let downloadJobs = new Array;
    for await (const object of listObjects(s3)) {
      try {
        if (object.Bucket === undefined) {
          throw new Error('"object.Bucket" is undefined');
        }
        if (object.Key === undefined) {
          throw new Error('"object.Key" is undefined');
        }
        if (object.Size === undefined) {
          throw new Error('"size" is undefined');
        }
        if (object.ETag === undefined) {
          throw new Error('"object.ETag" is undefined');
        }
        const path = getPathFromPathname(object.Key);
        const uploadInfo = uploadServer.getUploadInfo(object.Bucket, path);
        if (await uploadInfo.isVerified()) {
          continue;
        }
        if (object.Key.endsWith(UploadInfo.suffix)) {
          await this.submitChecksumJob(uploadInfo);
          continue;
        }
        let range5;
        try {
          range5 = getRangeFromPathname(object.Key);
        } catch (error) {
          continue;
        }
        if (range5.size() !== object.Size) {
          throw new Error("Mismatched size between object and range in file name: " + `${object.Size} != ${range5.size()}`);
        }
        const part3 = await uploadInfo.getPart({
          range: range5,
          checksumMD5: object.ETag
        });
        downloadJobs.push(await this.createDownloadJob({
          ...part3,
          name: getNameFromBucket(object.Bucket),
          path,
          size: await uploadInfo.getSize(),
          input: {
            Bucket: object.Bucket,
            Key: object.Key
          }
        }));
      } catch (error) {
        debug17("could not parse object %o: %O", object, error);
      }
      if (downloadJobs.length > 1000) {
        this.sendDownloadJobs(downloadJobs);
        downloadJobs = new Array;
      }
    }
    this.sendDownloadJobs(downloadJobs);
    const loop = this.loop.bind(this);
    setTimeout(loop, 600000);
  }
  sendDownloadJobs(downloadJobs) {
    const io2 = this.io;
    debug17("sending %o download jobs", downloadJobs.length);
    io2.to("download").emit("download:create", downloadJobs);
  }
  async submitChecksumJob(uploadInfo) {
    const io2 = this.io;
    let checksumJob;
    try {
      checksumJob = await uploadInfo.getChecksumJob();
    } catch (error) {
      return;
    }
    debug17("sending checksum job", checksumJob);
    io2.to("download").emit("download:checksum", checksumJob);
  }
  async createDownloadJob(u) {
    const io2 = this.io;
    const { range: range5, path, checksumMD5, size } = u;
    let input, name;
    if ("url" in u) {
      name = getNameFromURL(u.url);
      const rangeFromURL = getRangeFromURL(u.url);
      if (!range5.equals(rangeFromURL)) {
        throw new Error(`Mismatched range between job and upload URL: ` + `${range5.toString()} != ${rangeFromURL.toString()}`);
      }
      const pathFromURL = getPathFromURL(u.url);
      if (path !== pathFromURL) {
        throw new Error(`Mismatched path between job and upload URL: ` + `${path} != ${pathFromURL}`);
      }
      input = getInputFromURL(u.url);
    } else {
      name = u.name;
      input = u.input;
    }
    const url3 = await s3_request_presigner.getSignedUrl(io2.s3, new client_s33.GetObjectCommand(input), signedUrlOptions);
    const downloadJob = {
      name,
      url: url3,
      range: range5,
      path,
      checksumMD5,
      size
    };
    return downloadJob;
  }
}

// src/upload-server.ts
var import_debug19 = __toESM(require_src(), 1);
var client_s34 = __toESM(require_dist_cjs69(), 1);
var s3_request_presigner2 = __toESM(require_dist_cjs71(), 1);

// src/upload-parts.ts
var import_debug18 = __toESM(require_src(), 1);
import {stat} from "node:fs/promises";
async function* generateUploadRequests(path, workerPool, { minPartSize, maxPartCount }) {
  const stats = await stat(path);
  const size = stats.size;
  const partCount = Math.min(maxPartCount, Math.floor(Number(size) / Number(minPartSize)));
  const partSize = Math.ceil(Number(size) / partCount);
  for (let i2 = 0;i2 < partCount; i2++) {
    const start = i2 * partSize;
    let end = start + partSize;
    end = (end > size ? size : end) - 1;
    const range6 = new Range(start, end);
    const checksumMD5 = await workerPool.submitCalculateChecksum(path, "md5", range6);
    debug18("generated upload request %o", { path, size, range: range6, checksumMD5 });
    yield { path, size, range: range6, checksumMD5 };
  }
}
var debug18 = import_debug18.default("upload-client");
var makeSuffix = (uploadRequest) => {
  const { size, range: range6 } = uploadRequest;
  const digits = size.toString(10).length;
  const [start, end] = [range6.start, range6.end].map((n) => n.toString(10).padStart(digits, "0"));
  return `${delimiter}${start}-${end}`;
};

// src/upload-server.ts
var debug19 = import_debug19.default("serve");

class UploadServer {
  io;
  uploadInfos = new Map;
  constructor(io2) {
    this.io = io2;
  }
  getUploadInfo(bucket, path) {
    const key = `${bucket}/${path}`;
    let uploadInfo = this.uploadInfos.get(key);
    if (uploadInfo === undefined) {
      uploadInfo = new UploadInfo(bucket, path, this.io.s3);
      this.uploadInfos.set(key, uploadInfo);
    }
    return uploadInfo;
  }
  listen(socket4) {
    const { downloadServer } = this.io;
    const { bucket } = socket4;
    const getUploadJob = async (uploadRequest) => {
      const { s3 } = this.io;
      parseRange(uploadRequest);
      const { path } = uploadRequest;
      const uploadInfo = this.getUploadInfo(bucket, path);
      let success;
      try {
        success = await uploadInfo.addUploadRequest(uploadRequest);
      } catch (error) {
        debug19(error);
        return { error: "unknown" };
      }
      if (!success) {
        return { error: "upload-exists" };
      }
      const suffix = makeSuffix(uploadRequest);
      const url3 = await s3_request_presigner2.getSignedUrl(s3, new client_s34.PutObjectCommand({
        Bucket: bucket,
        Key: `${path}${suffix}`
      }), signedUrlOptions);
      const uploadJob = {
        ...uploadRequest,
        url: url3
      };
      debug19("sending upload job %o", uploadJob);
      return uploadJob;
    };
    socket4.on("upload:create", async (uploadRequests, callback) => {
      callback(await Promise.all(uploadRequests.map(getUploadJob)));
    });
    socket4.on("upload:complete", async (uploadJob, callback) => {
      parseRange(uploadJob);
      const { path } = uploadJob;
      const uploadInfo = this.getUploadInfo(bucket, path);
      try {
        await uploadInfo.completePart(uploadJob);
      } catch (error) {
        debug19(error);
        callback({ error: "unknown" });
        return;
      }
      callback(undefined);
    });
    socket4.on("upload:checksum", async (path, checksumSHA256, callback) => {
      const uploadInfo = this.getUploadInfo(bucket, path);
      try {
        await uploadInfo.setChecksumSHA256(checksumSHA256);
      } catch (error) {
        debug19(error);
        callback({ error: "unknown" });
        return;
      }
      await downloadServer.submitChecksumJob(uploadInfo);
      callback(undefined);
    });
  }
}

// src/serve.ts
var debug20 = import_debug20.default("serve");
var makeServeCommand = () => {
  const command = new Command("serve");
  command.requiredOption("--port <number>", "Port to listen on").requiredOption("--public-key-file <path>", "Path to the public key file generated with `openssl ec -in key.pem -pubout`").action(() => {
    const options5 = command.opts();
    const port = parseInt(options5.port, 10);
    if (Number.isNaN(port)) {
      throw new Error(`"port" is not an integer`);
    }
    const publicKeyFile = options5.publicKeyFile;
    if (typeof publicKeyFile !== "string") {
      throw new Error("publicKeyFile must be a string");
    }
    const publicKey = readFileSync2(publicKeyFile, "utf8");
    serve(port, publicKey);
  });
  return command;
};
var serve = (port, publicKey) => {
  const io2 = new Server(port);
  io2.s3 = makeS3Client();
  io2.use(async (socket4, next) => {
    const handshake = socket4.handshake;
    const { token } = handshake.auth;
    if (token === undefined) {
      return next(new UnauthorizedError("Missing authorization token"));
    }
    if (typeof token !== "string") {
      return next(new UnauthorizedError("Authorization token needs to be string"));
    }
    let payload3;
    try {
      payload3 = import_jsonwebtoken3.default.verify(token, publicKey, {});
    } catch (error) {
      return next(new UnauthorizedError("Invalid token"));
    }
    if (payload3 === undefined || typeof payload3 !== "object") {
      return next(new UnauthorizedError("Invalid token payload"));
    }
    const { type, name, loc } = payload3;
    socket4.payload = { type, name };
    socket4.bucket = await requireBucketName(io2.s3, name, loc);
    socket4.join(type);
    return next();
  });
  io2.uploadServer = new UploadServer(io2);
  io2.downloadServer = new DownloadServer(io2);
  io2.on("connection", (socket4) => {
    io2.uploadServer.listen(socket4);
    io2.downloadServer.listen(socket4);
  });
  process.on("unhandledRejection", (error) => {
    console.error(error);
    process.exit(1);
  });
};

// src/upload-client.ts
var import_bytes2 = __toESM(require_bytes(), 1);
var import_debug22 = __toESM(require_src(), 1);
var import_fastq3 = __toESM(require_queue(), 1);
var import_joi8 = __toESM(require_lib4(), 1);
var import_jsonwebtoken4 = __toESM(require_jsonwebtoken(), 1);
import {open as open4} from "node:fs/promises";
import {PassThrough} from "node:stream";
import {pipeline as pipeline3} from "node:stream/promises";

// src/worker.ts
var import_debug21 = __toESM(require_src(), 1);
import {AsyncResource} from "node:async_hooks";
import {execFileSync} from "node:child_process";
import EventEmitter3 from "node:events";
import {parentPort, Worker} from "node:worker_threads";
var __filename = "/work/charite/src/upload/src/worker.ts";
var debug21 = import_debug21.default("upload-client");

class TaskInfo extends AsyncResource {
  callback;
  constructor(callback) {
    super("task-info");
    this.callback = callback;
  }
  done(error, checksum) {
    this.runInAsyncScope(this.callback, null, error, checksum);
    this.emitDestroy();
  }
}
var kTaskInfo = Symbol("kTaskInfo");
var kWorkerFreedEvent = Symbol("kWorkerFreedEvent");
var kErrorEvent = Symbol("kErrorEvent");

class WorkerPool extends EventEmitter3 {
  workers = new Array;
  freeWorkers = new Array;
  tasks = new Array;
  constructor() {
    super();
    const stdout = execFileSync("nproc", { encoding: "utf-8" });
    const numThreads = 4 * parseInt(stdout, 10);
    if (Number.isNaN(numThreads)) {
      throw new Error(`Invalid number of threads: ${stdout}`);
    }
    debug21(`Will use ${numThreads} threads for checksum calculation`);
    for (let i2 = 0;i2 < numThreads; i2++) {
      this.addNewWorker();
    }
    this.on(kWorkerFreedEvent, () => {
      if (this.tasks.length > 0) {
        const task = this.tasks.shift();
        if (task === undefined) {
          throw new Error("Invalid task");
        }
        this.runTask(task);
      }
    });
    this.on(kErrorEvent, (error) => {
      throw error;
    });
  }
  addNewWorker() {
    const worker = new Worker(__filename);
    worker.on("message", (checksum) => {
      if (typeof checksum !== "string") {
        throw new Error("Invalid checksum");
      }
      const taskInfo = worker[kTaskInfo];
      if (taskInfo === undefined) {
        throw new Error("Invalid taskInfo");
      }
      taskInfo.done(null, checksum);
      this.freeWorkers.push(worker);
      this.emit(kWorkerFreedEvent);
    });
    worker.on("error", (error) => {
      const taskInfo = worker[kTaskInfo];
      if (taskInfo !== undefined) {
        taskInfo.done(error, null);
      } else
        this.emit(kErrorEvent, error);
      this.workers.splice(this.workers.indexOf(worker), 1);
      this.addNewWorker();
    });
    this.workers.push(worker);
    this.freeWorkers.push(worker);
    this.emit(kWorkerFreedEvent);
  }
  runTask(task) {
    if (this.freeWorkers.length === 0) {
      this.tasks.push(task);
      return;
    }
    const { input, callback } = task;
    const worker = this.freeWorkers.pop();
    if (worker === undefined) {
      throw new Error("Invalid worker");
    }
    worker[kTaskInfo] = new TaskInfo(callback);
    worker.postMessage(input);
  }
  submitCalculateChecksum(path, algorithm, range7) {
    const input = { path, range: range7, algorithm };
    return new Promise((resolve, reject) => {
      const callback = (error, checksum) => {
        if (checksum !== null) {
          resolve(checksum);
        } else {
          reject(error);
        }
      };
      const task = { input, callback };
      this.runTask(task);
    });
  }
}
var worker = () => {
  if (parentPort === null) {
    throw new Error("Invalid parentPort");
  }
  parentPort.on("message", async (input) => {
    if (parentPort === null) {
      throw new Error("Invalid parentPort");
    }
    if (input.range !== undefined) {
      parseRange(input);
    }
    const { path, algorithm, range: range7 } = input;
    if (typeof path !== "string") {
      throw new Error("Invalid path");
    }
    if (typeof algorithm !== "string") {
      throw new Error("Invalid algorithm");
    }
    if (!(range7 === undefined || range7 instanceof Range)) {
      throw new Error(`Invalid range ${range7}`);
    }
    const checksum = await calculateChecksum(path, algorithm, range7);
    parentPort.postMessage(checksum);
  });
};

// src/upload-client.ts
var debug22 = import_debug22.default("upload-client");
var makeUploadCommand = () => {
  const command = new Command;
  command.name(`upload`).showHelpAfterError().requiredOption("--endpoint <value>", "Where the server is located").requiredOption("--token <value>", "Token to authenticate with the server").requiredOption("--path <value...>", "Path or paths to upload").option("--min-part-size <size>", "Minimum size of file parts for concurrent upload", "16MB").option("--max-part-count <size>", "Maximum number of file parts", "10000").option("--num-threads <count>", "Number of concurrent upload threads", "20").action(async () => {
    const options5 = command.opts();
    const endpoint = options5.endpoint;
    if (typeof endpoint !== "string") {
      throw new Error(`"endpoint" needs to be a string`);
    }
    import_joi8.default.assert(endpoint, endpointSchema);
    const token = options5.token;
    if (typeof token !== "string") {
      throw new Error(`"token" needs to be a string`);
    }
    const payload3 = import_jsonwebtoken4.default.decode(token);
    if (typeof payload3 !== "object" || payload3 === null) {
      throw new Error(`"token" does not have a payload`);
    }
    const { type } = payload3;
    if (type !== "upload") {
      throw new Error(`"token" is not an upload token`);
    }
    const paths = options5.path;
    if (!Array.isArray(paths)) {
      throw new Error(`"paths" needs to be an array`);
    }
    const minPartSize = import_bytes2.parse(options5.minPartSize);
    if (!Number.isInteger(minPartSize) || minPartSize === null) {
      throw new Error(`"minPartSize" is not an integer`);
    }
    const maxPartCount = Number(options5.maxPartCount);
    if (!Number.isInteger(maxPartCount) || maxPartCount === null) {
      throw new Error(`"maxPartCount" is not an integer`);
    }
    const numThreads = parseInt(options5.numThreads, 10);
    if (typeof numThreads !== "number") {
      throw new Error(`"numThreads" needs to be a number`);
    }
    const socket4 = makeClient(endpoint, token);
    const client2 = new UploadClient(socket4, numThreads);
    try {
      await client2.submitPaths(paths, { minPartSize, maxPartCount });
    } finally {
      socket4.disconnect();
    }
  });
  return command;
};

class UploadClient {
  socket;
  queue;
  workerPool = new WorkerPool;
  progress = new Progress;
  constructor(socket4, numThreads) {
    this.socket = socket4;
    this.queue = import_fastq3.default.promise(this, this.runUploadJob, numThreads);
  }
  async retryUploadJob(writeStream, uploadJob) {
    const { progress: progress3 } = this;
    const { path, range: range7, checksumMD5 } = uploadJob;
    let fileHandle;
    try {
      fileHandle = await open4(path);
      const readStream2 = fileHandle.createReadStream({
        ...range7,
        highWaterMark: 524288
      });
      await pipeline3(readStream2, async function* (source) {
        for await (const chunk of source) {
          progress3.gauge.pulse();
          yield chunk;
        }
      }, writeStream, new PassThrough);
    } finally {
      await fileHandle?.close();
    }
    const etag = JSON.parse(writeStream.response?.headers.etag ?? "");
    if (typeof etag !== "string") {
      throw new Error(`Received invalid response from server: "etag" needs to be a string`);
    }
    if (etag !== checksumMD5) {
      throw new Error(`Received invalid response from server: "etag" does not match MD5 checksum`);
    }
  }
  async runUploadJob(uploadJob) {
    const { url: url3, range: range7 } = uploadJob;
    const writeStream = client.stream.put(url3, {
      headers: {
        "Content-Type": "application/octet-stream",
        "Content-Length": `${range7.size()}`
      },
      ...requestOptions
    });
    return new Promise((resolve, reject) => {
      const fn = async (retryStream) => {
        try {
          retryStream.once("retry", (retryCount2, error, createRetryStream) => {
            fn(createRetryStream());
          });
          await this.retryUploadJob(retryStream, uploadJob);
          await this.finalizeUploadJob(uploadJob);
          resolve(uploadJob);
        } catch (error) {
          debug22(error);
        }
      };
      fn(writeStream);
    });
  }
  async finalizeUploadJob(uploadJob) {
    this.progress.completePart(uploadJob);
    await this.socket.emitWithAck("upload:complete", uploadJob);
  }
  async submitChecksum(path) {
    const checksumSHA256 = await this.workerPool.submitCalculateChecksum(path, "sha256");
    await this.socket.emitWithAck("upload:checksum", path, checksumSHA256);
  }
  async submitPaths(paths, options5) {
    const createUploadJobsPromises = new Array;
    const jobPromises = new Array;
    let uploadRequests = new Array;
    const createUploadJobs = async (uploadRequests2) => {
      if (uploadRequests2.length === 0) {
        return;
      }
      let results;
      while (true) {
        try {
          results = await this.socket.timeout(5000).emitWithAck("upload:create", uploadRequests2);
          break;
        } catch (error) {
        }
      }
      for (const [index, result] of results.entries()) {
        if ("error" in result) {
          const { error } = result;
          const uploadRequest = uploadRequests2[index];
          if (error == "upload-exists") {
            this.progress.addPart(uploadRequest);
            this.progress.completePart(uploadRequest);
          } else {
            debug22('skipping upload job because "%s" for %s in range %s', result.error, uploadRequest.path, uploadRequest.range.toString());
          }
          continue;
        }
        parseRange(result);
        jobPromises.push(this.queue.push(result));
        this.progress.addPart(result);
      }
    };
    for (const path of paths) {
      jobPromises.push(this.submitChecksum(path));
      for await (const uploadRequest of generateUploadRequests(path, this.workerPool, options5)) {
        uploadRequests.push(uploadRequest);
        if (uploadRequests.length > 1000) {
          createUploadJobsPromises.push(createUploadJobs(uploadRequests));
          uploadRequests = new Array;
        }
      }
    }
    createUploadJobsPromises.push(createUploadJobs(uploadRequests));
    await Promise.all(createUploadJobsPromises);
    await Promise.all(jobPromises);
  }
}

// src/index.ts
if (isMainThread2) {
  const command = new Command;
  command.option("--debug", "Output extra debug information").addCommand(makeCreateTokenCommand()).addCommand(makeServeCommand()).addCommand(makeUploadCommand()).addCommand(makeDownloadCommand()).hook("preAction", (that, actionCommand) => {
    if (that.opts().debug) {
      import_debug23.default.enable("*");
    } else {
      import_debug23.default.enable("upload-client,download-client,socket-client,serve,storage");
    }
  });
  command.parse(process.argv);
} else {
  worker();
}
